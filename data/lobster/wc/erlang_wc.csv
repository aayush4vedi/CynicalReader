ID,Source,Tag_Code,Tag_Name,Title,Url,ProcessdedTitle,WeightedContent,Content
1,Lobsters,erlang,Erlang development,The New Scalable ETS ordered_set,http://blog.erlang.org/the-new-scalable-ets-ordered_set/,new scalable ets orderedset,contention adapting search tree try escript avl tree contention adapting search tree nutshell ca tree paper preprint pdf thread progress click benchmark test suite ets page note decentralized counter reading ets ca tree source code author phd thesis conclusion,august kjell winblad scalability ets table type orderedset writeconcurrency option substantially better erlangotp earlier release extreme case expect time better throughput erlangotp compared erlangotp cause improvement new data structure called contention adapting search tree ca tree short blog post give insight ca tree work show benchmark result comparing performance ets orderedset table otp otp try escript make convenient try new orderedset implementation machine erlangotp installed escript measure time take p erlang process insert n integer orderedset ets table p n parameter escript ca tree utilized ets table option orderedset writeconcurrency true active one therefore easily compare new data structure performance old one avl tree protected single readerswriter lock writeconcurrency option effect orderedset table release erlangotp get following result running escript developer laptop two core intel r core tm cpu escript insertdisjointrangeserl old time second escript insertdisjointrangeserl old time second escript insertdisjointrangeserl old time second escript insertdisjointrangeserl new time second escript insertdisjointrangeserl new time second escript insertdisjointrangeserl new time second see particular benchmark ca tree superior scalability old data structure benchmark ran twice fast new data structure four process old data structure one process machine two core look performance scalability new ca treebased implementation greater detail later describing ca tree work contention adapting search tree nutshell key feature distinguishes ca tree concurrent data structure ca tree dynamically change synchronization granularity based much contention detected inside data structure way ca tree avoid performance memory overhead come using many unnecessary lock without sacrificing performance many operation happen parallel example let u imagine scenario ca tree initially populated many thread parallel used single thread scenario ca tree adapt use finegrained synchronization population phase finegrained synchronization reduces contention ca tree change use coarsegrained synchronization singlethreaded phase coarsegrained synchronization reduces locking memory overhead structure ca tree illustrated following picture actual item stored ca tree located sequential data structure bottom layer sequential data structure protected lock base node middle layer base node lock counter associated counter base node lock increased contention detected base node lock decreased contention detected value base node lock counter decides split join happen operation performed base node routing node top picture form binary search tree directs search particular item routing node also contains lock flag used joining base node detail splitting joining work described article interested reader find detailed description ca tree paper preprint pdf illustrate ca tree change synchronization granularity going example initially ca tree consists single base node sequential data structure depicted picture parallel thread access ca tree value base node counter may eventually reach threshold indicates base node split base node split divide item base node two new base node replaces original base node routing node two new base node rooted following picture show ca tree base node pointed tree root split process base node splitting continue long enough contention base node lock max depth routing layer reached following picture show ca tree look like another split synchronization granularity may differ different part ca tree example particular part ca tree accessed frequently parallel rest following picture show ca tree yet another split following picture show ca tree fourth split following picture show ca tree fifth split two base node holding adjacent range item joined join triggered operation see base node counter value certain threshold remember base node counter decreased thread experience contention acquiring base node lock might noticed illustration splitting joining result old base node routing node get splicedout tree memory node occupy need reclaimed happen directly got splicedout thread might still reading erlang runtime system mechanism called thread progress ets ca tree implementation us reclaim node safely click see animation example benchmark performance new ca treebased ets orderedset implementation evaluated benchmark measure throughput operation per second many scenario benchmark let configurable number erlang process perform configurable distribution operation single ets table curious reader find source code benchmark test suite ets following figure show result benchmark machine two intel r xeon r cpu core total hyperthreading average set size scenario detail benchmark machine configuration found page see throughput ca treebased orderedset improves add core way core old implementation throughput often get worse process added old implementation write operation serialized data structure protected single readerswriter lock slowdown old version adding core mainly caused increased communication overhead core try acquire lock fact competing core frequently invalidate cache line graph lookup scenario last graph list graph look bit strange first sight ca tree scale much better old implementation scenario answer almost impossible guess without knowing implementation detail orderedset table type first ca tree us readerswriter lock implementation base node lock old implementation us protect whole table difference thus due lock difference default orderedset implementation one active writeconcurrency optimization mainly improves usage scenario single process iterates item table example sequence call ets function optimization keep static stack per table operation use stack reduce number tree node need traversed example ets operation need recreate stack top stack contains key one passed operation see one static stack per table potentially many reader due readerswriter lock static stack reserved thread currently using unfortunately static stack handling scalability bottleneck scenario like one lookup ca tree implementation type optimization suffer scalability bottleneck however also mean old implementation may perform better new one table mainly sequentially accessed one example old implementation still used setting writeconcurrency option false performs better single process case insert delete lookup sequence ets call scenario second last graph list graph therefore conclude turning writeconcurrency orderedset table probably good idea table accessed multiple process parallel still turning writeconcurrency might better mainly access table sequentially note decentralized counter ca tree implementation optimization introduced erlangotp affecting scalability orderedset writeconcurrency optimization decentralized counter orderedset table writeconcurrency turned also introduced erlangotp see option enable optimization table type introduced erlangotp see find benchmark result comparing scalability table without decentralized counter reading following paper describes ca tree optimization applied ets ca tree yet much detail blog post paper also includes experimental comparison related data structure also lockfree variant ca tree described following paper lockfree ca tree us immutable data structure base node substantially reduce amount time range query similar operation conflict operation following paper discus evaluates prototypical ca tree implementation ets first ca treerelated paper look directly ets ca tree source code interested specific implementation detail finally might also interesting look author phd thesis want get link related work want know motivation concurrent data structure adapt contention conclusion erlangotp release introduced new ets orderedset implementation active writeconcurrency option turned data structure contention adapting search tree superior scalability old data structure many different scenario design give excellent performance variety scenario benefit different synchronization granularity
2,Lobsters,erlang,Erlang development,The BEAM Has Spoiled Me,https://gvaughn.github.io/2020/08/08/beam_spoiled_me.html,beam spoiled,beam spoiled began fault tolerance let crash freedom bigger thought game changer,august beam spoiled greg vaughn noticed change prefer develop software since focusing career elixir allows think bigger thought develop lower friction le fear want go back began fault tolerance many people introduced elixir focus concurrency joe armstrong even called erlang concurrency oriented language note point generic beam language experience come elixir perspective please excuse bias terminology find helpful consider concurrency logical consequence primeval concern fault tolerance achieving beamstyle fault tolerance come isolated process affect crash plus supervisory process informed another process dy core point process contain blast radius damage caused error happens isolation quality enable also make great candidate concurrency let crash first heard let crash mantra erlang community sounded crazy based prior development exerience important understand license irresponsibility care system crashing core recognition system error even write bugfree code hardware bug u eventually architecture managing blast radius damage little part system crashing longer scary thing le fear yes please learned write elixir code focus blast radius driver reach process even case need concurrency use process enclose damage error might cause use supervision tree durable work queue recover minor crash process learned prefer upserts insert allow logic retried safely greater idempotency two idea process enclose possible error plus idempotency become second nature elixir code write freedom automatic ability recover error change complexion topic like test coverage enforcement static type extensive code review etc heart preventing error introduced first place yes recognize secondary benefit still good thing advocating irresponsibility solid safety net fault tolerance beam able look different perspective see add friction inertia delivering software perhaps temper reliance upon favor greater delivery speed circumstance le fear mean freedom choose bigger thought elixir reignited intellectual interest software development found via erlang beam history general huge body wisdom distributed system learn new tool toolbox think software process lightweight pervasive offering freedom fear crashing perspective shifted exciting way think writing web application thought immediately limited think building system think bigger thought better abstraction build upon team happy use elixir write web application fit preexisting microservice deployment model urge developer reach bigger thought fault tolerant lighweight process enable consider process logical microservice need friction deploying separately serializing tofrom json container orchestration distributed logging etal deploy entire system million interacting logical microservices single beam release game changer elixir beam certainly game changer fearless build system hope share freedom others beam spoiled good way tag beam elixir introspection
3,Lobsters,erlang,Erlang development,Erlang dbg Intro,https://antranigv.am/weblog_en/posts/erlang-dbg-intro/,erlang dbg intro,erlang elixir kernel process messaging facility many elixir tcp server application tree see,one programming language changed life erlang using erlang couple year moved elixir based erlang vm one important aspect erlang vm real vm kernel process messaging facility many lately debugging huge erlang application whose architecture familiar needed find way see kind message sent received module function called returning wanted write small howto case need future okay example using elixir tcp server simple tcp server get data sends back origin first let clone repo antranigv zvartnots prj git clone http githubcomsonatigranyanelixirtcpserver okay let run server antranigv zvartnots elixirtcpserver iex mix erlangotp source hipe compiling file ex generated tcpserver app interactive elixir press ctrlc exit type h enter help iex good default tcp server listens port specified application tree okay send data antranigv zvartnots elixirtcpserver echo test nc localhost test interactive way antranigv zvartnots elixirtcpserver nc localhost first mesage first mesage good tcp server good tcp server bye antranigv zvartnots elixirtcpserver good see connection closed server get bye okay say want trace dosend function observe get return iex dbgstart ok pid iex dbgtracer ok pid iex dbgtpl tcpserver dosend returntrace ok matched nonode nohost saved iex dbgp newprocesses c ok matched nonode nohost iex call elixirtcpserver dosend port message client n okay first start dbg facility start tracing server local node use function tpl specify local call want trace end use p function start tracing call c newprocesses dosend function called see get send bye see following returned elixirtcpserver ok happening software system running production either attaching node connecting folk
4,Lobsters,erlang,Erlang development,The Erlang Runtime System,https://blog.stenmans.org/theBeamBook/,erlang runtime system,,list sort list seq erlang list sort erlang list redbug done timeout
5,Lobsters,erlang,Erlang development,"v0.10 of Gleam, a statically typed language for the Erlang VM, is out",https://lpil.uk/blog/gleam-v0.10-released/,gleam statically typed language erlang vm,module constant ahmad sattar bit string syntax benjamin tan blog post encoding alternative tom whatmore rest erik terpstra peter saxton gleam changelog standard library changelog supporting gleam sponsoring gleam sponsored,month line code later time another gleam release let see new time module constant sometimes want use certain fixed value multiple place project two option first option copy paste value multiple place code pub fn isbefore year int bool year pub fn isduring year int bool year year duplication value like error prone especially want update value later need find every place used order change another option wrap value function pub fn startyear int pub fn endyear int pub fn isbefore year int bool year startyear pub fn isduring year int bool startyear year year endyear better copying value code yet ideal function perform amount computation side effect called read definition function sure make matter worse gleam case clause guard support calling function within code rejected compiler pub describe year int string case year year year startyear year year endyear solve problem gleam module constant always inlined compiler used case clause guard using code rewritten like pub const startyear int pub const endyear int pub fn isbefore year int bool year startyear pub fn isduring year int bool startyear year year endyear pub describe year int string case year year year startyear year year endyear much better module constant going provide basis exciting new feature future watch space thanks ahmad sattar taking lead implementation feature bit string syntax one great thing erlang easy work raw bit byte using bit string literal syntax starting release gleam support explaining thing one bit string syntax would take longer short give declarative way constructing parsing raw data format erlang vm highly optimised bit syntax highly efficient example wanted create bit unsigned little endian integer value could using bit syntax like let myinteger unsignedlittleintsize wanted extract title artist album year comment music file tag could pattern match like pub fn getmetadata bitstring result metadata string case tag title binarysize artist binarysize album binarysize year binarysize comment binarysize rest binary ok metadata title artist album year comment error valid tag thanks benjamin tan blog post example another example bit syntax action check serious encoding alternative convert arbitrary data emojis part new feature introduced bitstring utfcodepoint type prelude split standard library iodata type stringbuilder bitbuilder type efficiently constructing string bit string respectively thanks tom whatmore taking lead implementation feature rest many new addition improvement bug fix compiler standard library including limited support regex expression implemented erik terpstra environment variable implemented peter saxton information rest release please check gleam changelog standard library changelog supporting gleam would like help make strongly typed programming erlang virtual machine productionready reality please consider sponsoring gleam via github sponsor program release would possible without support people sponsored contributed huge thank thanks reading fun
6,Lobsters,erlang,Erlang development,Operating via development,https://www.theerlangelist.com/article/operating_via_development,operating via development,certbot siteencrypt instruction start system locally phoenix live dashboard soul erlang elixir certification acme automatic certificate management environment protocol siteencrypt make task straightforward midlevel module lowerlevel module reducing devproduction mismatch testability automation tight integration operation final thought,two year ago decided add http support site using automatic certification via let encrypt article subject relied tool called certbot couple variation mentioned requiring tool run site others using nginx certbot combination seemed installing running additional external tool production mandatory point erlangelist standalone elixirpowered system required external program seemed start worrying setting additional service interact using custom dsl would complicate operation create disconnect production development change certification configuration would need tested directly production alternatively setup staging server either way testing certification would done manually unhappy state started work siteencrypt library take different approach automatic certification siteencrypt library dependency external tool required install oslevel package use certification process periodical renewal running o process rest system o process need started everything configured project system implemented interaction siteencrypt done via elixir function data yaml ini json kind dsl required trivial run certification locally reduces difference prod local dev support automatic testing certification provided need setup staging machine make change directly production system example call integrated operation instead spread across bunch yamls inis jsons bash script somehow glued together oslevel operation done development ie place rest system implemented using language approach significantly reduces technical complexity system erlangelist mostly implemented elixir administrative task installation o package user creation port forwarding rule similar provisioning task done outside elixir also simplifies local development instruction start system locally simple install build tool elixir erlang nodejs fetch dependency invoke single command start system locally started system extremely close production version almost nothing significance running production running locally two difference note think port forwarded prod prod version us let encrypt certification local version us local ca server later may sound like much simple blog host behind scene erlangelist bit simple request responder erlangelist system run two separate web server public facing server one use read article another internal server us phoenix live dashboard expose metric small handmade database running collect aggregate persists reading stats periodically removing older stats disk system periodically renews certificate locally ci another web server act local certificate authority ca running word erlangelist blog site server app system consisting multiple activity collectively work together support full enduser service well operational aspect system activity running concurrently block crash system utilizes cpu core host machine detail work take look talk soul erlang elixir let take closer look siteencrypt certification let encrypt support automatic certification via acme automatic certificate management environment protocol protocol describes conversation client system wanting obtain certificate domain server certificate authority ca create certificate acme conversation system asks ca provide certificate domain ca asks u prove owner domain ca give u random byte make request domain expecting get byte return also called challenge successfully respond challenge ca create certificate u real story course involved simplified version hopefully give basic idea conversation activity system job need occasionally done allow system provide full service certification valid certificate people use site likewise decide shut site certification serf purpose anymore situation preferred approach run activity together rest system le fragmented system easier manage running part system externally fine stronger reason see reason simple scenario siteencrypt make task straightforward add library dep fill blank good go certification configuration provided defining certification function def certification siteencryptconfigure client native domain mysitecom wwwmysitecom email contact mysitecom anothercontact mysitecom dbfolder folderwheresiteencryptstoresfiles directoryurl directoryurl end code look pretty declarative executable code collection fact mean lot flexibility shape configuration data however want example want make certification parameter configurable system operator say via yaml file nothing stop u invoking loadconfigurationfromyaml instead hardcoding data say want make parameter configurable eg domain email leaving rest hardcoded simply keywordmerge loadsomeparamsfromyaml hardcodeddata supporting kind config source like etcd database equally straightforward always build declarative top imperative opposite require imagination trickery running external configuration generator good luck managing production also worth mentioning siteencrypt internally ship two lowerlevel module sort plumbing porcelain midlevel module provides workflowrelated operation create account perform certification lowerlevel module provides basic acme client operation module used want finer grained control certification process reducing devproduction mismatch one interesting thing happening configuration presented earlier def certification siteencryptconfigure directoryurl directoryurl end directoryurl property defines ca siteencrypt obtain certificate instead hardcoding url invoking function compute happens need use different url production v staging v local development let take look defp directoryurl case systemgetenv mode local production http staging http local internal port end end distinguishing production staging development based mode o env easily replaceable source owing programmable api env provided assume system running locally production machine go real ca staging use let encrypt staging site internal port thing use local development pas particular shape data siteencrypt internal acme server started given port sort local mock let encrypt server running inside o process rest system locally siteencrypt start mock let encrypt use mock obtain certificate word locally system certify example action local version erlangelist iex mix phxserver info running erlangelistwebblogendpoint http info running erlangelistwebblogendpoint http info running local acme server port info creating new acme account domain theerlangelistcom info ordering new certificate domain theerlangelistcom info new certificate domain theerlangelistcom obtained info certificate successfully obtained testability since local erlangelist behaves exactly real one test system behaviour example even local version http request redirected http test verifying test http request redirected http assert redirectedto clientget http localhost http localhost end likewise redirection www also tested test theerlangelistcom redirected wwwtheerlangelistcom assert redirectedto clientget http theerlangelistcom http wwwtheerlangelistcom end contrast external proxy rule defined nginx configuration typically tested mean change configuration might break something else way obvious operator addition siteencrypt ship small helper testing certification relevant test test certification cleanrestart erlangelistwebblogendpoint cert getcert erlangelistwebblogendpoint assert certdomains wtheerlangelistcom wwwtheerlangelistcom end test blog endpoint ie blog web server restarted previously existing certificate removed restart endpoint certified via local acme server certification go whole process mocking save fact local ca used http request made key generated system call ca concurrently make request system ultimately certificate obtained finished invocation getcert establish ssl connection blog server fetch certificate peer assert expected property certificate test significantly increase confidence system course always chance something going wrong production eg dns correctly configured let encrypt reach site possibility error reduced test also compiled language used example make syntax error changing configuration code even compile let alone make production make typo eg specifying theerlangelistorg instead theerlangelistcom certification test fail contrast external configuration much harder test typically end manually verified staging case production automation beyond obtaining certificate siteencrypt periodically renew periodic job executed three time day job check expiry date certificate start renewal process certificate expire day addition every time certificate obtained siteencrypt optionally generate backup data system starting siteencrypt database folder present backup file exists siteencrypt automatically restore database backup user siteencrypt zero work make happen significantly reduces amount operational work required bringing bulk regular development elaborate backup scenario siteencrypt provides callback hook endpoint module define function invoked certificate obtained use function eg store cert arbitrary secure storage choice notice becomes part regular system codebase convenient logical place express task fact running together rest system also mean testable testing new certificate correctly stored desired storage straightforward tight integration since run o process powered language siteencrypt integrate much better client lead nice benefit mentioned earlier certification conversation system ca server using certbot tool dialogue turn threeparty conversation instead system asking certificate ask certbot behalf however ca verification request aka challenge need served site since certbot external tool treat site opaque box result certbot know responded ca challenge bit conservative namely certbot sleep three second start polling ca see challenge answered native elixir acme client run o process integrate much better acme client informed challenge handler challenge fulfilled use much shorter delay start polling ca production optimization particularly relevant local dev especially test difference becomes significant certification test via certbot take second machine test via native client tight integration offer interesting possibility bit change api siteencrypt could support arbitrary storage database could also support coordination multiple node making possible implement distributed certification arbitrary node cluster initiate certification node successfully respond challenge including even node came online challenge started operation bulk system behaviour described elixir code remaining operational task done outside elixir exclusively related preparing machine run erlangelist task involve creating necessary account creating folder structure installing required o package essentially docker needed setting single systemd unit starting container production dockerized production docker image lightweight site run apk nocache upgrade apk add nocache ncurses copy frombuilder optappsitebuildprodrelerlangelist erlangelist volume volume workdir erlangelist entrypoint erlangelistbinerlangelist key part copy instruction add built release system image release contain compiled binary well minimal erlang runtime system therefore pretty much selfcontained requiring one small oslevel package installed final thought might argue using certbot optionally nginx caddy simple enough completely disagree perfectly valid reach external product solve technical challenge related business domain product help u solve problem quickly focus core challenge hand feel critical problem introduced product tried show simple example integrated operation approach reduces amount moving part technology used bridge gap production development improves testability system implementation simpler time flexible since tool driven function data approach work need runtime support managing multiple system activity beam runtime erlang elixir make possible example many case serving traffic directly phoenix without reverse proxy front work fine feature ets table genserver reduce need tool like redis running periodic job regulating load ratelimiting pipeline processing done directly elixir without requiring external product course always case external tool make sense also many case integrated approach work fine especially smaller system operating level scale complexity netflix twitter facebook similar option available would allow u start simple move external tool complicated scenario reason started work siteencrypt library still incomplete probably buggy issue fixed time effort believe benefit approach worth effort continue work library like see library appearing giving u simpler option challenge load balancing proxying persistence long technical challenge running external product option opportunity simplification u developer make happen
7,Lobsters,erlang,Erlang development,Introducing Lean Server for Midas (HTTP server in Gleam),https://crowdhailer.me/2020-06-23/introducing-lean-server-for-midas/,introducing lean server midas http server gleam,introducing lean server midas midas web framework lean ace raxx gleam using lean server,introducing lean server midas lean server http server written gleam gleam new type safe language erlang virtual machine beam lean builtin server midas web framework import midaslean maxconcurrency import gleamhttp fn handle request httpresponse httpsetbody hello world fn startlink leanstartlink handle maxconcurrency lean simple use simple maintain fast hopefully lean incorperates lesson learnt developing ace raxx ace http server written elixir aimed abstract away difference ace also supported http long lived connection streaming requestsresponses opinion ace successful goal however feature one server increased implementation complexity since starting ace written several service use narrow subset feature application mostly json api service streaming deployed behind load balancer needed neither http lean aim focus api application sizeable list nongoals ssl streaming http pipelining websockets tackling nongoals lean simpler therefore easier maintain make easier address feature bug well easier contribute also faster though yet test course feature listed important framework writing adapter server ace cowboy midas framework able support feature gleam gleam feel like promising approach getting benefit type beam something several people wish list including mine quite long time gleam compiles readable erlang readable erlang nt controversial statement also great interop erlang elixir feature would argue considered production ready part application part application benefit type safety others write topic later time using lean server lean sever bundled part midas currently midas using feature yet part gleam stable release therefore need use git dependency midasframeworkmidas
8,Lobsters,erlang,Erlang development,Hamler – Haskell-style functional programming language running on Erlang VM,https://www.emqx.io/news/open-source-functional-programming-language-hamler,hamler haskellstyle functional programming language running erlang vm,hamler haskellstyle functional programming language running erlang vm functional programming language hamler hamler hamler emq x philip wadler simon marlow dialyzer elixir akka welltyped cloud haskell lfe alpaca efene elchemy gleam emq hamler core feature hamler compiler purescript documentation community discussion support hamler contributing hamler hamlerissues hamlerlanghamler hamlerwiki core team emq technology co ltd emq emq,hamler haskellstyle functional programming language running erlang vm proud announce first public release new opensource functional programming language hamler hamler stronglytyped language compiletime type checking builtin support concurrency distribution empowers industry build next generation scalable reliable realtime application especially iot edge computing hamler almost decade developing software system based erlangotp especially main product emq x scalable opensource mqtt broker always believed erlang masterpiece engineering amazing concurrency distribution fault tolerance one generalpurpose language platform able properly handle concurrency soft realtime however year experience developing erlang program looking solve two problem compiletime type system friendly language syntax powerful compiletime type system help build reliable software system friendly syntax help build prosperous developer community taken nearly year academia industry find solution started prof philip wadler simon marlow type annotation dialyzer static analysis tool introduced erlang since project industry trying solve problem elixir language project introduced ruby syntax attracted developer ruby rail community akka project imitated implementation erlangotp lost soft realtime feature erlangotp welltyped cloud haskell project attempt simulate implementation erlang otp haskell project currently stalled others like lfe introduced lisp syntax etc attempted introduce ml style syntax static type still early stage development emq team made another attempt address issue new design approach today present industry release hamler language hamler core feature core feature hamler functional programming language running erlang vm haskelllike syntax summarized follows haskell mllike friendly syntax type checking inference compile time concurrency soft realtime support runtime combined year experience understanding developing erlang haskell program hamler language support major feature functional programming believe help industry better prepare coming wave development iot edge computing attract developer use erlang vm beam functional programming haskell ml style adt type checkinginference function higherorder function currying partial application pattern matching guard list comprehension applicative monad advanced module system builtin concurrency hamler compiler hamler source code parsed generate cst coreerlang ir generated cst ast corefn syntax tree transformation syntax analysis type checking code used erlang compiler generate final beam bytecode hamler compiler architecture shown hamler compiler initially attempted implemented based ghc later changed adapt purescript compiler implementation documentation community discussion support reach hamler community core team via following channel contributing contribute hamler project report issue submit bug issue hamlerissues contribute code fork project submit feature request hamlerlanghamler submit proposal fork hamlerwiki project submit pull request core team hamler core team come emq technology co ltd emq emq open source software company providing highlyscalable realtime messaging streaming platform iot application era
9,Lobsters,erlang,Erlang development,"v0.9 of Gleam, a statically typed language for the Erlang VM, is out",https://lpil.uk/blog/gleam-v0.9-released/,gleam statically typed language erlang vm,improved error handling opaque type standard library addition iterator iterator documentation set set documentation queue queue documentation option option documentation rest changelog changelog thanks gleam sponsor sponsoring gleam,thanks new contributor gleam development faster ever time another release let take look improved error handling main way error represented handled gleam result type baked language implement library would implemented like pub type result successvalue failuredetail ok successvalue error failuredetail function fail return result wrapping successful return value ok record returning detail failure error record successful parseint string result int string parseint ok parseint erl error expected number got erl function return result pattern match handle success failure case parseint error e ioprintln nt int ok ioprintln parsed int work need handle multiple result value function becomes verbose error handling obscures business logic case parseint error e error e ok inta case parseint b error e error e ok intb ok inta case parseint c error e error e ok intc ok inta intb intc release gleam try keyword make error handling easier concise rewritten using try previous example look like try inta parseint try intb parseint b try intc parseint c ok inta intb intc variable declared using try gleam check see whether value error ok record ok inner value assigned variable try x ok ok x ok error error returned immediately try x error failure ok x error failure testing try application happy clean error handling give try opaque type gleam new opaque type feature allows library writer export custom type without exporting internal detail type srcboxgleam pub opaque type box box innervalue int pub fn new x int box box innervalue x another module import custom type able create box using new function call box constructor use innervalue accessor pattern match box get inner value import box let one boxnew permitted oneinnervalue compile error let boxbox one compile error boxbox compile error feature great creating carefully controlled api data type hiding private implementation detail ensure used correctly brings u next feature standard library addition standard library gained wealth new module type function highlight made possible new opaque type feature iterator new iterator type lazily evaluated sequence element similar stream type elixir iterators useful working collection large fit memory infinite size require element currently processed memory see iterator type used create infinitely long sequence ints mapped first element evaluated import gleamiterator let double fn x x iteratorfromlist create element iterator iteratorcycle repeat iterator forever iteratormap double double element iteratortake evaluate first element iterators lazy even though iterator infinite size double function called time information see iterator documentation set set collection value unlike list unordered contain duplicate value finding value set fast import gleamset let popband setnew iris karl priya setcontains popband iris true setcontains popband martin false information see set documentation queue queue ordered collection element similar list however fast add remove end queue list quickly accessed front import gleamqueue queuenew queuepushfront queuepushfront queuepushback queuepushback queuetolist information see queue documentation option option type used represent value may present absent making similar nullable value language defined like pub type option none optional int someint present represented theint absent none information see option documentation rest addition standard library include io module addition result dynamic list string module change label make consistent full detail see changelog addition compiler include improvement formatter style ability include additional markdown page generated code documentation initial support elixir mix build tool type annotation let assert try custom type support case clause guard several bug fix info see changelog thanks would possible release big without support gleam sponsor contributor huge thank would like help make strongly typed programming erlang virtual machine productionready reality please consider sponsoring gleam via github sponsor program thanks reading fun
10,Lobsters,erlang,Erlang development,"Scaling Erlang cluster to 10,000 nodes (2018)",https://codesync.global/media/maxim-fedorov-scaling-erlang-cluster-to-10-000-nodes/,scaling erlang cluster node,objective target audience,growing user population beyond leave chance keep server footprint small used adding new capability requires processing power get impossible keep everything ten server scale cluster hundred hundred get tight expand next possible considering current scalability limit single erlang cluster talk guide along way took improve erlang scalability remove bottleneck increase efficiency erlangbased application objective demonstrate example live erlang cluster scaled node machine service interruption target audience scalability engineer people interested optimising erlang largescale server application
11,Lobsters,erlang,Erlang development,Erlang online resources,https://gist.github.com/macintux/6349828,erlang online resource,similar list instruction documentation community mailing list advocacy style project exercise general fp ish exercise collection conference video alternative vms alternative language targeting erlang vm erlang like environment jvm actor implementation hipe high performance erlang erlangheavy blog software pattern actor pattern currently akka resource history paper erlang actor model similar process calculus communicating sequential process csp πcalculus misc slide deck twitter changelog http githubcomllaisdybeamlanguages http githubcomdrobakowskiawesomeerlang http githubcomalpacalangalpaca http wwwslidesharenetarbowcomparingcppanderlangformotorolatelecomssoftware http githubcompurerlpurescript http http protoactor http adventofcodecom http http githubcomwendeelchemy http githubcombragfulephp http githubcomkjnilssonfez http http githubcomheathermillerdistprogbook http erightsorg http wikihaskellorgcloudhaskell http githubcomcromaincean,intended comprehensive authoritative free online resource found valuable learning erlang similar list instruction documentation community mailing list advocacy style project exercise general fp ish exercise collection conference video alternative vms alternative language targeting erlang vm erlang like environment jvm actor implementation hipe high performance erlang erlangheavy blog software pattern actor pattern currently akka resource history paper erlang actor model similar process calculus communicating sequential process csp πcalculus misc slide deck twitter twitter seems de facto water cooler technical conversation erlang exception far active account comfortably list interesting one changelog started several year creation gist rarely actually update added dale schumacher blog focused actor model added humus schumacher blog list actor implementation added http githubcomllaisdybeamlanguages language previously listed added http githubcomdrobakowskiawesomeerlang added http githubcomalpacalangalpaca start new section hipe add http wwwslidesharenetarbowcomparingcppanderlangformotorolatelecomssoftware add http githubcompurerlpurescript http add http protoactor add http adventofcodecom http http githubcomwendeelchemy http githubcombragfulephp http githubcomkjnilssonfez add http http githubcomheathermillerdistprogbook http erightsorg http wikihaskellorgcloudhaskell http githubcomcromaincean
12,Lobsters,erlang,Erlang development,Getting Erlang to talk to the outside world (2002),http://erlang.org/workshop/2002/Armstrong.pdf,getting erlang talk outside world,,obj length filter flatedecode stream ɀq hj l aso ޟᰊ pt snϵk fc c r 뢧 z ɹ h k b endobj obj type page content r resource r mediabox parent r endobj obj type xobject subtype form formtype matrix bbox resource procset pdf text extgstate r font r length r filter flatedecode stream xta l endobj obj type extgstate name tr identity opm sm endobj obj subtype basefont helvetica type font name endobj obj endobj obj font r r r r r r r r r xobject r procset pdf text endobj obj length filter flatedecode stream xڍ vwyt k ܫ b uw ъp dxo h r j ksqpboza nw bf ȱ ou hz v 鉿 g x v v l l endobj obj type page content r resource r mediabox parent r endobj obj font r r r r r procset pdf text endobj obj length filter flatedecode stream xڵ ǒ b q bckx r c c k gy ɳc n ԙb 㴹õ lqnyz ai c b x x u vzx ȷ wr rz r endobj obj type page content r resource r mediabox parent r endobj obj type xobject subtype form formtype matrix bbox resource procset pdf text extgstate r font r length r filter flatedecode stream h endobj obj subtype basefont helvetica type font name endobj obj endobj obj font r r r r r r r r r r xobject r procset pdf text endobj obj length filter flatedecode stream xڵ u մ ˣ n k q b u n g h c g
14,Lobsters,erlang,Erlang development,Optimising for Concurrency: Comparing and contrasting the BEAM and JVM virtual machines,https://www.erlang-solutions.com/blog/optimising-for-concurrency-comparing-and-contrasting-the-beam-and-jvm-virtual-machines.html,optimising concurrency comparing contrasting beam jvm virtual machine,optimising concurrency comparing contrasting beam jvm virtual machine semantics erlang programming language otp library middleware beam virtual machine highlight beam highlight jvm attempt akka framework concurrency parallelism technique beam concurrency lightweight process scheduler dirty scheduler garbage collector garbage collector blog post lukas larsson wombatoam hot code loading use beam conclusion learn beam book beam wisdom may also like go back blog tag,optimising concurrency comparing contrasting beam jvm virtual machine francesco cesarini gabor olah success programming language erlang ecosystem apportioned three tightly coupled component semantics erlang programming language top language implemented otp library middleware used architect scalable resilient concurrent system beam virtual machine tightly coupled language semantics otp take one component runner put three together uncontested winner scalable resilient softreal time system quote joe armstrong copy erlang library run beam emulate get enforced robert first rule programming state sufficiently complicated concurrent program another language contains ad hoc informallyspecified bugridden slow implementation half post want explore beam vm internals compare contrast jvm applicable highlighting pay attention care long component treated black box taken granted without understanding reason implication time change highlight beam erlang beam vm invented right tool solve specific problem developed ericsson help implement telecom infrastructure handling mobile fixed network infrastructure highly concurrent scalable nature display soft realtime property may never fail want hangout call mobile grandmother dropped online gaming experience fortnite affected system upgrade high user load software hardware network outage beam vm optimised solve many challenge providing finetuned feature work top predictable concurrent programming model secret sauce lightweight process share memory managed scheduler manage million across multiple core us garbage collector run perprocess basis highly optimized reduce impact process result garbage collector impact overall soft real time property system beam also widely used vm used scale builtin distribution model allows program run multiple machine transparently highlight jvm java virtual machine jvm developed sun microsystem intent provide platform code run everywhere created object oriented language similar c memorysafe runtime error detection check array bound pointer dereferences jvm ecosystem became extremely popular internetera making defacto standard enterprise server application wide range applicability enabled virtual machine caters wide range use case impressive set library catering enterprise development jvm designed efficiency mind concept abstraction feature found popular operating system threading model map operating system thread jvm highly customisable including garbage collector gc class loader stateoftheart gc implementation provide highly tunable feature catering programming model based shared memory jvm allows change code program running jit compiler allows byte code compiled native machine code intent speed part application concurrency java world mostly concerned running application parallel thread ensuring fast programming concurrency primitive difficult task challenge created shared memory model overcome difficulty attempt simplify unify concurrent programming model successful attempt akka framework concurrency parallelism talk parallel code execution part code run time multiple core processor computer concurrent programming refers handling event arriving system independently concurrent execution simulated single threaded hardware parallel execution although distinction may seem pedantic difference result different problem solve think many cook making plate carbonara pasta parallel approach task split across number cook available single portion would completed quickly took cook complete specific task concurrent world would get portion every cook cook task use parallelism speed concurrency scale parallel execution try solve optimal decomposition problem part independent boil water get pasta mix egg fry guanciale ham grate pecorino shared data example serving dish handled lock mutexes various technique guarantee correctness another way look data ingredient present want utilise many parallel cpu resource possible finish job quickly possible concurrent programming hand deal many event arrive system different time try process within reasonable time multicore distributed architecture execution run parallel requirement another way look cook boil water get pasta mix egg following sequential algorithm always change across process cook data ingredient work exist multiple instance jvm built parallelism beam concurrency two intrinsically different problem requiring different solution beam concurrency beam provides lightweight process give context running code process also called actor share memory communicate message passing copying data one process another message passing feature virtual machine implement mailbox owned individual process message passing nonblocking operation mean sending message another process almost instantaneous execution sender blocked message sent form immutable data copied stack sending process mailbox receiving one achieved without need lock mutexes among process lock mailbox case multiple process send message recipient parallel immutable data message passing enable programmer write process work independently focus functionality instead lowlevel management memory scheduling task turn simple design work single thread also multiple thread local machine running vm using built distribution across network cluster vms machine message immutable process sent another thread machine without lock scaling almost linearly distributed multicore architecture process addressed way local vm cluster vms message sending work transparently regardless location receiving process process share memory allowing replicate data resilience distribute scale mean two instance process two separate machine sharing state update among machine fails copy data continue handling request making system fault tolerant machine operational process handle request giving scalability beam provides highly optimised primitive work seamlessly otp provides higher level construct make life programmer easy akka great job replicating higher level construct somewhat limited lack primitive provided jvm allowing highly optimised concurrency primitive jvm enable wider range use case make programming distributed system harder built primitive communication often based shared memory model example distributed system place shared memory cost accessing scheduler mentioned one strongest feature beam ability break program small lightweight process managing process task scheduler unlike jvm map thread o thread let operating system schedule beam come scheduler scheduler start default o thread every core optimises workload process consists code executed state change time scheduler pick first process run queue ready run give certain amount reduction execute reduction rough equivalent command process either run reduction blocked io waiting message completes executing code scheduler pick next process run queue dispatch scheduling technique called preemptive mentioned akka framework many time biggest drawback need annotate code scheduling point scheduling done jvm level removing control hand programmer soft real time property preserved guaranteed risk accidentally causing process starvation process spread around available scheduler thread maximise cpu utilisation many way tweak scheduler rare needed edge borderline case default option cover usage pattern sensitive topic frequently pop regarding scheduler handle natively implemented function nifs nif code snippet written c compiled library run memory space beam speed problem nifs preemptive affect scheduler recent beam version new feature dirty scheduler added give better control nifs dirty scheduler separate scheduler run different thread minimise interruption nif cause system word dirty refers nature code run scheduler garbage collector modern high level programming language today mostly use garbage collector memory management beam language exception trusting virtual machine handle resource manage memory handy want write high level concurrent code simplifies task underlying implementation garbage collector fairly straightforward efficient thanks memory model based immutable state data copied mutated fact process share memory remove process interdependency result need managed another feature beam garbage collection run needed per process basis without affecting process waiting run queue result garbage collection erlang stoptheworld prevents processing latency spike vm never stopped whole specific process never time practice part process treated another reduction garbage collector collecting process suspends process short interval often microsecond result many small burst triggered process need memory single process usually allocate large amount memory often short lived reducing impact immediately freeing allocated memory termination feature jvm ability swap garbage collector using commercial gc also possible achieve nonstopping gc jvm feature garbage collector discussed excellent blog post lukas larsson many intricate detail optimised handle immutable data efficient way dividing data stack heap process best approach majority work short lived process question often come topic much memory beam us hood vm allocates big chunk memory us custom allocator store data efficiently minimise overhead system call two visible effect used memory decrease gradually space needed reallocating huge amount data might mean doubling current working memory first effect really necessary mitigated tweaking allocator strategy second one easy monitor plan visibility different type memory usage one monitoring tool provides system metric box wombatoam hot code loading hot code loading probably cited unique feature beam hot code loading mean application logic updated changing runnable code system whilst retaining internal process state achieved replacing loaded beam file instructing vm replace reference code running process crucial feature downtime code upgrade telecom infrastructure redundant hardware put use handle spike nowadays era containerization technique also used production update never used dismiss le important feature nonetheless useful development workflow developer iterate faster replacing part code without restart system test even application designed upgradable production reduce time needed recompilation redeployment use beam much right tool job need system extremely fast concerned concurrency handling event parallel handle fast need crunch number graphic ai analytics go c python java route telecom infrastructure need fast operation float speed never priority aided dynamic typing type check runtime mean compiler time optimization trivial number crunching best left jvm go language compile native surprise floating point operation erjang version erlang running jvm faster beam seen beam shine using concurrency orchestrate number crunching outsourcing analytics c julia python rust map outside beam reduce within beam mantra always fast enough take hundred millisecond human perceive stimulus event process brain meaning micro nano second response time necessary many application would use beam microcontrollers resource hungry embedded system bit processing power multicore becoming norm need concurrency beam shine back implementing telephony switch handling ten thousand subscriber running embedded board memory much memory raspberrypi day finally hard real time system would probably want beam manage airbag control system need hard guarantee something hard real time o language garbage collection exception implementation erlang vm running bare metal grisp give similar guarantee conclusion use right tool job writing soft real time system scale box never fail without hassle reinvent wheel beam battle proven technology looking many work black box knowing work would analogous driving ferrari capable achieving optimal performance understanding part motor strange sound coming learn beam understand internals ready finetune fix used erlang elixir anger launched one day instructorled course demystify explain lot saw whilst preparing handle massive concurrency scale course available new instructor lead remote training learn also recommend beam book erik stenman beam wisdom collection article dmytro lytovchenko may also like author also like similar looking dish called carbonara made cream go back blog tag
15,Lobsters,erlang,Erlang development,Erlang/OTP 23 Released,https://www.erlang.org/news/140,erlangotp released,otp potential incompatibility ssl improvement new feature ssh ssl kernel http http http http http githubcomerlangotp,otp erlangotp new major release new feature improvement well incompatibility potential incompatibility ssl support ssl completely removed tl added list default supported version erlinterface removed deprecated part erlinterface erlinterfaceh essentially c function prefix erl deprecated erlang bif return empty list instead stacktrace erlang scheduled removal otp improvement new feature ssh openssh introduced new file representation key called supported exception handling encrypted key algorithm configuration could done config file useful example enable algorithm disabled default without need change code ssl support middlebox compatibility mode make tl handshake look like tl handshake increase chance successfully establishing tl connection legacy middleboxes add support key exchange edward curve pssrsa padding signature verification possibility run erlang distribution without relying epmd extended achieve couple new option inet distribution added distlisten false setup distribution channel listen incoming connection erlepmdport port configure default port builtin epmd client return first experimental socket backend gentcp inet implemented genudp gensctp follow putting inetbackend socket first option listen connect make easy try existing code new module erpc kernel implement enhanced subset operation provided rpc module enhanced sense make possible distinguish returned value raised exception error erpc also better performance scalability original rpc implementation utilizing newly introduced spawnrequest bif also rpc module benefit improvement utilizing erpc possible scalability performance improvement plus new functionality regarding distributed spawn operation binary matching size segment matched allowed guard expression matching map key guard expression ssh support tcpip port forwarding aka tunnelling aka tcpforwarddirecttcp implemented openssh client corresponds option l r allow underscore numeric literal improve readability example new function shell displaying documentation erlang module function type function print documentation module functionarity print type documentation module typearity embedded documentation created docchunks eep building erlangotp documentation kernel module pg new implementation distributed named process group introduced old module deprecated scheduled removal otp tool chain building window package upgraded new c compiler java compiler openssl library wxwidgets version using wsl linux subsystem window building make easier handle build environment detail see http pre built version window fetched http http online documentation browsed http erlangotp source also found github official erlang repository http githubcomerlangotp
16,Lobsters,erlang,Erlang development,"v0.8 of Gleam, the statically typed language for the Erlang VM, is out",https://lpil.uk/blog/gleam-v0.8-released/,gleam statically typed language erlang vm,html documentation gleam format fancy pipe accessor syntax spread operator rest changelog thanks midas sponsoring gleam,really good couple month gleam community growing getting new feature improvement time another release let take look html documentation documentation bit sore point wanted write program gleam way see type function available use likely would source code standard library open window somewhere nicest way learn language solve problem gleam generate html documentation gleam source code publish hexdocs home documentation erlang ecosystem check example new documentation gleam format consistency matter code consistent style make code easier read easier work hand maintaining consistent style hand expensive time sink easy waste time debating exactly right place put curly brace code review solution problem code formatter write whatever code want without spending time style press save editor automatically fix style taken finger keyboard starting release gleam includes formatter new gleam project preconfigured format validated ci enable formatter editor never waste time fixing style interested learning formatters work year back gave talk subject context elixir language hold true gleam well fancy pipe pipe operator favourite feature gleam allows u write chain function read toptobottom lefttoright work taking value left hand side using argument function right hand side without pipe print eval read stdin stdout pipe stdin read eval print stdout example function print take two argument function capture syntax used tell gleam insert left hand side value practice gleam function take multiple argument capture syntax needed often score listmap double listfold add shouldequal gleam fancy pipe boilerplate longer needed used function call right hand side b pipe first check see left hand value could used first argument call b fall back calling result right hand side function b score listmap double listfold add shouldequal much better resolved compile time using type system performance safety penalty use nested function call accessor syntax pattern matching great sometimes want get single value record tuple enable gleam support field syntax common language work record let student student subject theatre let mary person name mary role student maryname mary maryrolesubject theatre work tuples let pair tuple apple orange apple orange spread operator gleam pattern matching expanded new operator called spread operator allows write partial pattern record without spread let uri scheme scheme port port path query fragment authority userinfo host uri spread let uri scheme scheme port port uri consistent record syntax prepending list matching head list updated also use spread operator let newlist existinglist case list first first old x x list syntax deprecated still accepted run formatter automatically upgrade code first rest addition change also support number numerical operator case guard assert syntax inexhaustive pattern matching todo syntax type checking function without finished implementation handful performance improvement whole bunch bug fix outside compiler continue grow standard library made good progress otp support prototype type safe supervision tree information check changelog github thanks exciting thing release much community grown since last release people writing gleam people sharing idea people working compiler even got beginning gleam web server web framework midas project would possible release big without support gleam sponsor contributor huge thank would like help make strongly typed programming erlang virtual machine productionready reality please consider sponsoring gleam via github sponsor program thanks reading fun
18,Lobsters,erlang,Erlang development,"archseer/enigma - Enigma VM, an implementation of the Erlang VM in Rust",https://github.com/archseer/enigma,archseerenigma enigma vm implementation erlang vm rust,enigma vm installation rustup iex also work rendering bug feature status opcodes bifs roadmap feature goal idea experiment hyper runtime initial nongoals rustler contributing elixir slack,enigma vm implementation erlang vm rust aim complete correct fast order importance otp compatible sans distributed bit code eventually run enigma unchanged deprecated opcodes wo nt supported fun learning lot beam hipe awesome massive sloc small implementation make easier new people learn erlang internals also get platform quickly iterate idea inclusion beam installation prerequisite building enigma rust use rustup install latest nightly rust time nt support stable beta anymore relying asyncawait scheduled run stable time boot otp also need compile standard library moment relies beam build system git submodule update init depth cd otp otpbuild setup make libs make localsetup hope simplify step future enigma run compiler run cargo run install dependency build run vm default boot erlang shell iex also work rendering bug expect crash lot functionality already available prebuilt binary various platform available reach certain level stability feature status implement opcodes half bifs view detailed progress breakdown opcodes bifs roadmap feature goal idea experiment process scheduling implemented top rust future process simply long running future scheduled top tokiothreadpool workstealing queue timer delaytimeout future relying tokiotimer timewheel port future await file io asyncreadasyncwrite awaitable nifbifs future yield certain point play nice reduction allows much simpler yielding implementation future possibility write documentation sparsely documented beam aspect binary matching time wheel process monitor explore using immix gc erlang eir runtime jit via eir bif generator function yield suspendon reduce provide builtin adapter module hyper plug adapter http client crosscompile webassembly runtime initial nongoals vm nt reach certain level completeness nt make sense consider distributed erlang node tracing debugging support beam compatible nifs ffi note nifffi abi compatibility otp going quite work ruststyle nif interface available would also probably possible make adapter compatible rustler contributing contributor welcome easiest way get started look note folder pick bif opcode implement take look srcbifrs bif folder bifs implemented also issue open good first issue tag would also good introduction internals alternatively search codebase todo fixme unimplemented mark various place partial implementation exists bit work need done test coverage currently lacking varying level documentation addressing soon also enigma channel elixir slack
19,Lobsters,erlang,Erlang development,Matching binary patterns with Erlang,https://dev.to/l1x/matching-binary-patterns-11kh,matching binary pattern erlang,complete example creating request sending receiving processing response first bit processing response rest http githubcommnperlangntp http,erlang easy construct binary bitstrings matching binary pattern running mitchell perilstein excellent work ntp erlang thought going use explain bitstrings binary work erlang two concept bitstring sequence zero bit number bit need divisible binary number bit divisible syntax follows element specifies certain segment bitstring segment set contiguous bit binary necessarily byte boundary reallife example let unpack bit going worth knowing whole syntax value sizetypespecifierlist value sizetypespecifierlist alternatively ei value value size valuetypespecifierlist value sizetypespecifierlist mean reallife example value size bit four value bit size specify type specifier typespecifierlist list type specifier order separated hyphen dash default value used omitted type specifier following type specifier supported type integer float binary byte bitstring bit default integer byte shorthand binary bit shorthand bitstring signedness signed unsigned matter matching type integer default unsigned endianness big little native nativeendian mean endianness resolved load time either bigendian littleendian depending native cpu erlang machine run endianness matter type either integer float default big complete example one simplest protocol ntp header file look like following used request response let craft request first createntprequest based header structure see integer li integer version number integer mode stratum poll precision need set first value rest bit let try wild creating request request sending receiving use erlang builtin function one genudp pretty comprehensive lowlevel udp implementation want open local socket indicates pick random local port activefalse mean need receive ok socket genudp open binary active false genudp send socket request ok address port resp genudp recv socket ok processing response first bit response binary need slice dice similarly created request resp first get first bit restbinary resp li li version version mode mode work rest header bit tricky bitstring syntax easy manage processing response rest finally matching mandatory field resp making sense value requires bit legwork first need utility function binary fraction erlang function arity differentiates function following binfrac bin binfrac bin binfrac frac frac binfrac bin n frac binfrac bin bsr n frac bin band n function implement one process response return value interested offset unix epoch processntpresponse ntpresponse ntpresponse nowms now nowus erlang timestamp nowtimestamp nowms now transmittimestamp xmti binfrac xmtf li li vn version mode mode stratum stratum poll poll precision precision rootdelay rootdel rootdispersion rootdisp referenceid referencetimestamp rtsi binfrac rtsf originatetimestamp otsi binfrac otsf receivetimestamp rcvi binfrac rcvf transmittimestamp transmittimestamp clientreceivetimestamp nowtimestamp offset transmittimestamp nowtimestamp wit process response precision originatetimestamp offset please note first step ntp workflow implement complete ntp protocol take consideration bunch detail next time might look implement simple server like dns erlang michael original work http githubcommnperlangntp date version elixir port http
22,Lobsters,erlang,Erlang development,There's a new Language Server and Code Formatter for Erlang,https://notamonadtutorial.com/erlang-tooling-in-2020-b9606596353a,new language server code formatter erlang,blog post language server protocol erlangls github brujo led decision start working erlang code formatter thought erlang latecomer code formatting game design process tool look like pretty consistently ugly strange stuff erlang formatter compare wellknown formatting tool eg go fmt mix format rustfmt tool main difficulty found way developing handling comment along valid code common difficulty code analysing tool must deal erlang formatter handle likewise code formatter handle incorrect code macro configurable code formatter please obstacle adoption perceive kind adoption expect three think future erlang formatter actively erlang formatter usable else roberto aloi project start sourcer language server protocol compare similar effort sourcer lsp implementation sourcer blog post vscode erlang erlangls integrate existing erlang tooling eg elvis wrangler refactorerl gradualizer build server protocol encounter challenge way implementing lsp protocol specific erlang reddit language server index format mnesia find advantage within erlangbeam tech stack designing implementing erlangls syntaxtools,henry studley carpenter tool chest vox populi erlang tooling always lagging behind language elixir came along somewhat forced community action whatever exact cause true today erlang benefiting crosspollination new community building system around beam platformone fruit new plugin adding formatter erlang project initiator brujo wrote blog post presented asked followup questionsanother sorely needed piece tooling working implementation language server protocol server erlang several effort underway particular erlangls github headed roberto aloi reached recentlygiven serendipitous situation two important development erlang launched time decided joint interview brujo robertobrujowhat led decision start working erlang code formatter almost since started working developer always cared lot software maintainabilitythat generally advocate usage tool like xref dialyzer etca back working inaka learned hound ruby wanted something like erlang found nothing similar therefore worked juan facorro inakos create elvis fill voidin way since learned mix format started looking similar tool erlang knew could create tool presented project idea spawnfest twice luck opportunity presented hackweek nextroll weeklong hackathon happens twice year presented project juan bono diego calero thrilled help built team week first mvp even published hexpm alldo thought erlang latecomer code formatting game believe except language generally ahead time like smalltalk code formatter everybody us relatively new thing something expected modern language case even year ago hand getting traction official formatter new language like elixir go hard since many huge codebases around people enough time get attached formatting style yetfor older ecosystem like erlang impressively huge repository widely different code style even within convincing developer start using single universal code format easyand fact different editor like intellij emacs etc provide autoformatting tool one producing code distinct style share nothing others make even worsewhat design process tool look like hack week right trial error accurately digging trial errorjokes aside knew wanted first day going create tool capable parsing formatting breaking erlang code want formatted code pretty wanted consistently ugly achieved said check version hexpmto achieve goal wanted use many existing tool could find want reinvent wheel juan bono came pure hackathonstyle working different timezones barcelona juan buenos aire time done day day started told instance need tool parse erlang term another one print next day started message like found epp parse erlprettypr produce formatted output implemented solution came back epp handle macro well erlprettypr limited dug stuff told eppdodger many different reimplementations erlprettypr different trial error process repeatedat time diego constantly trying find strange edge case break formatter found strange stuff check test app repo promise say actually oncehow erlang formatter compare wellknown formatting tool eg go fmt mix format rustfmt one hand format still much younger le battletested toolsit also official yet hey otp read maybe would good idea conversation visit stockholm soon hand tool mention particularly mix format much strongly opinionated format practically one way format code themknowing hard convince every erlang developer world format code way aimed humble goal convince every erlang developer world format code tool keep style style use format apply whole project way reformatting code style matter running single command console brujo format rokstyle commafirst fan certainly default formatting style main difficulty found way developing think main issue lack clear documentation extensibility around existing tool work juan finding obscure otp module name like eppdodger actually function resembled actually needed close enough invaluable much code invisible unprepared eyeif tool like eppdodger erlprettypr etc visible extensible formatter would reality many year agohandling comment along valid code common difficulty code analysing tool must deal erlang formatter handle luckily u tool provided otp already work need patch mostly trivial stuff hand still comment format handle beautiful manner format lose comment file might misplace bit particularly want add comment thing like type field nothing solved manually moving comment better place filelikewise code formatter handle incorrect code since use tool compiler us parse code formatter find syntactically incorrect code fails like compiler would hand since formatter process macro code invalid macro formatter format anyway even syntactically correct semantically incorrect code eg function unused exported variable used bound etc formatted anywaywhat formatter actually learned oldreliable steamroller verify ast generated code affected formatter ie ast generated code formatting exactly except line number ast generated code running formatter configurable code formatter lot basically two level first need choose formatter use ie implementation behavior format code format come two default otpformatter basically erlprettypr defaultformatter nextroll preferred way formatting code formatter list option use default formatter approximately different option tweak otp formatter allows change paper ribbonof course create formatter need implement behavior accept contribution create rokstyle formatter please send pull request obstacle adoption perceive kind adoption expect oddly enough biggest obstacle likely competition daniel oldreliable put think time remembered great formatter war age formatters erlang many people complained one two soon three format steamroller one michał muskała soon presentin case sad believe three different formatters far better none think future erlang formatter become de facto formatter erlang code whole wide world course dream big right seriously greatest dream formatter would considered default erlang formatter maybe otp team adopts start requiring contribution erlangotp code formatted etc etc realistically say plan use erlang project within nextroll already using opensource one progressively adding private one much massive keeping mind company committed providing support actively expect help community form bug report configuration formatter idea pull request erlang formatter usable else think main focus day education working group erlang ecosystem foundation active member working initiative called meetup intervention early stage idea help meetup organizer around world provide workshop session training different subject introductory others advanced first round workshop start soon miriam pena simon thompson johnny winn trainer see go decide properly scale idea think great successbesides recently moved sant cugat del vallès beautiful town near barcelona spain give access many european thing giving talk codebeam sto may attending elixirconf eu also helping new friend revitalize elixir meetups madrid hopefully visiting coruña university soon give guest lecture tooi excited opportunity much closer still settling new home already love finally would like mention even particularly active erlang battleground lately still looking happen idea something beamrelated want write contact help get published shared lot people roberto aloihow project start original plan simply start contributing edts http githubcomsebastiwedts project erlang development tool suite emacs editor project actively maintained longer experiencing issue upgrading latest version erlangotpi started diving edts codebase discovered architecture particularly interesting emacs client implemented emacs lisp communicating via http server implemented erlang responsible heavylifting played idea bit effort one could grow http api used clientserver communication edts something solid generic allowing editor reuse logic implemented edts serversome week code beam stockholm conference attended talk author sourcer project gave introduction language server protocol apparently microsoft already thought meant go process designing brandnew protocol could simply focus implementing server maybe based edts one would comply protocol started looking existing language server implementation erlang guess lead second compare similar effort sourcer lsp implementation currently three major implementation language server aware sourcer year old codebase erlang plugin eclipse converted language server make hard contribute familiar original project sourcer make heavy use custom library scanner parser erlang l try leverage otp library much possible project last updated six month ago know current status development checkout blog post accurate comparison erlang l sourcervscode erlang visual studio extension includes erlang language server project tightly coupled vscode editor though defeat purpose language server first placeerlang l built scratch language server aim truly ideagnostic lot effort put documenting installation process different editor providing clear troubleshooting procedure end usershow erlangls integrate existing erlang tooling eg elvis way see erlang l act platform allows thirdparty tool elvis smoothly integrate development workflowsin erlang community many tool exist lot potential used limited way developer refactoring tool wrangler refactorerl good example case installation process tool straightforward case tool tightly coupled specific editor unavoidably limit adoption tool could live reinassance period get thing right erlang l hope crosseditor platform available erlang tool find attention deserveanother interesting situation competing tool exist solving problem code formatters example erlang scene currently experiencing little explosion term formatting tool adroll released whatsapp presenting new formatter code beam san francisco speak dialyzer gradualizer another example two different strategy pro con achieve goal case idea provide integration tool via erlang l platform tool work outofthebox always possible end user optin optout specific integration major challenge approach end language server bloated dependenciesi also glad mentioned since fall different category tool deserve separate discussion building tool erlang l accepts lowlevel configuration parameter dependency path include directory custom macro definition etc set via erlanglsconfig specific project used instruct server build erlang module also going introduce concept project type first one user mark project one course automate process looking presence rebarconfig file lowlevel configuration parameter required language server automatically inferred rebarconfig file minimizing required configuration approach make project work outofthebox erlang l ensuring erlang l still used project use building tool choice also keeping eye build server protocol require investigationdid encounter challenge way implementing lsp protocol specific erlang lsp protocol fairly new still go maturity process part protocol overengineered handshaking shutdown sequence fact protocol support two different transport tcp stdio feel unnecessary concept mentioned protocol either well explained eg document link coupled specific language need eg distinction gotodefinion v gotodeclaration v gotoimplementation interesting reddit post author one vim lsp client highlight lsp protocol imperfectionseven ide nowadays decent lsp client intellij integration particularly challenging u testing language server also trivial task actually mind create testing framework language server combining propertybased testing language server index format deserves blog post window support also revealed particularly challenging due fact windowserlang stack travis ci github actionsin term erlang specific challenge major one probably decide database use persist indexed information currently settled mnesia used keyvalue store two main reason minimize setup end user mnesia come erlangotp require additional installation step allows u store erlang term without need encodingdecoding mnesia come challenge though get performance needed big project million line code dig mnesia internals tweak setting mnesia also distributed database feel bit like overkill singlenode project like erlang l see decide keep move different solutionfinally erlang standard library still lack opinion basic functionality one would expect stdlib implement function delete nonempty directory deal relative absolute path even function hard implement require time member erlang community bit proactive ensuring contribute type functionality erlangotpdid find advantage within erlangbeam tech stack designing implementing erlangls plenty experience using erlang implement language server awesome farpattern matching message passing combined flexibility map encodedecode json entity make implementation protocol straightforward lightweight process allow u implement feature cancellable request background job sometimes hard implement using technology stack trivial idiomatic way behaviour give wonderful way separate generic implementationspecific part code use heavily implementing provider transport syntaxtools library contain building block necessary play abstract syntax tree erlang program even quirk ability attach running language server using remote shell trace individual request client play crucial role troubleshoot bug would required plenty stepbystep debugging ioformatting otherwise common test group precious parameterize test run stdout tcp transport could continue long time stop really hope erlang l make easier newcomer erlang community get chance get started erlang minimal friction experience wonderful advantage beam tech stack provide implementing erlang project
23,Lobsters,erlang,Erlang development,"BEAM in the Browser with Lumen, Part 1: Motivations & Constraints",https://tylerscript.dev/bringing-the-beam-to-webassembly-with-lumen,beam browser lumen part motivation constraint,preface paul schoenfelder talk introducing lumen rust project lumen dockyard lumen existing beam build steady api crosspollination wasm become widely supported otp user interface actor model supervision tree erlang term storage observer browser thing know webassembly next section already familiar webassembly webassembly assembly language harvard architecture harvard architecture von neumann architecture jump table structured control flow structured control flow control flow graph talking webassembly integer value ffi bring elixirerlang environment code size load time wasm concurrency model web worker javascriptdom interop async function event ffi mentioned earlier use beam runtime apis incompatible scheduler shipping beam bytecode expensive hot code reloading hot code reloading dead code elimination performance consideration thanks reading paul schoenfelder,april preface article first short series aiming unofficially transcribe interpret paul schoenfelder excellent talk introducing lumen alternative beam implementation written rust hope writing might assist others goal eventually contributing project lumen lumen new compiler runtime erlangelixir developed thanks support dockyard primarily built around erlang support elixir language compile beam bytecode central goal project bring language browser functionality beam otp standard library least part worth bringing targeting webassembly lumen new elixirlike syntax top javascript elixir javascript transpiler effort crosscompile existing beam implementation wasm effort replace existing beam build steady api crosspollination common criticism clientside web ecosystem fractured constantly flux much could symptom enormous reach popularity new pattern feature brought javascript browser dom apis time could argue left shaky ground build application looked another way using elixir erlang backend javascript frontend pretty likely reason using javascript defacto language web wasm become widely supported begin change given choice many would choose invest one language ecosystem could effectively support environment organizational benefit like code reuse ease endtoend knowledge sharing difficult ignore otp user interface actor model beam actually mesh well pattern see componentbased userinterface library like react component thoughtfully designed react application essentially tightly focused state machine tree responsible one part application except without significant effort one encounter error often crash rest took application implemented elixirerlang based frontend component could exist supervision tree operating concurrently able crash fail recover without affecting rest application get beam running browser also get pattern otp tooling come imagine implementing client application using erlang term storage miniature database key many common beam pattern spinning observer analyze memory consumption performance browser application alongside rich standard library thing know webassembly getting technical detail lumen thing know wasm next section already familiar webassembly webassembly abbreviated wasm binary instruction format stackbased virtual machine wasm designed portable target compilation highlevel language like ccrust enabling deployment web client server application think like assembly language slightly higherlevel look like simple function module func param lh param rh result localget lh localget rh harvard architecture webassembly built upon harvard architecture machine based common von neumann architecture code data live memory address space mean simple take address code jump start executing using harvard architecture code data address space separate take address code call equivalent function pointer actually index jump table function wasm runtime know order call function give index argument table runtime check see exists nothing found instead accessing invalid memory structured control flow goto explanation explanation wasm operates something called structured control flow instead using control flow graph difference control flow graph allow multiple entry point piece code whereas structured control flow dictate everything must one entry point mean design jump like goto instead provides structured control flow construct like ifelse one one hand good thing express irreducible loop wasm attack use arbitrary jump assembly impossible add complexity implementation come expressing beam behavior utilize goto statement talking webassembly let memory new webassemblymemory passing data wasm javascript module exactly simple currently pas integer value across barrier sound incredibly difficult anything useful constraint like essentially way pas object convert sharing pointer linear memory wasm module parsing memory limitation large impact ffi interoperability javascript dom apis bring elixirerlang environment compile wasm must accommodate major constraint code size load time building api life server easy overlook consider deliver virtual machine code make useful every client loading lumen application client also compile code even run achieve small code size also deliver fast load time user expect web environment wasm concurrency model let wasmworker new worker workerjs wasm achieves concurrency using web worker spawn web worker run code named javascript file separate calling window process make different traditional server environment web worker behave like multiple different process operating system rather multiple thread within process mean actortoactor message passing currently nontrivial share memory effort underway work around worth noting threading model wasm still evolving javascriptdom interop webassemblyinstantiatestreaming fetch lumenwasm importobject result also appropriately accommodate javascript runtime async function scheduler lumen much like beam scheduler represent javascript async function separate closure within erlangelixir garbage collected javascript runtime must managed separately event event receive javascript dom surfaced message process erlangelixir rather getting giving callback fired event come get message like would event erlangelixir application central idea making usually server bound language compatible browser environment ensuring consistent behavior delivering either client server ffi integer time limitation mentioned earlier pas data back forth need handle translation erlang term javascript value every time cross barrier different ffi traditional server environment pas thing directly via erlnif api translation routine javascript side wasm side make work use beam make existing beam implementation work web instead build ground runtime apis apis beam expects available present wasm environment virtually everything runtime depends system apis even memory allocation incompatible scheduler could argue apis could shimmed worked around bigger problem thing like treat j async function separate resource erlang closure current beam scheduler would need almost completely rewritten accommodate anyway shipping beam bytecode expensive beam bulky full dependency tree average elixirerlang application get ten megabyte completely nonviable web every module dependency tree included final build accommodate two major thing hot code reloading otp allows hot code reloading meaning point might need call code dependency tree currently called source function allows call function completely dynamically runtime constraint ultimately mean get pretty weak dead code elimination capability reduce code size performance consideration finally issue running virtual machine top another virtual machine browser actually pretty clever way generate native code wasm javascript executing beam bytecode top virtual machine effectively reason beyond seeing central core loop executing limit option looking apply optimization code really want implementation come computational performance ceiling like place start thing considered give u pretty compelling reason pursue alternative implementation better suited requirement web thanks reading part currently progress covering second half paul schoenfelder talk discussing lumen compiler tackling challenge kudos kudos
24,Lobsters,erlang,Erlang development,Comparing Cpp And Erlang For Motorola Telecoms Software,https://www.slideshare.net/Arbow/comparing-cpp-and-erlang-for-motorola-telecoms-software,comparing cpp erlang motorola telecom software,user agreement privacy policy privacy policy user agreement,slideshare us cooky improve functionality performance provide relevant advertising continue browsing site agree use cooky website see user agreement privacy policy slideshare us cooky improve functionality performance provide relevant advertising continue browsing site agree use cooky website see privacy policy user agreement detail
25,Lobsters,erlang,Erlang development,Squeezing the most out of the server: Erlang Profiling,http://tech.nextroll.com/blog/dev/2020/04/07/erlang-profiling.html,squeezing server erlang profiling,squeezing server erlang profiling realtime bidding past article hazardous land software optimization without profiling first infrastructure requestlevel timer recon fred hebert erlang anger recon redbug redbug erlang easy profiling eep eep kcachegrind erlgrind lookingglass erlang systemmonitor conclusion observer eprof fprof eflame eministat efficiency guide builtin profiling module,squeezing server erlang profiling written facundo olano april realtime bidding rtb platform featured several time tech blog run fleet erlang application bidder typically range one two thousand node described past article ongoing goal rtb team well source interesting technical minimize operational cost much possible obvious way reduce cost make system efficient mean entering hazardous land software optimization even experienced programmer identifying bottleneck hard enough problem using right tool trying guess could make code run faster waste time likely introduce unnecessary complexity cause problem line cousin premature optimization necessary optimization without profiling first erlang famously known concurrency model faulttolerant design one biggest strength level live inspection tuning offer often little setup runtime cost article outline leverage feature profile system driving optimization lead cost reduction minute read infrastructure interesting aspect realtime bidding fairly lowrisk test production even new code slow contains error bidder architected send nobid response whenever request fulfilled taking advantage incorporate canary deploys daytoday development workflow context optimization mean quickly test performance hypothesis updating code testing live traffic metric dashboard give feedback common metric like timeouts error amount request processed making obvious change beneficial requestlevel timer bid request processing fundamental operation bidder application improvement amount time take u send response ad exchange mean process request per server requiring fewer server handle traffic ultimately saving u money work involved bid request broadly divided series task payload parsing selection matching ad pricing particular ad response encoding common practice periodically measure time invested phase make sure degrade time help provide frame reference use look area code worthy optimization effort sample bid request timing per phase basic way profiling consists timing call given piece code perhaps one deemed suspicious one method described next section evaluates fun report evaluation time histogram metric spec timecall name fun result result timecall metric fun start erlang systemtime microsecond result fun end erlang systemtime microsecond diff end start update histogram metric diff result helper used wrap call function want measure canary deploy timed code production generate average median percentile metric compare overall request time identify bottleneck recon timing request operation useful technique understanding specific request flow give u limited perspective entire system bid request phase handled single process involve idle time waiting external system many periodic task longlived support process bidder benefit systemwide profiling look beyond bid request processing erlang toolbox come play first valuable resource piece software little book fred hebert erlang anger guide perfect reference describes method gaining insight optimizing production system backed realworld experience companion library recon provides safer friendlier productive interface powerful inspection tool follows simple example mostly derived book get node general stats bidderdev node recon nodestatsprint schedulerusage get top memory consumer bidderdev node recon proccount memory bidderbanker currentfunction genserver initialcall proclib bidguardian currentfunction genserver initialcall proclib currentfunction priminet initialcall proclib get top cpu consumer bidderdev node recon proccount reduction currentfunction exometerprobe initialcall proclib currentfunction exometerprobe initialcall proclib currentfunction exometerprobe initialcall proclib get top cpu consumer time window bidderdev node recon procwindow reduction currentfunction viewsbid initialcall proclib currentfunction timer initialcall proclib currentfunction priminet initialcall proclib get process stats including stacktrace bidderdev node recon info meta registeredname bidderbanker dictionary initialcall bidderbanker ancestor biddersup groupleader status running signal link monitor monitoredby trapexit true location initialcall proclib currentstacktrace bidderbanker file biddersrcpacingbidderbankererl bidderbanker file biddersrcpacingbidderbankererl bidderbanker file biddersrcpacingbidderbankererl bidderbanker file biddersrcpacingbidderbankererl genserver file genservererl genserver file genservererl proclib file procliberl memoryused garbagecollection maxheapsize errorlogger true kill true size work suggested book good method run recon procwindow repeatedly try identify pattern eg process frequently rank among top cpu consumer process id passed recon info get useful information stacktrace order understand process using method quickly found commonly accessed data structure contained debug data copied thousand time per second approach though tend highlight longrunning busy process shortlived one could called lot account bigger overhead overall partially overcome running procwindow repeatedly aggregating result location rather process id however better tool look aggregated process time redbug strictly speaking redbug profiling tool useful debugging live system deserves mention article allows safely trace function shell intuitive yet sophisticated way opposed rougher erlang builtin tracing module handy get quick notion function called frequently production data look like bidderdev node redbug start jiffy erlang jiffy encode bidderdev node redbug start jiffy encode return erlang jiffy encode usd erlang jiffy usd bidderdev node redbug start jiffy encode n isinteger n return erlang jiffy encode erlang jiffy including recon redbug erlang application release cost real lifesaver diagnosing production issue tool promote flow powerful adding print code feel natural step debugger useful highly concurrent world anyway erlang easy profiling eep eep allows approach profiling using erlang tracing take snapshot system operation function call count execution time interdependency requires bit effort use safe rest tool described article slow system potentially even killing used carelessly output file eat lot disk space m snapshot take system depending nature application may make sense run directly production example tracing session using eep bidderdev node eep startfiletracing filename timer sleep eep stoptracing note start sleep stop tracing line rely shell responsive tracing could send message call function well force certain part code executed taking snapshot instruction output filenametrace file release directory file need moved production server processed local erlang shell local eep converttracing filename working msg msgssec sec slowdown msg msgssec sec slowdown done turn produce callgrindoutfilename input kcachegrind qcachegrind macos note default tracing discriminate entry per process id would yield similar situation saw recon procwindow interesting view merge function call process accomplished stripping pid grep v ob callgrindoutfilename callgrindoutmergedfilename qcachegrind callgrindoutmergedfilename qcachegrind present snapshot sophisticated ui used spot frequently called function time spent etc eep output qcachegrind since eep based erlang tracing add overhead code may comparatively misrepresent work done builtin function bifs nativeimplemented function nifs timing shown snapshot need taken grain salt nevertheless still great exploratory tool understand different component system interact dependency used learn obscure suspicious area hard spot looking code note erlang profiling library tried yet produce callgrind output erlgrind lookingglass erlang systemmonitor yet another way looking application erlang bif allows set process receive message every time certain condition met particularly helpful u examining long garbage collection schedule long duration latter surface issue nifs would go unnoticed method example use shell based snippet erlang anger bidderdev node loop fun f receive monitor pid event info reconlocation recon info pid location io format monitorp pidp n infop n reconpn event pid info reconlocation end f end bidderdev node spawn fun register tempsysmonitor self erlang systemmonitor self longschedule longgc loop end timer sleep exit whereis tempsysmonitor kill monitor system second output process information shell every time garbage collection schedule take monitorlonggc pid info recon location initialcall proclib currentstacktrace bidderstat file biddersrcbidderstaterl viewsbid file biddersrcviewsviewsbiderl viewsbid file biddersrcviewsviewsbiderl erlstat file biddersrcbidderstaterl bidderwebhandler file biddersrcbidderwebhandlererl proclib file procliberl conclusion article mean exhaustive list erlang diagnosing tool observer eprof fprof eflame eministat list go erlang documentation nice efficiency guide overview builtin profiling module since started effort consistently reduced request time operational cost month month large extent gain came thanks advanced tool erlang ecosystem offer interesting achieved getting know system better fixing bug often removing rather adding specialized code
26,Lobsters,erlang,Erlang development,The New Scalable ETS ordered_set,http://blog.erlang.org/the-new-scalable-ets-ordered_set/,new scalable ets orderedset,contention adapting search tree try escript avl tree contention adapting search tree nutshell ca tree paper preprint pdf thread progress click benchmark test suite ets page note decentralized counter reading ets ca tree source code author phd thesis conclusion,august kjell winblad scalability ets table type orderedset writeconcurrency option substantially better erlangotp earlier release extreme case expect time better throughput erlangotp compared erlangotp cause improvement new data structure called contention adapting search tree ca tree short blog post give insight ca tree work show benchmark result comparing performance ets orderedset table otp otp try escript make convenient try new orderedset implementation machine erlangotp installed escript measure time take p erlang process insert n integer orderedset ets table p n parameter escript ca tree utilized ets table option orderedset writeconcurrency true active one therefore easily compare new data structure performance old one avl tree protected single readerswriter lock writeconcurrency option effect orderedset table release erlangotp get following result running escript developer laptop two core intel r core tm cpu escript insertdisjointrangeserl old time second escript insertdisjointrangeserl old time second escript insertdisjointrangeserl old time second escript insertdisjointrangeserl new time second escript insertdisjointrangeserl new time second escript insertdisjointrangeserl new time second see particular benchmark ca tree superior scalability old data structure benchmark ran twice fast new data structure four process old data structure one process machine two core look performance scalability new ca treebased implementation greater detail later describing ca tree work contention adapting search tree nutshell key feature distinguishes ca tree concurrent data structure ca tree dynamically change synchronization granularity based much contention detected inside data structure way ca tree avoid performance memory overhead come using many unnecessary lock without sacrificing performance many operation happen parallel example let u imagine scenario ca tree initially populated many thread parallel used single thread scenario ca tree adapt use finegrained synchronization population phase finegrained synchronization reduces contention ca tree change use coarsegrained synchronization singlethreaded phase coarsegrained synchronization reduces locking memory overhead structure ca tree illustrated following picture actual item stored ca tree located sequential data structure bottom layer sequential data structure protected lock base node middle layer base node lock counter associated counter base node lock increased contention detected base node lock decreased contention detected value base node lock counter decides split join happen operation performed base node routing node top picture form binary search tree directs search particular item routing node also contains lock flag used joining base node detail splitting joining work described article interested reader find detailed description ca tree paper preprint pdf illustrate ca tree change synchronization granularity going example initially ca tree consists single base node sequential data structure depicted picture parallel thread access ca tree value base node counter may eventually reach threshold indicates base node split base node split divide item base node two new base node replaces original base node routing node two new base node rooted following picture show ca tree base node pointed tree root split process base node splitting continue long enough contention base node lock max depth routing layer reached following picture show ca tree look like another split synchronization granularity may differ different part ca tree example particular part ca tree accessed frequently parallel rest following picture show ca tree yet another split following picture show ca tree fourth split following picture show ca tree fifth split two base node holding adjacent range item joined join triggered operation see base node counter value certain threshold remember base node counter decreased thread experience contention acquiring base node lock might noticed illustration splitting joining result old base node routing node get splicedout tree memory node occupy need reclaimed happen directly got splicedout thread might still reading erlang runtime system mechanism called thread progress ets ca tree implementation us reclaim node safely click see animation example benchmark performance new ca treebased ets orderedset implementation evaluated benchmark measure throughput operation per second many scenario benchmark let configurable number erlang process perform configurable distribution operation single ets table curious reader find source code benchmark test suite ets following figure show result benchmark machine two intel r xeon r cpu core total hyperthreading average set size scenario detail benchmark machine configuration found page see throughput ca treebased orderedset improves add core way core old implementation throughput often get worse process added old implementation write operation serialized data structure protected single readerswriter lock slowdown old version adding core mainly caused increased communication overhead core try acquire lock fact competing core frequently invalidate cache line graph lookup scenario last graph list graph look bit strange first sight ca tree scale much better old implementation scenario answer almost impossible guess without knowing implementation detail orderedset table type first ca tree us readerswriter lock implementation base node lock old implementation us protect whole table difference thus due lock difference default orderedset implementation one active writeconcurrency optimization mainly improves usage scenario single process iterates item table example sequence call ets function optimization keep static stack per table operation use stack reduce number tree node need traversed example ets operation need recreate stack top stack contains key one passed operation see one static stack per table potentially many reader due readerswriter lock static stack reserved thread currently using unfortunately static stack handling scalability bottleneck scenario like one lookup ca tree implementation type optimization suffer scalability bottleneck however also mean old implementation may perform better new one table mainly sequentially accessed one example old implementation still used setting writeconcurrency option false performs better single process case insert delete lookup sequence ets call scenario second last graph list graph therefore conclude turning writeconcurrency orderedset table probably good idea table accessed multiple process parallel still turning writeconcurrency might better mainly access table sequentially note decentralized counter ca tree implementation optimization introduced erlangotp affecting scalability orderedset writeconcurrency optimization decentralized counter orderedset table writeconcurrency turned also introduced erlangotp see option enable optimization table type introduced erlangotp see find benchmark result comparing scalability table without decentralized counter reading following paper describes ca tree optimization applied ets ca tree yet much detail blog post paper also includes experimental comparison related data structure also lockfree variant ca tree described following paper lockfree ca tree us immutable data structure base node substantially reduce amount time range query similar operation conflict operation following paper discus evaluates prototypical ca tree implementation ets first ca treerelated paper look directly ets ca tree source code interested specific implementation detail finally might also interesting look author phd thesis want get link related work want know motivation concurrent data structure adapt contention conclusion erlangotp release introduced new ets orderedset implementation active writeconcurrency option turned data structure contention adapting search tree superior scalability old data structure many different scenario design give excellent performance variety scenario benefit different synchronization granularity
27,Lobsters,erlang,Erlang development,The BEAM Has Spoiled Me,https://gvaughn.github.io/2020/08/08/beam_spoiled_me.html,beam spoiled,beam spoiled began fault tolerance let crash freedom bigger thought game changer,august beam spoiled greg vaughn noticed change prefer develop software since focusing career elixir allows think bigger thought develop lower friction le fear want go back began fault tolerance many people introduced elixir focus concurrency joe armstrong even called erlang concurrency oriented language note point generic beam language experience come elixir perspective please excuse bias terminology find helpful consider concurrency logical consequence primeval concern fault tolerance achieving beamstyle fault tolerance come isolated process affect crash plus supervisory process informed another process dy core point process contain blast radius damage caused error happens isolation quality enable also make great candidate concurrency let crash first heard let crash mantra erlang community sounded crazy based prior development exerience important understand license irresponsibility care system crashing core recognition system error even write bugfree code hardware bug u eventually architecture managing blast radius damage little part system crashing longer scary thing le fear yes please learned write elixir code focus blast radius driver reach process even case need concurrency use process enclose damage error might cause use supervision tree durable work queue recover minor crash process learned prefer upserts insert allow logic retried safely greater idempotency two idea process enclose possible error plus idempotency become second nature elixir code write freedom automatic ability recover error change complexion topic like test coverage enforcement static type extensive code review etc heart preventing error introduced first place yes recognize secondary benefit still good thing advocating irresponsibility solid safety net fault tolerance beam able look different perspective see add friction inertia delivering software perhaps temper reliance upon favor greater delivery speed circumstance le fear mean freedom choose bigger thought elixir reignited intellectual interest software development found via erlang beam history general huge body wisdom distributed system learn new tool toolbox think software process lightweight pervasive offering freedom fear crashing perspective shifted exciting way think writing web application thought immediately limited think building system think bigger thought better abstraction build upon team happy use elixir write web application fit preexisting microservice deployment model urge developer reach bigger thought fault tolerant lighweight process enable consider process logical microservice need friction deploying separately serializing tofrom json container orchestration distributed logging etal deploy entire system million interacting logical microservices single beam release game changer elixir beam certainly game changer fearless build system hope share freedom others beam spoiled good way tag beam elixir introspection
28,Lobsters,erlang,Erlang development,Erlang dbg Intro,https://antranigv.am/weblog_en/posts/erlang-dbg-intro/,erlang dbg intro,erlang elixir kernel process messaging facility many elixir tcp server application tree see,one programming language changed life erlang using erlang couple year moved elixir based erlang vm one important aspect erlang vm real vm kernel process messaging facility many lately debugging huge erlang application whose architecture familiar needed find way see kind message sent received module function called returning wanted write small howto case need future okay example using elixir tcp server simple tcp server get data sends back origin first let clone repo antranigv zvartnots prj git clone http githubcomsonatigranyanelixirtcpserver okay let run server antranigv zvartnots elixirtcpserver iex mix erlangotp source hipe compiling file ex generated tcpserver app interactive elixir press ctrlc exit type h enter help iex good default tcp server listens port specified application tree okay send data antranigv zvartnots elixirtcpserver echo test nc localhost test interactive way antranigv zvartnots elixirtcpserver nc localhost first mesage first mesage good tcp server good tcp server bye antranigv zvartnots elixirtcpserver good see connection closed server get bye okay say want trace dosend function observe get return iex dbgstart ok pid iex dbgtracer ok pid iex dbgtpl tcpserver dosend returntrace ok matched nonode nohost saved iex dbgp newprocesses c ok matched nonode nohost iex call elixirtcpserver dosend port message client n okay first start dbg facility start tracing server local node use function tpl specify local call want trace end use p function start tracing call c newprocesses dosend function called see get send bye see following returned elixirtcpserver ok happening software system running production either attaching node connecting folk
29,Lobsters,erlang,Erlang development,The Erlang Runtime System,https://blog.stenmans.org/theBeamBook/,erlang runtime system,,list sort list seq erlang list sort erlang list redbug done timeout
30,Lobsters,erlang,Erlang development,"v0.10 of Gleam, a statically typed language for the Erlang VM, is out",https://lpil.uk/blog/gleam-v0.10-released/,gleam statically typed language erlang vm,module constant ahmad sattar bit string syntax benjamin tan blog post encoding alternative tom whatmore rest erik terpstra peter saxton gleam changelog standard library changelog supporting gleam sponsoring gleam sponsored,month line code later time another gleam release let see new time module constant sometimes want use certain fixed value multiple place project two option first option copy paste value multiple place code pub fn isbefore year int bool year pub fn isduring year int bool year year duplication value like error prone especially want update value later need find every place used order change another option wrap value function pub fn startyear int pub fn endyear int pub fn isbefore year int bool year startyear pub fn isduring year int bool startyear year year endyear better copying value code yet ideal function perform amount computation side effect called read definition function sure make matter worse gleam case clause guard support calling function within code rejected compiler pub describe year int string case year year year startyear year year endyear solve problem gleam module constant always inlined compiler used case clause guard using code rewritten like pub const startyear int pub const endyear int pub fn isbefore year int bool year startyear pub fn isduring year int bool startyear year year endyear pub describe year int string case year year year startyear year year endyear much better module constant going provide basis exciting new feature future watch space thanks ahmad sattar taking lead implementation feature bit string syntax one great thing erlang easy work raw bit byte using bit string literal syntax starting release gleam support explaining thing one bit string syntax would take longer short give declarative way constructing parsing raw data format erlang vm highly optimised bit syntax highly efficient example wanted create bit unsigned little endian integer value could using bit syntax like let myinteger unsignedlittleintsize wanted extract title artist album year comment music file tag could pattern match like pub fn getmetadata bitstring result metadata string case tag title binarysize artist binarysize album binarysize year binarysize comment binarysize rest binary ok metadata title artist album year comment error valid tag thanks benjamin tan blog post example another example bit syntax action check serious encoding alternative convert arbitrary data emojis part new feature introduced bitstring utfcodepoint type prelude split standard library iodata type stringbuilder bitbuilder type efficiently constructing string bit string respectively thanks tom whatmore taking lead implementation feature rest many new addition improvement bug fix compiler standard library including limited support regex expression implemented erik terpstra environment variable implemented peter saxton information rest release please check gleam changelog standard library changelog supporting gleam would like help make strongly typed programming erlang virtual machine productionready reality please consider sponsoring gleam via github sponsor program release would possible without support people sponsored contributed huge thank thanks reading fun
31,Lobsters,erlang,Erlang development,Operating via development,https://www.theerlangelist.com/article/operating_via_development,operating via development,certbot siteencrypt instruction start system locally phoenix live dashboard soul erlang elixir certification acme automatic certificate management environment protocol siteencrypt make task straightforward midlevel module lowerlevel module reducing devproduction mismatch testability automation tight integration operation final thought,two year ago decided add http support site using automatic certification via let encrypt article subject relied tool called certbot couple variation mentioned requiring tool run site others using nginx certbot combination seemed installing running additional external tool production mandatory point erlangelist standalone elixirpowered system required external program seemed start worrying setting additional service interact using custom dsl would complicate operation create disconnect production development change certification configuration would need tested directly production alternatively setup staging server either way testing certification would done manually unhappy state started work siteencrypt library take different approach automatic certification siteencrypt library dependency external tool required install oslevel package use certification process periodical renewal running o process rest system o process need started everything configured project system implemented interaction siteencrypt done via elixir function data yaml ini json kind dsl required trivial run certification locally reduces difference prod local dev support automatic testing certification provided need setup staging machine make change directly production system example call integrated operation instead spread across bunch yamls inis jsons bash script somehow glued together oslevel operation done development ie place rest system implemented using language approach significantly reduces technical complexity system erlangelist mostly implemented elixir administrative task installation o package user creation port forwarding rule similar provisioning task done outside elixir also simplifies local development instruction start system locally simple install build tool elixir erlang nodejs fetch dependency invoke single command start system locally started system extremely close production version almost nothing significance running production running locally two difference note think port forwarded prod prod version us let encrypt certification local version us local ca server later may sound like much simple blog host behind scene erlangelist bit simple request responder erlangelist system run two separate web server public facing server one use read article another internal server us phoenix live dashboard expose metric small handmade database running collect aggregate persists reading stats periodically removing older stats disk system periodically renews certificate locally ci another web server act local certificate authority ca running word erlangelist blog site server app system consisting multiple activity collectively work together support full enduser service well operational aspect system activity running concurrently block crash system utilizes cpu core host machine detail work take look talk soul erlang elixir let take closer look siteencrypt certification let encrypt support automatic certification via acme automatic certificate management environment protocol protocol describes conversation client system wanting obtain certificate domain server certificate authority ca create certificate acme conversation system asks ca provide certificate domain ca asks u prove owner domain ca give u random byte make request domain expecting get byte return also called challenge successfully respond challenge ca create certificate u real story course involved simplified version hopefully give basic idea conversation activity system job need occasionally done allow system provide full service certification valid certificate people use site likewise decide shut site certification serf purpose anymore situation preferred approach run activity together rest system le fragmented system easier manage running part system externally fine stronger reason see reason simple scenario siteencrypt make task straightforward add library dep fill blank good go certification configuration provided defining certification function def certification siteencryptconfigure client native domain mysitecom wwwmysitecom email contact mysitecom anothercontact mysitecom dbfolder folderwheresiteencryptstoresfiles directoryurl directoryurl end code look pretty declarative executable code collection fact mean lot flexibility shape configuration data however want example want make certification parameter configurable system operator say via yaml file nothing stop u invoking loadconfigurationfromyaml instead hardcoding data say want make parameter configurable eg domain email leaving rest hardcoded simply keywordmerge loadsomeparamsfromyaml hardcodeddata supporting kind config source like etcd database equally straightforward always build declarative top imperative opposite require imagination trickery running external configuration generator good luck managing production also worth mentioning siteencrypt internally ship two lowerlevel module sort plumbing porcelain midlevel module provides workflowrelated operation create account perform certification lowerlevel module provides basic acme client operation module used want finer grained control certification process reducing devproduction mismatch one interesting thing happening configuration presented earlier def certification siteencryptconfigure directoryurl directoryurl end directoryurl property defines ca siteencrypt obtain certificate instead hardcoding url invoking function compute happens need use different url production v staging v local development let take look defp directoryurl case systemgetenv mode local production http staging http local internal port end end distinguishing production staging development based mode o env easily replaceable source owing programmable api env provided assume system running locally production machine go real ca staging use let encrypt staging site internal port thing use local development pas particular shape data siteencrypt internal acme server started given port sort local mock let encrypt server running inside o process rest system locally siteencrypt start mock let encrypt use mock obtain certificate word locally system certify example action local version erlangelist iex mix phxserver info running erlangelistwebblogendpoint http info running erlangelistwebblogendpoint http info running local acme server port info creating new acme account domain theerlangelistcom info ordering new certificate domain theerlangelistcom info new certificate domain theerlangelistcom obtained info certificate successfully obtained testability since local erlangelist behaves exactly real one test system behaviour example even local version http request redirected http test verifying test http request redirected http assert redirectedto clientget http localhost http localhost end likewise redirection www also tested test theerlangelistcom redirected wwwtheerlangelistcom assert redirectedto clientget http theerlangelistcom http wwwtheerlangelistcom end contrast external proxy rule defined nginx configuration typically tested mean change configuration might break something else way obvious operator addition siteencrypt ship small helper testing certification relevant test test certification cleanrestart erlangelistwebblogendpoint cert getcert erlangelistwebblogendpoint assert certdomains wtheerlangelistcom wwwtheerlangelistcom end test blog endpoint ie blog web server restarted previously existing certificate removed restart endpoint certified via local acme server certification go whole process mocking save fact local ca used http request made key generated system call ca concurrently make request system ultimately certificate obtained finished invocation getcert establish ssl connection blog server fetch certificate peer assert expected property certificate test significantly increase confidence system course always chance something going wrong production eg dns correctly configured let encrypt reach site possibility error reduced test also compiled language used example make syntax error changing configuration code even compile let alone make production make typo eg specifying theerlangelistorg instead theerlangelistcom certification test fail contrast external configuration much harder test typically end manually verified staging case production automation beyond obtaining certificate siteencrypt periodically renew periodic job executed three time day job check expiry date certificate start renewal process certificate expire day addition every time certificate obtained siteencrypt optionally generate backup data system starting siteencrypt database folder present backup file exists siteencrypt automatically restore database backup user siteencrypt zero work make happen significantly reduces amount operational work required bringing bulk regular development elaborate backup scenario siteencrypt provides callback hook endpoint module define function invoked certificate obtained use function eg store cert arbitrary secure storage choice notice becomes part regular system codebase convenient logical place express task fact running together rest system also mean testable testing new certificate correctly stored desired storage straightforward tight integration since run o process powered language siteencrypt integrate much better client lead nice benefit mentioned earlier certification conversation system ca server using certbot tool dialogue turn threeparty conversation instead system asking certificate ask certbot behalf however ca verification request aka challenge need served site since certbot external tool treat site opaque box result certbot know responded ca challenge bit conservative namely certbot sleep three second start polling ca see challenge answered native elixir acme client run o process integrate much better acme client informed challenge handler challenge fulfilled use much shorter delay start polling ca production optimization particularly relevant local dev especially test difference becomes significant certification test via certbot take second machine test via native client tight integration offer interesting possibility bit change api siteencrypt could support arbitrary storage database could also support coordination multiple node making possible implement distributed certification arbitrary node cluster initiate certification node successfully respond challenge including even node came online challenge started operation bulk system behaviour described elixir code remaining operational task done outside elixir exclusively related preparing machine run erlangelist task involve creating necessary account creating folder structure installing required o package essentially docker needed setting single systemd unit starting container production dockerized production docker image lightweight site run apk nocache upgrade apk add nocache ncurses copy frombuilder optappsitebuildprodrelerlangelist erlangelist volume volume workdir erlangelist entrypoint erlangelistbinerlangelist key part copy instruction add built release system image release contain compiled binary well minimal erlang runtime system therefore pretty much selfcontained requiring one small oslevel package installed final thought might argue using certbot optionally nginx caddy simple enough completely disagree perfectly valid reach external product solve technical challenge related business domain product help u solve problem quickly focus core challenge hand feel critical problem introduced product tried show simple example integrated operation approach reduces amount moving part technology used bridge gap production development improves testability system implementation simpler time flexible since tool driven function data approach work need runtime support managing multiple system activity beam runtime erlang elixir make possible example many case serving traffic directly phoenix without reverse proxy front work fine feature ets table genserver reduce need tool like redis running periodic job regulating load ratelimiting pipeline processing done directly elixir without requiring external product course always case external tool make sense also many case integrated approach work fine especially smaller system operating level scale complexity netflix twitter facebook similar option available would allow u start simple move external tool complicated scenario reason started work siteencrypt library still incomplete probably buggy issue fixed time effort believe benefit approach worth effort continue work library like see library appearing giving u simpler option challenge load balancing proxying persistence long technical challenge running external product option opportunity simplification u developer make happen
32,Lobsters,erlang,Erlang development,Introducing Lean Server for Midas (HTTP server in Gleam),https://crowdhailer.me/2020-06-23/introducing-lean-server-for-midas/,introducing lean server midas http server gleam,introducing lean server midas midas web framework lean ace raxx gleam using lean server,introducing lean server midas lean server http server written gleam gleam new type safe language erlang virtual machine beam lean builtin server midas web framework import midaslean maxconcurrency import gleamhttp fn handle request httpresponse httpsetbody hello world fn startlink leanstartlink handle maxconcurrency lean simple use simple maintain fast hopefully lean incorperates lesson learnt developing ace raxx ace http server written elixir aimed abstract away difference ace also supported http long lived connection streaming requestsresponses opinion ace successful goal however feature one server increased implementation complexity since starting ace written several service use narrow subset feature application mostly json api service streaming deployed behind load balancer needed neither http lean aim focus api application sizeable list nongoals ssl streaming http pipelining websockets tackling nongoals lean simpler therefore easier maintain make easier address feature bug well easier contribute also faster though yet test course feature listed important framework writing adapter server ace cowboy midas framework able support feature gleam gleam feel like promising approach getting benefit type beam something several people wish list including mine quite long time gleam compiles readable erlang readable erlang nt controversial statement also great interop erlang elixir feature would argue considered production ready part application part application benefit type safety others write topic later time using lean server lean sever bundled part midas currently midas using feature yet part gleam stable release therefore need use git dependency midasframeworkmidas
33,Lobsters,erlang,Erlang development,Hamler – Haskell-style functional programming language running on Erlang VM,https://www.emqx.io/news/open-source-functional-programming-language-hamler,hamler haskellstyle functional programming language running erlang vm,hamler haskellstyle functional programming language running erlang vm functional programming language hamler hamler hamler emq x philip wadler simon marlow dialyzer elixir akka welltyped cloud haskell lfe alpaca efene elchemy gleam emq hamler core feature hamler compiler purescript documentation community discussion support hamler contributing hamler hamlerissues hamlerlanghamler hamlerwiki core team emq technology co ltd emq emq,hamler haskellstyle functional programming language running erlang vm proud announce first public release new opensource functional programming language hamler hamler stronglytyped language compiletime type checking builtin support concurrency distribution empowers industry build next generation scalable reliable realtime application especially iot edge computing hamler almost decade developing software system based erlangotp especially main product emq x scalable opensource mqtt broker always believed erlang masterpiece engineering amazing concurrency distribution fault tolerance one generalpurpose language platform able properly handle concurrency soft realtime however year experience developing erlang program looking solve two problem compiletime type system friendly language syntax powerful compiletime type system help build reliable software system friendly syntax help build prosperous developer community taken nearly year academia industry find solution started prof philip wadler simon marlow type annotation dialyzer static analysis tool introduced erlang since project industry trying solve problem elixir language project introduced ruby syntax attracted developer ruby rail community akka project imitated implementation erlangotp lost soft realtime feature erlangotp welltyped cloud haskell project attempt simulate implementation erlang otp haskell project currently stalled others like lfe introduced lisp syntax etc attempted introduce ml style syntax static type still early stage development emq team made another attempt address issue new design approach today present industry release hamler language hamler core feature core feature hamler functional programming language running erlang vm haskelllike syntax summarized follows haskell mllike friendly syntax type checking inference compile time concurrency soft realtime support runtime combined year experience understanding developing erlang haskell program hamler language support major feature functional programming believe help industry better prepare coming wave development iot edge computing attract developer use erlang vm beam functional programming haskell ml style adt type checkinginference function higherorder function currying partial application pattern matching guard list comprehension applicative monad advanced module system builtin concurrency hamler compiler hamler source code parsed generate cst coreerlang ir generated cst ast corefn syntax tree transformation syntax analysis type checking code used erlang compiler generate final beam bytecode hamler compiler architecture shown hamler compiler initially attempted implemented based ghc later changed adapt purescript compiler implementation documentation community discussion support reach hamler community core team via following channel contributing contribute hamler project report issue submit bug issue hamlerissues contribute code fork project submit feature request hamlerlanghamler submit proposal fork hamlerwiki project submit pull request core team hamler core team come emq technology co ltd emq emq open source software company providing highlyscalable realtime messaging streaming platform iot application era
34,Lobsters,erlang,Erlang development,"v0.9 of Gleam, a statically typed language for the Erlang VM, is out",https://lpil.uk/blog/gleam-v0.9-released/,gleam statically typed language erlang vm,improved error handling opaque type standard library addition iterator iterator documentation set set documentation queue queue documentation option option documentation rest changelog changelog thanks gleam sponsor sponsoring gleam,thanks new contributor gleam development faster ever time another release let take look improved error handling main way error represented handled gleam result type baked language implement library would implemented like pub type result successvalue failuredetail ok successvalue error failuredetail function fail return result wrapping successful return value ok record returning detail failure error record successful parseint string result int string parseint ok parseint erl error expected number got erl function return result pattern match handle success failure case parseint error e ioprintln nt int ok ioprintln parsed int work need handle multiple result value function becomes verbose error handling obscures business logic case parseint error e error e ok inta case parseint b error e error e ok intb ok inta case parseint c error e error e ok intc ok inta intb intc release gleam try keyword make error handling easier concise rewritten using try previous example look like try inta parseint try intb parseint b try intc parseint c ok inta intb intc variable declared using try gleam check see whether value error ok record ok inner value assigned variable try x ok ok x ok error error returned immediately try x error failure ok x error failure testing try application happy clean error handling give try opaque type gleam new opaque type feature allows library writer export custom type without exporting internal detail type srcboxgleam pub opaque type box box innervalue int pub fn new x int box box innervalue x another module import custom type able create box using new function call box constructor use innervalue accessor pattern match box get inner value import box let one boxnew permitted oneinnervalue compile error let boxbox one compile error boxbox compile error feature great creating carefully controlled api data type hiding private implementation detail ensure used correctly brings u next feature standard library addition standard library gained wealth new module type function highlight made possible new opaque type feature iterator new iterator type lazily evaluated sequence element similar stream type elixir iterators useful working collection large fit memory infinite size require element currently processed memory see iterator type used create infinitely long sequence ints mapped first element evaluated import gleamiterator let double fn x x iteratorfromlist create element iterator iteratorcycle repeat iterator forever iteratormap double double element iteratortake evaluate first element iterators lazy even though iterator infinite size double function called time information see iterator documentation set set collection value unlike list unordered contain duplicate value finding value set fast import gleamset let popband setnew iris karl priya setcontains popband iris true setcontains popband martin false information see set documentation queue queue ordered collection element similar list however fast add remove end queue list quickly accessed front import gleamqueue queuenew queuepushfront queuepushfront queuepushback queuepushback queuetolist information see queue documentation option option type used represent value may present absent making similar nullable value language defined like pub type option none optional int someint present represented theint absent none information see option documentation rest addition standard library include io module addition result dynamic list string module change label make consistent full detail see changelog addition compiler include improvement formatter style ability include additional markdown page generated code documentation initial support elixir mix build tool type annotation let assert try custom type support case clause guard several bug fix info see changelog thanks would possible release big without support gleam sponsor contributor huge thank would like help make strongly typed programming erlang virtual machine productionready reality please consider sponsoring gleam via github sponsor program thanks reading fun
35,Lobsters,erlang,Erlang development,"Scaling Erlang cluster to 10,000 nodes (2018)",https://codesync.global/media/maxim-fedorov-scaling-erlang-cluster-to-10-000-nodes/,scaling erlang cluster node,objective target audience,growing user population beyond leave chance keep server footprint small used adding new capability requires processing power get impossible keep everything ten server scale cluster hundred hundred get tight expand next possible considering current scalability limit single erlang cluster talk guide along way took improve erlang scalability remove bottleneck increase efficiency erlangbased application objective demonstrate example live erlang cluster scaled node machine service interruption target audience scalability engineer people interested optimising erlang largescale server application
36,Lobsters,erlang,Erlang development,Erlang online resources,https://gist.github.com/macintux/6349828,erlang online resource,similar list instruction documentation community mailing list advocacy style project exercise general fp ish exercise collection conference video alternative vms alternative language targeting erlang vm erlang like environment jvm actor implementation hipe high performance erlang erlangheavy blog software pattern actor pattern currently akka resource history paper erlang actor model similar process calculus communicating sequential process csp πcalculus misc slide deck twitter changelog http githubcomllaisdybeamlanguages http githubcomdrobakowskiawesomeerlang http githubcomalpacalangalpaca http wwwslidesharenetarbowcomparingcppanderlangformotorolatelecomssoftware http githubcompurerlpurescript http http protoactor http adventofcodecom http http githubcomwendeelchemy http githubcombragfulephp http githubcomkjnilssonfez http http githubcomheathermillerdistprogbook http erightsorg http wikihaskellorgcloudhaskell http githubcomcromaincean,intended comprehensive authoritative free online resource found valuable learning erlang similar list instruction documentation community mailing list advocacy style project exercise general fp ish exercise collection conference video alternative vms alternative language targeting erlang vm erlang like environment jvm actor implementation hipe high performance erlang erlangheavy blog software pattern actor pattern currently akka resource history paper erlang actor model similar process calculus communicating sequential process csp πcalculus misc slide deck twitter twitter seems de facto water cooler technical conversation erlang exception far active account comfortably list interesting one changelog started several year creation gist rarely actually update added dale schumacher blog focused actor model added humus schumacher blog list actor implementation added http githubcomllaisdybeamlanguages language previously listed added http githubcomdrobakowskiawesomeerlang added http githubcomalpacalangalpaca start new section hipe add http wwwslidesharenetarbowcomparingcppanderlangformotorolatelecomssoftware add http githubcompurerlpurescript http add http protoactor add http adventofcodecom http http githubcomwendeelchemy http githubcombragfulephp http githubcomkjnilssonfez add http http githubcomheathermillerdistprogbook http erightsorg http wikihaskellorgcloudhaskell http githubcomcromaincean
37,Lobsters,erlang,Erlang development,Getting Erlang to talk to the outside world (2002),http://erlang.org/workshop/2002/Armstrong.pdf,getting erlang talk outside world,,obj length filter flatedecode stream ɀq hj l aso ޟᰊ pt snϵk fc c r 뢧 z ɹ h k b endobj obj type page content r resource r mediabox parent r endobj obj type xobject subtype form formtype matrix bbox resource procset pdf text extgstate r font r length r filter flatedecode stream xta l endobj obj type extgstate name tr identity opm sm endobj obj subtype basefont helvetica type font name endobj obj endobj obj font r r r r r r r r r xobject r procset pdf text endobj obj length filter flatedecode stream xڍ vwyt k ܫ b uw ъp dxo h r j ksqpboza nw bf ȱ ou hz v 鉿 g x v v l l endobj obj type page content r resource r mediabox parent r endobj obj font r r r r r procset pdf text endobj obj length filter flatedecode stream xڵ ǒ b q bckx r c c k gy ɳc n ԙb 㴹õ lqnyz ai c b x x u vzx ȷ wr rz r endobj obj type page content r resource r mediabox parent r endobj obj type xobject subtype form formtype matrix bbox resource procset pdf text extgstate r font r length r filter flatedecode stream h endobj obj subtype basefont helvetica type font name endobj obj endobj obj font r r r r r r r r r r xobject r procset pdf text endobj obj length filter flatedecode stream xڵ u մ ˣ n k q b u n g h c g
39,Lobsters,erlang,Erlang development,Optimising for Concurrency: Comparing and contrasting the BEAM and JVM virtual machines,https://www.erlang-solutions.com/blog/optimising-for-concurrency-comparing-and-contrasting-the-beam-and-jvm-virtual-machines.html,optimising concurrency comparing contrasting beam jvm virtual machine,optimising concurrency comparing contrasting beam jvm virtual machine semantics erlang programming language otp library middleware beam virtual machine highlight beam highlight jvm attempt akka framework concurrency parallelism technique beam concurrency lightweight process scheduler dirty scheduler garbage collector garbage collector blog post lukas larsson wombatoam hot code loading use beam conclusion learn beam book beam wisdom may also like go back blog tag,optimising concurrency comparing contrasting beam jvm virtual machine francesco cesarini gabor olah success programming language erlang ecosystem apportioned three tightly coupled component semantics erlang programming language top language implemented otp library middleware used architect scalable resilient concurrent system beam virtual machine tightly coupled language semantics otp take one component runner put three together uncontested winner scalable resilient softreal time system quote joe armstrong copy erlang library run beam emulate get enforced robert first rule programming state sufficiently complicated concurrent program another language contains ad hoc informallyspecified bugridden slow implementation half post want explore beam vm internals compare contrast jvm applicable highlighting pay attention care long component treated black box taken granted without understanding reason implication time change highlight beam erlang beam vm invented right tool solve specific problem developed ericsson help implement telecom infrastructure handling mobile fixed network infrastructure highly concurrent scalable nature display soft realtime property may never fail want hangout call mobile grandmother dropped online gaming experience fortnite affected system upgrade high user load software hardware network outage beam vm optimised solve many challenge providing finetuned feature work top predictable concurrent programming model secret sauce lightweight process share memory managed scheduler manage million across multiple core us garbage collector run perprocess basis highly optimized reduce impact process result garbage collector impact overall soft real time property system beam also widely used vm used scale builtin distribution model allows program run multiple machine transparently highlight jvm java virtual machine jvm developed sun microsystem intent provide platform code run everywhere created object oriented language similar c memorysafe runtime error detection check array bound pointer dereferences jvm ecosystem became extremely popular internetera making defacto standard enterprise server application wide range applicability enabled virtual machine caters wide range use case impressive set library catering enterprise development jvm designed efficiency mind concept abstraction feature found popular operating system threading model map operating system thread jvm highly customisable including garbage collector gc class loader stateoftheart gc implementation provide highly tunable feature catering programming model based shared memory jvm allows change code program running jit compiler allows byte code compiled native machine code intent speed part application concurrency java world mostly concerned running application parallel thread ensuring fast programming concurrency primitive difficult task challenge created shared memory model overcome difficulty attempt simplify unify concurrent programming model successful attempt akka framework concurrency parallelism talk parallel code execution part code run time multiple core processor computer concurrent programming refers handling event arriving system independently concurrent execution simulated single threaded hardware parallel execution although distinction may seem pedantic difference result different problem solve think many cook making plate carbonara pasta parallel approach task split across number cook available single portion would completed quickly took cook complete specific task concurrent world would get portion every cook cook task use parallelism speed concurrency scale parallel execution try solve optimal decomposition problem part independent boil water get pasta mix egg fry guanciale ham grate pecorino shared data example serving dish handled lock mutexes various technique guarantee correctness another way look data ingredient present want utilise many parallel cpu resource possible finish job quickly possible concurrent programming hand deal many event arrive system different time try process within reasonable time multicore distributed architecture execution run parallel requirement another way look cook boil water get pasta mix egg following sequential algorithm always change across process cook data ingredient work exist multiple instance jvm built parallelism beam concurrency two intrinsically different problem requiring different solution beam concurrency beam provides lightweight process give context running code process also called actor share memory communicate message passing copying data one process another message passing feature virtual machine implement mailbox owned individual process message passing nonblocking operation mean sending message another process almost instantaneous execution sender blocked message sent form immutable data copied stack sending process mailbox receiving one achieved without need lock mutexes among process lock mailbox case multiple process send message recipient parallel immutable data message passing enable programmer write process work independently focus functionality instead lowlevel management memory scheduling task turn simple design work single thread also multiple thread local machine running vm using built distribution across network cluster vms machine message immutable process sent another thread machine without lock scaling almost linearly distributed multicore architecture process addressed way local vm cluster vms message sending work transparently regardless location receiving process process share memory allowing replicate data resilience distribute scale mean two instance process two separate machine sharing state update among machine fails copy data continue handling request making system fault tolerant machine operational process handle request giving scalability beam provides highly optimised primitive work seamlessly otp provides higher level construct make life programmer easy akka great job replicating higher level construct somewhat limited lack primitive provided jvm allowing highly optimised concurrency primitive jvm enable wider range use case make programming distributed system harder built primitive communication often based shared memory model example distributed system place shared memory cost accessing scheduler mentioned one strongest feature beam ability break program small lightweight process managing process task scheduler unlike jvm map thread o thread let operating system schedule beam come scheduler scheduler start default o thread every core optimises workload process consists code executed state change time scheduler pick first process run queue ready run give certain amount reduction execute reduction rough equivalent command process either run reduction blocked io waiting message completes executing code scheduler pick next process run queue dispatch scheduling technique called preemptive mentioned akka framework many time biggest drawback need annotate code scheduling point scheduling done jvm level removing control hand programmer soft real time property preserved guaranteed risk accidentally causing process starvation process spread around available scheduler thread maximise cpu utilisation many way tweak scheduler rare needed edge borderline case default option cover usage pattern sensitive topic frequently pop regarding scheduler handle natively implemented function nifs nif code snippet written c compiled library run memory space beam speed problem nifs preemptive affect scheduler recent beam version new feature dirty scheduler added give better control nifs dirty scheduler separate scheduler run different thread minimise interruption nif cause system word dirty refers nature code run scheduler garbage collector modern high level programming language today mostly use garbage collector memory management beam language exception trusting virtual machine handle resource manage memory handy want write high level concurrent code simplifies task underlying implementation garbage collector fairly straightforward efficient thanks memory model based immutable state data copied mutated fact process share memory remove process interdependency result need managed another feature beam garbage collection run needed per process basis without affecting process waiting run queue result garbage collection erlang stoptheworld prevents processing latency spike vm never stopped whole specific process never time practice part process treated another reduction garbage collector collecting process suspends process short interval often microsecond result many small burst triggered process need memory single process usually allocate large amount memory often short lived reducing impact immediately freeing allocated memory termination feature jvm ability swap garbage collector using commercial gc also possible achieve nonstopping gc jvm feature garbage collector discussed excellent blog post lukas larsson many intricate detail optimised handle immutable data efficient way dividing data stack heap process best approach majority work short lived process question often come topic much memory beam us hood vm allocates big chunk memory us custom allocator store data efficiently minimise overhead system call two visible effect used memory decrease gradually space needed reallocating huge amount data might mean doubling current working memory first effect really necessary mitigated tweaking allocator strategy second one easy monitor plan visibility different type memory usage one monitoring tool provides system metric box wombatoam hot code loading hot code loading probably cited unique feature beam hot code loading mean application logic updated changing runnable code system whilst retaining internal process state achieved replacing loaded beam file instructing vm replace reference code running process crucial feature downtime code upgrade telecom infrastructure redundant hardware put use handle spike nowadays era containerization technique also used production update never used dismiss le important feature nonetheless useful development workflow developer iterate faster replacing part code without restart system test even application designed upgradable production reduce time needed recompilation redeployment use beam much right tool job need system extremely fast concerned concurrency handling event parallel handle fast need crunch number graphic ai analytics go c python java route telecom infrastructure need fast operation float speed never priority aided dynamic typing type check runtime mean compiler time optimization trivial number crunching best left jvm go language compile native surprise floating point operation erjang version erlang running jvm faster beam seen beam shine using concurrency orchestrate number crunching outsourcing analytics c julia python rust map outside beam reduce within beam mantra always fast enough take hundred millisecond human perceive stimulus event process brain meaning micro nano second response time necessary many application would use beam microcontrollers resource hungry embedded system bit processing power multicore becoming norm need concurrency beam shine back implementing telephony switch handling ten thousand subscriber running embedded board memory much memory raspberrypi day finally hard real time system would probably want beam manage airbag control system need hard guarantee something hard real time o language garbage collection exception implementation erlang vm running bare metal grisp give similar guarantee conclusion use right tool job writing soft real time system scale box never fail without hassle reinvent wheel beam battle proven technology looking many work black box knowing work would analogous driving ferrari capable achieving optimal performance understanding part motor strange sound coming learn beam understand internals ready finetune fix used erlang elixir anger launched one day instructorled course demystify explain lot saw whilst preparing handle massive concurrency scale course available new instructor lead remote training learn also recommend beam book erik stenman beam wisdom collection article dmytro lytovchenko may also like author also like similar looking dish called carbonara made cream go back blog tag
40,Lobsters,erlang,Erlang development,Erlang/OTP 23 Released,https://www.erlang.org/news/140,erlangotp released,otp potential incompatibility ssl improvement new feature ssh ssl kernel http http http http http githubcomerlangotp,otp erlangotp new major release new feature improvement well incompatibility potential incompatibility ssl support ssl completely removed tl added list default supported version erlinterface removed deprecated part erlinterface erlinterfaceh essentially c function prefix erl deprecated erlang bif return empty list instead stacktrace erlang scheduled removal otp improvement new feature ssh openssh introduced new file representation key called supported exception handling encrypted key algorithm configuration could done config file useful example enable algorithm disabled default without need change code ssl support middlebox compatibility mode make tl handshake look like tl handshake increase chance successfully establishing tl connection legacy middleboxes add support key exchange edward curve pssrsa padding signature verification possibility run erlang distribution without relying epmd extended achieve couple new option inet distribution added distlisten false setup distribution channel listen incoming connection erlepmdport port configure default port builtin epmd client return first experimental socket backend gentcp inet implemented genudp gensctp follow putting inetbackend socket first option listen connect make easy try existing code new module erpc kernel implement enhanced subset operation provided rpc module enhanced sense make possible distinguish returned value raised exception error erpc also better performance scalability original rpc implementation utilizing newly introduced spawnrequest bif also rpc module benefit improvement utilizing erpc possible scalability performance improvement plus new functionality regarding distributed spawn operation binary matching size segment matched allowed guard expression matching map key guard expression ssh support tcpip port forwarding aka tunnelling aka tcpforwarddirecttcp implemented openssh client corresponds option l r allow underscore numeric literal improve readability example new function shell displaying documentation erlang module function type function print documentation module functionarity print type documentation module typearity embedded documentation created docchunks eep building erlangotp documentation kernel module pg new implementation distributed named process group introduced old module deprecated scheduled removal otp tool chain building window package upgraded new c compiler java compiler openssl library wxwidgets version using wsl linux subsystem window building make easier handle build environment detail see http pre built version window fetched http http online documentation browsed http erlangotp source also found github official erlang repository http githubcomerlangotp
41,Lobsters,erlang,Erlang development,"v0.8 of Gleam, the statically typed language for the Erlang VM, is out",https://lpil.uk/blog/gleam-v0.8-released/,gleam statically typed language erlang vm,html documentation gleam format fancy pipe accessor syntax spread operator rest changelog thanks midas sponsoring gleam,really good couple month gleam community growing getting new feature improvement time another release let take look html documentation documentation bit sore point wanted write program gleam way see type function available use likely would source code standard library open window somewhere nicest way learn language solve problem gleam generate html documentation gleam source code publish hexdocs home documentation erlang ecosystem check example new documentation gleam format consistency matter code consistent style make code easier read easier work hand maintaining consistent style hand expensive time sink easy waste time debating exactly right place put curly brace code review solution problem code formatter write whatever code want without spending time style press save editor automatically fix style taken finger keyboard starting release gleam includes formatter new gleam project preconfigured format validated ci enable formatter editor never waste time fixing style interested learning formatters work year back gave talk subject context elixir language hold true gleam well fancy pipe pipe operator favourite feature gleam allows u write chain function read toptobottom lefttoright work taking value left hand side using argument function right hand side without pipe print eval read stdin stdout pipe stdin read eval print stdout example function print take two argument function capture syntax used tell gleam insert left hand side value practice gleam function take multiple argument capture syntax needed often score listmap double listfold add shouldequal gleam fancy pipe boilerplate longer needed used function call right hand side b pipe first check see left hand value could used first argument call b fall back calling result right hand side function b score listmap double listfold add shouldequal much better resolved compile time using type system performance safety penalty use nested function call accessor syntax pattern matching great sometimes want get single value record tuple enable gleam support field syntax common language work record let student student subject theatre let mary person name mary role student maryname mary maryrolesubject theatre work tuples let pair tuple apple orange apple orange spread operator gleam pattern matching expanded new operator called spread operator allows write partial pattern record without spread let uri scheme scheme port port path query fragment authority userinfo host uri spread let uri scheme scheme port port uri consistent record syntax prepending list matching head list updated also use spread operator let newlist existinglist case list first first old x x list syntax deprecated still accepted run formatter automatically upgrade code first rest addition change also support number numerical operator case guard assert syntax inexhaustive pattern matching todo syntax type checking function without finished implementation handful performance improvement whole bunch bug fix outside compiler continue grow standard library made good progress otp support prototype type safe supervision tree information check changelog github thanks exciting thing release much community grown since last release people writing gleam people sharing idea people working compiler even got beginning gleam web server web framework midas project would possible release big without support gleam sponsor contributor huge thank would like help make strongly typed programming erlang virtual machine productionready reality please consider sponsoring gleam via github sponsor program thanks reading fun
43,Lobsters,erlang,Erlang development,"archseer/enigma - Enigma VM, an implementation of the Erlang VM in Rust",https://github.com/archseer/enigma,archseerenigma enigma vm implementation erlang vm rust,enigma vm installation rustup iex also work rendering bug feature status opcodes bifs roadmap feature goal idea experiment hyper runtime initial nongoals rustler contributing elixir slack,enigma vm implementation erlang vm rust aim complete correct fast order importance otp compatible sans distributed bit code eventually run enigma unchanged deprecated opcodes wo nt supported fun learning lot beam hipe awesome massive sloc small implementation make easier new people learn erlang internals also get platform quickly iterate idea inclusion beam installation prerequisite building enigma rust use rustup install latest nightly rust time nt support stable beta anymore relying asyncawait scheduled run stable time boot otp also need compile standard library moment relies beam build system git submodule update init depth cd otp otpbuild setup make libs make localsetup hope simplify step future enigma run compiler run cargo run install dependency build run vm default boot erlang shell iex also work rendering bug expect crash lot functionality already available prebuilt binary various platform available reach certain level stability feature status implement opcodes half bifs view detailed progress breakdown opcodes bifs roadmap feature goal idea experiment process scheduling implemented top rust future process simply long running future scheduled top tokiothreadpool workstealing queue timer delaytimeout future relying tokiotimer timewheel port future await file io asyncreadasyncwrite awaitable nifbifs future yield certain point play nice reduction allows much simpler yielding implementation future possibility write documentation sparsely documented beam aspect binary matching time wheel process monitor explore using immix gc erlang eir runtime jit via eir bif generator function yield suspendon reduce provide builtin adapter module hyper plug adapter http client crosscompile webassembly runtime initial nongoals vm nt reach certain level completeness nt make sense consider distributed erlang node tracing debugging support beam compatible nifs ffi note nifffi abi compatibility otp going quite work ruststyle nif interface available would also probably possible make adapter compatible rustler contributing contributor welcome easiest way get started look note folder pick bif opcode implement take look srcbifrs bif folder bifs implemented also issue open good first issue tag would also good introduction internals alternatively search codebase todo fixme unimplemented mark various place partial implementation exists bit work need done test coverage currently lacking varying level documentation addressing soon also enigma channel elixir slack
44,Lobsters,erlang,Erlang development,Matching binary patterns with Erlang,https://dev.to/l1x/matching-binary-patterns-11kh,matching binary pattern erlang,complete example creating request sending receiving processing response first bit processing response rest http githubcommnperlangntp http,erlang easy construct binary bitstrings matching binary pattern running mitchell perilstein excellent work ntp erlang thought going use explain bitstrings binary work erlang two concept bitstring sequence zero bit number bit need divisible binary number bit divisible syntax follows element specifies certain segment bitstring segment set contiguous bit binary necessarily byte boundary reallife example let unpack bit going worth knowing whole syntax value sizetypespecifierlist value sizetypespecifierlist alternatively ei value value size valuetypespecifierlist value sizetypespecifierlist mean reallife example value size bit four value bit size specify type specifier typespecifierlist list type specifier order separated hyphen dash default value used omitted type specifier following type specifier supported type integer float binary byte bitstring bit default integer byte shorthand binary bit shorthand bitstring signedness signed unsigned matter matching type integer default unsigned endianness big little native nativeendian mean endianness resolved load time either bigendian littleendian depending native cpu erlang machine run endianness matter type either integer float default big complete example one simplest protocol ntp header file look like following used request response let craft request first createntprequest based header structure see integer li integer version number integer mode stratum poll precision need set first value rest bit let try wild creating request request sending receiving use erlang builtin function one genudp pretty comprehensive lowlevel udp implementation want open local socket indicates pick random local port activefalse mean need receive ok socket genudp open binary active false genudp send socket request ok address port resp genudp recv socket ok processing response first bit response binary need slice dice similarly created request resp first get first bit restbinary resp li li version version mode mode work rest header bit tricky bitstring syntax easy manage processing response rest finally matching mandatory field resp making sense value requires bit legwork first need utility function binary fraction erlang function arity differentiates function following binfrac bin binfrac bin binfrac frac frac binfrac bin n frac binfrac bin bsr n frac bin band n function implement one process response return value interested offset unix epoch processntpresponse ntpresponse ntpresponse nowms now nowus erlang timestamp nowtimestamp nowms now transmittimestamp xmti binfrac xmtf li li vn version mode mode stratum stratum poll poll precision precision rootdelay rootdel rootdispersion rootdisp referenceid referencetimestamp rtsi binfrac rtsf originatetimestamp otsi binfrac otsf receivetimestamp rcvi binfrac rcvf transmittimestamp transmittimestamp clientreceivetimestamp nowtimestamp offset transmittimestamp nowtimestamp wit process response precision originatetimestamp offset please note first step ntp workflow implement complete ntp protocol take consideration bunch detail next time might look implement simple server like dns erlang michael original work http githubcommnperlangntp date version elixir port http
47,Lobsters,erlang,Erlang development,There's a new Language Server and Code Formatter for Erlang,https://notamonadtutorial.com/erlang-tooling-in-2020-b9606596353a,new language server code formatter erlang,blog post language server protocol erlangls github brujo led decision start working erlang code formatter thought erlang latecomer code formatting game design process tool look like pretty consistently ugly strange stuff erlang formatter compare wellknown formatting tool eg go fmt mix format rustfmt tool main difficulty found way developing handling comment along valid code common difficulty code analysing tool must deal erlang formatter handle likewise code formatter handle incorrect code macro configurable code formatter please obstacle adoption perceive kind adoption expect three think future erlang formatter actively erlang formatter usable else roberto aloi project start sourcer language server protocol compare similar effort sourcer lsp implementation sourcer blog post vscode erlang erlangls integrate existing erlang tooling eg elvis wrangler refactorerl gradualizer build server protocol encounter challenge way implementing lsp protocol specific erlang reddit language server index format mnesia find advantage within erlangbeam tech stack designing implementing erlangls syntaxtools,henry studley carpenter tool chest vox populi erlang tooling always lagging behind language elixir came along somewhat forced community action whatever exact cause true today erlang benefiting crosspollination new community building system around beam platformone fruit new plugin adding formatter erlang project initiator brujo wrote blog post presented asked followup questionsanother sorely needed piece tooling working implementation language server protocol server erlang several effort underway particular erlangls github headed roberto aloi reached recentlygiven serendipitous situation two important development erlang launched time decided joint interview brujo robertobrujowhat led decision start working erlang code formatter almost since started working developer always cared lot software maintainabilitythat generally advocate usage tool like xref dialyzer etca back working inaka learned hound ruby wanted something like erlang found nothing similar therefore worked juan facorro inakos create elvis fill voidin way since learned mix format started looking similar tool erlang knew could create tool presented project idea spawnfest twice luck opportunity presented hackweek nextroll weeklong hackathon happens twice year presented project juan bono diego calero thrilled help built team week first mvp even published hexpm alldo thought erlang latecomer code formatting game believe except language generally ahead time like smalltalk code formatter everybody us relatively new thing something expected modern language case even year ago hand getting traction official formatter new language like elixir go hard since many huge codebases around people enough time get attached formatting style yetfor older ecosystem like erlang impressively huge repository widely different code style even within convincing developer start using single universal code format easyand fact different editor like intellij emacs etc provide autoformatting tool one producing code distinct style share nothing others make even worsewhat design process tool look like hack week right trial error accurately digging trial errorjokes aside knew wanted first day going create tool capable parsing formatting breaking erlang code want formatted code pretty wanted consistently ugly achieved said check version hexpmto achieve goal wanted use many existing tool could find want reinvent wheel juan bono came pure hackathonstyle working different timezones barcelona juan buenos aire time done day day started told instance need tool parse erlang term another one print next day started message like found epp parse erlprettypr produce formatted output implemented solution came back epp handle macro well erlprettypr limited dug stuff told eppdodger many different reimplementations erlprettypr different trial error process repeatedat time diego constantly trying find strange edge case break formatter found strange stuff check test app repo promise say actually oncehow erlang formatter compare wellknown formatting tool eg go fmt mix format rustfmt one hand format still much younger le battletested toolsit also official yet hey otp read maybe would good idea conversation visit stockholm soon hand tool mention particularly mix format much strongly opinionated format practically one way format code themknowing hard convince every erlang developer world format code way aimed humble goal convince every erlang developer world format code tool keep style style use format apply whole project way reformatting code style matter running single command console brujo format rokstyle commafirst fan certainly default formatting style main difficulty found way developing think main issue lack clear documentation extensibility around existing tool work juan finding obscure otp module name like eppdodger actually function resembled actually needed close enough invaluable much code invisible unprepared eyeif tool like eppdodger erlprettypr etc visible extensible formatter would reality many year agohandling comment along valid code common difficulty code analysing tool must deal erlang formatter handle luckily u tool provided otp already work need patch mostly trivial stuff hand still comment format handle beautiful manner format lose comment file might misplace bit particularly want add comment thing like type field nothing solved manually moving comment better place filelikewise code formatter handle incorrect code since use tool compiler us parse code formatter find syntactically incorrect code fails like compiler would hand since formatter process macro code invalid macro formatter format anyway even syntactically correct semantically incorrect code eg function unused exported variable used bound etc formatted anywaywhat formatter actually learned oldreliable steamroller verify ast generated code affected formatter ie ast generated code formatting exactly except line number ast generated code running formatter configurable code formatter lot basically two level first need choose formatter use ie implementation behavior format code format come two default otpformatter basically erlprettypr defaultformatter nextroll preferred way formatting code formatter list option use default formatter approximately different option tweak otp formatter allows change paper ribbonof course create formatter need implement behavior accept contribution create rokstyle formatter please send pull request obstacle adoption perceive kind adoption expect oddly enough biggest obstacle likely competition daniel oldreliable put think time remembered great formatter war age formatters erlang many people complained one two soon three format steamroller one michał muskała soon presentin case sad believe three different formatters far better none think future erlang formatter become de facto formatter erlang code whole wide world course dream big right seriously greatest dream formatter would considered default erlang formatter maybe otp team adopts start requiring contribution erlangotp code formatted etc etc realistically say plan use erlang project within nextroll already using opensource one progressively adding private one much massive keeping mind company committed providing support actively expect help community form bug report configuration formatter idea pull request erlang formatter usable else think main focus day education working group erlang ecosystem foundation active member working initiative called meetup intervention early stage idea help meetup organizer around world provide workshop session training different subject introductory others advanced first round workshop start soon miriam pena simon thompson johnny winn trainer see go decide properly scale idea think great successbesides recently moved sant cugat del vallès beautiful town near barcelona spain give access many european thing giving talk codebeam sto may attending elixirconf eu also helping new friend revitalize elixir meetups madrid hopefully visiting coruña university soon give guest lecture tooi excited opportunity much closer still settling new home already love finally would like mention even particularly active erlang battleground lately still looking happen idea something beamrelated want write contact help get published shared lot people roberto aloihow project start original plan simply start contributing edts http githubcomsebastiwedts project erlang development tool suite emacs editor project actively maintained longer experiencing issue upgrading latest version erlangotpi started diving edts codebase discovered architecture particularly interesting emacs client implemented emacs lisp communicating via http server implemented erlang responsible heavylifting played idea bit effort one could grow http api used clientserver communication edts something solid generic allowing editor reuse logic implemented edts serversome week code beam stockholm conference attended talk author sourcer project gave introduction language server protocol apparently microsoft already thought meant go process designing brandnew protocol could simply focus implementing server maybe based edts one would comply protocol started looking existing language server implementation erlang guess lead second compare similar effort sourcer lsp implementation currently three major implementation language server aware sourcer year old codebase erlang plugin eclipse converted language server make hard contribute familiar original project sourcer make heavy use custom library scanner parser erlang l try leverage otp library much possible project last updated six month ago know current status development checkout blog post accurate comparison erlang l sourcervscode erlang visual studio extension includes erlang language server project tightly coupled vscode editor though defeat purpose language server first placeerlang l built scratch language server aim truly ideagnostic lot effort put documenting installation process different editor providing clear troubleshooting procedure end usershow erlangls integrate existing erlang tooling eg elvis way see erlang l act platform allows thirdparty tool elvis smoothly integrate development workflowsin erlang community many tool exist lot potential used limited way developer refactoring tool wrangler refactorerl good example case installation process tool straightforward case tool tightly coupled specific editor unavoidably limit adoption tool could live reinassance period get thing right erlang l hope crosseditor platform available erlang tool find attention deserveanother interesting situation competing tool exist solving problem code formatters example erlang scene currently experiencing little explosion term formatting tool adroll released whatsapp presenting new formatter code beam san francisco speak dialyzer gradualizer another example two different strategy pro con achieve goal case idea provide integration tool via erlang l platform tool work outofthebox always possible end user optin optout specific integration major challenge approach end language server bloated dependenciesi also glad mentioned since fall different category tool deserve separate discussion building tool erlang l accepts lowlevel configuration parameter dependency path include directory custom macro definition etc set via erlanglsconfig specific project used instruct server build erlang module also going introduce concept project type first one user mark project one course automate process looking presence rebarconfig file lowlevel configuration parameter required language server automatically inferred rebarconfig file minimizing required configuration approach make project work outofthebox erlang l ensuring erlang l still used project use building tool choice also keeping eye build server protocol require investigationdid encounter challenge way implementing lsp protocol specific erlang lsp protocol fairly new still go maturity process part protocol overengineered handshaking shutdown sequence fact protocol support two different transport tcp stdio feel unnecessary concept mentioned protocol either well explained eg document link coupled specific language need eg distinction gotodefinion v gotodeclaration v gotoimplementation interesting reddit post author one vim lsp client highlight lsp protocol imperfectionseven ide nowadays decent lsp client intellij integration particularly challenging u testing language server also trivial task actually mind create testing framework language server combining propertybased testing language server index format deserves blog post window support also revealed particularly challenging due fact windowserlang stack travis ci github actionsin term erlang specific challenge major one probably decide database use persist indexed information currently settled mnesia used keyvalue store two main reason minimize setup end user mnesia come erlangotp require additional installation step allows u store erlang term without need encodingdecoding mnesia come challenge though get performance needed big project million line code dig mnesia internals tweak setting mnesia also distributed database feel bit like overkill singlenode project like erlang l see decide keep move different solutionfinally erlang standard library still lack opinion basic functionality one would expect stdlib implement function delete nonempty directory deal relative absolute path even function hard implement require time member erlang community bit proactive ensuring contribute type functionality erlangotpdid find advantage within erlangbeam tech stack designing implementing erlangls plenty experience using erlang implement language server awesome farpattern matching message passing combined flexibility map encodedecode json entity make implementation protocol straightforward lightweight process allow u implement feature cancellable request background job sometimes hard implement using technology stack trivial idiomatic way behaviour give wonderful way separate generic implementationspecific part code use heavily implementing provider transport syntaxtools library contain building block necessary play abstract syntax tree erlang program even quirk ability attach running language server using remote shell trace individual request client play crucial role troubleshoot bug would required plenty stepbystep debugging ioformatting otherwise common test group precious parameterize test run stdout tcp transport could continue long time stop really hope erlang l make easier newcomer erlang community get chance get started erlang minimal friction experience wonderful advantage beam tech stack provide implementing erlang project
48,Lobsters,erlang,Erlang development,"BEAM in the Browser with Lumen, Part 1: Motivations & Constraints",https://tylerscript.dev/bringing-the-beam-to-webassembly-with-lumen,beam browser lumen part motivation constraint,preface paul schoenfelder talk introducing lumen rust project lumen dockyard lumen existing beam build steady api crosspollination wasm become widely supported otp user interface actor model supervision tree erlang term storage observer browser thing know webassembly next section already familiar webassembly webassembly assembly language harvard architecture harvard architecture von neumann architecture jump table structured control flow structured control flow control flow graph talking webassembly integer value ffi bring elixirerlang environment code size load time wasm concurrency model web worker javascriptdom interop async function event ffi mentioned earlier use beam runtime apis incompatible scheduler shipping beam bytecode expensive hot code reloading hot code reloading dead code elimination performance consideration thanks reading paul schoenfelder,april preface article first short series aiming unofficially transcribe interpret paul schoenfelder excellent talk introducing lumen alternative beam implementation written rust hope writing might assist others goal eventually contributing project lumen lumen new compiler runtime erlangelixir developed thanks support dockyard primarily built around erlang support elixir language compile beam bytecode central goal project bring language browser functionality beam otp standard library least part worth bringing targeting webassembly lumen new elixirlike syntax top javascript elixir javascript transpiler effort crosscompile existing beam implementation wasm effort replace existing beam build steady api crosspollination common criticism clientside web ecosystem fractured constantly flux much could symptom enormous reach popularity new pattern feature brought javascript browser dom apis time could argue left shaky ground build application looked another way using elixir erlang backend javascript frontend pretty likely reason using javascript defacto language web wasm become widely supported begin change given choice many would choose invest one language ecosystem could effectively support environment organizational benefit like code reuse ease endtoend knowledge sharing difficult ignore otp user interface actor model beam actually mesh well pattern see componentbased userinterface library like react component thoughtfully designed react application essentially tightly focused state machine tree responsible one part application except without significant effort one encounter error often crash rest took application implemented elixirerlang based frontend component could exist supervision tree operating concurrently able crash fail recover without affecting rest application get beam running browser also get pattern otp tooling come imagine implementing client application using erlang term storage miniature database key many common beam pattern spinning observer analyze memory consumption performance browser application alongside rich standard library thing know webassembly getting technical detail lumen thing know wasm next section already familiar webassembly webassembly abbreviated wasm binary instruction format stackbased virtual machine wasm designed portable target compilation highlevel language like ccrust enabling deployment web client server application think like assembly language slightly higherlevel look like simple function module func param lh param rh result localget lh localget rh harvard architecture webassembly built upon harvard architecture machine based common von neumann architecture code data live memory address space mean simple take address code jump start executing using harvard architecture code data address space separate take address code call equivalent function pointer actually index jump table function wasm runtime know order call function give index argument table runtime check see exists nothing found instead accessing invalid memory structured control flow goto explanation explanation wasm operates something called structured control flow instead using control flow graph difference control flow graph allow multiple entry point piece code whereas structured control flow dictate everything must one entry point mean design jump like goto instead provides structured control flow construct like ifelse one one hand good thing express irreducible loop wasm attack use arbitrary jump assembly impossible add complexity implementation come expressing beam behavior utilize goto statement talking webassembly let memory new webassemblymemory passing data wasm javascript module exactly simple currently pas integer value across barrier sound incredibly difficult anything useful constraint like essentially way pas object convert sharing pointer linear memory wasm module parsing memory limitation large impact ffi interoperability javascript dom apis bring elixirerlang environment compile wasm must accommodate major constraint code size load time building api life server easy overlook consider deliver virtual machine code make useful every client loading lumen application client also compile code even run achieve small code size also deliver fast load time user expect web environment wasm concurrency model let wasmworker new worker workerjs wasm achieves concurrency using web worker spawn web worker run code named javascript file separate calling window process make different traditional server environment web worker behave like multiple different process operating system rather multiple thread within process mean actortoactor message passing currently nontrivial share memory effort underway work around worth noting threading model wasm still evolving javascriptdom interop webassemblyinstantiatestreaming fetch lumenwasm importobject result also appropriately accommodate javascript runtime async function scheduler lumen much like beam scheduler represent javascript async function separate closure within erlangelixir garbage collected javascript runtime must managed separately event event receive javascript dom surfaced message process erlangelixir rather getting giving callback fired event come get message like would event erlangelixir application central idea making usually server bound language compatible browser environment ensuring consistent behavior delivering either client server ffi integer time limitation mentioned earlier pas data back forth need handle translation erlang term javascript value every time cross barrier different ffi traditional server environment pas thing directly via erlnif api translation routine javascript side wasm side make work use beam make existing beam implementation work web instead build ground runtime apis apis beam expects available present wasm environment virtually everything runtime depends system apis even memory allocation incompatible scheduler could argue apis could shimmed worked around bigger problem thing like treat j async function separate resource erlang closure current beam scheduler would need almost completely rewritten accommodate anyway shipping beam bytecode expensive beam bulky full dependency tree average elixirerlang application get ten megabyte completely nonviable web every module dependency tree included final build accommodate two major thing hot code reloading otp allows hot code reloading meaning point might need call code dependency tree currently called source function allows call function completely dynamically runtime constraint ultimately mean get pretty weak dead code elimination capability reduce code size performance consideration finally issue running virtual machine top another virtual machine browser actually pretty clever way generate native code wasm javascript executing beam bytecode top virtual machine effectively reason beyond seeing central core loop executing limit option looking apply optimization code really want implementation come computational performance ceiling like place start thing considered give u pretty compelling reason pursue alternative implementation better suited requirement web thanks reading part currently progress covering second half paul schoenfelder talk discussing lumen compiler tackling challenge kudos kudos
49,Lobsters,erlang,Erlang development,Comparing Cpp And Erlang For Motorola Telecoms Software,https://www.slideshare.net/Arbow/comparing-cpp-and-erlang-for-motorola-telecoms-software,comparing cpp erlang motorola telecom software,user agreement privacy policy privacy policy user agreement,slideshare us cooky improve functionality performance provide relevant advertising continue browsing site agree use cooky website see user agreement privacy policy slideshare us cooky improve functionality performance provide relevant advertising continue browsing site agree use cooky website see privacy policy user agreement detail
50,Lobsters,erlang,Erlang development,Squeezing the most out of the server: Erlang Profiling,http://tech.nextroll.com/blog/dev/2020/04/07/erlang-profiling.html,squeezing server erlang profiling,squeezing server erlang profiling realtime bidding past article hazardous land software optimization without profiling first infrastructure requestlevel timer recon fred hebert erlang anger recon redbug redbug erlang easy profiling eep eep kcachegrind erlgrind lookingglass erlang systemmonitor conclusion observer eprof fprof eflame eministat efficiency guide builtin profiling module,squeezing server erlang profiling written facundo olano april realtime bidding rtb platform featured several time tech blog run fleet erlang application bidder typically range one two thousand node described past article ongoing goal rtb team well source interesting technical minimize operational cost much possible obvious way reduce cost make system efficient mean entering hazardous land software optimization even experienced programmer identifying bottleneck hard enough problem using right tool trying guess could make code run faster waste time likely introduce unnecessary complexity cause problem line cousin premature optimization necessary optimization without profiling first erlang famously known concurrency model faulttolerant design one biggest strength level live inspection tuning offer often little setup runtime cost article outline leverage feature profile system driving optimization lead cost reduction minute read infrastructure interesting aspect realtime bidding fairly lowrisk test production even new code slow contains error bidder architected send nobid response whenever request fulfilled taking advantage incorporate canary deploys daytoday development workflow context optimization mean quickly test performance hypothesis updating code testing live traffic metric dashboard give feedback common metric like timeouts error amount request processed making obvious change beneficial requestlevel timer bid request processing fundamental operation bidder application improvement amount time take u send response ad exchange mean process request per server requiring fewer server handle traffic ultimately saving u money work involved bid request broadly divided series task payload parsing selection matching ad pricing particular ad response encoding common practice periodically measure time invested phase make sure degrade time help provide frame reference use look area code worthy optimization effort sample bid request timing per phase basic way profiling consists timing call given piece code perhaps one deemed suspicious one method described next section evaluates fun report evaluation time histogram metric spec timecall name fun result result timecall metric fun start erlang systemtime microsecond result fun end erlang systemtime microsecond diff end start update histogram metric diff result helper used wrap call function want measure canary deploy timed code production generate average median percentile metric compare overall request time identify bottleneck recon timing request operation useful technique understanding specific request flow give u limited perspective entire system bid request phase handled single process involve idle time waiting external system many periodic task longlived support process bidder benefit systemwide profiling look beyond bid request processing erlang toolbox come play first valuable resource piece software little book fred hebert erlang anger guide perfect reference describes method gaining insight optimizing production system backed realworld experience companion library recon provides safer friendlier productive interface powerful inspection tool follows simple example mostly derived book get node general stats bidderdev node recon nodestatsprint schedulerusage get top memory consumer bidderdev node recon proccount memory bidderbanker currentfunction genserver initialcall proclib bidguardian currentfunction genserver initialcall proclib currentfunction priminet initialcall proclib get top cpu consumer bidderdev node recon proccount reduction currentfunction exometerprobe initialcall proclib currentfunction exometerprobe initialcall proclib currentfunction exometerprobe initialcall proclib get top cpu consumer time window bidderdev node recon procwindow reduction currentfunction viewsbid initialcall proclib currentfunction timer initialcall proclib currentfunction priminet initialcall proclib get process stats including stacktrace bidderdev node recon info meta registeredname bidderbanker dictionary initialcall bidderbanker ancestor biddersup groupleader status running signal link monitor monitoredby trapexit true location initialcall proclib currentstacktrace bidderbanker file biddersrcpacingbidderbankererl bidderbanker file biddersrcpacingbidderbankererl bidderbanker file biddersrcpacingbidderbankererl bidderbanker file biddersrcpacingbidderbankererl genserver file genservererl genserver file genservererl proclib file procliberl memoryused garbagecollection maxheapsize errorlogger true kill true size work suggested book good method run recon procwindow repeatedly try identify pattern eg process frequently rank among top cpu consumer process id passed recon info get useful information stacktrace order understand process using method quickly found commonly accessed data structure contained debug data copied thousand time per second approach though tend highlight longrunning busy process shortlived one could called lot account bigger overhead overall partially overcome running procwindow repeatedly aggregating result location rather process id however better tool look aggregated process time redbug strictly speaking redbug profiling tool useful debugging live system deserves mention article allows safely trace function shell intuitive yet sophisticated way opposed rougher erlang builtin tracing module handy get quick notion function called frequently production data look like bidderdev node redbug start jiffy erlang jiffy encode bidderdev node redbug start jiffy encode return erlang jiffy encode usd erlang jiffy usd bidderdev node redbug start jiffy encode n isinteger n return erlang jiffy encode erlang jiffy including recon redbug erlang application release cost real lifesaver diagnosing production issue tool promote flow powerful adding print code feel natural step debugger useful highly concurrent world anyway erlang easy profiling eep eep allows approach profiling using erlang tracing take snapshot system operation function call count execution time interdependency requires bit effort use safe rest tool described article slow system potentially even killing used carelessly output file eat lot disk space m snapshot take system depending nature application may make sense run directly production example tracing session using eep bidderdev node eep startfiletracing filename timer sleep eep stoptracing note start sleep stop tracing line rely shell responsive tracing could send message call function well force certain part code executed taking snapshot instruction output filenametrace file release directory file need moved production server processed local erlang shell local eep converttracing filename working msg msgssec sec slowdown msg msgssec sec slowdown done turn produce callgrindoutfilename input kcachegrind qcachegrind macos note default tracing discriminate entry per process id would yield similar situation saw recon procwindow interesting view merge function call process accomplished stripping pid grep v ob callgrindoutfilename callgrindoutmergedfilename qcachegrind callgrindoutmergedfilename qcachegrind present snapshot sophisticated ui used spot frequently called function time spent etc eep output qcachegrind since eep based erlang tracing add overhead code may comparatively misrepresent work done builtin function bifs nativeimplemented function nifs timing shown snapshot need taken grain salt nevertheless still great exploratory tool understand different component system interact dependency used learn obscure suspicious area hard spot looking code note erlang profiling library tried yet produce callgrind output erlgrind lookingglass erlang systemmonitor yet another way looking application erlang bif allows set process receive message every time certain condition met particularly helpful u examining long garbage collection schedule long duration latter surface issue nifs would go unnoticed method example use shell based snippet erlang anger bidderdev node loop fun f receive monitor pid event info reconlocation recon info pid location io format monitorp pidp n infop n reconpn event pid info reconlocation end f end bidderdev node spawn fun register tempsysmonitor self erlang systemmonitor self longschedule longgc loop end timer sleep exit whereis tempsysmonitor kill monitor system second output process information shell every time garbage collection schedule take monitorlonggc pid info recon location initialcall proclib currentstacktrace bidderstat file biddersrcbidderstaterl viewsbid file biddersrcviewsviewsbiderl viewsbid file biddersrcviewsviewsbiderl erlstat file biddersrcbidderstaterl bidderwebhandler file biddersrcbidderwebhandlererl proclib file procliberl conclusion article mean exhaustive list erlang diagnosing tool observer eprof fprof eflame eministat list go erlang documentation nice efficiency guide overview builtin profiling module since started effort consistently reduced request time operational cost month month large extent gain came thanks advanced tool erlang ecosystem offer interesting achieved getting know system better fixing bug often removing rather adding specialized code
52,Lobsters,erlang,Erlang development,Are formatters better than linters?,https://medium.com/@elbrujohalcon/are-formatters-better-than-linters-cbab91189be3,formatters better linters,formatters better linters michał muskała juan bono diego calero facundo olano formatter steamroller michał formatters linters steroid michał elvis nesting level debug call dry simonthompson know one consistent indentation clause personalization article conclusion well written best practice nicely written easy understand obsolete,formatters better linters watched michał muskała talk codebeamsf something getting pretty might know also working juan bono diego calero facundo olano others formatter erlang like daniel tipping working steamroller could write article formatter differs michał time want focus attention different topicparticularly want look following lintersare formatters linters steroid michał present concept talk somewhat widespread think correct idea linters tell need improve code formatters better fix ithaving worked elvis linter formatter believe complementary independent tool intersection really interesting part one intersect believe happens well language instance credo mix format elixirthere thing linters detect formatters fix name elvis rule like nesting level linter detect code nested deeply formatter fix could theoretically move line different function think something would expect formatter right debug call linter tell left io format production code good think formatter remove leaving aside fact sometimes easy removing callsdry favorite elvis rule time linter identify piece code repeated formatter tool would actually refactor code extract separate function would amazing think formatter toolif tool automatically perform maybe simonthompson know one hand thing formatter fix linter deal like consistent indentation clause linter warn whether using tab space indentation figuring properly indented code using right number spacestabs worth effort particularly tool like formatter fix youpersonalization mentioned article linked believe formatters room personalization read code way understand best read code way like best need fight commafirst rokstyle indentation level long share format code pushed one u work using hisher style something linter allow since idea rule enforced linter respected usconclusionthe linter formatter different tool serve different purpose linter make sure code well written follows best practice defined community team formatter make sure code nicely written easy understand developera formatter happily make linter rule obsolete great remove need allin stop using linter start using formatter
53,Lobsters,erlang,Erlang development,Observing Processes in Elixir - The Little Elixir & OTP Guidebook (2015),https://www.akitaonrails.com/2015/11/22/observing-processes-in-elixir-the-little-elixir-otp-guidebook,observing process elixir little elixir otp guidebook,must choice otp worker wrong exactor otp supervisor ets graphically visualizing process fault tolerance supervision tree,yes erlang allows u see going inside runtime environment even take action individual process running inside cool show fault tolerancy observer need explain process matter must understand following concept successfully understand elixir programming nt object runtime instance class prototipical object copy object instead class collection function organized module without dependency internal state instead object roughly speaking process example defmodule myprocess def start acceptingmessages end def acceptingmessages state receive hello message ioputs hello message acceptingmessages state counter newstate state ioputs new state newstate acceptingmessages newstate ioputs acceptingmessages state end end end execute function inside another process spawn brand new concurrent lightweight process iex pid spawn fn myprocessstart end pid called stop block waiting receive new message send message like iex send pid hello world hello world receives hello world atom message pattern match value world message variable concatenates hello world string print recurse call block block waiting message iex send pid counter new state counter iex send pid counter new state counter iex send pid counter new state counter iex send pid counter new state send counter message process pid receive message get state value function argument increment print new state call passing new state new argument block waiting message time receives counter message increase previous state one recurses basically maintain state elixir kill process spawn new one restarts zero function nt object however process superficially process behaves like object careful think process like heavyweight thread though erlang internal scheduler control concurrency parallel load many billion lightweight process hardware allows thread super heavy erlang process super light saw example process internal mechanism receive message process message accumulate internal mailbox choose receive pattern match message recursing order receive new message want process linked monitor process example within iex shell within elixir process could iex self pid iex pid spawn fn myprocessstart end pid iex processalive pid true iex processlink pid true self see current process id iex shell spawn process call block receive call new process different id assert new process indeed alive link iex shell pid process whatever happens process cascade shell iex processexit pid kill exit pid killed interactive elixir press ctrlc exit type h enter help warning redefining module r iex self pid indeed forcefully send kill message process iex shell also killed process iex restarts new pid instead old way one way process different normal object behaves like operating system process crash process affect whole system hold external shared state corrupt system state important concept mechanism define parent process iex example child process linked parent process nt need stupidly suicide child screwed instead trap exit decide later iex processflag trapexit true false iex pid spawnlink fn myprocessstart end pid iex send pid counter new state counter first declare iex shell trap exists die spawn new process link function effect send message new pid check indeed still working iex processexit pid kill true iex processalive pid false iex flush exit pid killed ok forcefully kill new process iex crash time explicitly trapping error check killed pid assert indeed dead also inspect iex process mailbox case flushing whats queued inbox see received message saying child killed could make iex process treat message decide mourn deceased child commit suicide move spawnlink new choice face disaster otp worker letting aside grim metaphor learned parent child process importantly fit role supervisor worker supervised respectivelly worker put code code bug depend external stuff make code crash unexpected reason normal language would start using dreaded trycatch block ugly wrong nt catch error elixir let crash explained previous article everything elixir end called otp application example simple contraption expand upon let rewrite thing otp genserver defmodule myfancyprocess use genserver def startlink genserverstartlink module name module end public api def hello message genservercall module hello message end def counter genservercall module counter end genserver callback def init startcounter ok startcounter end def handlecall hello message state ioputs hello message reply noproc state end def handlecall counter state newstate state ioputs new state newstate reply noproc newstate end end new myfancyprocess essentially myprocess otp genserver top public api function genserver callback benjamin book go great lenghts detail every bit implemented understand basic module use genserver import necessary genserver bit convenience essence one thing create receive block first version wait message function create instance genserver return linked process internally call back function set initial state worker flexible language multiple way thing good single way writing code boring convention one public function call internal synchronous call asynchronous call could call handlecall outside ugly find convention everywhere place start calling directly iex myfancyprocessstartlink ok pid iex myfancyprocesshello world hello world noproc iex myfancyprocesscounter new state noproc iex myfancyprocesscounter new state noproc iex myfancyprocesscounter new state noproc much cleaner version manually spawnlink send message pid handled nicely genserver underneath said result initial crude myprocess example fact convention make u type lot boilerplate many time library called exactor grealy simplifies genserver implementation making previous code become something like defmodule myfancyprocess use exactorgenserver initialstate defcall hello message state ioputs hello message noreply end defcall counter state newcounter state ioputs new state newcounter newstate newcounter end end way cleaner using iex using version next section stick longer version myfancyprocess listed beginning section otp supervisor worker create supervisor supervise defmodule myfancysupervisor use supervisor def startlink supervisorstartlink module end def init child worker myfancyprocess opts strategy oneforone supervise child opts end end simple boilerplace supervisor many detail must learn article purpose important bit first definition child specification saying supervisor start myfancyprocess genserver instead u myfancyprocessstartlink manually second important bit opts list defines strategy oneforone meaning supervisor detects child died restart clean iex copy paste myfancyprocess myfancysupervisor start playing iex shell iex ok suppid myfancysupervisorstartlink ok pid iex myfancyprocesshello foo hello foo noproc iex myfancyprocesscounter new state noproc iex myfancyprocesscounter new state noproc start supervisor see right away start sending message myfancyprocess genserver supervisor successfully started u iex supervisorcountchildren suppid active spec supervisor worker iex supervisorwhichchildren suppid myfancyprocess pid worker myfancyprocess using supervisor pid captured right started ask count many child monitoring example ask detail child well see myfancyprocess started pid iex workerpid supervisorwhichchildren suppid myfancyprocess pid worker myfancyprocess iex processexit workerpid kill true grab worker pid manually force crash screwed right nope iex supervisorwhichchildren suppid myfancyprocess pid worker myfancyprocess iex myfancyprocesscounter new state noproc iex myfancyprocesscounter new state noproc ask supervisor list child see old process indeed vanish new one spawned place supervisor strategy oneforone defined continue making call myfancyprocess see previous state lost restarts zero add state management genserver using number different persistent storage builtin ets think ets builtin memcache service think get idea graphically visualizing process entire article motivated simple thing benjamin book end page book built simple pool system able start process pool guarded supervisor go show observer erlang builtin inspector tool called observer use supervisor builtin function inspect process demonstrated much cooler see visually assuming installed erlang solution propertly ubuntu wget http sudo dpkg start observer directly iex shell like graphical window show stats first powerful becuase insight control entire erlang runtime see status window even show uptime line unix system made stay matter process garbage collector behave nicely towards entire system hook remote observer remote erlang runtimes well wondering jump application tab see pooly exercise look like child pool child supervised proper restart strategy visually kill one one pid labeled observer immediatelly show supervisor took action spawned new child added pool bringing count back fault tolerance proper control mean using otp bit explained article enough concept finally grasp erlang high reliabiliby fuzz basic concept simple hook application otp also nobrainer otp implemented hood make application much reliable clear guideline design application supervises happen application state worker restarted divide responsabilities different group supervisorchildren application supposed look like tree supervision tree failure one leaf bring branch everything know behave recover elegantly really like unix operating system kill one process nt bring system initd monitored service get respawned important optional feature party library choose use builtin erlang must use want play choice best choice pattern implemented concurrent language represents big failure language elixir strength high level control wo nt find anywhere else still nt even talk otp application exchange message across wire really distributed system erlang runtime reload code application running zero downtime akin iex capable phoenix allow development mode code reloading otp give free well worth learning detail went process pid send kill message process trap exit parent child process feel similar unix work know unix easily grasp fit together including elixir pipe operator compared unix pipe similar finally little elixir otp guidebook easy read handson small book read couple day grasp everything quickly summarized much highly encourage buy right
54,Lobsters,erlang,Erlang development,Discord Incident Report (March 16 Outage),https://status.discordapp.com/incidents/62gt9cgjwdgf,discord incident report march outage,summary timeline http http investigation analysis http githubcometcdioetcd action item response,time pdt summary discord unavailable user period hour root cause well understood fixed bug service discovery system used service within infrastructure discover one another instance service discovery used real time chat service service order discover rpc endpoint use load data database connect discord discord server guild created first time need reloaded database timeline set node serve api traffic scale deal growing load api cluster event happens throughout day single node called scaled unexpected error announcing service discovery elixir service used handle real time connection chat message processing started crash resulting instantaneous loss capacity causing cascading failure dependent system multiple alarm internally go signal drop key metric look well anomaly alert cluster utilization incident declared phone bridge set available engineer hop start investigating establish internal external communication status page incident opened let user know investigating http tweet posted letting user know looking issue check status page update http engineer investigate exactly lost much capacity real time system engineer focus recovering service restarting lost capacity begin throttle connection discord order help service recovery additionally begin stop database maintenance operation antientropy repair two scylladb cluster would lead resource starvation everyone attempting reconnect engineer pinpoint issue strongly correlated spike error originating service discovery module determined service discovery process api service gotten crash loop due unexpected deserialization error triggered event called max restart intensity process supervisor determined crashing frequently decided trigger full restart node event occurred instantaneously across approximately node watching api node across multiple cluster believed related u hitting cap number watcher etcd keyvalue store use service discovery attempt increase using runtime configuration engineer continue remediate failed node restore service user connection throttle continually increased allowing user reconnect service recover status page incident resolved service deemed fully operational mitigation issue deployed production order prevent issue recurring root cause fully understood investigation analysis root cause outage determined invalid service entry inserted service discovery causing parse error trying deserialize entry loading etcd engineer worked recreate issue test environment able reproduce issue observed production development environment discord us open source distributed reliable keyvalue store called etcd http githubcometcdioetcd order store service discovery information service discoverable announce setting key specific directory etcd pertains cluster part key second ttl service responsible heartbeating etcd reannounce key discord using etcd api node joined api cluster introduced google cloud managed instance group autoscaler normal event happens hundred time day utilization platform increase approach peak hour node logged error attempting initially announce etcd httpclientremotedisconnected remote end closed connection without response nearly immediately almost elixir node logged service watcher discordapi service crashed attempting parse json metadata stored key value etcd process crashlooped briefly due invalid json data etcd cluster lasted api node retried announcing service discovery fixing corrupt key written etcd node announce etcd issuing http put request contains urlencoded form body contains value key case value json encoded metadata information relevant discovery service etcd client us python builtin http client sends put request along contentlength header one packet request body another packet determined connection reset sending first packet second packet could sent wellbehaved http server would see received request specifying contentlength incomplete nonexistent body reject request etcd written go programming language us go standard library nethttp http request handler key api order parse form body sent client us nethttprequestparseform method method check see request body length match length specified contentlength header caused key written empty string value announce request able successfully send header send body turn caused invalid key written service discovery caused downstream service crash key rewritten announcing node retried action item response code within service discovery system resilient type failure within expectation key could announced without value due transient network error service discovery system resilient various failure mode within etcd however anticipate client able write corrupt record due improper http handling golang nethttp module violation http specification specific case introduced additional failure case anticipate expected contentlength header incomplete body rejected server incomplete unfortunately nethttp check byte read body portion request match contentlength header since hardened system reduce likelihood occurring also handle invalid service announced without crash looping order reduce likelihood invalid key written service discovery modified etcd client send announce request single tcp packet instead two mean header body either received completely added additional error handling ignore service corrupt key value case issue recur worst happen service discovered able investigate additionally filling upstream bug report go project aware issue hopefully nobody else learn hard way sorry inconvenience caused working around clock make sure discord reliable available everyone especially utilization platform time high thank choosing discord place hang talk friend
55,Lobsters,erlang,Erlang development,"v0.7 of Gleam, the statically typed language for the Erlang VM, is out",https://lpil.uk/blog/gleam-v0.7-released/,gleam statically typed language erlang vm,improved error message alternative pattern clause guard named subpatterns type alias window support rest changelog installation page awesomegleam suggestion tracker thanks sponsoring gleam,two month since last one time another gleam release let see new time improved error message since last release put lot work error message emitted compiler common arguably important type error type error want clear friendly possible look like gleam big improvement previous version would struggle highlighting multiline code section would state problem int float rather list int list float improved error message include import cycle error message error message invalid pattern case expression slew error message relating error trying read write file gleam project gleam aim exceptionally friendly productive language error message important error find confusing unclear please get touch let u know adding new error message discovered bug unicode character would printed incorrectly circumstance bug fixed find error look incorrect please try upgrading version running local upgrade alternative pattern sometimes writing case expression want multiple different clause able trigger clause different shaped data meet need introducing alternative pattern separated operator case expression first clause match variable number hold case number even number odd number sure clause guard sometimes pattern matching want assert two variable value release need nested case expression clause guard case x b b two equal element b b two unequal element something else named subpatterns sometimes pattern matching want assign name value specifying shape time release using keyword case x innerlist innerlist type alias sometimes tiring writing long type name function annotation result list tuple string string nil often rather write short alias instead option header type alias possible pub type option value result value nil pub type header list tuple string string pub fn header option header ok tuple xservedby gleam option value alias often pretty useful want use defined gleamresult module gleam standard library window support gleam compiler test suite running successfully window window binary compiled new release developing window please give try let u know problem encounter rest addition change bunch bug fix performance improvement refactorings compiler please see changelog detail want try new version gleam head installation page love hear find get feedback gleam continue improve want view existing gleam project head awesomegleam list looking something build gleam check suggestion tracker thanks lastly huge thank contributor sponsor gleam since last release would like help make strongly typed programming erlang virtual machine productionready reality please consider sponsoring gleam via github sponsor program thanks reading fun
56,Lobsters,erlang,Erlang development,The new code formatter for Erlang: rebar3 format,http://tech.nextroll.com/blog/dev/2020/02/25/erlang-rebar3-format.html,new code formatter erlang format,new code formatter erlang format gofmt mix format introduction elvis hackweeks bit history code formatters one parsing formatting erlang code erlangmode emacs juan facorro choosing right format behavior alone pierre krafft pr daniel tipping within use quick start configuration format formatter use configure formatter online proposed workflow example repo please spillway mero extremely ugly appendix beautiful code favorite piece code,new code formatter erlang format written brujo benavides february recent year many language ecosystem developed automatic code formatters reduce mental overhead code reader therefore share code easily tool work ensuring code written language look example tool include gofmt go mix format elixir erlang community lacking tool like created plugin automatically format code article discus history erlang parsing formatting tool challenge developing formatter resulting tool created learn use customize need minute read bug bunny rabbit seville introduction rtb team devotes quite bit effort make codebase mature maintainable erlang code started working task year ago trim dead code using xref remove discrepancy help dialyzer make sure code well behaved using pest let elvis find stylistic one tool missing codeformatter using code formatter go elixir python barely erlang decided use one hackweeks create one bit history code formatters code formatting certainly nothing new around age several interesting paper written recently tendency modern language include one one formatter like gofmt course one influenced u mix format mean expert area therefore wanted rely existing effort much could took inspiration tried use many already written component possible usual bunch already baked parsing formatting erlang code first initiative try find existing tool format erlang code found readytouse solution fmt problem clearly state description requires emacs something u use pointed u generally recognized de facto standard erlang formatters erlangmode emacs otp team considers standard way formatting erlang code tool included otp loosely based tool say follow question well one found erltidy closest thing automatic code formatter erlang us many module list parse rewrite erlang code bit old bunch wellknown deficiency including limited lack proper support macro comment code erlprettypr pretty printer take ast abstract syntax tree input print pretty way standard erlang pretty printer original intention use extensibility support complex poorly documented best like many others u eg wrangler erlangls etc copied project started epp side story erlang parser come otp also limitation importantly come macro comment since intended used primarily compiler eppdodger module explicitly created work like epp bypassing macro preprocessor directive also bit buggy limited support extensibility luckily juan facorro already copied improved katanacode ended using ktndodger katanacode parse code turn ast version erlprettypr output formatted code choosing right format tool developed first version formatter still find hexpm version simply passed provided erlang code tool generated code formatted erlprettypr considered canonical formatting since know come otp right many others like u want code formatted strictly erlprettypr output started adding configuration option able adjust formatter taste though realized wanted extension erlprettypr different formatter moved one formatter lot option formatting behavior multiple implementation favorite way formatting erlang code encoded defaultformatter kept otpapproved way alive otpformatter define alone research found one saw need erlang formatter matter fact several people working different code formatting tool erlang day mentioned emacs user already plugin use fmt back pierre krafft tried improve erltidy wrote pr thread learned also working formatter probably called erlfmt later found steamroller daniel tipping steamroller erlfmt much opinionated formatter mostly author aim consistent formatting across erlang codebases world much like goal mix format see great goal fairly smaller one want consistent formatting within erlang codebases world word want module project consistently formatted even share formatting rule project point hard even define canonical formatting erlang code wild achieve goal developer format code using format another developer read code using different formatter one used eg use commafirst rokstyle formatter need switch option rebarconfig run format ugly code look way enough history see tool use format quick start add rebarconfig either project globally plugins run format enjoy configuration really like default formatting asis format configured using format section rebarconfig three main option specify format determine file formatter format use file parameter format file src erl test erl formatter use unless specify otherwise format always use default formatter baked want use otpformatter one like format file src erl test erl formatter otpformatter configure formatter finally also set individual option formatter want use instance otpformatter change paper ie expected max width formatted code format file src erl test erl formatter otpformatter option paper find option provider check doc available online proposed workflow drawing smalltalk formatter experience code formatted presenting developer stored image want propose workflow team member preferred style code formatting idea take advantage profile write following rebarconfig file canonical format used pushing code central repository format file src erl include hrl test erl formatter defaultformatter option paper profile brujo format file src erl include hrl test erl formatter rokformatter prefer commafirst formatting option paper miriam format file src erl include hrl test erl formatter defaultformatter option inlineclausebodies false nt like oneliners inlineitems nt like long list item whenever work something follow ritual git checkout master git checkout b mybranch brujo format work code normally run test whatnot ready commit format git commit apply change git push origin mybranch setupstream miriam using miriam instead brujo way one u read code way understand better write code exactly like write etc publish consistent way match style rest project example want see formatter code best place go sample project repo sort example many edge case could create find know others please contribute adding writing issue add even though still process testing improving tool already started using several repository see formatter action spillway mero best code reviewer may notice pr required manual adjustment processing code formatter consider feature formatter allowing u spot ugly piece code eg deeply nested structure refactor clear formatter break code builtin verification made look extremely ugly therefore prompting u beautify bug bunny rabbit seville releasing formatter early catch many bug nuance possible please try code report bug new idea plan keep using anybody feel like making tool official member otp team message would amazing appendix beautiful code bonus track wanted know favorite piece code look like formatted format module author john author paul author george author ringo export mylife newplaces place db getall place updatedplaces newplace newplace newplaces list member newplace place list foreach fun place db insert place place end updatedplaces deletedplaces place place place list member place newplaces db delete place deletedplaces moment moment place place moment place moment place people person moment moment person moment lover moment moment friend moment dead living list partition fun person people list foreach fun person dead living db getfirst people person person people person comparable person ok love update updatedmemories moment meaning moment null moment moment db update moment updatedmemories mylife people updatedmemories mylife people thing case rand uniform timer sleep rand uniform person thinkabout people timer sleep rand uniform moment thinkabout thing dontstopnow end person love mylife people thing bad huh bug bunny rabbit seville
57,Lobsters,erlang,Erlang development,"Bastion - distributed, fault tolerant system for Rust",https://github.com/bastion-rs/bastion,bastion distributed fault tolerant system rust,highlyavailable distributed faulttolerant runtime usage feature guarantee fort lightproc bastion bastion ecosystem get started getting started example example bastion documentation architecture runtime license documentation docsrs getting help discord stackoverflow discussion development discord contributing bastion contributing guide license,highlyavailable distributed faulttolerant runtime latest release license doc bastion doc bastion executor doc lightproc build status downloads discord bastion highlyavailable faulttolerant runtime system dynamic dispatchoriented lightweight process model supply actormodellike concurrency lightweight process implementation utilizes system resource efficiently guaranteeing atmostonce message delivery usage bastion come default oneforone strategy root supervisor use launch automatically supervised task feature messagebased communication make project lean mesh actor system without web server weird shenanigan forced trait implementation static dispatch runtime faulttolerance make good candidate distributed system want smell erlang powerful aspect rust completely asynchronous runtime numaaware cacheaffine smp executor exploiting hardware locality wherever possible designed server supervision system make easy manage lifecycles kill application certain condition restart subprocesses whenever certain condition met automatic member discovery cluster formation custom message passing cluster member using zeroconf launch bastion cluster everywhere single actor block proactive io system nt depend anything future bastion proactive io scattergather operation iouring support much guarantee delivery message completely asynchronous system design asynchronous program boundary fort dynamic supervision supervisor adding subtree later execution lifecycle management future lightproc layer faster middleware development fault tolerance bastion answer question yes bastion want proactive io need faulttolerance project hate implement weird actor trait nt need webserver run actor system right want make existing code unbreakable trust issue orchestration system want implement application lifecycle bastion ecosystem bastion ecosystem provide way customize nt need newcomer install use bastion without knowing everything work hood hope find section soon nucleus proactive io system independently used without executor restriction also powering bastion io system learn nucleus check nucleus repo sophisticated use case lightproc lightweight process abstraction rust us future lifecycle callback implement erlang like process contains basic pid identify process panic inside future propagated upper layer bastion executor numaaware smp based faulttolerant executor highlyavailable async communication oriented independent framework implementation us lightproc encapsulate provide faulttolerance future based workload use future lightproc run workload bastion executor without need framework agnostik layer application executor async stuff let switch executor smooth easy without change application code valid feature runtimebastion default runtimetokio runtimeasyncstd runtimenostd coming soon get started check getting started example bastionexamples example cover possible use case crate include bastion project information please check bastion documentation architecture runtime runtime structured user root supervision come batteriesincluded fashion worker code worker group redundancy supervisor supervision strategy defined user license licensed either option documentation official documentation hosted docsrs getting help please head discord use stackoverflow discussion development use discord development discussion also please nt hesitate open issue github ask feature report bug comment design interaction idea better contributing bastion contribution bug report bug fix documentation improvement enhancement idea welcome detailed overview contribute found contributing guide github license
58,Lobsters,erlang,Erlang development,The Let It Crash Philosophy Outside Erlang,https://stratus3d.com/blog/2020/01/20/applying-the-let-it-crash-philosophy-outside-erlang,let crash philosophy outside erlang,occur handle properly ought,let crash fault tolerant design pattern like every design pattern variation actually mean looked around online find simple authoritative definition term closest thing found quote joe armstrong program happy case specification say task supposed good terse description let crash coding happy path acknowledging fact fault occur going able handle properly know program ought handle approach improve program apply practice
59,Lobsters,erlang,Erlang development,Ernie - binary encoding format based on External Term Format (Erlang),https://github.com/hauleth/ernie,ernie binary encoding format based external term format erlang,ernie external term format bert name rpc schemastructured data specification introduction bcp type encoding open question license creative common attributionsharealike international license,ernie simple binary data exchange format based external term format erlang update bert little bit outdated right name ernie fun original bert name sesame street bert ernie couple rpc document define rpc syntax reason scope document meant define data encoding format service one use author document belief rpc bad use instead use message passing service schemastructured data meant encode freeform data want encode structured data schema highly suggest take look format like encoding protobuffers apache thrift flatbuffers cap nproto specification introduction key word must must required shall shall recommended may optional document interpreted described bcp type integer binary representation integer implementation must support least unsigned signed integer full precision float ieee double precision float implementation must support nonnan noninfinite nonsubnormal value described ieee spec implementation encode value tuple fixed length sequence value list dynamic length sequence value binary representation byte arbitrary length used store humanreadable string must encoded correct string map list keyvalue pair arbitrary order key must appear twice map encoding top level binary encoded data must start magic byte decimal value followed single byte tag value followed arbitrary length data tag data integer integer encoded different form value range aka byte data data unsigned byte representation value value range signed value data data signed representation integer bigendian encoding short arbitrary long signed integer n sign data n bigendian unsigned integer data represents littleendian encoded n byte long integer sign positive integer negative one long arbitrary long signed integer long n sign data n bigendian unsigned integer data represents littleendian encoded n byte long integer sign positive integer negative one float data data ieee double precision floatingpoint number encoded bigendian tuple tuples element arity data tuples element arity data arity bigendian unsigned integer declaring amount element data list byte list n data optimisation list contains value range inclusive general list arity data arity bigendian unsigned integer declaring amount element data empty list binary n data map arity data arity field unsigned integer bigendian format determines number keyvalue pair map key value pair ki vi encoded section data following order kn vn open question support atom allow defining improper list license document released creative common attributionsharealike international license
60,Lobsters,erlang,Erlang development,systemd integration library for Erlang applications,https://github.com/hauleth/erlang-systemd,systemd integration library erlang application,systemd feature installation nonsystemd system usage log standard error datagram socket license license,systemd simple library notifying systemd process state feature notifysocket handled notify supervisor event happening application watchdog process started automatically enabled also handle sending keepalive message automatically file descriptor fetching environment journal logger handler formatters installation add rebarconfig case mix project mixexs defp deps systemd end call systemd notify ready application ready workaccept connection nonsystemd system application function within safe call even nonsystemd nonlinux os case systemd configuration option function simply work almost noops usage assuming myappservice unit like unit descriptionmy awesome app service userappuser groupappgroup allow using systemd informing system supervisor application status typenotify application need start foreground instead forking background otherwise may correctly detected system try start execstartpathtomyapp start enable watchdog process expect message given timeframe otherwise restart process defunct managed automatically systemd application case send message twice often equested force failure using systemd watchdog trigger manually ping systemd watchdog via systemd watchdog ping restartonfailure install wantedbymultiusertarget inform systemd state application call make systemctl start myappservice wait application running want restart application notify systemd systemd notify reloading message application shutting handled automatically simplification readiness notification systemd ready function return child spec temporary process used part supervision tree mark point application ready ex module myappsup behaviour supervisor export startlink opts supervisor startlink local module module opts init opts supflags strategy oneforone child myappdb childspec myappwebserver childspec systemd ready myappperiodicjob childspec ok supflags child log handle log possible option output data standard output error special prefix approach much simpler straightforward however support structured logging multiline message use datagram socket special communication protocol requires little bit effort set seamlessly support structured logging multiline message library support format one app decide use standard error systemdkmsgformatter format data using kmsglike level prefix used logger output standard output standard error attached journal default systemd library update handler use loggerstdh type standardio standarderror attached journal automatically detected via journalstream environment variable disable behaviour setting systemd autoformatter false custom logger use formatter adding new option parent formatter option used upstream formatter ex logger addhandler examplehandler loggerdisklogh formatter systemdkmsgformatter parent loggerformatter template msg config file varlogmyapplog datagram socket one requires systemd application started spawn process required handling socket best way handle add predefined systemd handler application start logger addhandlers systemd aware one guaranteed work nonsystemd system nt sure application ran systemdenabled o nt use logger solution application end logger attached handler used systemdkmsgformatter result pointless kmsglike prefix log message license see license
61,Lobsters,erlang,Erlang development,Webserver Benchmark: Erlang vs Go vs Java vs NodeJS,https://stressgrid.com/blog/webserver_benchmark/,webserver benchmark erlang v go v java v nodejs,cowboy mochiweb fasthttp netty rapidoid methodology stressgrid dummy web application previous test result conclusion article discussion lobster discussion hacker news,article compare performance webservers commonly used implement serverside application opposed webservers used serve static content proxy look webservers implemented erlang go java openjdk javascript nodejs test following webservers cowboy erlang otp cowboy erlang otp mochiweb erlang otp go nethttp fasthttp go nodejs clustered nodejs netty openjdk rapidoid openjdk methodology simulate generic web application behavior devised following synthetic workload client device open connection sends request millisecond one server handle request sleeping millisecond simulate interaction backend database return kb payload without additional delay result average connection lifetime second perdevice load averaging request per second connection per second workload expressed combination following stressgrid script dummy web application created web server enumeach fn get delay end test mediumsized instance vcpus gib ram test structured continuous ramp device chose number based packetpersecond limit exhibited previous test following calculation account network packet generated http request response transaction establishing closing http connection transsec packetstrans connsec packetsconn packetssec placing target number simulated device hardware limit want show software imposed limit compare use ubuntu kernel following sysctld override fsfilemax netcoresomaxconn workload using nonencrypted http produced stressgrid generator placed vpc target host result test notable exception nonclustered nodejs limiting factor cpu fully saturated essence test shown webservers scaling available cpu varying degree efficiency let look responsepersecond graph go fasthttp came top peaking nearly response per second javabased netty distant second almost go builtin webserver peaked slightly nodejs cluster erlangbased cowboy range another erlangbased webserver mochiweb cowboy javabased rapidoid finally nonclustered nodejs scored clustered nodejs rapidoid crashed running ram overloaded server overloaded maintained peak performance except mochiweb let look percentile response latency graph graph much easier see different webservers respond overload notably erlangbased server overloaded maintained stable response latency cowboy keeping around millisecond go java server getting progressively slower nonclustered nodejs limited utilizing one cpu slowest result clustered nodejs rapidioid inconclusive since ran available ram stressgrid get function default timeout second mean response latency graph includes response received second let look rate timeouts complete picture happening webservers overloaded notably java netty absent graph mean netty maintains mostly equal latency request overloaded erlang server different approach serve fraction request quickly possible let rest time interestingly behavior improves time fewer fewer timeouts observe similar behavior nonclustered nodejs go server overloaded start timing well since happens end test conclude behavior change time conclusion test shown modern webservers scale well able utilize cpu multicpu machine performance limited efficiency webserver implementation corresponding language runtime virtual machine go javabased webservers shown efficient clustered nodejs reasonably efficient run ram overloaded erlang webservers least efficient however stable overloaded surprisingly cowboy performed significantly better cowboy reason included test explore analyze anomaly dedicated article packetpersecond limit imposed become issue used efficient webservers like fasthttp test modeled backend database interaction variable sleep delay reality interaction consume additional packetpersecond budget proportionally workload since frontend traffic already consumes budget addition one database interaction every frontend request result oversaturation discussion lobster discussion hacker news
62,Lobsters,erlang,Erlang development,Implementing Clojure agents on BEAM VM,https://medium.com/clojure-on-the-beam/agents-9de923017adf,implementing clojure agent beam vm,agent good specific circumstance would use agent instead something else either jvm beam provides link limited know case please let know section implementation alternative single process one process per agent tuning vm starting process pool dispatch process process pool tradeoff appendix conclusion master clojerl repository appendix process process dictionary,gone agent let try figure good circumstance people use themwhat agent good simple answer come rather opinion let try take stab itthe agent abstraction extremely useful tool specially sane framework think state concurrency ie jvm beam concurrency state center embodied process keep internal state share nothing abstraction provided beam name indicate generic eg genserver genstatem etc agent abstraction serf defined specific purposea useful way rephrase question would specific circumstance would use agent instead something else either jvm beam provides try answer question look usage agent opensource github project use clojure jvm investigation scientific say least look term agent amongst clojure file public repository company listed using clojure link take one search result found show example usage agentsfrom limited observation got impression get agent used mostly test whenever concurrency need generated know case please let know agent also sound lot like beam process send action message keep state internal state get changed based action receive loop process message look deceiveing crucial difference agent process independence state control process need send message get state process busy long time message queue long left waiting indefinitely state agent state available immediatelyadditionally section joy clojure great book compare agent process interesting point view although fully agree everything finally even though seems like agent usage quite limited wild one clojure concurrency tool people might rely could still prove fruitful think different implementation alternative ass much work would involve possible something robust enough usefulimplementation alternativesso let try think different way could implement agent using beam providesstate access independent processing action saw point state always immediately available reading keep state separate whatever mechanism change mentioned easily done keeping agent state ets tablethe next thing need think apply action agent single processa single process applies action existing agent approach simple enough obvious limitation one single process would contention point action trying modify agent cpu limiting blocking io action since anything block single process would hold every agent one process per agentactions agent would independent safeguard creating many thus making bad use resource creating process extremely cheap overhead would memory footprint cpu limiting blocking io action would run process fine since action must applied sequentially agent beam bulitin feature us async thread pool io operation avoid blocking process possible configure many thread pool tuning vm starting process poolhaving limited amount process use would ensure control usage resource action specific agent sent process pool applied sequentially ie one point time mean cpu limiting blocking io action use pool process want ensure sequential processing situation would improvement option single point contention still issue set agent whose action end process pool need potentially wait dispatch process process poola dispatch process would keep track action sent agent dispatcher would use process pool cpu limiting action spawn new process blocking io action time ensuring action applied sequentially agenttradeoffsthe two main point come previous implementation option process contention resource management one process per agent dispatch process process pool option provide good balance involve tradeoff one process per agentthe agent treated resource therefore cleaned closed owner process dy approach used file resource management erlang detail check module file fileserver fileioserver price would paying using agent user need remember close agent done also owner process dy agent state lost could prove problematic case file reopened state agent deleted memory gonedispatch process process poolall agent action would go single process little work possible dispatch action another process either pool spawned dispatch process must keep track current action run agent collect sent action store pending one already applied agent apply pending action agent current action running action send ask process pool sendoff create processthese quite lot concern process need little work situation require coordination pool example happens worker available fail store action pending subscribe notification worker becomes available probably second one situation sort may arisealso keeping state agent ets table agent longer used still cleanup required ie delete entry table mean would still need require user close agentboth option seem promising however one process per agent lot simpler main shortcoming required cleanup also present dispatch process process pool alternative reasoning see appendix conclusionporting clojure construct beam seldom trivial almost always possible willing make tradeoffsafter postponed implementation agent long good exercise get bottom sketch outthe experimental implementation using one process per agent found latest master branch clojerl repositoryplease try feedback welcome enjoy main problem dispatch process process pool need clean ets table keep state somewhere else process would comply requirement state always immediately available reading even remove usage ets table would still need keep state somewhere went one process per agent would still need close agent process done went dispatch process process pool approach state would need live process part pool eg dispatch proces would also necessary remove longer usedprocess dictionary possible read internal dictionary process using erlang processinfo pid dictionary would extremely hacky approach cleaning mentioned still requirement
63,Lobsters,erlang,Erlang development,"v0.5 of Gleam, a statically typed language for the Erlang VM, is out",https://lpil.uk/blog/gleam-v0.5-released,gleam statically typed language erlang vm,gleam labelled argument familiar syntax multisubject case record compatibility record anonymous structs unqualified import project creation rest installation page awesomegleam suggestion tracker code mesh code mesh thanks sponsoring gleam,gleam reached quite bit larger previous release let take look labelled argument function take several argument difficult user remember argument order expected help gleam support labelled argument function argument given external label addition internal name take function replaces section string pub fn replace string pattern replacement given label like pub fn replace string pattern replacement variable string pattern replacement scope label used calling function replace b c labelled argument given order replace b c argument still given positional fashion replace b c use argument label allow function called expressive sentencelike manner still providing function body readable clear intent one neat thing unlike proplist argument erlang elixir gleam labelled argument resolved entirely compile time performance memory cost runtime familiar syntax one bit common feedback syntax enums case expression block felt little strange keeping wider language response adopted syntax closer found cinfluenced language ecmascript case x one two brace used multiple statement let number inttostring x stringconcat sure number pub enum cardinal north east south west multisubject case often useful pattern match multiple value time previously gleam solution wrap value struct pattern match value case pair x pair pair x pair pair neither remove boilerplate gleam case expression support pattern matching multiple value case x x neither theoretically case expression match value need match value please let know wow wan na know code record compatibility gleam structs erlang tuples runtime great performance memory usage make constructing erlang elixir le straightforward map resolve gleam structs runtime tag atom first position making compatible erlang record erlang record definition header file generated struct imported erlang project used elixir using record module srccatgleam pub struct cat name string iscute bool pub fn main cat name nubi iscute true srcprogramerl module program export import cat record definition import gensrccatcathrl use cat record main cat name nubi iscute true libprogramex defmodule program import cat record definition require record recorddefrecord cat recordextract cat gensrccatcathrl use cat record def main cat name nubi iscute true end end anonymous structs one drawback structs erlang record compatible longer used interop erlang tuples tag atom first position anonymous structs map onto erlang tuples useful situation interop erlang tuples required fn main struct hello type struct int string struct type struct int float list int anonymous structs need declared front also name field clarity prefer named structs field unqualified import tired typing module name repeatedly imported type value well import animalcat cat stroke pub fn main let kitty cat name nubi iscute true stroke kitty project creation terminal command gleam new accepts template flag generate different style project otp application template added alongside existing otp library template gleam new myfantasticapplication template app addition project generated gleam new come required configuration ci github action push project github code automatically compiled test run every code update enable created two new github action setting erlang gleam github workflow rest per usual addition feature number improvement quality error message generated code smattering bug fix want try new version gleam head installation page love hear find get feedback gleam continue improve want view existing gleam project head awesomegleam list looking something build gleam check suggestion tracker code mesh last month got speak gleam favourite conference code mesh recording talk found youtube channel thanks lastly huge thank contributor sponsor gleam since last release would like help make strongly typed programming erlang virtual machine productionready reality please consider sponsoring gleam via github sponsor program thank
64,Lobsters,erlang,Erlang development,ElixirConfLA 2019 - Erlang/OTP: What is in the box? by João Britto,https://www.youtube.com/watch?v=WXqbOBH9xjg,elixirconfla erlangotp box joão britto,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature elixirconfla erlangotp box britto youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature elixirconfla erlangotp box britto youtube
65,Lobsters,erlang,Erlang development,Survey of Cowboy Webserver Performance - Part 2,https://stressgrid.com/blog/cowboy_performance_part_2/,survey cowboy webserver performance part,part cowboy ranch fast stream handler fast stream pull request conclusion discussion lobster,article follow part survey cowboy webserver performance part surprise observed version le performant article analyze root cause performance degradation cowboy also point solution show effect test result decided start analysis looking erlang vm supervision tree dummy web application see supervision tree reflecting request handled made handler sleep several minute started request curl cowboy quickly identified ranch connection supervisor pid connection process serving request pid running elixir processsleep next experiment cowboy see ranch connection supervisor pid connection process pid another process pid spawned connection process running processsleep additional process undoubtedly introduce overhead passing request response process cowboy primary goal cowboy redesign cowboy introduce support http http possible handle multiple requestresponse interaction single tcp connection also possible overlap interaction word client may submit request without waiting response http achieves defining concept stream multiple stream multiplexed single tcp connection within stream request frame must followed response frame make logically corresponding single http connection cowboy defines straightforward interface programmer write applicationlevel http handler ranch responsible creating process handle tcp connection process responsible receiving parsing request calling application handler building writing response application handler expressed single function essence get request parameter return response since nothing else happen tcp connection call done synchronously http cowboy simple design work anymore process responsible handling tcp connection blocked waiting application handler respond since able process request response concurrently two possible way solving one change programmer interface require asynchronous handling another introduce one process dedicated handling stream interaction keep interface simple mostly compatible cowboy cowboy box keep handler interface simple cost introducing stream process also provides ability programmer write stream handler replaces default stream handler corresponding complexity handle multiple stream asynchronously downside http http share design therefore incur overhead even need http fast stream handler validate performance theory implemented version dummy web application replaces default cowboy stream fast stream handle request directly inside tcp connection like cowboy note fast stream implementation hack used beyond experimentation approach work nicely http server may affect scalability multiple http stream handler blocking test result confirming theory show cowboy performance comparable cowboy using process architecture reached response per second cowboy slightly faster active n another potential optimization using active n tcptls socket option note tl option available since otp otp active mode mean process attached socket receive data message instead proactively calling recv function cowboy traditionally us active sends single message reset back passive mode pull request us active n instead sends n message resetting passive mode n currently set change reduces number call otp port driver giving finegrained flow control test result showing improvement fast stream handler combined active n change cowboy reach response per second active n change alone improves response per second conclusion main finding http design cowboy add significant overhead even used http way work around implementing custom stream handler process request directly tcp connection process without spawning dedicated stream process approach cowboy performance comparable cowboy approach combined active n socket option cowboy achieves significant performance improvement cowboy discussion lobster
66,Lobsters,erlang,Erlang development,Elixir Module and Struct Interoperability for Erlang,http://marianoguerra.org/posts/rfc-elixir-module-and-struct-interoperability-for-erlang.html,elixir module struct interoperability erlang,warianoguerra http githubcommarianoguerraexat http hexpmpackagesexat exatexample erlang friendly elixir module name alias long elixir module name creating structs alias structs pattern matching structs note static compilation literal structs use build run syntax bikesheding,rfc shape project actually use interested feedback find marianoguerra erlang elixir slack warianoguerra twitter project github http githubcommarianoguerraexat hexpm http hexpmpackagesexat see exatexample project simple usage example description project write erlang friendly module name get translated right elixir module name automatically project parse transform also escript easily debug transformation done correctly erlang friendly elixir module name call like ex abc myfun translated automatically elixirabc myfun build time using parse transform trick symbol allowed atom first character thank node name use ex prefix identify module must translate since one us prefix module erlang alias long elixir module name since elixir module name tend nest long define alias use code save typing example following alias declaration ex alias ex baz ex foobarbaz bare ex foolong translate ex bar foo ex foobarbaz foo turn become elixirfoobarbaz foo also translate module name bare foo ex foolong foo turn become elixirfoolong foo creating structs code ex learnuser mapvar becomes elixirlearnuser struct mapvar code ex learnuser name bob age becomes elixirlearnuser struct name bob age elixir would learnuser name bob age alias structs following alias declaration ex alias ex structalias ex learnuser expand ex structalias name bob age elixirlearnuser struct name bob age pattern matching structs function call allowed pattern match position example functioncaseetc clause left side different syntax getname ex structalias name name name getname ex structalias error noname becomes getname struct elixirlearnuser name name name getname struct elixirlearnuser error noname ex structalias name ex learnuser name bob age becomes struct elixirlearnuser name elixirlearnuser struct name bob age pattern match map also key note static compilation literal structs elixir pas field struct compiled map place since compiler know field default compile time exat us slower version merges default provided field using elixirenum reduce future try get default compile time struct compiled already beam file compiled current file use add rebarconfig dep parse transform erlopts parsetransform exat deps exat build build escript escriptize run run escript builddefaultbinexat pp erlast pathtomoduleerl example exat repo builddefaultbinexat pp erl builddefaultbinexat pp ast syntax bikesheding syntax chose balance need produce compilerlinter error warning objective avoiding accidentally translating something nt translated please let know think famous last word
67,Lobsters,erlang,Erlang development,Survey of Cowboy Webserver Performance,https://stressgrid.com/blog/cowboy_performance/,survey cowboy webserver performance,cowboy cowlib ranch gun stressgrid first second third cowboy version otp version conclusion part discussion lobster,cowboy small modular webserver written erlang heart elixir phoenix web application framework well many project erlang elixir ecosystem cowboy evolved year version released latest version important note change significant required change user code cowboy composed two main component cowlib ranch cowlib generic parser builder http based protocol ranch socket acceptor pool stand directly top tcpip tl functionality exposed erlang otp cowlib sufficiently abstract shared library http server client gun ranch may underpin server implementing protocol top tl tcpip article benchmark performance cowboy release case use ranch cowlib linked release default benchmark default ranch separately newest ranch simulate generic web application client server behavior devised following synthetic workload client device open connection sends request millisecond one server handle request sleeping millisecond simulate backend database request return kb payload without additional delay result average connection lifetime second average load request per second per device following stressgrid script represents client side workload enumeach fn get delay end serverside three separate implementation first cowboy second cowboy third cowboy higher benchmark tested aws instance vcpus gib ram used ubuntu kernel following sysctld override fsfilemax netcoresomaxconn minute test load linearly increased device correspond request per second specifically selected maximum load outside capacity observe saturation point version cowboy cowboy version first series test used erlang otp graph show response rate observed client word completed request per second big difference version version surprising leader peaked request per second stayed ranch version significant effect performance percentile connection response latency tell similar story significantly outperforming otp version second series test decided use cowboy vary three otp version otp combined cowboy show best performance peaking almost request per second otp close second cowboy difference otp otp le significant version cowboy otp performance lowest conclusion surprising conclusion survey combination cowboy relatively old otp demonstrated best performance another surprise significant difference various version cowboy well ranch update part analyze root cause performance degradation cowboy also point solution show effect test result discussion lobster
68,Lobsters,erlang,Erlang development,Announcing Bastion 0.3 - Highly-available Distributed Fault-tolerant Runtime,http://bastion.rs/,announcing bastion highlyavailable distributed faulttolerant runtime,short way use fort procmacro bastion configure every piece,short way use fort procmacro bastion fort root fn main println running bastion runtime configure every piece use bastion prelude use std sync atomic atomicbool ordering use std sync arc fn main bastion init let started atomicbool new false let started arc new started bastion child child childrenwithexec move ctx bastioncontext let started startedclone async move println started startedswap true ordering seqcst println already started stopping ask system stop bastion stop stop child immediately return ok note err returned child would restarted system nt stopping return none let tryrecv ctxtryrecv await println tryrecvissome tryrecvissome false let answer ctx current ask hello world expect could nt send message msg ctxrecv await msg static str println r msg hello world msg hello world true let answer goodbye wo nt happen example asks static str msg answerawait msg static str println r msg goodbye msg goodbye true wo nt happen example answer static str panicking restart child group panic oh expect could nt start new child group bastion start bastion blockuntilstopped read documentation take look example get involved project
69,Lobsters,erlang,Erlang development,"Cowboy: Small, fast, modern HTTP server for Erlang/OTP",https://github.com/ninenines/cowboy,cowboy small fast modern http server erlangotp,join github today sign file permalink cowboy goal complete small low latency low memory usage binary string routing embedded clean well tested offline documentation topic resource license reload reload,small fast modern http server erlangotp dismiss join github today github home million developer working together host review code manage project build software together sign file permalink failed load latest commit information type name latest commit message commit time cowboy cowboy small fast modern http server erlangotp goal cowboy aim provide complete http stack small code base optimized low latency low memory usage part us binary string cowboy provides routing capability selectively dispatching request handler written erlang us ranch managing connection cowboy easily embedded application cowboy clean well tested erlang code offline documentation still online run make doc user guide available doc pdf html format function reference man page available run make installdocs install man page system full documentation asciidoc available docsrc example available example small fast modern http server erlangotp topic resource license perform action time signed another tab window reload refresh session signed another tab window reload refresh session
70,Lobsters,erlang,Erlang development,Adopting Erlang: Dependencies,https://adoptingerlang.org/docs/development/dependencies/,adopting erlang dependency,cean escript using open source library expectation hook plugins dynamic configuration warning override plugins custom resource type parse transforms declaring dependency custom resource definition servicediscovery otp high level building project dependency make lib app handler dependency lifecycles mirror checkout dependency using elixir dependency official elixir website setup rebarmix corporate environment proxy support private hex mirror minirepo project page tweak global config monorepos,large shift people approached programming last year whereas material yesterday focused lot writing reusable extendable component within project current trend make small isolated project individually end easy throw away replace current microservice implementation javascript dependency tree may lead u believe project small discardableironically shift towards strong isolation clearlydefined interface network apis necessary small singlepurpose component given rise possibly greatest amount code reuse ever seen reuse materialized shared need across various people project mythical ability providing perfectly extendable class hierarchy much reuse today reached point folk starting ask maybe maybe reusing code library come risk liability exposing lot sake moving fasterlang part always lived breathed strong isolation clearly defined messagepassing protocol wrapped functional interface small community size generally experienced developer probably made lag behind community come library packaging despite prior effort package manager like cean processone faxien installed otp application globally really became easy install library people made possible first version rebar favored perproject dependency installation first come escript portable script required installation developererlang library proliferated github similar hosted version control service haphazardly point became possible find twelve different version postgresql driver name similar version thing differentlyit took decent push back elixir bringing newer perspective tool mix hexpm erlang community collect get understandable ecosystem modern day erlang community still small adopted better practice share package library infrastructure elixir half dozen smaller language virtual machinein chapter see modern library usage community integration done within erlang world answering question like library use one dependency dependency lifecycle use elixir dependency work us monorepo using open source librarieserlang open source dependency otp application like every library release required use open source library otp application visible erlang toolchain conceptually simple every language community take slightly different approach choice make installing library globally computer within shared environment locally within project norm regarding versioning publishing also must adhered section show done first take detour expectation regarding project expectationssome tricky decision around open source work enshrined often easier go flow fight especially first starting initially built midsize corporation writing service semiprivate mode opensource dependency used published code remain private forever multiple unrelated service developed time necessarily erlang version library program deployed rolling restarts usual everywhere cloud system absolutely require hot code loading also developed time versioning practice downright messy community many library different version app file git tag github documentation yet mentioned another version back roughly library hexpm even reached version eitheras following property declarative build tool provide configuration executes code satisfy configuration want run custom script extend build specifically provides hook plugins interface also way gain dynamic configuration flexibly populate config filesas part declarative approach command defined dependency sequence example compile task relies getdeps rather private form lock dependency run command tar implicitly call sequence includes getdeps compile release tar therefore know compile project dependency defines working area within build directory expects control go track directory source control rely internal structure creates artifact user want use directly output path artifact terminal example escriptize print path generated escript builddefaultbin run ct print path common test html output test fail tar print path release tarballall project built locally within directory based erlang runtime currently loaded environment ie erl found pathall dependency fetched project build directoryall dependency define dependency recognize fetch root project build directory wellsince version number unreliable even semantic versioning consider version information human build tool case library end declared multiple time one closest project root chosen warning emitted first build know first lock dependency let user know version used assumption library declared closer root project used thoroughlycircular dependency support composable perproject profile let segment combine configuration setting dependency used test specific environment say specific target o restriction number name profile four profile default test doc prod used automatically specific tasksbuilds meant repeatable dependency locked upgraded specifically asked version rebarlock take precedence whatever version declared rebarconfig upgrade called update lock filedependencies always built prod profile applied always check match lock file build artifact present detect code change done hand within assumes sometimes need tweak configuration library control support override purposethe tool assumes developing source control mechanism git hg mercurial mean switching branch may switch dependency version lock file since verifies dependency build automatically refetch library get locked version current branch change switching branchesto ease contribution publishing natively support way use relative path declare library since could make build brittle nonrepeatable nonportable publishing codeknowing relative path common making change within dependency project checkout allow automatic way temporary override dependency local copy use case plugins allow creation custom resource installer runner enduser application support anything related aim generate build artifact install correct dedicated channel expect need ever production device sandbox make sure dependency download match right signature provides repeatable build guarantee script file invoked build parse transforms run compilation ever going safe intention taking responsibility plugins also locked automatically library author pin version case impact compilationthat lot information find useful know getting deep dependency operate assumption work like javascript npm elixir mix go toolchain even original rebar might find behaviour confusing said let use dependenciesdeclaring dependenciessince dependency projectlocal declared rebarconfig file project let know need fetch build make available project dependency must individual otp application versioned handled independently otherthe following format valid deps git dependency appname git http hosttldpathtoapp tag appname git http hosttldpathtoapp branch master appname git http hosttldpathtoapp ref similar format mercurial deps appname hg http hosttldpathtoapp reftype ref hex package appname latest known version per update appname appname latest version appname pkg pkgname application appname published package name pkgname additionally plugins allow define custom resource definition let add new type dependency projectslet see would work project created specifically book servicediscovery open rebarconfig file see deps erldns git http githubcomtsloughtererldnsgit branch revamp dns git http githubcomtsloughterdnserlanggit branch hexdeps recon eql jsx uuid pkg uuiderl elli grpcbox pgo git http githubcomtsloughterpgogit branch master git hex dependency work together project exception hex package depend hex package let compile whole project step going compile fetching covertool downloaded package caching compiling covertool verifying dependency fetching dns git http githubcomtsloughterdnserlanggit ref fetching downloaded package caching compiling fetching elli fetching version cached date reusing compiling quickrand compiling uuid compiling recon compiling servicediscoverystorage compiling servicediscovery compiling servicediscoveryhttp compiling servicediscoverygrpc compiling servicediscoverypostgresrunning build see multiple thing going plugins covertool fetched compiled anything else go onactual dependency project dns elli fetcheddependencies compiled quickrand others main application compiledif try run thing scratch deleting rebarlock file thing would bit different might see something looking like part output fetching dns git http githubcomtsloughterdnserlanggit branch hexdeps skipping dns git git githubcomdnsimplednserlanggit ref app name already fetched skipping jsx app name already fetched skipping recon app name already fetched little notice warning happen dependency resolution necessary rebarlock file available inform library maintainer conflict detected certain version library skipped finish audit build inspect final dependency resolving calling tree tree verifying dependency project app project app project app project app project app git repo hex package hex package hex package git repo hex package hex package hex package hex package hex package hex package hex package hex package hex package hex package hex package hex package hex package git repo hex package git repo hex package hex package hex package listing start verifying dependency line validating dependency resolved printing tree following toplevel application write repository dependency fetched see entire resolution tree way find version fetched application brought prove useful understand version selected transitive dependency included two applicationsif take look within builddefaultlib see application within directory l builddefaultlib acceptorpool gproc backoff grpcbox servicediscovery hpack servicediscoverygrpc chatterbox servicediscoveryhttp counter jsx servicediscoverypostgres ctx opencensus servicediscoverystorage dns pgo telemetry elli pgtypes uuid eql quickrand wts erldns reconeach otp application similar directory structure layout rather similar project structure described release otp high level still staging areabuilding project dependenciesbuilding otp application project requires fetching dependency compiling mentioned make lib app erlang runtime system expects find runtime definition dependency within app file putting tell buildtime dependency runtime one mean included task environment release ignore dialyzer avoid including analysis exampleopen appsservicediscoverysrcservicediscoveryappsrc look value application tuple application servicediscovery description core functionality service discovery service vsn git short registered mod servicediscoveryapp application kernel stdlib erldns servicediscoverystorage env module license apache link see erldns servicediscoverystorage added specifying dependency ensures available runtime release putting result broken buildsif ever worked build tool erlang ecosystem likely never tool erlangmk mix elixir end copying dependency project configuration application tuple sound like huge hindrance hand instead end following otp standard support buildtime dependency tool reach similar result additional option within configuration file let see scenario approach give critical bit controlthe first case important downloading dependency want include release help debug none otp application depend example include recon redbug custom logger handler would want application available release since application tuple let release know order application must booted started necessarily want part dependency chain debugging tool installed case running website work necessary want malfunctioning debug tool prevent actual application bootingin case want project configuration look like part servicediscovery relx release servicediscovery git long servicediscoverypostgres servicediscovery servicediscoveryhttp servicediscoverygrpc recon see along application recon debugging tool explicitly included release list application transitive dependency included according application tuple app file various otp application handled disjoint mannerlet focus servicediscovery application bit represent second type situation want split declaration dependency build rebarconfig declaration dependency runtime appsrc filesyou see toplevel dependency library declared single rebarconfig file make easy developer handle update version required however go look appsrc file servicediscovery servicediscoveryhttp find servicediscoveryappsrc application kernel stdlib erldns servicediscoverystorage servicediscoveryhttpappsrc application kernel stdlib servicediscovery jsx elli servicediscoveryhttp depends web server elli servicediscovery allows cleaner boot shutdown scenario actually need http server running actually start booting backend systemfor third scenario might also imagine small app servicediscoverymgmt used generate escript let system administration task interact system send command aroundif runtime dependency shared across application depending rebarconfig file even servicediscoverymgmt included release script side dependency would still risk pushed production apps getting automatically inserted possibly worse dependency servicediscovery release would risk bundled script well could end small admin tool contains web server database driver build tool tried nicethe maintainer therefore decided keep clear distinction application need fetching project build run rebarconfig runtime dependency otp application app file may part default otp install would therefore included rebarconfig build tool ecosystem let achieve similar result default including everything runtime whereas asks developer always specific intentwith place groom clean set dependenciesdependency lifecycleswhen come initianalizing project dependency resolution fetching heaviest work done result stored lock file result handled shorter partial change done first phase important understand even need rather infrequentlythe lock file created root project directory called saved rebarlock track source control choice open file look content need ever edit hand find mostly contains version number application name various hash might interesting audit time time end indirectly maintain dependency treethe lock file represents flattened tree dependency desired time build modified unless ask changed unless delete forcing new resolution done scratch strictness purpose part guarantee repeatable build circumstancesthe hash file mean even dependency fetched multiple layered mirror malevolent person alters package one various hex index git source might use able find information expected error ityou therefore update lock file required using following operation unlock appname remove unused dependency lockfile usually want call already removed rebarconfig file tell really gone downgraded transitive upgrade appname tell disregard locked version application rebuild dependency tree version currently specified rebarconfig generate new lock file reresolve transitive dependency might update strictly lock file update local snapshot remote hex package kind cache prevents build pinging package server find calling upgrade app upgrading latest version know available hex want update first limit use network trying resolve dependency local index cache update fetch latest index entry package already index another run upgrade see latest version note specify exact version upgrade automatically fetch updated index unable satisfy dependency tree print dependency tree built represented lock deps list dependency annotate could updated note strong limitation considers worth updating branch git tag whose reference shifted hex version specified specified package version available tell anythingthere command bit drastic namely unlock upgrade without argument get rid lock file next build project overall command everything need manage dependenciesin general workflow might look like set initial project compile track lock file source controlfind toplevel dependency want changechange dependency definition rebarconfig file optionally using nonversioned hex package call update call upgrade app update application transitive dependenciesand donecheckout want make developer life easier also staying safe repeatable checkout feature go repeatability concept lock file provides quick feedback better experience around local change dependenciesif adopting erlang whether fun work chance project dependency live separate repository working hard sooner later start patching dependency working corporate environment dozen dozen repository working might become frustratingthe problem would every time want try modification dependency commit publish change somewhere fetch build change made source file build already corresponding beam file module become annoying really fast work across repository boundary want test changeso little trickshot feature called checkout dependency checkout dependency work follows main project somewhere file systemthe dependency declared rebarconfig file main projectyou also dependency somewhere file system standalone projectyou add checkout directory main projectyou either copy symlink dependency directory checkout directoryfrom point every time main app built add ebin directory dependency directory checkout recompile toplevel application within main projectyou test change dependency within main project ready done remove ebin directory dependency commit publish code dependency remove checkout directory upgrade itthis let lot small iterative change locally dependency within context main project without push dependency change changing configuration file point dependency local directory massively reduces overhead perapplication repository overall development strategyusing elixir dependenciesfor many year elixir erlang road one way street could include erlang dependency elixir project opposite true since thanks support erlang ecosystem foundation change made give brand new compiler management structure structure made possible write compiler plugins let erlang user use elixir codethe way first install elixir might want follow step official elixir website elixir developer use asdf tool manage version described setup kerl option erlang used erlang plugin asdf give complete setupwith elixir place add rebarmix plugin library project plugins rebarmix providerhooks post compile mix consolidateprotocols relx overlay copy basedir consolidated release releaseversion consolidated following line vmargssrc file one pa release relvsn consolidatedfrom point able install hex dependency containing elixir code without problem plugin support hex dependency also rely hex dependency support transitive dependency using git coming soon howeverdo note mixed project using erlang elixir within library currently supported since work elixir side would need done make possible hand mix support pattern need itcorporate environmentscorporate environment tend kind weird restriction regarding done development tool idiosyncratic mostly developed fit opensourced world mainly focus enforcing project structure fetching dependency using together great pretext wrap bunch standard toolsas perhaps unsurprising fitting corporate environment tool prove bit challenging section cover standard tool common corporate environment may make life easier adopting erlangproxy supportmany workplace enforce strict firewall rule point incoming outgoing data must intercepted monitored generally place totally isolated public internet require use proxy server make outgoing connectionsit rather standard program respect httpproxy httpsproxy environment variable set development environment make sure communication make talking outside world us proxiesthis let properly work line department policy case even enoughprivate hex mirrorssome corporation go step segment internal network public internet data come site inspected hosted independently without chance talk common code repository like github gitlab hex another interesting case build server might want prevent connectivity outside world safety repeatability reasonsfor setup two approach tend used vendoring monorepo covered next section privately hosted package index cover herethe idea behind privately hosted index package dependency used project need fully vetted might want give technical review code quality security assessment corporate lawyer look code licensing patent issue package right version used kind index frequently accepted hermetic build assumption either run locally build server within private network tightly monitored build support use case want enable need first set private hex instance done minirepo project following instruction project page end running private hex server either local filesystem storage ability mirror index publish package privatelyyou need tweak global config make use done good goabout monoreposif work corporate environment monorepo private library otp application dependency treated equal footing umbrella release best tool job mostly come fact company using monorepo lot custom tooling custom workflow large codebases strong propension never share access maintainer becomes possible maintainer get access little possible frontvarious commercial user rely despite using monorepos reported obtaining successful build combination using checkout dependency along reconfiguring build directory however recommend approach time official support provided monoreposanother option vendor dependency done plugins place set manage lifecycle project dependency
71,Lobsters,erlang,Erlang development,Adopting Erlang: Docker images best practices,https://adoptingerlang.org/docs/production/docker/,adopting erlang docker image best practice,docker servicediscovery buildx building image offical erlang docker image alpine debian private dependency hex organization package hex dependency git dependency email protected moby documentation efficient caching basic instruction ordering experimental mount syntax dockerfile frontend experimental syntax local v remote cache buildx multistage build dockerfile systools running container building publishing image ci running container running container next chapter email protected job control mode jcl mode documentation volume tmpfs building publishing image ci circleci testing circleci google cloud build kaniko using kaniko cache next step,docker helped popularize linux container ease use registry prebuilt image became word often used interchangably linux container docker image contain multiple layer merged runtime make filesystem container docker creates layer running command found dockerfile command creates new layer layer shared image saving space used cache speeding building image additional space saved compared option like virtual machine vm including linux kernel image size image little larger size packaged erlang release deployingthe small size ability run like regular linux process new kernel booted make quicker start time le resource consumption using traditional vm isolation little overhead mean advantage isolation packaging running program standard practice instead burden would run vm per programadvantages container running filesystem network isolation perform operation common program isolated preinstalling shared librariesupdating configurationfinding open portfinding unique name node namenoteyou might notice using latest tag using docker tag commonly misunderstood misused assigned last image used without specific tag latest created image rarely ever relied unless really nt care version image usedin chapter cover efficiently building image running servicediscovery project well image running test dialyzer update continuous integration pipeline build publish new imagesthe minimum docker version required chapter buildx installed installing buildx done following command export docker build platformlocal git githubcomdockerbuildx mv buildx dockerclipluginsdockerbuildxbuilding imagesoffical erlang docker image published new otp release include come alpine debian flavor image updated new release alpinedebian well tagged image updated new release recommended mirror erlang image used base repository even repository also docker hub copy ensures base image change without developer intervention mirror registry separate docker hub mean dependent availability best practice example follow servicediscovery repository use image dockerpkggithubcomadoptingerlangservicediscovery usgcrioadoptingerlangprivate dependenciesthe first stumbling block many work environment encounter building docker image access private dependency private git repos hex organization package dependency able fetched docker container build often lead people include build dockerignore risk polluting build local artifact possibly reproducable elsewhere dependency could fetched running docker build option copying host ssh credential andor hex apikey build container recommended kept docker layer leaked anywhere push image instead recent docker release later ability mount secret ssh agent connection key secure manner data leak final image command explicitly mounted tosince servicediscovery private dependency look support separately getting started building image servicediscoveryhex keep access key private hex dependency file using experimental dockerfile syntax mounttypesecret config mounted container compile command file mounted separate tmpfs filesystem excluded build cache syntax dockerdockerfile experimental run mounttypesecret idhexconfig compileto mount host hexconfig running docker build simply pas secret matching id src path file docker build secret idhexconfig git dependenciesyou could use secret mount last section mounting ssh key docker added better solution mount type specifically dealing ssh run command need ssh access use mounttypessh syntax dockerdockerfile experimental run apk add nocache opensshclient git mkdir p ssh sshkeyscan githubcom sshknownhosts git config global url email protected insteadof http githubcom workdir src copy rebarconfig rebarlock run mounttypessh compilefirst run command installs necessary dependency ssh git sshkeyscan used download current public key github add knownhosts public key knownhosts mean ssh attempt prompt ask accept host public key next git config setting ensures even rebarconfig git url using http instead use ssh private repos github url replacement changed appropriate locationalong adding previous snippet dockerfiles see later chapter also need add ssh default build command run set dockerbuildkit export docker build ssh default additional information option ssh mount type found moby documentation moby name project make core functionality dockerefficient cachingbasic instruction orderingthe order command dockerfile important build time size image creates command dockerfile creates layer reused future build skip command nothing changed take advantage creating layer containing built dependency project copy rebarconfig rebarlock run compilethe copy command invalidate cache command run compile subsequent command file rebarconfig rebarlock different previously created layer since none project code copied build dependency result layer containing built dependency builddefaultlibafter dependency built cached copy rest project compile copy run compilebecause order operation dockerfile run docker build compiles project source assuming change otherwise existing layer used well command need rerun change project need come either copy command example installing alpine package run apk add git workdir appsrc setting working directoryuse copy discouraged make likely invalidate cache possible better copy file directory needed build dockerignore file filter file needed git directory one size fact change content effect build artifact good ignore however servicediscovery rely git command setting version release application make release project rely feature recommended add git dockerignoreexperimental mount syntaxcopying file image caching layer longer option efficiency building docker image caching built dependency layer well good layer also contains hex package cache creates change rebarconfig rebarlock result package rebuilt also refetched hex additionally instruction copy whole project creating additional layer source wasteful since care build artifactsthese issue resolved docker experimental syntax mounting file context run command enable experimental syntax environment variable dockerbuildkit must set feature buildkit true set etcdockerdaemonjson syntax dockerdockerfile experimental used first line dockerfile syntax dockerdockerfile experimental workdir appsrc env rebarbasedir appbuild build cache dependency layer copy rebarconfig rebarlock run mountidhexcache typecache sharinglocked compile run mounttarget mountidhexcache typecache sharinglocked compilein new set instruction build set workdir appsrc current working directory command follow environment variable rebarbasedir set appbuild base directory output build artifact default directory build root project case without environment variable would appsrcbuildthe copy configuration lock file remains following run changed include mount option type cache tell docker create cache directory separate docker layer stored locally host cache remain run docker build future local run docker build even config lock file changed mount cache newly needed package fetched hexnext unlike previous instruction building rest project instruction copy removed instead mount type bind default used target bind mount opposed cache mount mean docker mount build context container giving u result copy without creating layer copying file making build faster smaller copy command two copy made host build context copy build container run build copy requires copying whole project build context build container againby default mount immutable meaning build error anything written appsrc base directory configured appbuild option mount readwrite mode writes persisted remove optimization around make copy data build context build container read mount option buildkit doc dockerfile frontend experimental syntaxthe end result layer containing appbuild compiled dependency along appsrcrebar add little size layer followed layer containing appbuild compiled project nothing appsrc separately cache hex package downloadedlocal v remote cachethere couple type cache used section relied build done host access cache case hexcache mounted run solely feature local caching exported imported registry however layer built instruction dockerfile imported registryhaving build setup use remote cache particularly useful working continuous integration sort build server unless single node running build end wasting time rebuilding every step dockerfile resolve issue docker build told look layer including image remote registry cachefromthere two version cachefrom newer one still technically part experimental tech preview called buildx cover however since buildx much efficient easier use appears stable within bound feature require default used servicediscovery projectthe old cachefrom multistage aware meaning requires user manually building pushing stage multistage dockerfile individually building stage build earlier stage image referenced cachefrom pulled registrywith buildx cache manifest built include information previous stage multistage build argument cacheto allows cache exported various way use inline option writes cache manifest directly image metadata image pushed registry referenced later build cachefrom unique part new cache manifest layer cache hit downloaded old form entire image previous stage downloaded referenced cachefromcaching security updatesthere security concern keep mind using layer caching example since run command rerun text command change previous layer invalidated cache system package installed remain version even security fix released reason good occasionally run docker nocache reuse layer building imagemultistage buildfor erlang project going need image built release image contain anything required running release tool like erlangotp version used build project git used fetching dependency github etc must go instead removing item build complete multistage dockerfile used copy final release bundle erlang runtime stage built stage alpine base shared library necessary run release opensslwe step stage servicediscovery project dockerfile first stage named builder syntax dockerdockerfile experimental builder workdir appsrc env rebarbasedir appbuild install git fetching nonhex depenencies add alpine library needed compile project see http wikialpinelinuxorgwikilocalapkcache detail local cache need symlink run mounttypecache idapk sharinglocked targetvarcacheapk apk add update git build cache dependency layer copy rebarconfig rebarlock run mountidhexcache typecache compile builder prodcompiled run mounttarget mountidhexcache typecache prod compilethe builder stage start base image builder name stage use base image later stagesold docker cachingfor remote caching using old cachefrom described previous section builder stage would built tagged identifier let u reference image based dependency contains use command cksum rebarconfig rebarlock act similarly docker choosing invalidate cache chksum cat rebarconfig rebarlock cksum awk print docker build target builder servicediscovery builder chksum docker push servicediscovery builder chksum building stage us builder would include cachefromservicediscovery builder chksum pull previously built dependenciesit common developer working concurrent branch project potentially varying dependency using checksum current config lock file defining image use cache allows multiple set dependency project cached correct set used buildingthe next stage named releaser us prodcompiled image base prodcompiled releaser workdir appsrc create directory unpack release run mkdir p optrel tar unpacking target system run mounttypecache idapk sharinglocked targetvarcacheapk apk add update tar build release tarball unpack copied image built next stage run mounttarget mountidhexcache typecache prod tar tar zxvf rebarbasedirprodrel targz c optrelthis stage build tarball release using prod profile profile prod relx devmode false includeerts true includesrc false debuginfo strip profile includeerts set true mean tarball contains erlang runtime run target erlang installed end tarball unpacked optrel stage copy release releaser stage need tar installedwhy tar release might notice tarball release created untarred immediately done instead copying content release directory two reason first ensures explicitly defined version release used le important building docker image since previous release build buildprodrel directory still good second change made release tarring required use tool like releasehandler example boot script renamed relnameboot startboot detail see systools documentationfinally deployable image us regular o image base instead prior stage shared library needed run release installed first unpacked release releaser stage copied optservicediscovery runner workdir optservicediscovery env cookieservicediscovery write file generated startup tmp relxoutfilepathtmp servicediscovery specific env variable act default loggerleveldebug expose expose expose install openssl needed crypto app run mounttypecache idapk sharinglocked targetvarcacheapk ln v varcacheapk etcapkcache apk add update openssl ncurses copy fromreleaser optrel entrypoint optservicediscoverybinservicediscovery cmd foreground env command set useful default environment variable used release run relxoutfilepathtmp used release start script directory output file created script done release run sysconfig vmargs need generated respective src file default placed directory original src file want file written release directory src file best practice container filesystem written image run user writes tmp would run root needed write anywhere optservicediscovery writing tmp allows another best practice followed running container root go even make runtime filesystem readonly see running containeroptservicediscovery owned root recommended run container root relxoutfilepath set location used instead env command used ensure environment variable relxoutfilepath set tmp container run docker buildx build typedocker target runner tag servicediscovery git revparse head using script servicediscovery contains building pushing image circleci script also tag image twice git ref git revparse head done manual command name branch git symbolicref short head branch tag used referencing build manifest cache cachefrom script use image tagged master branch current branch cache available must include cachetotypeinline build commandusing current branch name master image inspect cache hit le exact use checksum rebarconfig rebarlock image containing stage build dependency nothing stopping build still making pushing explicit image tagged checksum using also one cachefrom image least project ease needing juggle additional image since buildkit cache manifest keep track stage outweighs potential cache miss dependency one happen schemelastly difference note script used circleci see building publishing image ci compared l option ci care getting image remote registry time saved loading built image docker daemon building image locally likely want run next section running container loading docker daemon necessaryrunning containernow image docker run used start release local verification testing default cmd foreground passed release start script configured entrypoint optservicediscoverybinservicediscovery cmd overridden last argument passed docker run using console command result interactive shell container run ti option tell docker want interactive shell useful local testing image want shell inspecting running release default set cmd dockerfile runner stage use foreground use ti dropped well command simply docker run servicediscovery exec noshell noinput bd boot mode embedded bootvar ertslibdir optservicediscoverylib config tmpsysconfig argsfile tmpvmargs foreground root optservicediscovery optservicediscoveryto prevent accidental shutdown able stop container ctrlc stop container use docker kill container id note foreground default run production though would background docker run servicediscovery short detach output container id log written stdout viewable docker log container id see next chapter kubernetes log routed log store choice even whenthe running node also attached docker exec container id seen output docker run use docker p find command remoteconsole matter container started console foreground course useful need shell node already start console exec use entrypoint defined image command run must start release start script binservicediscovery docker exec ti binservicediscovery remoteconsole email protected alternatively linux shell could run docker exec ti binsh drop optservicediscovery could connect remoteconsole inspect aspect running containerto exit remote console run q shutdown erlang node docker container use ctrlg enter q ctrlg enters shell called job control mode read shell mode used see job control mode jcl mode documentationin case release boot useful override entrypoint get shell container attempt boot release docker run ti entrypoint binsh servicediscovery optservicediscovery lastly previous section saw relxoutfilepath set tmp file would attempt write release directory remain readonly docker diff command show difference image filesystem current running container filesystem docker container diff c tmp tmpsysconfig tmpvmargsthis useful command easily inspecting release writing disk run problem want verify release something case lot writes disk release best mount volume point writes small configuration file necessary unless creating config file template sensitive data used want run container readonly case tmpfs mount recommended linux simply add tmpfs tmp docker run command tmp part writable layer container separate volume exists memory destroyed container stoppedbeware zombie erlangotp erlang node gracefully shutdown init stop term signal received used docker kubernetes shutting containersbut still potential issue encounter zombie container using docker exec run remoteconsole release script command like ping leave zombie process behind unless container started argument init docker offer starting small init entrypointthis usually issue like atom certainly us nt limited example something avoid reason unless running init tiny init pid would using ping health check run periodically life container container runtime long running container like eventually kernel process table run slot possible create new processesbuilding publishing image cisince would tedious manually build publish image registry release common include image building part continuous integration process usually restricted occur merge master new tag created sometimes useful also build branch image testing purpose section cover couple option automating process whatever ci tool already using capable something similarcircleciin testing chapter coming covered circleci running test build publish docker image servicediscovery new job added named dockerbuildpush us vm instead docker image executor first installs latest docker version time writing version available default support feature used servicediscovery dockerfilejobs dockerbuildandpush executor dockermachine step run name install latest docker command sudo addaptrepository deb http downloaddockercomlinuxubuntu lsbrelease c stable sudo aptget update upgrade latest docker sudo aptget install dockerce docker version install buildx mkdir p dockercliplugins curl http output dockerclipluginsdockerbuildx chmod ax dockerclipluginsdockerbuildx checkout gcpgcrgcrauth run name build push image command cibuildimagesh p runner r gcrioadoptingerlangafter installing latest docker code servicediscovery repository checked since using google cloud registry kubernetes authenticates registry lastly script found ci directory servicediscovery called build publish image script us docker build command discussed earlier chapter build individual stage use cachefrom reference stage cache buildto run job test pas added circleci workflow requires constraint buildtestmaybepublish job dockerbuildandpush requires cloud buildin google released image build tool kaniko run userspace depend daemon feature enable container image building environment like kubernetes cluster kaniko meant run image gcriokanikoprojectexecutor used step google cloud buildkaniko offer remote caching layer created run command build check layer cache image registry match building layer however buildkit feature used servicediscovery dockerfile available kaniko separate dockerfile cidockerfilecb used google cloud build configuration cloudbuildyaml step name gcriokanikoprojectexecutor latest args targetrunner dockerfilecidockerfilecb buildargbaseimage baseimage buildargrunnerimage runnerimage destinationgcrio projectidservicediscovery commitsha cachetrue substitution baseimage gcrio runnerimage gcrio kaniko work checking instruction cache directory registry need instructing use specific image cache like docker cachefrom docker build cache act like kaniko setting export cache metadata registry export layer stage cachetotyperegistry modemax supported registry time written coveredfor detail using kaniko google cloud build see using kaniko cache documentationnext stepsin chapter built image service finished creating ci pipeline continually building publishing image change made repository next chapter cover build deployment kubernetes image running kubernetes following chapter cover observability connecting running node well structured log reporting metric distributed trace
72,Lobsters,erlang,Erlang development,Spawnfest 2019 Submissions,https://github.com/spawnfest?q=2019,spawnfest submission,grow team github sign repository fiqusprexent used topic reload reload,dismiss grow team github github home million developer working together join grow development team manage permission collaborate project sign result repository matching repository commandline spritesheet generator elixir elixir updated sep realtime databaseasaservice reststyle resource location time traveling feature support elixir updated jul javascript updated jul elixir updated sep elixir updated jul idea tech festival available one roof elixir updated jul ejdbc erlang jdbc erlang bridge jdbc api erlang updated sep elixir updated sep tuple space based erlang application fast fourier transforms erlang updated sep erlang updated sep kanban board built using elixir phoenix liveview using liveview hook elixir updated jul erlang updated sep forked fiqusprexent fast live beautiful presentation markdown powered phoenix liveview elixir mit updated sep used topic perform action time signed another tab window reload refresh session signed another tab window reload refresh session
73,Lobsters,erlang,Erlang development,"v0.4.0 of Gleam, the statically typed language for the Erlang VM, is out",https://lpil.uk/blog/gleam-v0.4-released/,gleam statically typed language erlang vm,gleam structs comparison operator second class module rest installation page code beam lite berlin code beam lite berlin thanks,gleam reached version new feature bug fix breaking change let take look structs gleam map tuple type removed replaced structs many benefit like map structs collection named value type unlike map named two structs type field coincidence making gleam type system little stricter default like tuples structs constant access time need linearly scanned order find field access unlike either struct type declared upfront struct keyword pub struct cat name string cuteness int declared newly defined constructor used create instance struct pub fn cat let cat name nubi cuteness let cat cuteness name biffy alternatively field given without label let cat ginny one downside structs le convenient returning one value function tuples struct type need predeclared negate inconvenience standard library declares pair triple type gleampair gleamtriple module wish return value function recommended create struct name value make clear comparison operator next breaking change comparison operator work previously operator would take two value type determine larger according erlang ordering value convenience may result surprising behaviour used custom type enums example order enum would expect gt greater larger lt le according erlang value ordering case enum order gt eq lt version accept ints argument avoid surprising behaviour comparison operator added comparing float ordering type comparison function found standard library ordercompare boolcompare second class module module longer first class value gleam meaning longer assigned variable used argument function first class module inspired ocaml intended way work erlang behaviour genstage within gleam however several month using module gleam became clear taking ocaml first class module functor module system resulted gleam module far le useful first class function combined gleam data structure sufficient use erlang behaviour easier construct compose first class module determined ideal solution either first class module removed longer need special syntax accessing field module operator removed replaced operator making universal operator accessing named field module container data type gleam import gleamlist pub fn main listreverse removal module map gleam type system become simpler le structural nominal style put u good position research new form polymorphism type class trait rest addition feature number improvement quality error message generated code handful bug fix want try new version gleam head installation page love hear find get feedback gleam continue improve code beam lite berlin october speaking code beam lite berlin gleam attending want recommend good thing weekend berlin say hello thanks lastly huge thank code contributor release
74,Lobsters,erlang,Erlang development,Types On The BEAM,https://medium.com/@gordonguthrie/types-on-the-beam-2af8b1cb9be9,type beam,,consider three erlang function addone x x x isnumber x x x isnumber x ok x error number second one trivial runtime assertion code cause crashin third one runtime assertion turned well behaved error messageby hoisting genserver call gleam generating hashed nonce mixture modulefunctionsargument type would possible runtime interprocess call compile erlang look like genserver call pid myterm nonce generated nonce hash effectively pointer type specification matching run time type checkthe compiler would generate remote handling code like handlecall term state reply myreply newstate handlecall nonce term state reply error typeerror got nonce expected handlecall msg n state reply error wtactualf normal sideeffect free type check asserts function invoked correct typesthis new blended type check asserts remote function invoked invoked correct type also something gone wrong calling module correctly handle complete error set bear mind error set calling code handle superset error type example deal tried call timed know crashed available partition compiler need generate code invocation side well normally type signature symmetricthe callee function declares call argument type return value type bthe caller function declares call argument type expect return value type bthis longer case callee function type spec caller type spec extended call argument type expectation write time return value type b may also return one list error type run timewe moved hard guarantee fuzzy partial one think happypath typingdefining language naturalistically blend type interprocess calling contract nontrivial business sharp aesthetic choice make kinda scope interesting trivial craft message call another beam language invokes function incorrect type type system defence byzantine failure untrusted distributed malicious partnerbut wider set failure type let u call brexit failure one party reliable trustworthy party chaotic slapdash arrogant ignorant bloated selfimportant pompous klown kar kavalkade krap normal software development error happypath typing prevent make diagnosis rest simpler cleanermoving error message cause failure error type error returned code fingerprint error handling routine standardised hoisted normal writetime task developer implement reimplement rererereimplement writetime task compiler writer
75,Lobsters,erlang,Erlang development,"Which companies are using Erlang, and why?",https://www.erlang-solutions.com/blog/which-companies-are-using-erlang-and-why-mytopdogstatus.html,company using erlang,company using erlang mytopdogstatus cisco revealed ship million device per year running erlang code beam stockholm ericsson solution problem national health service nh adroll pairing advertiser user millisecond vocalink mastercard company blockchain goldman sachs nintendo programming language language bt mobile formerly tmobile otp middleware motorola study involved rewriting telecommunication system whatsapp whatsapp virtual machine whatsapp million tcpip connection phoenix framework bleacher report launched new mortgage offering super bowl ad still badly kept secret form monitor erlang elixir rabbitmq system get free trial wombatoam page mytopdogstatus blog company using elixir check included blog form hear first find conference near go back blog,company using erlang mytopdogstatus francesco cesarini upon time cisco ericsson klarna goldman sachs tmobile whatsapp amazon many top company kept secret erlang badly kept secret many heard realise control vast amount infrastructure including fixed mobile network use daily basis monumental cisco revealed ship million device per year running erlang code beam stockholm conference translates internet traffic going router switch controlled erlang heard ericsson erlang core gprs infrastructure market share high probability program written erlang assigned ip address smartphone using today amongst thing since released open source erlang spreading beyond telecom establishing vertical fintech gaming healthcare automotive iot blockchain technology created switch phone call make way vertical care consider using serverside development erlang elixir top dog tech stack time let people company know beam technology kicking first blog part mytopdogstatus series showcase success story follow elixir focus next bigger picture technology solution problem one first thing try find meet programming language inventor problem trying solve creating language range answer fascinating often reveals fit purpose ask coinventors erlang get unanimous response trying understand better build next generation telecom system system back late scalable faulttolerant predictable maintainable never set intention inventing programming language solution problem happened programming language successfully created solve problem one keep eye without doubt right tool job answer language invented experimenting esoteric computer science concept listen learn beware time erlang conception telecom system system scalable handle peak load predictably never fail internet changed erlang released open source telecom grade resilience scale gave way webscale turn gave way mobile application connected device inception gave way iot transition possible seamless switching phone call sm publishsubscribe instant mobile message credit card transaction money stock medical record online gaming command sequence blockchain propagation telemetry data business logic still whilst might ok lose odd sm message device offline hour transmit data absolutely cool lose financial transaction involves money stock cryptocurrencies basically change system tradeoff scalability reliability consistency data item programming language agnostic taken care business logic system everything else remains better example erlang reliability english national health service nh nh obviously requires high availability handle million record request every day spine centralised point allowing exchange information across national local system using riak written erlang nh managed availability five year health advertising industry adroll receives average realtime bid request per second spike many time substantial financial value attached use erlangotp manage realtime bidding platform amazon platform pairing advertiser user millisecond many country rely erlang immediate payment switch allowing instant bank transfer bill payment service vocalink mastercard company shipping financial switch implemented erlang far alone area erlang used anger includes private public blockchain payment credit card gateway banking apis traditional infrastructure management scratch surface find erlang team major bank financial institution using using rabbitmq couchdb riakkv one open source erlang application investment banking giant goldman sachs use erlang part hedge fund trading platform goldman sachs platform low latency microsecond eventdriven market data processing strategy order submission engine erlang used help deliver realtime change response market condition massively multiuser online gaming nintendo switch sold million console system us erlang based messaging system handle million concurrent connection popular gaming company riot game use erlang league legend million concurrent player time erlang messaging system allowing chat simultaneously without interruption even one world used online dating apps used erlang grindr used erlang stack manage million daily active user handle message per second moving beam helped maintain reliable system minimal number outage programming language programming language matter good limited use combine powerful optimised runtime middleware abstract scalability reliability system developer get foundation powerful ecosystem erlang ecosystem programming language family programming language virtual machine powerful operating system set middleware library abstract many recurring tricky problem deal working scale resilience language let focus language talk erlang programming language mean language semantics language semantics includes aspect taken functional logic concurrent programming providing higher level abstraction resulting le code expressive easier maintain ultimately reduces cost business language semantics put concurrency model core making process main building block process provide natural way reason around problem facilitating implementation system lot thing happening time best described joe armstrong tenet world concurrent thing world share data thing communicate message thing fail picture model applied u human human concurrent entity share brain speak asynchronous message sometimes top human receiving message process store copy whatever believe relevant sometimes human fail one around continue assigned task whilst new human created human failed repaired model world programming language simple bt mobile formerly tmobile uk us approach many core system one thirdparty gateway system written handle machine human sm includes alert service traffic financial weather alert tv voting competition reminder million message sent received day many spike traffic tv vote special promotion sm sent received process developer need reason around sending receiving single sm scale handled creation new process online betting another industry extreme spike load manage busy day betting agency like black friday amazon price change every second many online betting company including use erlang manage thousand concurrent user sometimes hear complaint erlang way thinking requires serious mind shift problem mindshift unlearning unnatural model programming language taught u going back basic using joe tenents understood understanding erlang easy otp middleware otp set framework principle pattern guide support structure design implementation deployment erlang system innovation otp language copying abstract principle used describe software architecture process given design pattern server finite state machine event handler supervisor packaged reusable library library builtin support debugging software upgrade generic error handling also abstract take care tricky edge case occur concurrent programming providing solid tried approach problemsolving make code easier understand maintain reduces maintenance cost stop developer reinventing square wheel motorola funded study involved rewriting telecommunication system used emergency service c erlang focusing productivity gain depending calculated code reduction erlang system achieved result time le code time reduction assumed otp library part erlang standard library c generic otp original project implement good part seems norm project dealing concurrency scale norm also implementation often bugridden development first otp release started alongside ericsson major project including broadband solution foray packetbased switching one first project use otp switch atm switch allowed generic network also used telephony telecom provider around world including bt network stopped routing call dedicated network instead started routing common backbone longdistance call made uk routed using erlang switch productivity gain time le code best visible whatsapp got acquired facebook million active user active daily basis traffic record time december hour sent billion message twice number estimated sm sent day engineering team consisted people ten worked serverside serverside team developed new feature maintained existing one supported whole system basically also one got woken middle night something went wrong whatsapp acquisition highlighted erlang enhances programmer productivity scalability modest hardware footprint low maintenance cost system entail small team able develop support maintain scale system hundred million user today scaled billion using otp help developer avoid accidental complexity thing difficult picked inadequate tool know always enhances productivity reduces maintenance cost problem remain difficult irrespective programming tool middleware difficulty one focus virtual machine erlang us virtual machine vm executing code approach similar nodejs java ruby program compiled lowlevel instruction called byte code beam commonly used erlang vm executes byte code seen operating system running container virtual instance another operating system directly bare metal beam last two decade optimised heavy load rendered predictable type problem erlang good solving capable concurrently handling million process ensuring process display soft realtime property fairly treated throughput remains constant irrespective load system handle request per second take second per request served simultaneously number request increase throughput remain latency increase second important request served degradation throughput even spike happen many virtual machine increase request often lead degradation service possibly grinding halt beam built scale process share memory memory management done perprocess basis scheduler allow process execute predefined number instruction suspending ensuring fair execution process completed task scheduled continue executing process go result constant execution time request unlike java virtual machine garbage collecting affect request going system particular point time nodejs request execute completion blocking request thread done rubyvm decade engineering resource put result scale virtual machine around property beam making unique capability predictably handle massively concurrent spike traffic fastest vm stable predictable one advantage using beam apply practice imagine vm handling million tcpip connection managed process serving customer load share cpu allocation process fair constant equates predictable userexperience million user served single instance programmer worry developing code handle single user process vm automatically scale million request fails corrupt data bug software request continue executing independently isolating failure whatsapp achieved million tcpip connection managed process single beam instance back using connection serve message notification whilst minimising hardware footprint turn greatly reduced infrastructure cost size team needed maintain similar number achieved using elixir phoenix framework messaging vertical scalability single node move web bleacher report news app website focusing sport similar impact operational infrastructure cost changing virtual machine migrated ruby beam able reduce hardware requirement server quicken loan launched new mortgage offering super bowl ad knowing confidence server would handle traffic ease fact trouble load testing traditional tool end needed fall back using erlang load test erlang copy otp library run beam emulate semantics using otp ported net jvm work hand many language ported beam vm making full use otp elixir popular let forget luerl lisp flavoured erlang efene least dozen still badly kept secret blog post scratching surface many company using erlang power serverside infrastructure reduce development cost whilst ensuring system scale resilient resilient endusers often focusing glitzy app website even know time looked erlang well part pack already using erlang would like share story fill form monitor erlang elixir rabbitmq system currently using erlang elixir rabbitmq stack get full visibility system wombatoam find get free trial wombatoam page mytopdogstatus video want see mytopdogstatus campaign check blog company using elixir head hub video news team erlang elixir news check included blog part pack already using erlang would like share story fill form hear first many story shared first code sync conference find conference near hear latest erlang success story directly team involved go back blog
76,Lobsters,erlang,Erlang development,Stacking Theory for Systems Design,https://medium.com/@jlouis666/stacking-theory-for-systems-design-2450e6300689,stacking theory system design,stacking theory system design mode operation stopping development production cloud stacked design one level,stacking theory system designin recent year adopted method system design think yield good result lack better word overloaded stack yet use metaphor designas everything else silver bullet design equally good tradeoff come erlang background course design going influenced design think method widely applicable however could easily use preferred programming language order make thing clear first little bit erlang terminology topdown perspective erlang release comprises erlang runtime system containing interpreter garbage collector builtin part standard library need code module release completely selfcontained requires outside library order able run essentially almost dockercontainer inside erlang release application either standard system kernel stdlib crypto application building release release manager figure dependency among application wish run make sure include themeach application consists process process sits somewhere supervision tree process erlang terminology point concurrent execution operate independently communicates via message passing one physical core execute parallel systemthe code process run resides module single process run code many module module run many process module roughly static component insofar exist time programmer writes included application process dynamic sense exists runtime executing code modulesin erlang system process also defines boundary isolation state process scrutinized outside process way interact process send message wait replymodes operationwhen boot erlang system go several mode operation first runtime executed start booting initsequence sequence initialization begin loading module system avoids accidentally missing module later ononce every module loaded go configure application start configuration level usually stop system anything wrong configuration error human error aborting often better trying cope mistake configurationat point system operationalhowever tend call baseline system nothing wrong system rather claim operational like cut operational behavior stack baseline level stack try move system upwards stack adding another level important stress transitioning best effort method make attempt increasing operational level system stay put current levelwe could instance introduce database connection pool system level start pool spawn proxyprocesses connection worker try connect level guarantee baseline system running able carry service client connection database transition level periodically try connect connection proceed higher operational level get database connection log fact might raise alarm system order tell devops something amissthe key made level assume connectivity database system would far le flexible suddenly experience intermittent transient network error level baseline must terminate system whole stacking service go back level start besteffort transition level structure ratchetmechanism erlang system higher level continue operating error lead faulttolerance handling acting upon system move operating level resetting restarting affected process continues operation lower levelnote safe state database connectivity stable state try establishing one error occurs internal state single database connection complex model trying recover state insanely complicated terminate connection reset known good state connected system level transition level level may connect message queue broker thing applies database connection make besteffort getting error reset u level database connection need broker connectionand level try go level enable cowboy web server listen port point assume level system underlying part must operational hence give service outside world introduce loadbalancer callback service tell loadbalancer able give service point entered service pool loadbalancer system operates nominallyan error level single process give rise total system failure reset many error transient intermittent erlang fault tolerance principle defines policy threshold deem operation level failure due many error short timespan solution course gradually try resetting web server internals fault removed worst case reset lower operating level stackstoppingonce leveled stack operation stopping service becomes easy stop going level first remove listen socket request enter system drain request currently operating level move level point terminate systema common mistake botch closedown procedure system test usually load system try terminate loaded often see crashing burning closedown phase request currently running fails nonstandard way problem modern world use elastic computing machine added removed time automatically load requires happening situation load balancer coerced participate closedown procedure help since drain connection always casedevelopment productionanother test say start system development environment connectivity system need database central logging metric broker system fails boot due network connectivity problem chance fail boot production system assuming presence system unwritten dependency chain boot production system certain order thing work often bound troublefurthermore suppose decide move database another address one advantage stacked design often add another database pool system without yet allows deploy system first await presence new database cluster system pick automatically start using building system least one system able handle transition infrastructure build system far easier manage often use trick add new restful endpoint deploy production start using avoids u coordinate client launch approval committee apple might prove problem extending trick infrastructure nice support version protocol time decide move one put onus later decisionmakerin development stacked design also nice may need start centralized logger og metric gatherer developing system need test something metric logging simple invocation netcat nc tool suffices help production lost metric server coordinate main service take wellthe cloudcloud environment notoriously flaky weekly disconnect among service small disruption common need build system tolerate small amount noise stacked design excellent tolerating noise instance lost single database connection pool pick another try replenishing lost connection lost back level advantage tolerating small amount noise often tolerate larger amount connection error rate suddenly rise system cope picked absolute path everything entirely correct time made reboot failure thousand time likely hurt serviceuse alarm handler erlang one built set clear alarm connection outside world say second raise alarm turn system going tell world problem rather poor devops person figure wrong system saying broken connection database thus give service far better one rolling around rebootrestart loop timestacked design one level upfinally stacked design stop servicesystem use one level architecture well far better deploy machine starting empty machine configuring installing software starting contrast mutation existing machine rebuilding environment essentially build whole data center scratch every time make sure safe even system get hosedwhen error occur find core dump erlang crashdump file log file ship elsewhere wipe machine build new one take allows postmortem analysis error keeping system operational postmortem analysis paramount want stable system need distinguish error benign due rare event chain error need programmer fix done analyzing error occur note benign error system must never fixed fixing certain error requires much change code base change pose greater risk benign error unless find elegant approach problem fix themalso make ordering assumption architecture u operate environment error occur break ordering assumption running build system cope stacked design long always one stack increase level system eventually untilt especially important microservice architecture dependency tend complex nobody actually tested possible interactionsfinally stacked design cover bad system design long system cope failure often saving grace architecture deploying system able cope trouble avoid total failure nygard circuit breaker pattern come handy software
77,Lobsters,erlang,Erlang development,lumen/lumen - Compile Erlang/Elixir Applications to WebAssembly,https://github.com/lumen/lumen,lumenlumen compile erlangelixir application webassembly,lumen new compiler runtime beam language contributing tool first need install rustup wasmpack repository llvm ninja ccache note building lumen note project structure lumen frontend diagnostics library moved compiler mlir interpreter runtime making change lumen goal nongoals architecture compiler internally compiler represents erlangelixir code form similar continuationpassing style continuation powerful construct enable straightforward implementation nonlocal returnsexceptions green threading optimization primarily performed representation prior lowering llvm ir see eirprojecteir runtime nifs license,lumen new compiler runtime beam language machine vendor operating system host subgroup status unknown unknown macos na unknown unknown linux na apple darwin macos compiler apple darwin macos library apple darwin macos runtime full unknown linuxgnu linux library unknown linuxgnu linux runtime full contributing order build lumen make change need following installed tool first need install rustup follow instruction link installed rustup need install nightly version rust currently ci build nightly require nightly due large number nightly feature use well dependency webassembly target make use use latest nightly rustup default nightly case issue install nightly match ci rustup default may also want install following tool editor support rustfmt required pull request rustup component add rls rustfmt clippy next need install target toolchain rustup target add toolchain name nightly chose previous step also need install wasmbindgen commandline tool cargo install wasmbindgencli set nightly toolchain default need instead cargo nightly install wasmbindgencli finally need wasmpack needed build example get running follow installation instruction wasmpack repository llvm llvm modification used lumen code generation backend needed build compiler typically need build instruction also provide prebuilt distribution everything needed installing prebuilt distribution recommended linux instruction reference xdgdatahome environment variable recommended export xdg variable general replace usage xdgdatahome homelocalshare usual default xdg variable mkdir p xdgdatahomellvmlumen cd xdgdatahomellvmlumen http tar xz stripcomponents f rm cd macos mkdir p xdgdatahomellvm cd xdgdatahomellvmlumen wget http tar xzf rm mv lumen cd nt yet provide prebuilt package operating system need build source following direction building source llvm requires cmake cc compiler python highly recommended also install ninja ccache make build significantly faster especially subsequent rebuilds find dependency system package manager including homebrew macos build le fully automated three simple step git clone http githubcomlumenllvmproject cd llvmproject make llvm install llvm xdgdatahomellvmlumen homelocalsharellvmlumen xdgdatahome set assumes ninja ccache installed customize llvm target makefile use make instead removing g ninja invocation cmake likewise change setting use ccache removing option well note building llvm first time take long time grab coffee smoke em got em etc building lumen llvm installedbuilt build lumen executable make build create compiler executable associated toolchain host machine bin root project invoke lumen via symlink binlumen eg binlumen help compile erlang file executable currently binlumen compile outputdir build lc pathtosourceerl produce executable name source file current working directory exe extension depending platform note compilerruntime still experimental stage stability guaranteed may need provide additional compiler flag linker warns missing symbol eg lpthread project structure lumen currently divided major component compiler interpreter runtime lumen frontend diagnostics library moved eir project includes erlang parser highlevel intermediate representation eir short erlang intermediate representation lumen depends eir library component compiler lumen compiler composed following sublibrariescomponents liblumentarget contains target platform metadata configuration liblumensession contains state configuration single instantiation compiler session find bulk option processing inputoutput generation related item liblumenincremental contains core incremental compilation engine based salsa query inputsparsing defined liblumencompiler contains core compiler driver well higher level query generating artifact parsed source liblumencodegen contains code generation backend divided two primary phase first handle translation eir dialect mlir case llvm ir directly translation mostly aim preserve level abstraction found eir preparing conversion llvm ir second phase conversion mlir dialect llvm bulk codegen work occurs liblumenterm contains essential part term encoding scheme shared runtime library compiler requires order handle encoding constant term compilation interpreter interpreter alternative way test execute erlang code build top eir similar compiler work albeit significant difference due nature interpreting eir rather translating code generation runtime runtime broken multiple library liblumencore contains essential apis interacting system performing allocation well various common type used throughout lumen liblumenalloc contains bulk erlang runtime system core data type apis liblumencrt act core runtime entry point executables handle bootstrapping runtime system linked compilergenerated executables lumenrtcore wip core runtime library used across targetspecific runtimes lumenrtminimal wip experimental runtime library built top lumenrtcore designed platform currently used runtime executables generated compiler lumenweb original webassembly runtime build lumenrtfull lumenrtfull original runtime library target slowly broken smaller piece either merged lumenrtcore new targetspecific runtime crate currently used interpreter contains bif function implemented far collection library correspond ert beam virtual machine making change making major change please open issue tagged rfc problem need solve proposed solution outstanding question term implementation core team use issue talk change either green light proposal request change case proposal may request change either incompatible project goal impose high maintenance complexity burden turned importance rfc discussion first prevents someone bunch work ultimately upstreamed allows core team community provide feedback may make work simpler better end smaller changesbug fix feel free open issue first new project want guidance working fix otherwise acceptable open pr directly fix let review happen always feel free open issue bug even perceived issue question useful resource others please make sure use search function avoid duplication plan participate discussion contribute project aware project tolerate abuse kind member community feel someone abusive inappropriate please contact one core team member directly u want foster environment people new experienced feel welcomed question answered hopefully work together make project better lumen lumen compiler runtime well consists two part compiler erlang native code given target arm webassembly erlang runtime implemented rust provides core functionality needed implement otp primary motivator lumen development ability compile elixir application could target webassembly enabling use elixir language frontend development also possible use lumen target platform well producing selfcontained executables platform lumen different beam following way aheadoftime compiler rather virtual machine operates bytecode additional restriction allow powerful optimization take place particular hot code reloading supported runtime library provided lumen written rust similar differs mostly transparent way one goal provide better foundation learning runtime implemented take advantage rust powerful static analysis catch bug early support targeting webassembly well target result compiling beam application via lumen static executable differs significantly deployment beam work today ie via otp release sacrifice ability perform hot upgradesdowngrades make huge gain crossplatform compatibility ease use simply drop executable compatible platform run tool required special consideration build work way building rust go application work today goal support webassembly build target produce easytodeploy static executables build artifact integrate tooling provided beam language efficient execution removing need interpreter runtime feature parity mainline otp exception nongoals listed nongoals support hot upgradesdowngrades support dynamic code loading lumen alternative implementation erlangotp result battle tested necessarily performant beam chance run benchmark hard know difference two term performance actually lumen intended replace beam point time minimum stated nongoals project mean least percentage project required functionality would missing however meant dropin replacement application better served feature set architecture compiler compiler frontend accepts erlang source file parsed abstract syntax tree lowered eir erlang intermediate representation finally lowered llvm ir codegen performed internally compiler represents erlangelixir code form similar continuationpassing style continuation powerful construct enable straightforward implementation nonlocal returnsexceptions green threading optimization primarily performed representation prior lowering llvm ir see eirprojecteir information compiler frontend eir lowering llvm ir continuation representation stripped away platformspecific method implementing various construct generated example handwritten assembly used perform extremely cheap stack switching scheduler provide dynamic function application facility implementation apply currently cstyle zerocost exception model used implementing exception future proposal progress webassembly may allow u use continuation exception yet stabilized implemented browser compiler produce object file handle linking object together executable also dump intermediate artifact ast eir mlir various form llvm ir llvm bitcode plain assembly runtime runtime design mostly otp running interpreter instead code aheadoftime compiled entry point set environment start scheduler scheduler composed one scheduler per thread scheduler steal work scheduler short work process spawned scheduler process spawned scheduler able steal away load balance io asynchronous dedicated thread event loop dispatch initial version quite spartan focus getting runtime behavior rock solid circle back add capability nifs nifs able defined language c ffi need compiled object file passed via linker flag compiler compiler ensure nifs linked executable design ffi still air likely compatibility layer mimic existing erlnifh interface since runtime different may opportunity provide direct hook part system license apache
78,Lobsters,erlang,Erlang development,How to Comprehend Comprehensions,https://medium.com/erlang-battleground/how-to-comprehend-comprehensions-c924f92a97e1,comprehend comprehension,write function like,write function like let first think come beautiful functionthe requirement pretty simple function receive single argument list return list possible permutation itto understand let write test shall use string since joe used book list cool try run test tell u need implement c joe joe test exception error undefined function joe function joe joeerl line start base case permutation empty list itselfthat moved u one step ahead cool c joe joe test exception error function clause matching joe perm joeerl line function joe joeerl line recursive writing recursive function must assume know apply function smaller input case working list smaller input tail list since smaller list first step writing code would something like ht perm word take head list h apply function recursively tail figure move list permutation list permutation ht let say ha b c perm b c c b want get b c c b b c c b b c c b first two easy build hp p perm far good let try see test say c joe joe test exception error match right hand side value ab function joe joeerl line perm ab equal ab ba ab adding permutation element order since traversing list left right need different way reduce listso far perm list permutation element tail list access list permutation sublist original list ht one element le ie b c could build list permutation b list permutation b c one c case build final result need add missing element headstoo complex let go step first let build list list h h list let test shell c joe joe perm ab b c joe joe perm abc bc ac ab c joe joe perm abcd bcd acd abd abc nice following code work could compute permutation sublists like list perm list h h list would end something c joe joe perm ab b c joe joe perm abc bc cb ac ca ab ba let first apply neat trick flatten list something easily list comprehension using multiple generatorsperms list h list perm list h using builtup example since code actually work like c joe joe perm ab b c joe joe perm abc bc cb ac ca ab ba really close get b actual result want ab ba need prepend list element originally removed h code let try c joe joe test joe code expect
79,Lobsters,erlang,Erlang development,"v0.3.0 of Gleam, the statically typed language for the Erlang VM, is out",https://lpil.uk/blog/gleam-v0.3-released/,gleam statically typed language erlang vm,gleam module namespaces type annotation easier installation gleam github release page plugin gleam easier project creation rest installation page code beam lite berlin code beam lite berlin,gleam reached let take look new feature introduced since module namespaces module namespaced allowing use short convenient module name without risk collision gleam erlang module use namespace create directory name namespace inside src directory put module example making hot new food delivery app snackr might choose directory structure like src snackr customergleam paymentgleam food falafelgleam pizzagleam saladgleam created module brought scope using import statement import snackrcustomer import snackrfoodfalafel fn eatlunch louis customer eat louis falafel new possible use multiple module name convenience module given name imported import spacerocket spaceship import saladrocket leafygreen type annotation gleam type inference require annotation understand type code provide full type safety might still want add documentation specify restrictive type gleam might otherwise infer look little something like fn isempty list list bool list easier installation precompiled gleam binary linux osx downloaded gleam github release page longer required install rust machine build compiler source victor borja kindly created asdf version manager plugin gleam asdf user installing gleam easy asdf install gleam docker fan gleam compiler packaged docker image tagged lpilgleam easier project creation previously gleam project created using plugin worked one thing install good way ensuring date version plugin match gleam installation project creation handled gleam binary get started gleam run gleam new mycoolproject generate required got rebargleam installed safe delete longer used rest addition feature number improvement quality error message generated code handful bug fix want try new version gleam head installation page love hear find get feedback gleam continue improve code beam lite berlin october speaking code beam lite berlin gleam attending berlin attending say hello
80,Lobsters,erlang,Erlang development,The Erlang Rationale,http://rvirding.blogspot.com/2019/01/the-erlang-rationale.html,erlang rationale,erlang rationale,long time since last post come question erlang rationale wrote year ago come presentation never published way attempt explain thing look like erlang thinking behind many property feature language also description part system today seem lack description example io system group rationale mainly deal core part language older part library otp found erlang rationale rationale finished adding expandingimproving already significant enough change release new version however someone suggested could release new bit come get comment suggestion seems like good idea try edit saw old blog post well updated link work
82,Lobsters,erlang,Erlang development,"Two months left until SpawnFest. Code in Elixir, Erlang, LFE and win",https://spawnfest.github.io/,two month left spawnfest code elixir erlang lfe win,,tweet spawnfest status event
83,Lobsters,erlang,Erlang development,Pattern Matching Versus Elixir's Access Behavior,https://stratus3d.com/blog/2019/07/13/pattern-matching-versus-elixirs-access-behavior,pattern matching versus elixir access behavior,,nummapkeys numkeystotal key numkeystotal enummap fn key integertostring key end map key enumtakerandom nummapkeys mapnew true numtimes bencheerun compare empty loop baseline baseline fn key key numtimes ok ok end mapget fn key key numtimes mapget map key end ok end access fn key key numtimes map key end ok end
84,Lobsters,erlang,Erlang development,Ten Years of Erlang,https://ferd.ca/ten-years-of-erlang.html,ten year erlang,ten year erlang smp hype phase hype cycle killer app build blog engine minute ejabberd mongooseim couchdb cap theorem barreldb rabbitmq kafka facebook chat whatsapp needed engineer million user riak violation fiduciary duty greased slide failure programming erlang hacker news forced discussion innards erlang ladder idea counterfactuals nine circle erl relx erlang otp action changed hamts time handling atomics counter persistent term signal handling made asynchronous port ssa memory allocation management microstate accounting logging framework huge performance gain manual operate debug production system package manager erlang ecosystem whole list release note erlang ecosystem foundation erlang go,ten year erlang joined erlang community year ago midst first major hype phase erlang told future concurrency parallelism easiest fastest way get done could get distribution free back thing starting get amazing virtual machine recently gotten smp support needed run multiple vms computer truly use cpu wanted take bit time reflect decade post cover thing hype phase related erlang ladder idea within language impact adoption changed ten year finish think erlang still bring programming community large hype phase hype cycle introduces phase lifetime product technology marketing concept scientific one often felt useful describe thing going part interest idea hype phase kind gold rush happens programming community probably seen one seem attached killer app force everyone rush example come mind may include ruby rail build blog engine minute look thing still fun sentence go kubernetes already seeing significant usage really exploded example lesser extent elixir phoenix could fit list well hype phase like incredible influx newcomer drop see fuss stay leave stay might term month year rare case find home could last decade vast majority continuous flow serial early adopter surf tech tech sniffing best opportunity gain competitive advantage first use type framework language toolkit idea often need get one true killer app people come ecosystem killer app drive rush build come keep small percentage active stay lively community foreseeable future weird way reminiscent rain follows plow god speed plow wonderful provision man mastery nature cloud dispensing copious rain plow instrument separate civilization savagery convert desert farm garden concise rain follows plow basic premise theory human habitation agriculture homesteading effected permanent change climate arid semiarid region making region humid theory widely promoted justification settlement great plain region previously known great american desert also used justify expansion wheat growing marginal land south australia period get one big project going devs appear become selfsustaining believe patently false mostly erlang dozen killer apps biggest hype phase yet community remained small see example following killer apps era ejabberd first stable release far one scalable hosted chat server one could run ejabberd massive success extent still day still find stackoverflow question module around forked mongooseim solution still maintained couchdb one first popular database written erlang following cap theorem one new wave multimaster document store time mongodb ate space couchdb still spiritual child storage engine barreldb top still maintained well rabbitmq one queue software implementation pretty much ate whole amqp space still ongoing relevant often get debated along kafka come streaming workload although pretty distinct property use case facebook chat initial version facebook chat written erlang due lot internal decision stability strong internal presence c engineer established set solution rewritten c later time whatsapp bought facebook got rid erlang chat system ended buying whatsapp famously needed engineer million user still ongoing today fact whatsapp folk decided get far heavily involved erlang elixir community ever riak one best example muscleflexing distributed system world riak really solid distributed keyvalue store basho product still run healthcare system critical piece infrastructure basho struggled financially forced go bankrupt small part due violation fiduciary duty put company greased slide failure folk since bought ip gracefully opened database still life open source world albeit limited support better day many came around time joe armstrong book programming erlang first came created kind perfect storm heavy adoption erlang ton onlooker even day hacker news forced discussion innards erlang noticeable impact yet people stayed compared many took look think killer apps driven people glutting initial hype phase opposite always smaller earlier phase people sniffing interesting tech deciding like building something something killer app get even bigger hype phase people cargo cult thing success story breed copycat common thing phase reinventing world everyone spends time reimplementing everything exists get bunch announcement something language killer apps never really sufficient one interesting consequence product like rabbitmq ejabberd popularity community user far larger community contributor thousand thousand corporation use product necessarily participate erlang community much part doubt due idea erlang killer apps turn specialized infrastructure create one high reliability black box component everybody else use work well enough never need look inside box go dozen developer provided foundation thousand product service specialized infrastructure definition space nt need massive amount people massive impact always going smaller contributor group community thing sit closer end product web framework uncountable web developer even generalized infrastructure make sense use smallscale deployment project business may find use even without factor easy feel like erlang missed massive opportunity capturing larger share foot traffic came hype phase ladder idea wo nt get counterfactuals describing could done instead want dig common learning pattern seen erlang community year teaching writing also pattern see happening right elixir community feel could sign similar future pet theory mine technical topic like programming language ecosystem multiple layer complexity various concept go learn discover first started toying idea learn erlang diagram called nine circle erl tongue cheek approach nt think learning piece tech endless suffering least nt liked pun put simply often core track sequence topic study learning technology creating ladder idea worthwhile concept put higher higher harder reach fewer people actually make erlang would consider ladder might look like functional programming isolated process concurrency reliable concurrency link monitor timeouts otp behaviour system abstraction structure otp system build release handle life cycle never take system operate starting erlang first time grabbing beginner book likely spend first day first rung getting friend functional programming immutability recursion similar concept sooner later get concurrency parallelism process message passing right start learn link monitor handling failure make erlang erlang big hype phase second third rung sold truly amazing onlooker learn something carry future project one thing rung would follow later stuck program particularly otp rung would decried actually concurrency functional programming nice sure general development framework represented otp something truly unique stick use lot people would play find nice abstraction make may feel bit confused structure everything right fact application like ejabberd development barely breaking rung ecosystem time bit like wild west otp knowledge thing folk worked ericsson motivated selflearners people would never reach rung something worth putting production started issue wanted look better way rung rare probably relx came make whole experience easier rung almost never reached fact bunch people feel like never hot upgrade node ideally never ssh debug production either practice everyone go order book flip around erlang otp action come mind fine ladder illustrative purpose community tend move wave since hype phase increase size community tenfold hundredfold people take curious look leave user community tend sit first rung rarely make past fraction make level ever shrinking fraction make one inner circle expert highest level think erlang first three rung probably easy one get fourth one took year develop perceived worthwhile fifth one thing became extremely hard erlang tooling ecosystem lacking people erlang community selfselected could tolerate barren environment insensitive plight newcomer keep post short well long rather absurdly long erlang user conference keynote probably complete rant ecosystem video case elixir user probably see arbitrarilydefined ladder get feel faction within community generally located lot folk probably fine phoenix nothing else rarely break rung many stick level foreseeable future many case fine judgment call observation someone seen lot rung possibly still head environment like patching vm something feel like missing lot frankly might never prove useful information fine say think community probably hamstrung making difficult people go basic level lesson learned ca nt rushed extent blind leading blind erlang small enough people share experience required thing easier today getting outside hype cycle much likely able find good help fewer people asking like think erlang second hype phase tomorrow better place welcome riding big wave hopefully experience along much better collaboration erlang elixir community double chance success increasing surface area changed erlang nt stay glass container filled formaldehyde awaiting taken broad daylight continuously evolved part due pressure demand elixir community fortunately came expecting tool erlang user grown accustomed part also due actual industrial need pushed platform forward academia driving thing forward like thing think people might glad know changed since earlier multicore support good used past core thing would start hit kind bottleneck control application developer could handle core fine day quite sure max value pretty sure wrote operated stack ran core without hiccup line number stacktraces almost unthinkable go back era line number back write short selfdescriptive function question design question survival debug erlang program without otherworldly debugging skill although never hurt unicode support acceptable string module contains important algorithm unicode module handle conversion normalization fine general strategy deal raw codepoints locale support still lacking thing workable module regular expression higher level filehandling code also cope unicode fine map implemented hamts supported explicit pattern matching syntax type analysis done dialyzer also allows substitute multiple use case record previously used lot pain time handling mechanism virtual machine world class thing right come dealing time warping various type clock timezone formatting handling still mostly better done community library however highperformance tool atomics counter persistent term added help improve underlying mechanism power observability feature lowerlevel core library signal handling made asynchronous including port massively reduced bottleneck compiler still rewritten higher level analysis performance gain ssa dirty scheduler nifs exist make integration c even rust code simple support io cpuintensive workload language probably infinitely faster even though faster easier ever drop higher performance library without impacting runtime stability much various improvement memory allocation management faster flexible live tracing microstate accounting correctness performance investigation flexible genstatem otp behaviour implement finite state machine handle selective receives new improved logging framework builtin support structured logging rewrite crypto module use nifs instead complex often slower update driver entire rewrite file driver using nifs huge performance gain ongoing rewrite network driver using nifs similar performance gain whole rewrite ssl application tl handling back day heroku managed make competitive c solution term latency maybe slower whole lot better term predictability around lower percentile major improvement ets performance wrote manual operate debug production system using erlang vm entirely new build tool integrates unified package manager erlang ecosystem multiple new programming language also available vm interchangeable library usage including limited elixir efene lfe luerl clojerl least two language type inference gleam alpaca whole lot inside outside core erlang distribution interested finding take look whole list release note short year around release otp bit slower otp team ericsson version latest investment made using erlang flagship product really visible even outside ericsson thing moving erlang community along elixir community contributor language erlang vm banded together set erlang ecosystem foundation lively working group help coordinate tackle issue regarding build packaging tool observability work security training adoption like part big initial hype phase unlike nt stick around lot thing felt unusable tricky might want give second try ergonomics language ecosystem improved drastically erlang go nt necessarily big killer apps popping ether way around mean project showing promise erlang still wedged deep infrastructure lot corporation initial killer apps still around also plenty interesting new player every beam conf show really sold concept propertybased testing erlang elixir best framework world available despite sign point idea hype phase right however going another hype phase maybe maybe could say elixir next hype phase ecosystem enough common lesson learned one place transferable one similarity difference maybe still new renaissance personally care much anymore tend like smaller community feel good erlang need geometric growth enjoy need remain sustainable size erlang community also never blocker worldwide impact erlang long known situation enough job amount erlang developer enough developer number erlang job around lot go around aligning right term geography corporation employee open remote market tend best erlang could easily pierce webapp market whole elixir job market available rather minimal effort adapt probably important grand scheme thing whether using language like erlang feel underused underrated biggest benefit running system us biggest benefit come learning fundamental solid system design internalizing lesson practical context one type question heard lot year finding guidance learn designing protocol good reading recommend building distributed system go extra mile make something robust fault tolerant know design modular abstraction nt leaking good error handling good way know optimization premature mean make something declarative like short digestible solution like cookbook best practice real answer turn variation learned year honestly say nothing career could ever compare spending time world erlang absorbing experience veteran community osmosis large community number certainly rich metric year gone junior developer working senior role speaking around world finding way teach experience back owe community maybe still ca nt write blog engine minute truth told slow developer anyway personally become much solid developer system architect think timeeffective manner always spoke using system building making work motivates people nt universal anyway ca nt imagine gotten much community last year amazing interesting erlang community still small mostly untapped mean plenty opportunity get involved anything get one one time folk full wisdom eager share make place
85,Lobsters,erlang,Erlang development,The wide world of almost-actors: comparing Pony to BEAM languages,https://www.youtube.com/watch?v=_0m0_qtfzLs,wide world almostactors comparing pony beam language,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature scott lystig fritchie wide world almostactors comparing pony beam language youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature scott lystig fritchie wide world almostactors comparing pony beam language youtube
86,Lobsters,erlang,Erlang development,An Unprecedented Subtraction,https://medium.com/erlang-battleground/erlang-elixir-list-subtraction-wat-5b764020d69c,unprecedented subtraction,going elixir whole page doc right left side integer erlang erlang expression table dedicated self self self something flush something,going usual better first try decipher mystery go ahead check found know happening fair elixir dev slightly better situation erlang counterpart documentation believe much clearerbut let go step step first let see happens add parenthesis iex actually make sense look like associate right left let see find documentation prof itin elixirwhat looking operator associativity elixir actually whole page doc dedicated see binary two argument list operation associate right leftthat easyas aside let try verify one actually right argumenterror range first last expect side integer got elixir erlangnow let try find thing page operator associativity google carefully redirected doc erlang expression deep last part page find table dedicated operator precedencetable operator precedenceif squint bit find see right associative like never seen operator erlang row actually stating right associativewhich actually cool since let stuff self self self flush shell got somethingshell got somethingshell got something broadcast message pi yeah article insightful deep revealing others topic sitting towrite list almost year way
87,Lobsters,erlang,Erlang development,(BEAM) Data Types Memory Layout,http://beam-wisdoms.clau.se/en/latest/indepth-memory-layout.html,beam data type memory layout,data type memory layout list con boxed,data type memory layout describes data format heap seen c code debugger never able see format erlang code list con list term boxed value ie contains pointer heap leastsignificant bit list value remaining bit pointer value heap contains word namely car list head cdr list tail see car cdr macro emulatorbeamerltermh pair word called con cell terminology lisp functional programming con cell header word stored memory con cell contains pointer next cell cdr tail also visible erlang last con cell list contains nil special value empty list nonlist term value make improper list structure may look inefficient hand allows connecting tail list multiple con cell reuse existing data boxed boxed value pointer leastsignificant bit tagged remaining bit pointer boxed pointer must always point header see explanation header boxed value found everywhere register stack heap box always point header garbage collection box point another box thenonvalue mark moved object never
88,Lobsters,erlang,Erlang development,Practical Type Inference Based on Success Typings (2006),http://www.it.uu.se/research/group/hipe/papers/succ_types.pdf,practical type inference based success typing,,obj stream 엿o x su zo x w g n e b b
89,Lobsters,erlang,Erlang development,No more need for records,http://www.cs.otago.ac.nz/staffpriv/ok/frames.pdf,need record,,obj length filter flatedecode stream
90,Lobsters,erlang,Erlang development,BEAM + Rust A match made in heaven,https://codesync.global/media/beam-rust-a-match-made-in-heaven/,beam rust match made heaven,objective audience,beam wellknown faulttolerant property quite performant memory efficient many usecases occasionally find hitting limit beam provide u happens need interface directly hardware specific part application need fast possible talk sonny introduce audience rust system programming language aim empower everyone build reliable efficient software various method used integrate beam objective demonstrate flexiblity beam integrating outside world introduce audience rust programming language benefit provides audience anyone want learn rust use within beambased application
91,Lobsters,erlang,Erlang development,New release available for Clojerl (Clojure on the BEAM),https://github.com/clojerl/clojerl,new release available clojerl clojure beam,clojerl building getting started documentation resource clojerlorg feature differs clojure online repl try clojerl docker repl local repl code example scriptsexamples web application example examplewebapp building app rationale goal personal goal qas clojerl heard lfe joxa nt language construct concurrency different clojure erlang rich hickey list reason chose use actor model clojure clojerl support every single clojure feature reuse existing clojure script library discussion clojerl slack channel clojerl jfacorro clojure erlang,clojerl clojure implemented erlang vm building building clojerl requires erlangotp git clone http githubcomclojerlclojerl cd clojerl make window git clone http githubcomclojerlclojerl cd clojerl clojerl compile getting started documentation resource information regarding clojerl clojerlorg find feature clojerl include differs clojure online repl try get sense visit try clojerl docker repl quickly try clojerl via docker make use docker image like docker pull clojerlclojerl docker run clojerlclojerl able see prompt clojure cljeuser local repl running make repl window first run clojerl compile bincljebat start repl show prompt clojure cljeuser repl possible start evaluating clojure expression cljeuser map inc range cljeuser doc map clojurecoremap f f coll f f f colls return lazy sequence consisting result applying f set first item coll followed applying f set second item coll one colls exhausted remaining item colls ignored function f accept numberofcolls argument return transducer collection provided nil cljeuser doc inc clojurecoreinc x return number one greater num nil cljeuser code example basic example scriptsexamples directory meant reference special form clojure beam used sometimes differ clojure jvm web application example basic example web project please check examplewebapp repository building app build tool clojerl plugin official build tool erlang community plugin provides helpful command build basic directory scaffolding new project compile run test start repl information use plugin please check documentation rationale erlang great language building safe reliable scalable system provides immutable persistent data structure box concurrency semantics unequalled language clojure lisp come goody lisp provide apart clojure also introduces powerful abstraction protocol multimethods seqs name clojure built simplify development concurrent program concurrency abstraction could adapted erlang fair say combining power erlang vm expressiveness clojure could provide interesting useful result make life many programmer simpler make world happier place goal interoperability smooth possible like clojure proper clojurescript provide clojure abstraction provide erlang abstraction toolset include default otp library clojerl personal goal learn erlang vm clojure language implementation project experiment hope others find useful regardless whether becomes fully functional implementation clojure learned lot along way qas clojerl clojerl experimental implementation clojure erlang vm goal leverage feature abstraction clojure love macro collection seq protocol multimethods metadata etc robustness erlang vm provides building distributed system heard lfe joxa yes lfe joxa created specific different goal mind lfe born provide lisp syntax erlang joxa mainly created platform creating dsl could take advantage erlang vm syntax inspired clojure creator nt interested implementing clojure feature nt language construct concurrency different clojure erlang yes one hand clojure provides tool handle mutable state sane way making clear distinction identity state reference type concurrency erlang vm implemented process message passing idea clojerl encourage erlangotp concurrency model support many clojure construct possible far make sense erlang vm rich hickey list reason chose use actor model clojure question see mean point make course good example state shared process communication overhead isolation also advantage lot circumstance also mention building distributed case aka process message passing complex always necessary decided optimise nondistributed case add distribution part system need rich hickey call erlang quite impressive interpretation writing exposing rationale behind decision tradeoff made designing clojure jvm disregarding actor model clojerl support every single clojure feature clojure feature implemented relying underlying mutability jvm object system erlang vm provides mutability construct support defining new type make hard nearly impossible port feature clojerl implementation reuse existing clojure script library yes need ported like clojurescript fact clojure core namespaces ported original clj file clojure jvm repository discussion join conversation clojerl mailing list clojerl slack channel also find news update clojerl question find jfacorro lurking clojure erlang mailing list feedback comment andor suggestion welcome
92,Lobsters,erlang,Erlang development,Help Dialyzer Help You,https://medium.com/erlang-battleground/help-dialyzer-help-you-94db66bfbc5a,help dialyzer help,going latest talk codebeamsf dialyzer say dialyzer mean opaque would like dialyzer say elli fragkaki started local return elixirmyodt elixirmyodt argument vodt elixirmyodt,going ok usually happens many question never let see figure sean brilliantly expressed latest talk codebeamsf must little misunderstanding dialyzerwhat dialyzer saysso let obvious thing dialyzer say call proper myodtt argument using argument function odt variable according spec wrote myodtuserprintodt actually instance myodtt also say myodtuserprintodt never return likely considering discrepancy fix one remove oncewhat dialyzer meansif check stavros talk video learn dialyzer work inferring broader possible type variable emitting warning infer possible type onewith mind since complaining odt let try figure dialyzer inferred success typeactually go far warning vodt might noticed vodt erlang representation variable odt typethat map somewhat similar opaque type myodtt since allows map key value long field called myodtt allows key required could dialyzer found type odt let try see information available inferring typesthere typespec dialyzer us typespecs narrow success type found case spec dialyzer mind time warningthe info available fact odt used call key solve mystery check code module notice spec tnot spec dialyzer best figure type odt success typing argument function ie type opaque since spec say way dialyzer tell actually requires instance myodtt map keythen dialyzer try match type success typing argument ie myodtt way match random map type opaque type matter fact type match opaque type opaque type whole point even manage build something look like definition opaque type dialyzer prove fact expected opaque type emit warning word violating opaqueness argumentsimply adding spec remove warning lead u lesson day define opaque type add spec exported function use ie module api would like dialyzer sayone day someone finish elli fragkaki started dialyzer tell u something along line function local call elixirmyodt requires opaque term type elixirmyodt argument variable using vodt must type since also used call elixirmyodt something even clearer helpful
93,Lobsters,erlang,Erlang development,OTP Cheatsheet,https://stratus3d.com/blog/2019/05/18/otp-cheatsheet,otp cheatsheet,created erlang cheatsheet email github repository,last year created erlang cheatsheet goal keep fairly simple include thing often forgot decided limit single page could print pin wall reference lot elixir recently cheatsheet still useful coworkers lot thing often lookup working supervisor otp behavior month decided would nice seperate cheatsheet otp new cheatsheet follows vein erlang cheatsheet intended experienced otp beginner really like hear thought new otp cheatsheet something missing something simplified removed let know via email twitter want contribute directly feel free create issue pull request github repository
95,Lobsters,erlang,Erlang development,BEAM Architecture Handbook,https://speakerdeck.com/whatyouhide/beam-architecture-handbook,beam architecture handbook,fewer faster,copyright fewer faster llc slide content description owned creator
96,Lobsters,erlang,Erlang development,The Soul of Erlang and Elixir,https://www.youtube.com/watch?v=JvBT4XBdoUE,soul erlang elixir,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature goto soul erlang elixir saša jurić youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature goto soul erlang elixir saša jurić youtube
97,Lobsters,erlang,Erlang development,Erlang/OTP 22.0 is released,https://www.erlang.org/news/132,erlangotp released,otp http potential incompatibility new feature ert compiler standard library http http http http erlangorgdocsearch http githubcomerlangotp,otp erlangotp new major release new feature improvement well incompatibility deeper dive highlight otp release read blog http potential incompatibility gen behaviour logging last n message sys active server log included terminate report reltool new element opts included rel tuple reltool release specific configuration format rel name vsn relapps opts external pidsportsrefs created erlang listtopid similar function compare equal pidportref number node old legacy erlinterface library deprecated otp removed otp apply ei library vxworks deprecated otp removed otp new feature ert support erlang distribution protocol split payload large message several fragment ets option writeconcurrency also effect improves scalability orderedset table bif used calculate length list one go without yielding even list long yield called long list new still experimental module socket introduced implemented nif idea shall close possible o level socket interface added nif function eniftermtype help avoid long sequence enifisxyz returning type given term especially helpful nifs serialize term json encoders improve performance readability compiler compiler rewritten internally use intermediate representation based static single assignment ssa new intermediate representation make optimization possible binary matching optimization applicable many circumstance type optimization applied across local function call remove lot redundant type test compiler option given source file given option list command line erlc otp hipe native code compiler fully functional reason new beam instruction binary matching hipe native code compiler support erlc invoked native option new binary matching instruction used compiler issue warning produce beam file without native code standard library cover us counter module instead ets updating counter new function cover allows running cover restricted faster localonly mode increase speed vary depending type code covercompiled example compiler test suite run twice fast new cover simple socket api provided socket module low level api replace gen tcpudpsctp intended eventually replace inet driver also provides basic api facilitates implementation protocol tcp udp sctp known issue support window o currently small term leakage feature classed experimental otp ssl us new logger api including log level verbose debug logging ssl basic support tl server experimental use crypto new function return map information hash cipher argument detail see http pre built version window fetched http http online documentation browsed http erlangorgdocsearch erlangotp source also found github official erlang repository http githubcomerlangotp thank contribution
98,Lobsters,erlang,Erlang development,Learn You Some Erlang for Great Good,https://learnyousomeerlang.com/,learn erlang great good,twitter account send email please grab code,hey learn erlang great good book got programming experience familiar functional programming still useful good progressively go advanced topic book started free online guide still read way prefer soft touch paper delicious smell real book possibility physically hug document want boast padding bookcase buy copy ebooks also available want contact check twitter account send email find erlang nickname mononcqc oh get please grab code nice day buy read online download code zip
99,Lobsters,erlang,Erlang development,Gun. The powerful Erlang HTTP client,http://big-elephants.com/2019-05/gun/,gun powerful erlang http client,blog post problem hackney httpoison hackney hexpm mint issue gun rescue gun cowboy previous highlight word ssl certifi sslverifyhostname conclusion p whatyouhide ericmj announced mint,previous blog post described send million http request using genstage without mentioning http client app depends sending request given app requirement http client must fast importantly reliable send http request back pressure mechanism matter strongly recommend reading previous blog post diving deep one problem hackney come http client elixir first option would httpoison httpoison wrapper around erlang http client called hackney according hexpm httpoison popular http client elixir fact mint release httpoison elixirerlang http client proper ssl verification default box httpoison provides simple straightforward interface send http request hiding complexity establishing connection maintaining connection pool however encountered issue hackney occasionally hackney could get stuck call httpoison would hanging blocking caller process would look like graph see new genstage process spawned anymore already spawned process blocked call httpoison way get state restart hackney app using function likely problem encountered related issue gun rescue thankfully time started looking around alternative http client gun reached version gun erlang http library author cowboy gun provides lowlevel abstraction work http protocol every connection gun process supervised gun supervisor gunsup request simply message gun process response streamed back message process initiated connection full documentation could found asynchronous nature gun allows performing http request multiple connection without locking calling process gun provide connection pool manage connection manually implemented gun based httpclient module app defmodule httpclient def connection host port opts keepalive infinity host tocharlist host connectopts connecttimeout timerminutes retry retrytimeout httpopts keepalive opts keepalive keepalive opts keepalive ok connpid gunopen host port connectopts ok protocol gunawaitup connpid timerminutes ok connpid else error reason error reason end end creates new connection new gun process given host port process started connection established gun process sends back gunup message caught point gun process ready receive request call function upon campaignproducer start campaignproducer first process genstage pipeline actually sends http request defmodule campaignsproducer use genstage def init meta connpid obtainconnection meta connpid meta mapput meta connpid connpid producer demandstate queuenew meta meta else ignore end end defp obtainconnection meta case httpclientconnection metahost metaport keepalive ok connpid connpid error reason log error nil end end end way campaignsproducer owner gun process receive message gun campaignproducer get campaign facebook pass pipeline spawn genstage worker also send request facebook idea child genstage process would send subsequent request facebook using one connection created campaignproducer process thus number campaignproducer across facebook account equal number gun workersconnections mean control let show scheme previous blog post insight costdata costdata producer producer producer campaignproducer initiate new gun connection sends request facebook get campaign pass pipeline insightsproducer costdataproducerconsumer use gun connection received campaignproducer pas httpclient function order send http request worth noting sending get post request case spawn new process connection genstage worker spawned campaignproducer send http request utilizing gun connection campaign consumed campaignproducer close gun connection dy normal state effectively built pool gun connection within existing genstage pipeline let see sending get post request gun would look like defmodule httpclient def get connpid query header header converttoelixir header monitorref processmonitor connpid streamref gunget connpid tocharlist query header asyncresponse connpid streamref monitorref end def post connpid query body header header converttoelixir header header contentlength bytesize body header monitorref processmonitor connpid streamref gunpost connpid tocharlist query header body asyncresponse connpid streamref monitorref end defp asyncresponse connpid streamref monitorref receive gunresponse connpid streamref fin status header httpclientresponse statuscode status body header header gunresponse connpid streamref nofin status header case receivedata connpid streamref monitorref ok data httpclientresponse statuscode status body data header header error reason httpclienterrorresponse message reason end gunerror connpid streamref reason httpclienterrorresponse message reason gunerror connpid error httpclienterrorresponse message error gundown connpid protocol reason killedstreams unprocessedstreams httpclienterrorresponse message gundown monitorref process connpid reason httpclienterrorresponse message reason timerminutes httpclienterrorresponse message recvtimeout end end defp receivedata connpid streamref monitorref responsedata receive gundata connpid streamref fin data ok responsedata data gundata connpid streamref nofin data receivedata connpid streamref monitorref responsedata data gundown connpid protocol reason killedstreams unprocessedstreams error reason monitorref process connpid reason error reason timerminutes error recvtimeout end end defp converttoelixir header enummap header fn name value name tocharlist value end end end quite lot code gun documentation highlight well stating advantage developer architecture may seem verbose using message like advantage never locking process allowing easily debug code also allows start one connection concurrently perform query time sending request basically sending message gun worker connpid variable example process initiated connection start receive response message gun process request uniquely identified streamref important pattern match receive block receiving full response achieved receiving message gun process till fin mark please note implementation block process process waiting message inside receive block receive block suffice case order avoid process locking implement receive block via genserver handleinfo callback word ssl mentioned httpoison elixirerlang library proper ssl certificate verification default order instruct gun well need provide certain option function transport tl transportopts verify verifypeer cacerts certificacerts depth servernameindication host reusesessions false verifyfun checkhostname host certifi sslverifyhostname dependency listed mixexs conclusion gun lowlevel http client quite verbose look bit awkward first glance however provides lowlevel abstraction work http giving full control connection allowing receive response asynchronously without locking process exactly need send million http request per day important thing case ability control connection split different branch genstage pipeline way single dropped connection impact others making app resilent http error p recently two elixir core contributor whatyouhide ericmj announced first stable release mint first native elixir http client big deal elixir community ask mint ssl verification default share principle gun however mint basic idea gun fundamental difference mint completely processless gun supervisor gunsup spawn gun worker hold connection every connection gun process mint connection mint struct looking forward trying mint one project future
100,Lobsters,erlang,Erlang development,My Take on Property-Based Testing,https://medium.com/erlang-battleground/property-based-testing-erlang-elixir-de72ad24966b,take propertybased testing,opinion stuff tested way code podcast data structure optimization refactoring library generic processing complex algorithm checkout code kata complex stateful system system opaque data structure hernán inaka try find library final note,opinionsfirst want set one thing straight believe reasoning behind propertybased testing sound fred put propertybased testing able write simple short concise test automatically comb code way obsessive tester couldwriting good property letting good framework check code undoubtedly test code much much better unit test obsessive tester ever write think anybody deny stuff tested way worth test code property think basis thesis project problem tried use quickcheck test everything including gui wise choice various reason propertybased test slower unit test bydesign since property tested multitude time instead using one examplewriting good property easy fred state multiple time book sometimes good unit test hard write even cover one possible scenario writing property capture thing general way different instance test system much complexwriting enough property easy way hardly ever sure wrote enough unit test really cover functionality modulecomponentsystem testing hard sure wrote enough property fred great job showing situation book describes different type property write particularly verifying system behavior model also wary adding many property since property take time run want suite run worth testing property believe fred summarized idea quite well podcast said come figuring want write test first propertybased test really really hard need find general rule something stupid simple rule test want find something trivial understand well significant complexity implementation usually data structure interesting perspective thing totally worth checking property general one used fred example structureswhen writing module manage new complex data structure like new model list particular kind tree hash table etc writing unit test almost certainly miss bunch corner case propertybased testing writing test property also help define module better come nicer api besides book show list test otp propertybased test use far le code toooptimizations refactoringone best scenario find use property testing refactoring something sure work correctly let say trying optimize certain function performance module readability use previous version model verify new implementation work exactly old one writing property least easy writing unit test think easier since need come example give much confidencelibraries generic processingmuch like data structure writing library like csv parser fred present book something really know use case beforehand maybe standard rfc guide great since encoding rfcs property easier coming general property properly written specification another thing make use property easier complementary functionality like encodingdecoding write symmetric propertiescomplex algorithmsthis least experience common place reap benefit writing property system point write algorithmic piece sits core system logic likely get free library might involve multiple data structure andor complex piece book fred present checkout code kata example algorithm respond correctly parameter may vary widely quite edge case writing property instead unit test definitely pay would personally still write unit test shrunk value produced time property found bug system mecomplex stateful systemsthen stateful property great way test system whole multiple api endpoint executed different sequence conflict writing system stated code user perceives simple code implemented get lot benefit writing stateful property system big complex like usual crud http server code really hard model maybe muchwhat system question often write system worth testing property often create new data structure work opaque data structure almost every day work generally flat ie map record multiple field accessors regularly create new type tree hash tableshow often work large enough refactoringoptimization task large complex enough merit adding property compare new version old one thoroughly people remember hernán instance may muchhow often write new generic library actually used lot inaka believe many library would certainly benefit propertybased testing indeed hand scenario like one described book find writing system need parse csv well think ever face requirement go ok write generic csv parser either try find library write code exactly system need ie parse csv file case book often write complex algorithm whole stateful system actually happens often stuff previous paragraph happens least per system maybe course includes relatively small piece system build believe using propertybased testing would nice additionfinal notesin conclusion see propertybased testing great tool seriously consider using place benefit traditional examplebased test outweigh drawback basically time consumed writing running property test tool tool disposal therefore would advocate propertiesdriven developmentifwhen decide start using propertybased testing totally read fred book guide process make smooth enjoyable make expert writing property get far book take
101,Lobsters,erlang,Erlang development,Uses This: Joe Armstrong,https://usesthis.com/interviews/joe.armstrong/,us joe armstrong,joe armstrong erlang hardware use macbook pro macbook air imac synology raspberry pi arduinos dell latitude ubuntu lumix roland roland bose quietcomfort software emacs make bash keynote page photoshop element aperture spotify rdio aspell javascript chrome github dropbox git svn c prolog lisp evernote chandler would dream setup,joe armstrong software engineer best known work erlang hardware use home use macbook pro travel lecture etc macbook air imac picture editing na synology two raspberry pi quite lot arduinos work dell latitude quadcore ssd running ubuntu camera lumix micro fantastic vario lens music production roland fantastic machine entire orchestra box roland stage piano oh bose quietcomfort noise reducing headphone essential longdistance flight sonos sound system listening music software emacs make bash programming keynote slide page letter photoshop element editing photo aperture organizing image spotify rdio music write book using xml markup emacs nxml mode run text spell checker aspell mac voice synthesizer write code emacs nt use ides use printf debugging apart javascript run chrome browser use github collaborative project dropbox transfer file work machine dreamhost backup private project use git svn version control use erlang bash script javascript c prolog various lisp makefiles programming project evernote web clipbook chandler organise job would dream setup software broken infinite supply paper pen nt leak like laptop day battery ca nt think would need memory ssd would high quality voice input would cache data offmachine faulttolerant storage machine broke would like go machine resume work within second without losing data machine stolen would like totally unusable short time nobody would bother steal would like machine recognize mechanism fingerprint retina scan dna know nt need password would like access data securely forever index could find thing want total backup solution snapshot guard data nothing ever get accidentally lost destroyed want zero virus trojan malware trying build thing right still stuck first point making software broken
102,Lobsters,erlang,Erlang development,Introducing Telemetry,https://www.erlang-solutions.com/blog/introducing-telemetry.html,introducing telemetry,introducing telemetry need monitoring telemetry exometer folsom ecto plug core library tree fallen forest one around hear ecosystem telemetry library telemetrypoller prometheus statsd next monitor erlang elixir rabbitmq system get free trial wombatoam page link thought might also interested go back blog,introducing telemetry arkadiusz gil need monitoring longrunning mantra beam world might misinterpreted merit software unexpected thing often viable choice crash start simply restarting part application sufficient understand cause error handle properly future release also need know error occurred affected customer enable thing need way introspect analyze behaviour runtime need monitoring telemetry new open source project aiming unifying standardising library application beam instrumented monitored suite library developed last couple month erlang solution collaboration elixir core team contributor existing metric project exometer folsom served community well year would need yet another solution might start feel like popular comic strip design telemetry try cover every use case rather provides small simple interface instrumenting code allows anyone hook instrumentation point runtime enables modularity project like ecto plug need rely core library engineer building application use data exposed library monitoring system dive little bit deeper rationale behind telemetry design tree fallen forest core telemetry lie event event indicates something happened http request accepted database query returned result user signed event many handler attached performing specific action event published example event handler might update metric log data enrich context distributed trace becomes extremely convenient library emit telemetry event usually write web framework database client use existing package library provide instrumentation data via event code handle way suit need thing need implement handler attach application start example ecto since version publishes event database query could write handler log whenever total query time exceeds defmodule myappmonitoring require logger def logslowqueries event measurement metadata config systemconverttimeunit measurementstotaltime native millisecond loggerwarn query inspect metadataquery completed measurementstotaltime m end end end measurement metadata property single event telemetry event carry value handler need attached runtime example application start assuming ecto repo called myapprepo attach handler using code telemetryattach slowquerylogger myapp repo query noconfig specify name handler need unique across system event attaching function invoked time event emitted handler config passed last argument handler every invocation one around hear telemetry designed small performance footprint almost cost associated including even popular elixir library already used ecto plug coming phoenix soon telemetry requires single ets lookup event published handler executed synchronously process emitting event mean bottleneck single point failure whole library ecosystem apart core telemetry library provides interface emitting handling event built additional tool addressing common use case related monitoring telemetrypoller allows perform measurement periodically emit telemetry event include library project default poller process started publishing measurement related erlang vm like memory usage length run queue telemetrymetrics provides bunch function declaring metric based event example definition counter myapprepoquery mean want count many database query made ecto apart counter telemetrymetrics also defines aggregation sum last value sometimes referred gauge distribution also support multidimensional metric via tag unit conversion metric declared need fed reporter attache relevant event handler forward metric monitoring system choice runtime currently two reporter available hex one prometheus one statsd next telemetry core reached stable api right time including library user benefit exposed instrumentation data telemetry community run project without contributor able flourish encourage everyone telemetry active group contributor early day project would love part growth adoption want get involved integrate library telemetry build reporter telemetrymetrics give u feedback apis documentation currently improving performance core well extending polishing poller metric weare also working making existing reporter performant stable next big thing planned metric dashboard phoenix imagine generating new phoenix project basic dashboard metric served endpoint without setting external system telemetry allows u much near future monitor erlang elixir rabbitmq system currently using erlang elixir rabbitmq stack get full visibility system wombatoam find get free trial wombatoam page link thought might also interested go back blog
103,Lobsters,erlang,Erlang development,Using Fault-Injection to Evolve a Reliable Broadcast Protocol,http://christophermeiklejohn.com/erlang/partisan/2019/04/20/fault-injection-reliable-broadcast.html,using faultinjection evolve reliable broadcast protocol,partisan testing asynchrononous protocol reliable broadcast attempt demers direct mail broadcast assertion membership command fault command model command counterexample omission fault identifying replaying fault resolution acknowledgement defeat finite omission fault counterexample unresolved omission fault counterexample crash failure attempt demers antientropy attempt demers rumormongering,first article series building reliable faulttolerant application partisan highperformance distributed runtime erlang programming language part project start pretty simple protocol show system guide adjusting protocol faulttolerance issue testing asynchrononous protocol reliable broadcast demonstrate constructing protocol based identifying counterexample refining implementation based counterexample going consider case implementing protocol achieve reliable broadcast protocol going consider well documented original presentation demers et al presented refinement efficiency b reliability first protocol direct mail simplest protocol try achieve reliable broadcast fails achieve membership change general message omission crash failure second protocol consider antientropy protocol extremely resilient failure relies pairwise exchange message received ensure reliable broadcast final protocol consider rumormongering protocol attempt achieve reliable broadcast using technique direct mail antientropy direct mail efficiency antientropy resilience attempt demers et al direct mail start creating process direct mail protocol implementation implementation support two call broadcast sending message update updating membership received partisan system view change occur state node track currently known membership look every time want make broadcast export record state membership doc broadcast broadcast serverref message genserver cast module broadcast serverref message doc membership update update localstate partisanpeerservice decode genserver cast module update localstate need implement behavior callback first define behavior occurs membership updated update local cache membership doc perform membership update membership change handlecast update state membership membership noreply state state membershipmembership use helper called membership used ensure node system sort membership way ensures want begin testing remain deterministic private sort remove nondeterminism node selection membership membership list usort membership direct mail protocol state message want broadcast first deliver message member cluster determined known membership implementing callback broadcast us cluster local view membership forward message every node view broadcast function implemented follows take named process identifier destination message forwarded derive unique deterministic identifier payload message known member cluster forward message node use local storage keep track transmitted message doc handle outgoing broadcast message handlecast broadcast serverref message state membershipmembership state manager manager generate message id mynode partisanpeerservicemanager mynode id mynode erlang uniqueinteger monotonic positive forward process partisanutil processforward serverref message store outgoing message true ets insert module id message forward message every node except node identifier list foreach fun n manager forwardmessage n gossipchannel module broadcast id serverref message end membership membership mynode noreply state need define message handled upon receipt node cluster implement handler incoming message pattern match body message take action accordingly example message received node forward destination process using supplied process identifier seen message yet otherwise drop message without processing doc incoming message handleinfo broadcast id serverref message state case ets lookup module id forward process partisanutil processforward serverref message store true ets insert module id message ok ok end noreply state direct mail protocol implementation finished however reader suspicious protocol built redundancy message omission membership change crash failure test bug use partisan builtin testing infrastructure start using provided reliable broadcast model take input model state every transmitted message received noncrashed node cluster reliable broadcast model provides two possible command test generation application developer supplied broadcast implementation broadcast broadcast function given node identifier message broadcast destination process identifier transmits message application developer implement broadcast protocol expected provide broadcast function destination process identifier provided automatically test harness passed call assertion checkmailbox function given node identifier set expected message performs assertion verify expected received message function us spawned destination process accumulate perform assertion message specified partisan testing infrastructure automatically generate random schedule command command insert postconditions command return true partisan command selected following type command membership command maintaining minimum number node cluster partisan perform random join leave operation number additional node ensures application behavior remains correct cluster transition fault command given fault model introduce number fault including limited stop failure crash failure sendomission failure receiveomission failure general omission failure arbitrary failure failure introduced given failure tolerance level specified application developer model command command model specific command drive application behavior case discussing command reliable broadcast model counterexample omission fault let u start testing model omission fault typically observed network partition start running partisan fault injector find counterexample failure tolerance simultaneous failure simply running following command faultinjectiontrue bincounterexamplefindsh find first counterexample several schedule test command counterexample look follows partisan produce full execution trace output retain important part explanation see missing two message mailbox assertion verifying mailbox node sent received verification mailbox failed missing received postcondition result false command proppartisanreliablebroadcast checkmailbox look excerpt message trace execution see following parrhesia parrhesia forwardmessage demersdirectmail broadcast receiver parrhesia parrhesia dropped broadcast receiver parrhesia parrhesia forwardmessage demersdirectmail broadcast receiver parrhesia parrhesia forwardmessage demersdirectmail broadcast receiver parrhesia parrhesia forwardmessage demersdirectmail broadcast receiver parrhesia parrhesia forwardmessage demersdirectmail broadcast receiver parrhesia parrhesia forwardmessage demersdirectmail broadcast receiver parrhesia parrhesia forwardmessage demersdirectmail broadcast receiver parrhesia parrhesia dropped broadcast receiver see trace partisan introduced several failure randomly throughout execution see send omission identifying replaying fault see assertion missing two message examining message trace clear send omission failure prohibited sending caused two message omission resulting failure therefore reliable broadcast satisfied fault model replay fault using partisan deterministic testing replay behavior use previous trace command schedule run set command enforce message delivery order using barrier ensure deterministic replay message network run following command replay faultinjectiontrue bincounterexamplereplaysh staging counterexample replaying counterexample replaying fault produce output previous example see replay failure verifying mailbox sent received verification mailbox failed missing received postcondition result false command proppartisanreliablebroadcast checkmailbox counterexample held replayed cool replayed example resolution acknowledgement defeat finite omission fault omission fault problematic using protocol transmit message case network partition cause message omitted two participant resulting two message never get delivered one node cluster one solution problem use message acknowledgement use modified partisan call transmitting message ensure continue redeliver message remote node acknowledges ensure partition resolved message eventually delivered able fulfill reliable broadcast provide example modify call message forwarding ask message acknowledgement call specifies message need acknowledged using ack true tuple optional argument forward message list foreach fun n manager forwardmessage n gossipchannel module broadcast id serverref message ack true end membership membership mynode adding message acknowledgement direct mail protocol performs single message transmission peer ensure able recover message omission failure network partition heals omission fault stop occurring provided reliable unicast mechanism partisan retransmit deduplicate message based message identifier shown using ack true option counterexample unresolved omission fault however quickly discover random testing may enough network partition heal consider following execution network partition recover continuous retransmission result omitted message another generated test fails due unresolved message omission verifying mailbox sent received verification mailbox failed missing received postcondition result false command proppartisanreliablebroadcast checkmailbox resulting trace showing even retranmission dropped message sufficient partition heals parrhesia parrhesia dropped broadcast receiver parrhesia parrhesia forwardmessage parrhesia undefined demersdirectmail broadcast receiver parrhesia parrhesia forwardmessage parrhesia undefined demersdirectmail broadcast receiver parrhesia parrhesia forwardmessage parrhesia undefined demersdirectmail broadcast receiver parrhesia parrhesia forwardmessage parrhesia undefined demersdirectmail broadcast receiver parrhesia parrhesia dropped broadcast receiver parrhesia parrhesia dropped broadcast receiver parrhesia parrhesia dropped broadcast receiver parrhesia parrhesia dropped broadcast receiver parrhesia parrhesia dropped broadcast receiver leaving command checkmailbox valid counterexample unrealistic test demonstrates assertion fails due fact partition resolved resolve consider alternative scheduler partisan assumes partition heal finite time discus detail scheduler demonstrate usage testing counterexample crash failure assuming system suffer network partition finite length soon discover acknowledgement mechanism enough system also consider possibility crash failure consider case node buffered message retransmitting message crash transmitting node prevent message ever delivered destination short acknowledgement sufficient resilient generalomission failure direct mail protocol however acknowledgement sufficient robust crash failure node omission fault demonstrate use finite fault scheduler partisan ensures fault exist finite time execution resolving fault either crashing faulted node healing performing final assertion demonstrate usage finite fault scheduler schedulerfinitefault faultinjectiontrue bincounterexamplefindsh running quickly identify another counterexample counterexample demonstrates finite fault enabled sufficient node partitioned send sends kept outstanding retransmitted duration experiment node crashed prior receiving acknowledgement send relates case faulty node transmits message receive acknowledgement ultimately crashing attempt demers et al antientropy demers et al antientropy performs pairwise exchange message synchronize two replica originally designed replica repair clearinghouse system antientropy node operate possible three mode pull one node request content another b push one node push data store content another c pushpull twoway exchange performed modern implementation algorithm node would exchange either checksum message identifier would used identify difference data object would result transmission data object implementation simplicity demonstrate protocol transmit entire content database exchange implementation use pushpull algorithm widely used implementation rumormongering today since implementation antientropy quite different implementation direct mail let u spend time walk assume toplevel api containing broadcast checkmailbox function let u look initializer sure initiate callback schedule periodic exchange schedule antientropy scheduleantientropy periodic function private scheduleantientropy interval erlang sendafter interval module antientropy timer fire perform following action transmit message push message b reschedule timer handleinfo antientropy state membershipmembership state manager manager mynode partisanpeerservicemanager mynode get message ourmessages ets foldl fun id message acc acc id message end module forward random subset peer antientropymembers selectrandomsublist membership membership gossipfanout list foreach fun n manager forwardmessage n gossipchannel module push mynode ourmessages end antientropymembers mynode reschedule scheduleantientropy noreply state another node receives push respond pull message containing message incorporated incoming message state handleinfo push fromnode theirmessages state manager manager mynode partisanpeerservicemanager mynode encorporate message process see list foreach fun id serverref message case ets lookup module id forward process partisanutil processforward serverref message store true ets insert module id serverref message ok ok end end theirmessages get message ourmessages ets foldl fun id serverref message acc acc id serverref message end module forward message back sender lager info p sending message node p node fromnode manager forwardmessage fromnode gossipchannel module pull mynode ourmessages noreply state handle pull message process incoming message store handleinfo pull fromnode message state process incoming list foreach fun id serverref message case ets lookup module id forward process partisanutil processforward serverref message store true ets insert module id serverref message ok ok end end message noreply state implementation complete use failure model identify counterexample schedulerfinitefault faultinjectiontrue bincounterexamplefindsh clear antientropy resilient message omission crash failure given message higher probability reaching node transmitting message peer prior crash therefore ensuring message ultimately received final recipient transitivity antientropy process however original model fails time take happen reduce latency broadcast attempt demers et al rumormongering demers et al rumormongering protocol designed around theory epidemic protocol design message sent recipient immediately continuously reforwarded node seen message enough time factor level resilience system desire based theory implementation protocol reforward message node seen message least build upon direct mail implementation earlier using part antientropy implementation alter original broadcast include origin node message also choose send message random subset peer forward random subset peer antientropymembers selectrandomsublist membership membership gossipfanout list foreach fun n manager forwardmessage n gossipchannel module broadcast id serverref message mynode end antientropymembers mynode next modify behavior receive message receive message seen forward random subset peer excluding peer received message handleinfo broadcast id serverref message fromnode state membershipmembership state case ets lookup module id forward process partisanutil processforward serverref message store true ets insert module id message forward peer manager manager mynode partisanpeerservicemanager mynode forward random subset peer except got antientropymembers selectrandomsublist membership membership gossipfanout list foreach fun n manager forwardmessage n gossipchannel module broadcast id serverref message mynode end antientropymembers mynode fromnode ok ok end noreply state implementation complete run new implementation failure model schedulerfinitefault faultinjectiontrue bincounterexamplefindsh however still run issue purely asynchronous send source network partition message may ultimately delayed final destination message omission failure implementation still yielding counterexample robust implementation reliable broadcast seen yet minimizes latency send optimizing fanout attempt achieve reliable broadcast way achieve stronger guarantee rely form consensus
104,Lobsters,erlang,Erlang development,The Forgotten Ideas in Computer Science,https://www.youtube.com/watch?v=-I_jE0l7sYQ,forgotten idea computer science,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature joe armstrong keynote forgotten idea computer science code beam sf youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature joe armstrong keynote forgotten idea computer science code beam sf youtube
105,Lobsters,erlang,Erlang development,The Mess We're In,https://www.youtube.com/watch?v=lKXe3HUG2l4,mess,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature mess joe armstrong youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature mess joe armstrong youtube
106,Lobsters,erlang,Erlang development,Obfuscated Erlang,https://ferd.ca/obfuscation.html,obfuscated erlang,obfuscation late promise learn erlang look like gist look like running work bitbucket version io protocol version version way erlang hot code loading work need good later never know use conclusion title nt say conclusion terrible code,obfuscation late promise long showed various people consider one twisted bit obfuscated erlang written bit year showed bunch erlang people back erlang user conference sweden back promised write blog post explaining wrote promptly deferred later one brave act procrastination decided finally put whole thing together writing new learn erlang chapter formatting older one publisher work code see something wrote still working erlang solution ltd work place called bloom digital platform still erlang working esl would spend quite time traveling around world go teach course erlang different people business include share long airport waiting time long pause hotel without wifi access bus ride took time fun challenge write messiest erlang code possible using feature mostly unique language look like look like alternatively gist module obfuscation compile exportall define swap b b define module define v define p define q define define define define ooo lll l l l integer l l lll define l l l ooo lll atom define tuple define define according many haskellers type signature represent sufficient documentation thus provided type signature main function program hoping selfdescribing nature type enough enlighten reader code purpose inner working best regard ferd spec main main p q main p atom q main p bin q p bin q p p fun q p p p fun q p p p fun q p p p fun q p p p fun q p p p fun q p p p fun q p p p fun q p p p p ubry rwby q q q q q p p p fun q p n n q q p p p ugy swap r r ebbyoe q q q q q q p n n q q q p p p fun q p p p agrbu swap g vtkh og ur q q q q p p p vqtfr arnrzgn hn ul bg q q q q q q p n n q q q p p p p yvf sylnarl q q q q q q p n n q q q p p p xppyv q q q q q p n q groupleader p q iorequest self p q putchars unicode p q fun p b q p fun erlang q p b q end p q p q p q p q p b q fun p q p p p fun q p q q q p b q end way skip end info define var c op andalso op var c char op var c char op andalso op var c char op var c char nil op var c clause var c op define clause nil var acc var acc nil clause con var x nil tuple var con var b nil tuple var con con var x var b nil nil clause con var con var b var define code function clause var l call atom var l nil function clause var l something completely different something completely different something completely different something completely different something completely different something completely different something completely different something completely different something completely different right color scheme scrolling past section feel like matrix screensaver nil v nil con match h tuple p con l var e r con n var u b nil e e call r l n atom g c con var r l con f e r tuple con c n nil n con h nil w nil nil con call h atom e con e x op c n call b e u remote e atom f r list c atom p reverse con r g var h learning nil p u r var p cabbage b nil e nil nil con function n con n tuple var var b call c atom var hello joe tuple oh hello robert con click var var f con var b e var b nil nil define function h clause con e b var str nil e con r match var f n fun clause clause andalso op var c char op var c char op andalso op var c char op var c char op var c clause var c var c call remote atom list atom map var f var str define function clause nil nil clause match var con var con var b var r op op rem call atom length var con var b con var call atom var r clause con var con var b var r con var b con var call atom var r clause con var x nil con var x nil p x q isatom p x q bin compile file p module debuginfo exportall binary q ok abstractcode r beamlib chunk p bin abstractcode q b list split p length p r q r q ast erlparse normalise p b ok newbin compile form p ast q module code loadbinary p fake newbin q main p ast q p r q receive exit killed whoa killed b list split p length p r q r q ast aerlparse normalise p code q b ok newbin compile form p ast q module code loadbinary p fake newbin q list keyreplace p r erlparse normalise p q q ok newbin compile form p q spawnlink p fun p q processflag p trapexit true q timer sleep p q main p q end q module code loadbinary p fake newbin q timer sleep p q end nothing p x q x p x q x remove function vital ok gotcha info fun thing write look like running copying compiling module give following result c obfuscation ok obfuscation obfuscation main exception exit killed hello robert hello joe see managed fix bug yes finally click hrm interesting work short story module contains multiple abstract version module us erlang hotcode loading feature conjunction message passing multiple process mechanism available fault tolerance recompile twice starting new process copy looking first one die code get purged vm decode encoded version final text output descriptive longer version thing go dig history private mercurial repo bitbucket go slowly built code version first nt really know get going started following file module obfuscation compile exportall hello robert hello joe see managed fix bug yes finally click main fun fun fun fun fun fun fun fun fun hello robert n n hello joe n n see managed fix bug n n yes finally n n click n groupleader iorequest self putchars unicode concat fun b fun erlang b end b fun fun b end first started module simply outputting commented dialogue made confusing using two concat function right use annoying fun syntax allow build various fragment string weird order nesting call allowed make thing complex also went obscure feature rather calling io print code dove io protocol print message manner somewhat annoying read nt feel like erlang enough syntax flexibility simple allow really obscure code form wanted try annoying thing macro good way mess thing right write simple swap b macro add creative way move character bit string around module obfuscation compile exportall define swap b b hello robert hello joe see managed fix bug yes finally click main owncodeops fun fun fun fun fun fun fun fun hello joe fun n n hell swap robert n n fun fix swap h e bug see managed n n yes finally n n click n groupleader iorequest self putchars unicode concat fun b fun erlang b end b fun fun b end owncodeops bin compile file module debuginfo exportall binary ok abstractcode r beamlib chunk bin abstractcode io format pn r macro rather simple interesting owncodeops function nt anything importance wo nt however show simple way show abstract code allowing build module case module recompiling debuginfo using library function load abstract code final binary format erlang file compiled debuginfo contain kind metadata original source abstract code whatever read later case output plan module complex enough keep abstract code somewhere file remove original function trick reintroduce code back version thing still simple needed function wanted strip file add back added little bit code module obfuscation compile exportall define swap b b define module main owncodeops fun fun fun fun fun fun fun fun hello joe ubry rwby fun n n hell swap robert ugy swap r r ebbyoe n n fun fix swap h e bug agrbu swap g vtkh og ur see managed vqtfr arnrzgn hn ul bg n n yes finally yvf sylnarl n n click xppyv n groupleader iorequest self putchars unicode concat fun b fun erlang b end concata concat concatb concat b fun fun b end owncodeops bin compile file module debuginfo exportall binary ok abstractcode r beamlib chunk bin abstractcode r nothing x x x x whole code section copiedmoved another module dynamically compiled called alternatively module possibly alternating behaviour br length rem b r br b r x x l b list split trunc length l l merge list reverse b merge x x merge aa bb bmerge b l l l b rmerge l list reverse b rmerge acc acc rmerge x b xbs rmerge bt b rmerge aa bb str f fun c c andalso c c andalso c c c c n andalso c z c n andalso c z c c c end list map f str ah ha annoying function basically mix letter around mess order also opposite function put back right way passed final text wanted encoding function put inside module make text harder read version condense next version bit show change whole file time next step prepare recompiling module planned move function like outside module giving bit code looking like define module snip hello joe ubry rwby fun n n hell swap robert ugy swap r r ebbyoe n n fun managed move function take whole outputted result abstract format put macro let manipulate ease later define code l l l b rmerge snip b b owncodeops bin compile file module debuginfo exportall binary ok abstractcode r beamlib chunk bin abstractcode b list split length r r ast codeb ok newbin compile form ast module code loadbinary fake newbin see change bit take current module abstract code insert code macro basically module read includes preparsed part run time recompiling module reloading nifty trick work afterwards way erlang hot code loading work compiler wo nt complain fully qualified function call form module function args call look newest version module available look bit see owncodeops called function call module mean order happens call owncodeops module recompiles load new version code called owncodeops resume running older version module fully qualified function call run new version module actually included via macro nifty eh need still easy wanted add next many people still easily read abstract erlang code decided make thing harder taking abstract code abstract code handle problem need compile module twice hey problem worked like module obfuscation compile exportall define swap b b define module main main atom main bin owncodeops bin fun fun fun fun fun fun fun fun hello joe ubry rwby fun n n hell swap robert ugy swap r r ebbyoe n n fun fix swap h e bug agrbu swap g vtkh og ur see managed vqtfr arnrzgn hn ul bg n n yes finally yvf sylnarl n n click xppyv n groupleader iorequest self putchars unicode concat fun b fun erlang b end concata concat concatb concat b fun fun b end define code function clause snip var b var b define function clause var str snip var f var str define function clause snip var x nil owncodeops x isatom x bin compile file module debuginfo exportall binary ok abstractcode r beamlib chunk bin abstractcode b list split length r r ast erlparse normalise b ok newbin compile form ast module code loadbinary fake newbin io format owncode main ast owncodeops r io format aaaaan receive exit killed io format b list split length r r ast aerlparse normalise code b ok newbin compile form ast module code loadbinary fake newbin io format pn io format list keyreplace r erlparse normalise ok newbin compile form spawnlink fun processflag trapexit true timer sleep main end module code loadbinary fake newbin timer sleep end nothing x x x x ok tricky part new evolved function called first time module called obfuscation main give owncodeops arg arg atom work exactly way previous one except call erlparse normalize args convert abstract erlang code true form case transforms abstract code abstract code correct abstract code function clause bit different previous one take abstract code new module pass new call module main ast one call owncodeops ast resolve second function clause receive expression nothing yet run never catch message instead go timeout step look function replaces correct one recompiles code however loading decide spawn new process linked run main args third time trapping exit reload module sleep bit three level deep face inception work hotcode loading quirk little bit concurrency make thing work new process spawned linked trap exit know parent dy receives message new module version loaded cause purge new process stuck receive expression old process dy code purged exit message sent new process new process run third compiling finishing assembling part required whew part assembled initial code unswaps string concatenates output finally run spare snippet got iteration module add even layer abstract code abstract code abstract code good later adding bunch ugly abstract parse tree decided finally start making syntax harder read help simple macro module obfuscation compile exportall define swap b b define module define v define p define q define main p q main p atom q main p bin q owncodeops p bin q p p fun q p p p fun q p p p fun q p p p fun q p p p fun q p p p fun q p p p fun q p p p fun q p hello joe q p p p ubry rwby q q q q q p p p fun q p n n q q p hell swap q robert q q q p p ugy swap r r ebbyoe q q q q q q p n n q q q p p p fun q p fix swap h q e bug q q p p p agrbu swap g vtkh og ur q q q q p see managed q q q p p vqtfr arnrzgn hn ul bg q q q q q q p n n q q q p yes finally q q q p p p p yvf sylnarl q q q q q q p n n q q q p click q q q p p p xppyv q q q q q p n q groupleader p q iorequest self p q putchars unicode concat p q fun p b q p fun erlang q p b q end concata p q concat p q concatb p q concat p q p b q fun p q p p p fun q p q q q p b q end define var c op andalso op var c char op var c char op andalso op var c char op var c char op var c integer clause var c op define rmerge clause nil var acc var acc clause con var x nil tuple var var b tuple var con var x var b clause con var con var b var define code function clause var l call atom var l function clause var l match tuple var var b call atom rmerge var l tuple nil nil call atom op call remote atom list atom reverse var var b function tuple var var b call atom rmerge var tuple con var var con var b var b define function clause var str match var f fun clause clause andalso op var c char op var c char op andalso op var c char op var c char op var c integer clause var c var c call remote atom list atom map var f var str define function clause nil nil clause match var con var con var b var r op op rem call atom length var integer integer con var b con var call atom var r clause con var con var b var r con var b con var call atom var r clause con var x nil con var x nil owncodeops p x q isatom p x q bin compile file p module debuginfo exportall binary q ok abstractcode r beamlib chunk p bin abstractcode q b list split p length p r q r q ast erlparse normalise p b ok newbin compile form p ast q module code loadbinary p fake newbin q main p ast q owncodeops p r q receive exit killed b list split p length p r q r q ast aerlparse normalise p code q b ok newbin compile form p ast q module code loadbinary p fake newbin q list keyreplace p r erlparse normalise p q q ok newbin compile form p q spawnlink p fun p q processflag p trapexit true q timer sleep p q main p q end q module code loadbinary p fake newbin q timer sleep p q end nothing p x q x p x q x p q ok ugly mess see obscured thing bit needed next step add macro pretty much everything possible make thing harder played white space comment make macro definition bit harder read giving friendly face beginning final module also used atom form weird character represent function name making thing yet harder understand peppered comment mock haskell fun formatted abstract code one large erlang fun ugly code work built never know use conclusion title nt say conclusion earlier year euc obfuscated erlang contest hoped would one could show code held long never contest like think default yeah funnily enough terrible code one module fun writing purely explorative nature way us unique feature language hope least enjoyed reading uglyass obfuscation module work nice day
107,Lobsters,erlang,Erlang development,"Search erlang & efene code by pattern matching code with ""holes""",http://marianoguerra.org/posts/erplorer-search-erlang-and-efene-code-by-pattern-matching-the-ast.html,search erlang efene code pattern matching code hole,experience generating erlang ast walking ast tree efene erlplorer efene implemented,one day weird reason looking data structure would allow pattern match quick without confused existing data thought nobody would tuple inside one item tuple nt sure nt first time wanted search code structure text mean structure may want search stuff like call function module argument argument specific value tuples specific number item first item given atom guess get idea want match expression structure text formatting new line spacing also value important would like match expression place given experience generating erlang ast abstract syntax tree walking ast tree parse transforms macro magic efene decided give try result worked year later decided write blog post erlplorer search src erl decode module type value error f localmember name pid pid pid name localmember name pid pid tid oid op tid oid read tid oid write tid oid queued op tid oid queued op tid sym next sym welp yes erlplorer command line tool built efene allows search erlang efene code providing expression hole first argument erlang expression case one item tuple holding item tuple weird looking variable specially named variable erlplorer interprets match ast node nt care start variable match variable name code see searching place match item tuple ignoring place erlplorer search src erl many result show use meta variable pattern matching let search item tuples thing place erlplorer search src erl false false false search identity function erlplorer search fun end src erl fun end fun v v end fun end fun l l end fun old old end place add something erlplorer search src erl n n place add thing erlplorer search src erl sz sz get idea implemented wrap expression passed function compile module erlang ast extract ast body dummy function abstract ast take ast erlang data generate ast compiled generate erlang ast need put ast pattern match position pattern match ast node walk erlang asts yeah meta many ast reference example worth many word fake line code supposedly parsed erlparse abstract foo hi foo hi take care two thing var must match ast node var name act var bound first match pattern matched successive match var start compiled actual var behave var pattern match use pattern match compile abstracted ast module function pas load compiled module parse file passed last argument walk parsed ast compiled matcher match since ast try pretty print give try let know think p code hack use needed nt judge efene code see project p
108,Lobsters,erlang,Erlang development,Necessity is the Mother of Invention: stateful experiments on AWS Lambda,http://christophermeiklejohn.com/lasp/2018/03/10/serverless.html,necessity mother invention stateful experiment aws lambda,online demonstrated higher scalability orderofmagnitude improvement performance erlang lambda exlam exlam exlam modification distributed erlang lasp problem,january presented result european commission project called syncfree tasked largescale evaluation lasp programming system evaluation spent eur running largescale experiment amazon demonstrating runtime system programming environment could scale node fully replicated crdt data store using application scenario rovio entertainment written result paper ppdp available online running experiment clearly expensive multiple run cluster machine amazon cloud computing environment using apache mesos subdivide machine ran container per simulated node running instance lasp database achieve scale wrote new distribution layer erlang runtime system called partisan already adoption industry demonstrated higher scalability orderofmagnitude improvement performance however want get node year next year want node set figure run academic experiment much cheaper graduate student limited funding idea try figure could leverage cheaper computing service like amazon lambda serverless movement running shortlived geodistributed application scenario erlang lambda exlam start forked jesse schoch aws elixironlambda project exlam build upon way exlam work following aws lambda compatible nodejs project wrap installation erlang virtual machine relxgenerated release erlang elixir project bundled zip file deployed aws lambda using lambda command line interface deployment initial launch lambda container file unzipped temporary directory nodejs application invoked nodejs project us childprocess launch erlang virtual machine issue request container http interface exposed elixir application launched exlam modification get exlam working basic deployment erlang application make modification first beam launched distributed erlang enabled beam try launch instance erlang port mapper daemon fails bind socket eaccess crash beam work around create custom inialization script enable distributed erlang avoiding use name sname parameter next problem ran aws container used lambda running older version amazon linux version openssl longer available via amazon rpm repository prevented crypto library loading attempted build version beam statically linked openssl ran problem well beam static linking option openssl requires install file particular path path work discovered two day recompiling redeployment finally found elegant option wrote dockerfile exlam us aws amazon linux image version used lambda build bundle application deployment amazon environment distributed erlang without distributed erlang node communicate one another part work scaling distributed erlang built replacement system named partisan support different cluster topology different network transport allowing actor messaging erlang node box partisan support variety different transport mechanism gentcp different network topology clientserver unstructured overlay partial view spanning tree etc decided could use partisan provide transport message passing node however running aws lambda environment process ability bind port needed another transport message passing various instance running enable communicate one another faciliate wrote amqp backend partisan allows lambda instance connect message broker use outgoing tcp connection bidirectional communication node system node come online register locally generated name membership data structure stored crdt gossiped peer system lambda instance scale node come online register membership gossip membership around node system providing cluster membership visibility node system lasp lasp peertopeer fully replicated crdt database first get update system get update system use aws lambda invocation api submit http event exlam proxied nodejs erlang application exposing http interface getput easy deal antientropy unfamiliar modern eventually consistency distributed databses work antientropy background process run ensure new stale replica kept date instance stopped invocation container eventually killed system ensure stopped replica kept date slightly complicated problematic lambda invocation system take local update dispatch message broker node system determined membership sleep difference second minus propagation time ensure container stay second receipt message node merge change local state keeping state database alive transient function invocation final piece puzzle ensuring invoke lambda rate keep least one instance per region availability zone lambda keep database alive want node scale lambda invocation launch container join membership scale georeplicated database problem many problem still remain point couple obvious state alive long instance state large enough working data set antientropy session node able complete within time container alive failure detection interesting know node alive given node paused particular point eventually terminated due inactivity therefore important system adapt highchurn building experiment highlyscalable geodistributed system thing get expensive quickly ppdp paper argues reason many system evaluated scale difficult expensive run experiment could used dynamodb instance sure thing get expensive quickly managing individual server difficult start using spot instance transient nature instance make difficult draw conclusion system like kubernetes make experiment easier control cost increase fact latest experiment done google cloud platform using container engine ease difficulty running experiment rough calculation term cost operation assume n replica period single day average day month given one object stored database usd n usd keep instance running lambda usd n usd messaging sqs one day antientropy one per object usd n usd messaging sqs membership broadcast every second one notable thing came rube goldberg machine get extremely far running infrastructure free tier alone clever enough bend lambda interesting thing crazy thing done keep cloud computing cost
109,Lobsters,erlang,Erlang development,"The first release of Gleam, a statically typed language for the Erlang VM",https://lpil.uk/blog/hello-gleam/,first release gleam statically typed language erlang vm,gleam like battle proven good sound interesting website github,gleam reached happy first releaseday gleam gleam gleam functional programming language writing maintainable scalable concurrent system enjoy actor based concurrency model durable runtime erlang elixir sound type system ocaml reasonml elm hope enjoy gleam look something like pub enum user loggedin string guest pub fn check user case user loggedin al hi al loggedin name welcome back guest hello please log like gleam support generic algebraic data type module firstclass datatype row typed map enable flexible permissive function interface type system aim provide compile time safety easy refactoring without burdening programmer verbose annotation boilerplate type completely inferred though future release allow programmer add optional type annotation desired gleam compiles erlang run battle proven erlang virtual machine making suitable writing massively concurrent system fault tolerant relatively easy reason erlang ecosystem full great library language application gleam make straightforward import function written beam language use program gleam also aim good citizen library application written gleam used beam language without fuss performance overhead thanks erlang heritage gleam excels low latency high concurrency networked application web application backends database message broker erlang elixir also highly suited embedded application perhaps gleam useful gleam type system give edge rapidly evolving problem space help programmer refactor quickly safely supplying precise useful error message change full applied run browser mobile device graphic library suited gui application nearinstant boot time easy distribution native binary best command line application fast crunching number use statistical analysis good yes think would silly say otherwise perhaps put production yet usable enough pet project toy application sound interesting check website information check project github question want get involved join irc channel gleamlang freenode thanks reading
110,Lobsters,erlang,Erlang development,erlip - Erlang IP Address Library,https://gitlab.com/jimdigriz/erlip,erlip erlang ip address library,,erlang ip address library read
111,Lobsters,erlang,Erlang development,"Elixir protocols, how do they work? the erlang perspective",http://marianoguerra.org/posts/elixir-protocols-how-do-they-work-the-erlang-perspective.html,elixir protocol work erlang perspective,size protocol elixir struct warianoguerra http keybaseiomarianoguerra,start creating new project learn elixir protocol mix new learn module learn cd learn note using erlang elixir never coded elixir searched elixir protocol found official documentation example size protocol added liblearnex file added call hello function try ended looking like defmodule learn moduledoc documentation learn doc hello world example iex learnhello def hello learnsizesize asd learnsizesize learnsizesize end defprotocol size doc calculates size length data structure def size data end defimpl size bitstring def size string bytesize string end defimpl size map def size map mapsize map end defimpl size tuple def size tuple tuplesize tuple end end compiled project mix compile opened elixir shell iex wrote little script decompile beam file erlang warning elixir flavored erlang ahead f filelibwildcard builddevlib beam result beamlibchunks f abstractcode ok abstractcode ac result code erlprettyprformat erlsyntaxformlist ac outpath stringreplace f beam erl filewritefile outpath code end result tree build â dev â lib â learn â consolidated â â elixircollectablebeam â â elixircollectableerl â â elixirenumerablebeam â â elixirenumerableerl â â elixiriexinfobeam â â elixiriexinfoerl â â elixirinspectbeam â â elixirinspecterl â â elixirlearnsizebeam â â elixirlearnsizeerl â â elixirlistcharsbeam â â elixirlistcharserl â â elixirstringcharsbeam â â elixirstringcharserl â ebin â elixirlearnbeam â elixirlearnerl â elixirlearnsizebeam â elixirlearnsizebitstringbeam â elixirlearnsizebitstringerl â elixirlearnsizeerl â elixirlearnsizemapbeam â elixirlearnsizemaperl â elixirlearnsizetuplebeam â elixirlearnsizetupleerl â learnapp result seems consolidates protocol consolidated folder put module ebin protocol implementation named like protocol plus type handle also clear elixir module prefixed elixir also declare protocol inside module protocol belongs module case full qualified name protocol elixirlearnsize let start exploring code generated inspecting main module wrote cleanup unneeded code example module elixirlearn export hello elixirlearnsize size asd elixirlearnsize size elixirlearnsize size see calling function protocol implies calling desired function consolidated module protocol let see elixirlearnsize module module elixirlearnsize export implfor implfor case implfor nil orelse false erlang error elixirprotocolundefinederror exception protocol elixirlearnsize value end size implfor size structimplfor nil implfor struct erlang isatom structimplfor implfor erlang istuple elixirlearnsizetuple implfor erlang ismap elixirlearnsizemap implfor erlang isbitstring elixirlearnsizebitstring implfor nil protocol module elixirlearnsize protocol function size protocol consolidated true protocol impls consolidated elixirmap elixirbitstring elixirtuple exported function protocol simple thing asks implfor function module know handle given argument call module function size implfor size implfor call argument handle case value nt known implementation case raise exception elixirprotocolundefinederror otherwise return module name start checking argument elixir struct underneath map well known key struct contains type struct atom implfor struct erlang isatom struct call struct type argument structimplfor example struct implement protocol implementation simple structimplfor nil start trying find implementation non protocol type mostly erlang type try match using guard check type none match return nil like implfor erlang istuple elixirlearnsizetuple implfor erlang ismap elixirlearnsizemap implfor erlang isbitstring elixirlearnsizebitstring implfor nil got module handle protocol function type let see implementation elixirlearnsizebitstring size string erlang bytesize string elixirlearnsizemap size map erlang mapsize map elixirlearnsizetuple size tuple erlang tuplesize tuple got basic call dispatch sequence let try adding two structs implement protocol see work added two structs liblearnex module defstruct name john age defmodule user defstruct name john age end added call function def hello learnsizesize asd learnsizesize learnsizesize learnsizesize user age name john learnsizesize learn age name john end implemented protocol size structs defimpl size learn def size learn learnage end defimpl size user def size user userage end compiled mix compile inside iex pasted script let see changed hello world function look like hello elixirlearnsize size asd elixirlearnsize size elixirlearnsize size elixirlearnsize size age name john struct elixirlearnuser elixirlearnsize size age name john struct elixirlearn confirms elixir structs map special struct key checking generated file new file user struct elixirlearnusererl struct defined inside elixirlearnerl module code relevant struct nt anything specific protocol implement module elixirlearnuser export struct struct elixirlearnuser age name john struct elixirenum reduce struct elixirlearnuser age name john fun map update end almost code inside elixirlearnerl struct show struct two constructor one without argument return struct default value field one merges argument default value let see changed consolidated protocol module structimplfor elixirlearnuser elixirlearnsizelearnuser structimplfor elixirlearn elixirlearnsizelearn structimplfor nil struct type return module protocol implemented let see implementation elixirlearnsizelearnusererl size user case user age erlang ismap erlang error badkey age age end elixirlearnsizelearnerl size learn case learn age erlang ismap erlang error badkey age age end summary elixir protocol compiled module whose content consolidated dispatch logic logic created getting defimpl statement adding function clause function target type elixir struct clause function target type type function implfor return module protocol implementation provided type protocol function asks module via implfor call given argument guessing module indirection must allow hot code reloading protocol implementation type independently without requiring also reloading protocol consolidation structimplfor function destructure map nt see trace dynamic dispatch case module loaded protocol implementation known consolidation time need research extra guess logic struct field get age field case learn age erlang ismap erlang error badkey age age end may elixir allows call struct method without parenthesis look field first function name second entirely sure since elixir knowledge basically non existent question correction warianoguerra account http keybaseiomarianoguerra
112,Lobsters,erlang,Erlang development,Why should every process be supervised?,https://medium.com/@derek.kraan2/why-should-every-process-be-supervised-4fbd39c495c6,every process supervised,elixir programmer day elixir programmer night independent software consultant moose code bv,elixir programmer day elixir programmer night independent software consultant moose code bvfollow
113,Lobsters,erlang,Erlang development,The Ideas in Erlang (2010),http://www.erlang-factory.com/upload/presentations/222/ErlangFactorySFBay2010-JoeArmstrong.pdf,idea erlang,,äüöß obj stream endstream endobj obj endobj obj stream endstream endobj obj endobj obj stream f q f endstream endobj obj endobj obj stream x endstream endobj obj endobj obj stream jfif c c yimf j z ˬ pݦ hw sg c v gvk c 㾷 v zj n㚱 cx w eerip e ڐ erڄ r颧 q u ucw j hu xjt lty w j l hէ ћ
114,Lobsters,erlang,Erlang development,An interview with the creator of Gleam: an ML like language for the Erlang VM with a compiler,https://notamonadtutorial.com/an-interview-with-the-creator-of-gleam-an-ml-like-language-for-the-erlang-vm-with-a-compiler-e94775f60dc7,interview creator gleam ml like language erlang vm compiler,tell u little working programming language long first programming language learned think ml language good fit beam vm gleam compare mllike initiative targeting erlang vm alpaca elchemy etc main difference motivated create gleam compile gleam directly beam bytecode kind type system gleam us hindleymilner static typing provide runtime guarantee beyond compilation check type system interact message passing distribution handle message passing feature erlang given thought protocol specification type checking choose rust implementing gleam compiler instead choosing erlangelixir etc rust good language implementing programming language kind feature plan add gleam future inspired specific language recommendation would give someone want start writing first programming language,tell u little working programming language long professionally web programmer last year hobby project largely compiler one form another two popular one dogma elixir angry error message compiler exfmt elixir slightly prettier elixir formatter last year focusing gleam ml inspired statically typed language erlang ecosystemwhat first programming language learned first language attempted learn c though experience nothing youtube video make much progress discovered online version mit introduction computer science worked way python first program successfully learnt finishing course discovered ruby became daytoday language introduction world web dev professional programming haskell really shaped think solving problem codewhy think ml language good fit beam vm family share lambda calculus core discarded various bell whistle individual language process type class module functors etc strikingly similar semantics given shared semantics think take much loved type system ml language proven value beam vm create language best least lot fun gleam compare mllike initiative targeting erlang vm alpaca elchemy etc main difference motivated create gleam think gleam subtly different outlook project focused using learning ml enhance beam rather creating actual ml language thinking resulted design difference simple interop direction autocurrying effect system curly brace based syntax erlang style module systemi glad multiple project working area gleam fails one project manages build healthy community still happy want one succeed use real worlddo compile gleam directly beam bytecode gleam compiler full rewrite previous version compiled beam bytecode via core erlang intermediate representation erlang compiler current version compiles regular erlang source code prettyprinted nice advantage providing escape hatch people longer wish use gleam enabling erlangelixiretc project use library written gleam without install gleam compilerwhat kind type system gleam us hindleymilner gleam us hindleymilner type system fairly standard implementation algorithm w one slightly unusual addition row type used represent record erlang map module making polymorphic way believe fit way use map module erlangelixirdoes static typing provide runtime guarantee beyond compilation check runtime type erased runtime check nice performance make calling gleam erlang easier mean way automatically handling incorrect type annotation calling erlang gleamif unruly unreliable erlang function wish call gleam standard library provides module handling dynamically typed data used handle return value safely runtimehow type system interact message passing distribution handle message passing feature erlang given thought protocol specification type checking currently good solution typed message passing development currently focused building runofthemill part language rather introduce flawed stopgap solution later need replaced opted first class support beam low level concurrency primitive used via erlang ffion hand otp behaviour genserver implemented using gleam first class module system enough start writing otp application using gleam todaywhy choose rust implementing gleam compiler instead choosing erlangelixir etc gleam started little experiment elixir fairly quickly shifted erlang december realised going refactor type inference module fairly major fashion order correct mistake design typer easily complex part compiler accrued lot technical debt learnt iterated language feel confident refactoring especially without static type system guide mei decided full rewrite compiler would give chance produce better application without mistake first version using statically typed language would enable refactor easily future picked rust roughly month new compiler roughly feature fewer bug le tech debt also considerably fasteris rust good language implementing programming language yes think type system sophisticated robust enough take refactorings would bested erlang version complete relatively little stress fewer bug tooling documentation library delightful community exceptionally friendly helpfulas nice little bonus performance rust improved user experience somewhat compilation faster longer noticeable lag caused erlang virtual machine booting loading various moduleshowever certainly perfect language compiler implementation rust linear type system mean need garbage collector frustrating experience learning write code type check resulting code quite verbose speculate opted use ocaml instead type inference code would half size currently isi quite sure someone rust experience could make lot code concise remove unnecessary memory allocation today performs well difficult modify overall happy decision use rustwhat kind feature plan add gleam future inspired specific language two main feature asked typed message passing enquired form adhoc polymorphism like haskell type class think type class good fit gleam though perhaps something like ocaml proposed implicit module system could worth exploring either way long time start design experiment plenty beforehandi like enhance atom represented type level currently say value atom would useful could say value atom ok atom error function take atom atom atom could also extended create polymorphic enum variant though unsure whether make sense well gleam existing predeclared enumsit could fun alternative backends compiler compile javascript native binary allowing gleam used cloud function command line tool application beam le suiteda much mundane feature interested record punning found javascript haskell would nice able write thislet name score playerinstead oflet name name score score playerhowever syntax already taken tuples something would need change u featurewhat recommendation would give someone want start writing first programming language write lot code language writing compiler solve lot simple problem compile mind work different feature would interplay might work hood writing compiler take lot time experimentation learning build confidence language design better changing syntax one file fake code take second compiler may take many hour worse still changing semantics language compiler could take day week pay get design right first
115,Lobsters,erlang,Erlang development,Mid-air airplane repair: Troubleshooting at WhatsApp,https://www.youtube.com/watch?v=xi-ixFPjNpc,midair airplane repair troubleshooting whatsapp,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature maxim fedorov midair airplane repair troubleshooting whatsapp code beam sf youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature maxim fedorov midair airplane repair troubleshooting whatsapp code beam sf youtube
116,Lobsters,erlang,Erlang development,Operable Erlang and Elixir,https://www.youtube.com/watch?v=OR2Gc6_Le2U,operable erlang elixir,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature fred hebert operable erlang elixir code beam sf youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature fred hebert operable erlang elixir code beam sf youtube
117,Lobsters,erlang,Erlang development,Testing the Hard Stuff and Staying Sane,https://www.youtube.com/watch?v=zi0rHwfiX1Q,testing hard stuff staying sane,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature john hughes testing hard stuff staying sane youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature john hughes testing hard stuff staying sane youtube
118,Lobsters,erlang,Erlang development,Luerl: Lua in Erlang,https://fosdem.org/2019/schedule/event/luainerlang/,luerl lua erlang,luerl lua erlang luerl introduction emphasizing tradeoff scripting skin top beam ecosystem speaker attachment link,luerl lua erlang luerl introduction emphasizing tradeoff scripting skin top beam ecosystem luerl implementation standard lua written erlangotp lua powerful efficient lightweight embeddable scripting language common game iot device machine learning scientific computing research luerl vm mixture interpreting lua vm instruction using erlang directly implement function call use erlang function luerl augmented cope wide range different domain creating customized language sharing syntactical framework speaker attachment link
119,Lobsters,erlang,Erlang development,GRiSP 2 – Erlang and Elixir on metal,https://www.kickstarter.com/projects/peerstritzinger/grisp-2,grisp erlang elixir metal,funding period,funding period feb apr day
120,Lobsters,erlang,Erlang development,Embedded Elixir with Nerves,https://www.youtube.com/watch?v=IVCQvcCEjkU,embedded elixir nerve,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature greg mefford embedded elixir nerve code beam sto youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature greg mefford embedded elixir nerve code beam sto youtube
121,Lobsters,erlang,Erlang development,Introducing the Erlang Ecosystem Foundation,https://codesync.global/media/introducing-erlang-ecosystem-foundation/,introducing erlang ecosystem foundation,,thursday evening keynote code beam sf hear newly formed erlang ecosystem foundation talk jose valim peer stritzinger fred hebert miriam pena francesco cesarini sharing journey goal foundation waited erlang ecosystem foundation goal grow support diverse community around erlang elixir ecosystem encouraging continued development technology open source project based onaround runtime language
122,Lobsters,erlang,Erlang development,Spot The Discrepancies with Dialyzer for Erlang,http://tech.adroll.com/blog/dev/2019/02/19/erlang-dialyzer.html,spot discrepancy dialyzer erlang,spot discrepancy dialyzer erlang start using dialyzer huge project never applied erlangotp realtime bidding platform dialyzer introduction dialyzer run dialyzer use dialyzer goal metric datadog warning file number warning persistent lookup table plt organizing work jira cli keeping discrepancy bay hackweek hackweeks ci addition new dialyzer warnigns buildkite caveat caching plts enjoy building highquality largescale system roll u,spot discrepancy dialyzer erlang written brujo benavides february dialyzer great tool validate erlang code might slow development process devs applying huge codebases constantly particularly code never analyzed article answer big question start using dialyzer huge project never applied minute read continuing series article usage erlangotp build realtime bidding platform would like show added dialyzer ci pipeline main erlang application realtime bidding server created way existed performing task equivalent dialyzer easy also time consuming recently started using manage project part process decided finally deal bit technical debt course easy run dialyzer code remove warning started approximately warning deal main repo dependency tackled incrementally let walk introduction begin talk little bit dialyzer important use dialyzer dialyzer discrepancy analyzer erlangelixir code check application find discrepancy definite type error code become dead unreachable programming error unnecessary test among thing run dialyzer dialyzer run command line one several tool shipped erlangotp day far common run ie dialyzer use dialyzer dialyzer warn error dialyzer emits warning something code sure bug see bug finding stuff paragraph go back story goal able consistently reduce number discrepancy time without altering development speed metric goal mind established plan attack since improve measure first step instrument number dialyzer warning could keep eye hopefully watch go zero eventually use datadog realtime metric may considered severe misuse tool decided write simple bash script using datadog agent report number warning found dialyzer idea provide nice way visualize progress relative goal stated important question popped find number warning warning file luckily u dialyzer generates file list warning called build rebarprofile otpversion dialyzerwarnings look like call yourothermodule yourfunction call anotherone thing name instrumentation script look like binbash warning codequalitydialyzerdiscrepancies sed builddefault dialyzerwarnings wc l tr space g shell echo warning nc localhost read backwards script report number dialyzer discrepancy echoing content environment variable warning datadog agent listening port machine datadog agent turn ship datadog server content warning variable simply name metric codequalitydialyzerdiscrepancies following count count determined reading dialyzerwarnings file using sed remove empty line piping wc count line cleaning output space tr number warning added makefile target dialyzer follows dialyzer check project dialyzer dialyzer scriptsinstrumentdialyzersh started watching metric noticed something number seemed right general odd spike every turn generated running dialyzer first time ie clean clone project dialyzer run first time project generates persistent lookup table plt including project dependency dependency generate dialyzer warning warning generated already plt get actual number discrepancy want main project need run dialyzer plt already generated makefile target actually look like following dialyzer check project dialyzer dialyzer dialyzer scriptsinstrumentdialyzersh organizing work metric place wanted see go achieve first idea write ticket fix warning removing warning together course impossible imagine reviewing massive pull request using dialyzerwarnings file decided turn ticket use jira organize work come handy cli used write escript group warning creates ticket module paste whole script meaty part buildcommand mod msg binarytolist iolisttobinary jira create noedit overridecomponents boodah overridesummary integertolist length msg dialyzer warning mod overridedescription warning reported time writing n code erlang n msg code main ok output file readfile warningfile warning groupbymod list filtermap fun binary split output n global trim list foreach fun list map fun warning io format done n keeping discrepancy bay course stop development process put everyone work ticket generated script well hackweek one thing roller enjoy working unquestionably hackweeks last one team developer decided remove many dialyzer warning possible code removing original went whooping without affecting performance functionality slightest oh process eliminated ton dead code fixed bug still undetected test week wanted ensure start adding new discrepancy moved ci addition want require developer run dialyzer time although strongly recommended since original goal explicitely included altering development speed added dialyzer ci instead course still warning require clean run dialyzer pull request decided instead reject pr included new dialyzer warnigns use buildkite ci using dialyzerwarnings added new pipeline generates normalized warning list time anything pushed master label run dialyzer upload resulting list warning command make harshclean make dialyzer normalizewarningssh builddefault dialyzerwarnings masterdialyzerwarnings aws cp masterdialyzerwarnings normalizewarningssh script look like binbash set e cp predw sed e pwd g predw sed e sort rm predw basically three step remove current folder path file remove empty line sort place needed update existing pr verification pipeline generate normalize compare list warning one master extending already existing make dialyzer follows verifying newdialyzerwarnings empty buildkite dialyzerfast check project dialyzer dialyzer dialyzer scriptsinstrumentdialyzersh newdialyzerwarnings verifies new dialyzer warning normalizewarningssh builddefault dialyzerwarnings branchdialyzerwarnings aws cp masterdialyzerwarnings comm branchdialyzerwarnings masterdialyzerwarnings newdialyzerwarnings dialyzer check project dialyzer report new warning dialyzer dialyzerfast newdialyzerwarnings caveat keeneyed folk may notice since comparing file linenumbers exactly detecting new warning change alter line number line existing warning reported new one noticed decided fair rule modify module dialyzer warning fix part pr caching plts added dialyzer ci slowed development time working computer still slowed ci time considerably regain lost speed needed avoid recompiling plts run luckily u place plts convenient configurable location adjusted buildkite pipeline like see aws sync exclude include plt nofollowsymlinks make dialyzer aws sync exclude include plt nofollowsymlinks basically synched plts time ci run fast usual detects new warning keep improving code constantly eventually get warning look progress last went week important part effortlessly included dialyzer part development process forever thus increasing quality code significantly hope story inspires project happy proud code enjoy building highquality largescale system roll u
123,Lobsters,erlang,Erlang development,Figuring out a gen_tcp:recv limitation,http://pzel.github.io/2019/02/18/Figuring-out-a-gen_tcp-recv_limitation.html,figuring gentcp recv limitation,figuring gentcp recv limitation setup sending string tcp passive mode data python struct module yet data spelunking call inettcperl implement recv defined source file erlang decodepacket taking step back finding clean solution long man entry inet setopts,figuring gentcp recv limitation suprisingly pernicious framed payload lead otp spelunking erlang gentcp framing setup sending string tcp let say want send ascii string fiat lux erlang process listening side tcp connection big deal right sending application written python might look like usrbinenv import socket sock socketsocket socketafinet socketsockstream sockconnect datatosend b fiat lux socksendall datatosend receiving erlang application usrbinenv escript main ok l gentcp listen binary active false reuseaddr true ok sock gentcp accept l ok string gentcp recv sock io format got string tsn string erlang halt start erlang receiver shell run python sender see receiver emit following receiveescript got string fiat lux see optimistically sent data tcp python app received data intact side important erlang socket passive mode mean incoming tcp data need recv socket second argument gentcp recv sock mean want read however many byte available read o network stack case data kindly provided u one nice chunk success real production application dealing much bigger piece data behooves u test larger payload let try thousand character data update sender receiver follows usrbinenv import socket sock socketsocket socketafinet socketsockstream sockconnect datatosend b socksendall datatosend usrbinenv escript main ok l gentcp listen binary active false reusaddr true ok sock gentcp accept l ok string gentcp recv sock io format got string length pn bytesize string erlang halt run experiment see erlang process indeed get byte let add one zero payload usrbinenv import socket sock socketsocket socketafinet socketsockstream sockconnect datatosend b socksendall datatosend hit first snag got string length aha gentcp recv sock call asked o give u whatever byte ready tcp buffer received tcp streaming protocol guarantee given sequence byte received socket correspond logical message application layer loweffort way handling issue prefixing every logical message tcp socket knownwidth integer representing length message byte loweffort sound like kind thing put place deadline yesterday onward let take initial string example instead sending following sequence byte wire ascii f l u x binary first prefix integer representing size byte append binary giving byte total ascii f l u x binary first byte reach receiver interpreted length next logical message use number tell gentcp recv many byte want read socket encode integer bit use python struct module structpack exactly want encode unsigned integer case bigendian network order usrbinenv import socket import struct sock socketsocket socketafinet socketsockstream sockconnect datatosend b header structpack len datatosend socksendall header datatosend decoding side break receiving two part read byte socket interpret header unsigned int read header byte socket receiving erlang process block much data read side disconnect received byte constitute logical message usrbinenv escript main ok l gentcp listen binary active false reuseaddr true ok sock gentcp accept l ok gentcp recv sock io format got header pn header ok string gentcp recv sock header io format got string length pn bytesize string erlang halt run script see erlang receiver print following got header got string length success apparently application need handle message much bigger kilobyte let see far take approach yet data megabyte ten hundred let find using following loop sender usrbinenv import socket import struct sock socketsocket socketafinet socketsockstream sockconnect l datatosend b l header structpack len datatosend socksendall header datatosend sockclose recursive receive function receiver usrbinenv escript recv sock ok gentcp recv sock io format got header pn header ok string gentcp recv sock header io format got string length pn bytesize string recv sock main ok l gentcp listen binary active false reuseaddr true ok sock gentcp accept l recv sock running lead erlang process crashing interesting message got header got string length got header got string length got header got string length got header escript exception error match right hand side value error enomem enomem look like strange kind error indeed happens get header attempt read data socket let go spelunking find error coming spelunking error enomem first let take look gentcp recv argument seems check inetdb find socket call recv socket ok let check inetdb look like retrieves module information stored via erlang setportdata call grepping call inetdb registermodule reveals multiple module register way among find one particular interest libkernelsrcinettcperl inetdb registersocket module inetdb registersocket module let see inettcperl implement recv hmm passthrough priminet let look seems erlang callchain bottom call ctlcmd wrapper erlang portcontrol sending control data cland need look tcp port driver figure come next case ctlcmd tcpreqrecv enctime time length slight hitch finding source code driver perhaps marco tcpreqrecv help u find rg tcpreqrecv libkernelsrcinetinthrl define tcpreqrecv ertspreloadedsrcprimineterl case ctlcmd tcpreqrecv enctime time length ertsemulatordriverscommoninetdrvc define tcpreqrecv case tcpreqrecv enqasync inetp desc tbuf tcpreqrecv aha inetdrvc come indeed c function responsible actual call sockselect proactively reject recv call requested payload size n bigger tcpmaxpacketsize n tcpmaxpacketsize return ctlerror enomem rbuf rsize tcpmaxpacketsize defined source file define tcpmaxpacketsize thereby explaining weird enomem error solve conundrum possible approach would maintain state receiver optimistically read much data possible try reconstruct logical message perhaps using something like erlang decodepacket take care bookkeeping u taking step back finding clean solution jump writing code let consider position trying read framed message tcp stream done thousand time surely sagely developer whose combined experience encoded otp thought elegant solution problem turn read long man entry inet setopts eventually come across revealing paragraph packet packettype tcpip socket defines type packet use socket possible value raw packaging done packet consist header specifying number byte packet followed number byte header length one two four byte containing unsigned integer bigendian byte order send operation generates header header stripped receive operation header limited packet consist header specifying number byte packet followed number byte yes indeed let try usrbinenv escript recv sock ok string gentcp recv io format got string length pn bytesize string recv sock main ok l gentcp listen binary active false reuseaddr true packet ok sock gentcp accept l recv sock output got string length got string length got string length got string length escript exception error match right hand side value error closed problem solved last error recv call socket closed python side turn tcp framing pattern fact common subsumed otp mere option gentcp socket like know setting option let u sidestep tcpmaxpacketsize check encourage take dive otp codebase find suprisingly easy navigate full great code ever find fighting networking problem using bruteforce erlang please consider question peraphs solved long ago solution life otp chance answer yes
124,Lobsters,erlang,Erlang development,The Curious Case of BEAM CPU Usage,https://stressgrid.com/blog/beam_cpu_usage/,curious case beam cpu usage,benchmarking go v elixir v node beam virtual machine busy waiting microstate accounting msacc burstable performance instance option cowboy test stressgrid vmargs conclusion discussion lobster,benchmarking go v elixir v node discovered elixir running beam virtual machine much higher cpu usage go yet responsiveness remained excellent reader suggested busy waiting may responsible behavior turn busy waiting beam optimization ensures maximum responsiveness essence waiting certain event virtual machine first enters cpuintensive tight loop continuously check see event question occurred standard way handling let operating system kernel manage synchronization way waiting event thread get opportunity run however event question happens immediately entering waiting state coordination kernel wasteful interesting side effect busy wait approach cpu utilization reported operating system becomes misleading since kernel waiting even implemented busy waiting figure cpu utilization result busy waiting beam certainly confirm theory beam busy waiting contributing high cpu utilization benchmarking test reran test modified virtual machine modification enable extra microstate accounting running configure build withmicrostateaccountingextra parameter used msacc collect microstate accounting minute sustained phase connection test aws instance average thread realtime u accumulated system runtime u average scheduler runtime u thread alloc aux bifbusywait checkio async aux dirtycpusche dirtyiosched poll scheduler thread emulator ets gc gcfull nif async aux dirtycpusche dirtyiosched poll scheduler thread port send sleep timer async aux dirtycpusche dirtyiosched poll scheduler stats reveal two utilized thread type poll scheduler poll thread idle checking io state scheduler thread spend emulator running code busy waiting theory confirmed true utilization fact lower cpu utilization reported o another side effect busy wait approach occurs machine fully dedicated running beam case nonbeam kernel thread may receive unfairly low slice cpu time addition running beam cloud burstable performance instance busy waiting may result spending unnecessary cpu credit alleviate beam virtual machine set option regulate amount busy waiting done vm option sbwt sbwtdcpu sbwtdio set none disable busy waiting main scheduler dirty cpu scheduler dirty io scheduler respectively important question whether effect responsiveness busy waiting disabled find ran test limited use case serving http request cowboy web server test run test used stressgrid loadtesting framework generator stressgrid monitor cpu utilization generator avoid skewed result due generator oversaturation test generator stayed cpu utilization used synthetic workload consisting client device client device open connection sends request millisecond one server handle request sleeping millisecond simulate backend database request return kb payload without additional delay result average connection lifetime second average load request per second order compare beam behavior different condition ran test target instance chose instance type following assumption would allow meaningful headroom cpu capacity let virtual machine run without stress virtual machine would nearly exceed cpu capacity would sufficient cpu capacity handle workload causing virtual machine run stress instance type ran test without busy waiting disable busy waiting added following line vmargs sbwt none sbwtdcpu none sbwtdio none looking request per second see handle full target workload request per second becoming saturated request per second busy wait setting effect metric hand busy wait setting show significant impact cpu utilization graph instance type enabling busy waiting cause cpu saturated disabling busy waiting cause cpu utilization scale workload get detailed picture also collected two latency metric along corresponding distribution characteristic time open connection time http response header instance show similar result responsiveness meaningful difference respect busy wait setting latency metric collected instance confirm beam virtual machine working stress latency standard error increasing yet see meaningful difference enabled disabled busy waiting conclusion test found beam busy wait setting significant impact cpu usage highest impact observed instance available cpu capacity time observe meaningful difference performance vms busy waiting enabled disabled must note use case limited serving http request cowboy web server conceivable different scenario would noticeable difference probably busy waiting introduced beam first place running http workload cowboy dedicated hardware would make sense leave waiting place running beam o kernel shared software make sense turn busy waiting avoid stealing time nonbeam process would also make sense use busy waiting running burstable performance instance cloud discussion lobster
125,Lobsters,erlang,Erlang development,Runtime Verification in Erlang by Using Contracts,https://arxiv.org/pdf/1808.07937.pdf,runtime verification erlang using contract,,obj filter flatedecode length stream fb f r ӧ endobj obj filter flatedecode length stream r x u b f f nb lb n r n ο wka
127,Lobsters,erlang,Erlang development,"Property-Based Testing with PropEr, Erlang, and Elixir",https://ferd.ca/property-based-testing-with-proper-erlang-and-elixir.html,propertybased testing proper erlang elixir,propertybased testing proper erlang elixir propertybased testing basic book introduction propertestingcom book hypothesis,propertybased testing proper erlang elixir today publishing new book propertybased testing proper erlang elixir third book second one selfpublished back wrote blog post titled propertybased testing basic intended start short series introductory blog post explaining propertybased testing however soon started mapping content wanted cover found would lot needed would need frameworkspecific since lot propertybased testing automating away lot boring stuff get solid automated test short blog post ideal medium explains book today maybe year half part time free time spent book one year first draft maybe one year half adapting editing pragprog standard along various review since book introduction available online quote explaining decided write finished first book learn erlang told never something distressing spending month year work writing book spending bit free time find putting aside project hobby rewriting text close dozen time reach point even done tired writing topic chose write knew waiting ever wanted write another book decided anyway truly believe propertybased testing something amazing worth learning using fact part reason wanted write book wanted use propertybased testing project work online generally bad idea introduce technology one person team know work better compromise spend time effort writing book never using propertybased testing team know bring project hopefully feel learning worth time well feel making content accessible everyone important one aspect publishing book want negotiate one able keep free copy beer available online copy though book prior edited contains raw content nonedited reviewed missing stuff one critical part going editing hardtounderstand stuff inconsistent terminology unclear explanation plain confusing content pointed fixed text often restructured shuffled around logical book writing process pragprog also added elixir translation code chapter erlang due elixir tooling limitation time writing targeted property want see old site head propertestingcom although recommend book learn get copy book mostly start ground assuming got base knowledge erlang elixir testing experience matter much long done unit testing since found easier compare regular test done property better highlight difference tdd wo nt critical nt need amazing testing either build conceptual level exactly property write one got syntax part place challenging part think property know generate good data set able write good unit test property second section book put practice toy project one see use traditional unit test use property best one see could apply testdriven development tdd approach propertytesting discovering project requirement rest section helping debug property generator shrinking really exciting stuff called targeted propertybased testing latter fully unique proper framework show incredible promise last section book cover stateful testing modelbased approach sound fancy kind making abstract highlevel description system compare sequence operation system according model let write terse amazingly powerful integration system test framework use unit test short book bring knowing nothing property testing able test unit multiple component smooth curve try avoid highly complex description often associated propertybased testing aside got hypothesis objectively friendly text one friendliest resource get property testing think propertybased testing worth learning enough keep draft available free actually pay keep adfree would encourage anyone interested dive course also believe commercial version book much better gone editing review process get copy likely nicer experience well
128,Lobsters,erlang,Erlang development,Sketches of Elixir,https://blog.zdsmith.com/posts/sketches-of-elixir.html,sketch elixir,sketch elixir nim member rail core team phoenix frameio technically possible lfe joxa,sketch elixir friend least respect rare breed elixir programmer never written ruby never professional erlang programmer cut teeth python began working python erlang language learned one looked excuse write addition nim would come little later would also able finagle production makespace impression elixir first several year passing acquaintance erlang ruby syntax never ended writing ruby already happy erlang syntax fairly simplistic understanding elixir language root popularity seem anything value better worse first thing many people mention erlang come syntax unfamiliar confusing least controversial love ruby hand vastly popular erlang significant population find erlang syntax eccentric ruby conventional pleasing hand many reason recommend beam otp erlang runtime system concurrent programming functional programming vastly mainstream might erlang first developed steady stream objectoriented andor web application programmer ruby otherwise taking interest erlang beam would make sense programmer coming ruby background would find elixir palatable mark ruby frame reference elixir creator member rail core team influence manifest several area part visible outside syntax also much greater emphasis programming web including railslike web framework phoenix see much need elixir seemed solution problem mention sort misguided purist attitude towards whole thing year erlang experience back new elixir programmer seemed arriviste maybe tourist barging setting conference new concurrent ruby heralded next big thing erlang ignored even sure enough express opinion part language arriviste discussion forum one frequented josé valim preternaturally patient bdfl elixir language someone posted something along line deal elixir learn instead erlang responded something along line erlang different syntax learn real thing memory josé reply something like bit reductionist also macro embarrassed know josé going see response even know macro elixir fact telling memory looking back actually josé said quote directly think breaking many confidence give brief rundown feature josé cited distinct aside macro early erlang lazy collection robust structured data structs better tooling incl testing framework mix telling remember thinking well sure macro erlang parse transforms know use macro weird used much anyway macro guy fact still use macro much today hand part reply remember part lazy collection structs tooling use constantly started working frameio august many reason really exciting opportunity one almost entire backend application written elixir long time thinking cool day get write erlang living much chauvinist see chance write elixir fulltime modulo defends writing elixir fulltime several month better worse fullyconverted elixir programmer like believe understand language much better also think better understand place beam firmament wider realm programming language programmer erlang background ruby background might even somewhat unusual position comment actual value proposition elixir language erlang ruby syntax erlang robust useful standard library tooling thing ruby syntax elixir complete red herring far superficial least consequential element language like ruby syntax dislike ruby syntax really matter learn move disappears almost immediately perhaps first thing noticed coming elixir erlang base semantics almost identical almost every element erlang language preserved wholesale elixir seen almost entirely series goody piled top reassuring erlanger lose intuition make good code second thing discover reluctant erlangtoelixir convert standard library matter two quality neither one simple coddling rubyists deal quirk erlang standard library indexing inconsistent naming argument first aspect specific module pure elixir innovation relatively obviously wellconsidered big one mentioned stream struct stream lazy collection module lovely precisely nothing unique elixir hood one imago got kind protocol macro elixiry thing presented user simply exactly sort allpurpose highly functional library could want erlang standard library structs baked language struct syntax based map structs often seem result kind oostyle datamethods object expect python would never see erlang tradeoff get certain amount compiletime check attribute access static guarantee might thing would willing trade away erlang datatype minimalism second aspect given opportunity greenfield entire standard library top everything get erlang already turn implement pretty elegant feature instance make sure object function first argument position every single function making possible introduce pipe operator quite simply fucking love pipe relatively speaking extremely assignment elixir functional immutable programmer encouraged syntactically think code series data transformation chained together programmer rewarded extremely terse expressive time scarily close point free structure make debugging rearranging refactoring straightforward reduces parenthesis noise big win le erlangy arbitrary reason distrust erlang syntax make easier write better code third thing discover maybe new syntactic sugar kind nice use keyword argument example elixir approximate pythonstyle positional named function argument f x ztrue syntax f x z true exactly kind unnecessary imposition rubyist trope lookout realize actually sugar extremely idiomatic erlangism tagged value x z true precisely equal x z true existing erlang convention passing optional parameter function easier type read sort thing end quite reassuring sometimes elixir gotten heat read blog post talk phoenix microservices way people talk node air hype untroubled confidence new best way build web apps seems come reading blog post suffering building many system new upandcoming technology always carry penumbra thought leadership startup marketing masquerading howto blog post fact creator language seem understand erlang idiom well tread heavily possible reflect essential erlang imagine could extend took upon design several layer expressiveness top otp model much work elixir ecosystem almost elixir application built otp application model gen concept even extended new behaviour like genstage course simplicity flatness erlang nothing elixir traded away protocol using macro elixir many new form code reuse polymorphism possible idiomatic erlang mean many place magic imported module expanded macro thing obvious reading code said enormously happy working elixir experience writing elixir pleasure better foundation beam otp fact working elixir fulltime renewed interest entire beam ecosystem elixir demonstrated bone erlang valuable applicable enough serve foundation programming language flavor elixir programmer treated ecumenical view entire beam erlang standard library well erlang code path available transparently called elixir expand relationship direction calling elixir code erlang technically possible quite convenient chucking module file src make compiled elixir code transparently available erlang programmer matter lfe programmer far go making tool like mix functionally equivalent far get towards truly languageagnostic workflow running otp application module written lfe elixir erlang get point love see come elixir language community got wonderful momentum right lot interest lot new contributor thoughtful motivated core team opportunity work towards totally integrated beam ecosystem
129,Lobsters,erlang,Erlang development,Fibonacci Algorithms in Elixir Part 2,https://stratus3d.com/blog/2018/12/24/fibonacci-algorithms-in-elixir-part-2,fibonacci algorithm elixir part,another look algorithm time complexity last post wrote various fibonacci implementation unwind said lobster response rewriting algorithm implementation rosetta code popular implementationdave thomas function generates list fibonacci number fastest benchmarking source file result initial run four subsequent run conclusion original algorithm resource,another look algorithm time complexity last post wrote various fibonacci implementation elixir timed implementation generating list first n fibonacci number compared performance characteristic implementation based unwind said lobster response decided revisit fibonacci implementation elixir going update implementatios used last blog post use erlang process store previously computed fibonacci number benchmark implementation fibonacci implementation see much process sped thing rewriting algorithm needed process algorithm store computed fibonacci number chose create single generic genserver could spawn algorithm testing implementation settled fairly straightforward thing special genserver code allows caller specify server want use necessary multiple process running different instance genserver one implementation testing need different fibstore server algorithm different need make sure store fetch fibonacci number correct server defmodule fibstore use genserver def dofib name number fibfun case get name number nil result fibfun number put name number result result result result end end defp get name number genservercall name get number end defp put name number value genservercall name put number value end def maybestart name case genserverstartlink module name name ok pid ok error alreadystarted pid ok end end genserver callback def init ok end def handlecall get number state reply mapget state number state end def handlecall put number value state reply ok mapput state number value end end next needed update existing function use new genserver fetching storing value previous implementation fib function performed actual computation avoid modifying lot code added new function named dofib call existing fib function computation fibonacci number already computed stored genserver instance three new implementation implementation updated implementation fib clause generating number first two fibonacci sequence invokes ensures reuse already computed number one otherwise invoke compute store number defmodule myfib def fibonacci number fibstoremaybestart module enumreverse fibstoredofib module number end def fib def fib def fib number number x fibstoredofib module x yall end end rosetta code much way changed rosetta code algorithm invokes computing fibonacci number us precomputed number exist fibstore process otherwise invokes compute fibonacci number note unlike implementation one must recompute everything generating new number sequence example generating fifth number would able reuse cached fibstore process could make reuse precomputed number without changing way function work defmodule rosettacodefib def fibonacci number fibstoremaybestart module enummap number fn n fibstoredofib module n end end def fib def fib def fib n fib def fib prv prv def fib prvprv prv n next prv prvprv fib prv next end end popular implementationdave thomas implementation benefited fibstore caching precomputed number remains similar original implementation invokes computing number due recursive nature function call made every number must computed implementation able use precomputed number starting point computing new number unlike rosetta code implementation defmodule thomasfib def fibonacci number fibstoremaybestart module enummap number fn n dofib n end end def fib def fib def fib n dofib dofib defp dofib number fun fibstoredofib module number fun end end function generates list fibonacci number fastest bet implementation would still perform better others sure others would fastest rosetta code algorithm able leverage fibstore caching much others already fairly fast algorithm benchmarking reused benchmarking code first blog post see source file benchmarking code since new algorithm maintain state performance first run differ performance subsequent run decided would run benchmark capture performance initial run would run benchmark four time measure performance subsequent run first blog post result initial run ran benchmark capture performance state time microsecond number rosetta code dave thomas mine four subsequent run first run ran benchmark algorithm four time average run time shown table microsecond number rosetta code dave thomas mine comparison average run time original algorithm list size rosetta code dave thomas mine conclusion looking data table clear dave thomas algorithm benefited new process caching computed number surprising due increasing number recursive call original algorithm used computing large number clear run time time complexity original algorithm exponential process caching place time complexity longer exponential take time figure would guess new dave thomas algorithm process caching linear time complexity rosetta code algorithm really benefit new process caching performance characteristic remain run nearly time slower algorithm benefit process caching either ran time slower original algorithm even though process cheap erlang vm local message fast clear overhead caching data separate process taking toll algorithm sending message cheap eventually time take process scheduled receiving message add data cached algorithm must send receive least message every recursion needed compute final number even number already computed two message needed fetch number two original algorithm performed well keep precomputed number process memory reusing necessary caching reduces arithmetic operation needed subsequent call even subsequent call overhead sending receiving two message greater cost computing list fibonacci number least first fibonacci number sequence come generating list first n fibonacci number original algorithm still seems fastest algorithm tested algorithm designed ground specifically generating list first n fibonacci number sequence think take away code written specific task may outperform code general purpose resource
130,Lobsters,erlang,Erlang development,SpawnFest 2018 Winners were Announced,https://spawnfest.github.io/winners,spawnfest winner announced,,tweet spawnfest status event
131,Lobsters,erlang,Erlang development,Ode to Erlang aka my love story,https://pattern-match.com/blog/2018/12/11/ode-to-erlang/,ode erlang aka love story,http patternmatchcomblogodetoerlang,http patternmatchcomblogodetoerlang
132,Lobsters,erlang,Erlang development,SpawnFest repos made public,https://twitter.com/spawnfest/status/1074983265566646272,spawnfest repos made public,,detected javascript disabled browser would like proceed legacy twitter yes
134,Lobsters,erlang,Erlang development,"Partisan: Enabling Cloud-Scale, Erlang Applications",https://arxiv.org/pdf/1802.02652.pdf,partisan enabling cloudscale erlang application,,obj filter flatedecode length stream xڵz ex n q j lz v sp oormx v p ltfox l j j b r cw ڠ
135,Lobsters,erlang,Erlang development,From Datacenter Applications to Planetary Scale Applications,https://www.youtube.com/watch?v=01vedKGBQkQ,datacenter application planetary scale application,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature keynote distributed erlang datacenter application planetary scale application youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature keynote distributed erlang datacenter application planetary scale application youtube
136,Lobsters,erlang,Erlang development,AtomVM: how to run Elixir code on a 3 $ microcontroller,https://medium.com/@Bettio/atomvm-how-to-run-elixir-code-on-a-3-microcontroller-b414773498a6,atomvm run elixir code microcontroller,atomvm run elixir code microcontroller atomvm astarte ble lora nerve grisp blink led elixir hardware dev board software espidf cmake zlib gperf compiling flashing atomvm board configured fred dushin blogpost http githubcombettioatomvmgit compiling flashing elixir code portability supported hardware platform specific code kept library built library contributing fork github good first issue help wanted future,atomvm run elixir code microcontrolleratomvm tiny portable virtual machine allows beam code run microcontrollers le ram atomvm production ready yet might set house fireso mean word flash atomvm get elixirerlang code running itwhyi work full time astarte open source iot platform written elixir also use several embedded board work fun working board realized could interesting use cool concept behind elixir embedded hardware started atomvmso let focus spec moment connectivity builtin ethernet ble wifi bgn several dev board additional lora chipcpu dual core mhzmemory kib sram builtin flash usually mibpower µa deep sleep currenterlang elixir really good handling network packet network connectivity running concurrent process dual core dealing fault embedded software need reliable writing testable software early testing developing way better debugging real hardware enabling rapid development arduino selling point otp designed run low end devicesfor instance already two great project allow elixir code run embedded device nerve grisp however order run need linux powered embedded board raspberry pi nerve custom board mib ram grisp atomvm try overcome limitation design enables elixir development low end device like try use smallest possible amount memory design thanks trick executing code place flash memory usually memory mapped feature left implemented others planned optional instance floating point support might needed use case like also arbitraryprecision integer might needed deviceslast least also standard library stripped save precious flash memoryhow blink led elixirblinking led hello world program physical computing start wait second starting make sure required component hardware dev board led possible buy one le case board onboard led led cable breadboardsoftware erlangotp otp also fine elixir compiler fine espidf cmakezlib devel filesgperfcompiling flashing atomvm boardjust connect board make sure idfpath point espidf directory espidf sdk already configured using macos fred dushin made excellent blogpost git clone http githubcombettioatomvmgit cd atomvmatomvm cd make cd compiling flashing elixir codeblinkex compiled using elixirc elixirc blinkexonce compiled elixirblinkbeam actual compiled modulehowever elixirblinkbeam enough need packed together required module avm fileatomvm cd libsestdlibatomvmlibsestdlib erlc erlatomvmlibsestdlib cd exavmlibatomvmlibsexavmlib elixirc gpioexatomvmlibsexavmlib cd atomvm cmake atomvm cd toolspackbeamatomvmtoolspackbeam makeatomvmtoolspackbeam cd atomvm toolspackbeampackbeam blinkavm pathtoelixirblinkbeam libsestdlib beam libsexavmlib beamatomvm idfpathcomponentsesptoolpyesptoolesptoolpy chip port baud defaultreset hardreset writeflash u flashmode dio flashfreq flashsize detect blinkavmfor sake clarity outofsource build shouldportability supported hardwareright nix system board supported however atomvm designed easily portable platform specific code kept library porting atomvm new operating system new hardware fairly simple atomvm core built library embedded bigger projectatomvm also really dependency requires libc function optional zlib librarysupport platform forthcoming including welcome fork github send pull request good first issue issue good starting point also help wanted issue skilled developer one window port new issue welcome aswell feel free open find bug miss featurethe futuremore feature coming near future fun map better error handling multi core support complete garbage collector rewritefurther development planned implemented future like remote shell support hot code swapping clustering course also post story atomvm soon stay tuned
137,Lobsters,erlang,Erlang development,Erlang/OTP 21's new logger,https://ferd.ca/erlang-otp-21-s-new-logger.html,erlangotp new logger,erlangotp new logger structure otp persistent term storage data flow formatter behaviour flatlog good logging state fact log storage consuming unrelated concern advantage structured logging tying user guide nonrepudiation expanding scope distributed tracing prototype log handler erlang client cqrs metric vegur field log contain rfc conclusion,erlangotp new logger came new logging library erlang called logger come attempt offer builtin alternative long successful project lager seen year battle testing tweaking performance seen article written new logger decided lager came lot performance adjustment structurally speaking new logger pretty fast however know measured indeed case leave question someone else answer believe talk coming spring codebeamsf topic instead post look capability structure logger see new api allows enables project spoiler alert think finally get amazing structured logging hit point come logging flexibility show done along theory good logging structure logger library interesting internal structure necessary know use library useful know want extend extensibility something go bit later since really make library shine logger expose three type component welldefined behaviour interface log filter log handler log formatters three type element stored configuration database configuration database opaque set otp process hold data ets table fast access something lager well could well written using otp persistent term storage could land language starting erlangotp somewhere around case accessing configuration cheap reasonably critical bottleneck important allows logging operation take place closer calling source multiple programming language concurrency rather limited thing want log something soon possible move different thread process main one keep running uninterrupted tends work well scheduling cooperative logger log log formatting writing log costly allowed keep going without much problem logging process thread stalled disk operation program keep chugging along fine case language like erlang elixir safely assume core fully used stuff different cost starter since using process sure thread get copying cost message biggest problem strictly come point view erlang preemptive scheduling guarantee central process necessarily get cpu time need flush data raising process priority done carefully hog scheduler make everything rather unfair case want avoid pattern lot work done single process lot others produce log cheap logger filter format b c output filter b format b e output b filter c put bluntly introducing infrastructural bottleneck system cheaply easily overload central logger spawning lot shortlived process send one log line pretty much backpressure mechanism able anything without dropping log blindly instead want distribute much work possible callsite systematic view better frequent minor disruption hopefully small noticeable would cause overall system imbalance everyone notice long period time bit tradeoff magnitude frequency instability putting logging operation callsite instead get execution flow look like logger filter format filter b format b b filter c output format c output b filter c format filter e output c output logger process essentially left far le work whenever log message example debug log log level set come cost central logger process diagram filter e still need backpressure mechanism possibility shed load dropping log chance far rare since bottleneck nt nearly narrow structural load shedding take place callsite well sticking filter example fix every overload event shedding far fewer log shorter period time logger adopts structure configuration log central store cheap read concurrently everything place rapid dispatching filtering event callsite data flow every log call following step conceptually take place caller process level calling module log checked list global permission know logging go log level module blacklist set nodeglobal scope quickly filter many log system format log argument validated annotated string log format log argument pas io report data structure supported locality log checked process log another parent erlang vm node assume single local node primary nodeglobal configuration fetched list primary filter callback fetched filter executed one return whether stop log dead track stop log return potentially altered log line let another filter decide ignore list log handler fetched log handler following done list handlerspecific filter fetched list filter applied step callback called log handler point gone set level module filter list global filter perhandler filter log past point handler considered clear ready format output formatting left handler otp team created formatter behaviour uniform format could used handler decides let specify custom formatter flatlog redirect output way want whatever backend need handler output terminal may decide format data call output function right instead write disk loggerdisklogh however may decide format log send third party process handle output disk logging likely single process holding file descriptor ensuring none write clash batch log line pagesized payload get written one end processing flow look bit like level module filter global filter handler handler callback handler filter format process output real clever stuff nt need centralized processing nt get logger lager elixir logger library included use central event handler log forwarded calling custom handler new otp logger specific log need sent different backends console disk audit crash log process pay cost request log used one backend held unrelated one cover information flow consider good logger make sense let also tell think make good logging good logging good logging necessarily obvious get right get better logging seen enough terrible useless log know avoid eventually know enough mistake head generally good direction nutshell good logging requires remain nt interpret without strong separation concern log producing log consuming generally easier accomplish structured logging state fact first thing logging clear message content aware whatever state log people debugging system operate whatever say log whether want influence people approach debugging system log say something effect image upload service instead could connect upload service domain ip port reason reason may training user operator either go wild goose chase figure whether image service distrust log message unreliable essentially useless former log may looking friendlier trying offer interpretation generally worse case except right problem exist load balancer local firewall rule crossregion call certificate validation local resource exhaustion socket operator know operator get information dashboard tell upload service healthy log line disregarded unreliable rather valuable one side claim unable connect whereas part system connect fine worst example recall seeing old piece software would report impossibility validate ssl certificate hacked necessarily software became old properly connect online service using newer ciphersuites protocol started tell person entire network compromised possibly call department knowledgeable relative figure thing opaque report rather giving information someone knowledgeable course cater level expertise user careful trying helpful offering guess obfuscating truth may better say certificate validation failed hacked simply nontechnical user would necessarily know hacked bad certificate validation anyway log storage consuming unrelated concern one biggest mistake see various framework tying output format location directly source message sent production consuming log different thing done different context different people treated log production concerned output performance specific retention policy whereas log consuming extracting various type information unpredictable pattern worst offender seen objectoriented project log would stored perclass basis class would instantiate logger would write log file defined class name problem extreme approach play well retention policy want able store keep log various period time depending us developer trying understand thing staging may want log time since dev may need see kind noise data make sense however data probably need stored short period time application user information required support ticket might want store data maybe week give customer day find problem confirm end open support ticket let support ticket escalate level land development team lap give developer time address investigate respond ticket might need week longer relevant log kept day ticket escalation provide insight lowest level data gone legal audit purpose may want store log related configuration change user logins logouts purchase financial transaction possibly want store month many may generated info level level much lower warning error crash log might want long log content let filter redirect log based importance dispatching file disk retention policy logger let set dispatching application go different service want able dispatching logical level within application dispatching another service aggregated everything one feed log aggregation mechanism need log contain information necessary parsing storage case good idea clog code producing log concern bit worrisome see potential log consumer result single function generating log call directly hardly maintainable want single way produce log based log information able dynamically dispatch proper storage mechanism implement proper retention policy get appropriate performance class oo system generate lot log point cause performance issue may fine generate perclass log going various storage point long reaggregated devs use text editor comb log done good reason advantage structured logging need factual log consumed various yetunknown entity need dynamically dispatchable based content logical conclusion log generated generated easily parseable format also humanreadable structured logging two big example structured log using keyvalue pair look bit like levelinfo atmyapp logevent inmyrelmyapp whatcontainerbackup resulterror reason filesystem full containerpath containerscontainersdatacname containerstatusup use data serialization format json providing similar log format level info id myapp log event myrelmyapp containerbackup result error reason filesystemfull container id path containerscontainersdatacname status former advantage working well linebased tool syslog transport grep awk human reader whereas latter make really easy build programmatic tool analyse data little data loss original serialisation really performancecautious may want generate line format hand since essentially output one flat log cheaply spent time serializing everything introduce bunch edge case around serialization http path user requested contains query keyvalue generate properly parseable data instead safer although bit costly approach straight generate report map structs wellknown keyvalue data type language choice erlang might keyvalue pair map map preferable allow much faster efficient filtering various structure let keep performance early validation transformation may wish apply could write log expression erlang starting logger info id somecomponent configchange result error reason unauthorized user id name ferd role member result output default info report id somecomponent reason unauthorized result error user id name ferd role member configchange add custom log formatter using something like sysconfig file kernel logger handler structured loggerstdh formatter flatlog mapdepth termdepth switch using macrobased call automatically inject metadata callsite log includelib kernelincludeloggerhrl loginfo id somecomponent configchange result error reason unauthorized user id name ferd role member get log like extra metadata levelinfo pid atlogchk whatconfigchange userrolemember usernameferd resulterror reasonunauthorized insomecomponent good able get structured log format amenable tooling also still really effective manipulate logger filter tying since seen concern data production storage rotation forwarding formatting might want put fully working solution together using builtin logging facility erlang able something like kernel loggerlevel info logger console logger handler default loggerstdh formatter flatlog mapdepth termdepth disk logger error handler disklog loggerdisklogh config file logserror type wrap maxnofiles maxnobytes x level error formatter flatlog mapdepth termdepth synchronous audit log handler auditlog loggerdisklogh config file logsaudit type wrap maxnofiles maxnobytes x syncmodeqlen handle event synchronously filesyncrepeatinterval fsync change made drop overload control dropmodeqlen ridiculously large queue drop flushqlen ensure pretty much never drop silently burstlimitenable false burst protection overloadkillenable false kill whole node logger keep must filter auditfilter fun myproject state filterdefault stop keep structured log one line formatter flatlog mapdepth termdepth bigger term depth three logging handler defined first one standard output seen far error handler disk basically handler configuration cancel log error level store important error disk file given storage retention policy implicit overload handling overload handling allows thing log burst window memory message queue protection toggling synchronous asynchronous logging based performance since disk writing unpredictable pretty critical feature large system detail overload protection found user guide audit handler last longer retention error log file much shorter rotation period based file count expect custom filter myproject pick choose audit log filter note explicitly disabled overload protection audit log able leave audit trail critical problem prevents action nonrepudiation serious thing notice audit log also require full file synchronisation log every millisecond handler operation synchronous let u log make pretty sure reach form stable storage moving must really get absolute certainty loggerdisklogh filesync auditlog call might want audit log use disk file could instead create audit handler would send logged data structure external service inline prefer forward log disk later point based performance safety requirement hell could perlog basis financial information requires full blocking whereas user logins logouts handled le safety almost flexible enough scary aspectoriented programming aop change execution semantics afar parent told avoid expanding scope distributed tracing even fancier stuff remember touched handler filter made important point stating run within process currently run turn interesting distributed tracing distributed tracing kind cumbersome set application level beyond log metric need set bunch trace id span metadata set starting ending point usually annoying hell people reasonably stick distributed tracing layer beneath application read span information web server middleware add outgoing request similar adapter sdk http client least get span servicelevel scope neat since arguably already span handling middleware level automatically cheaply add support additional subspans based log data wrote small prototype log handler demonstrate based opencensus erlang client library expects may structured log system already respect kind request response log sequence possibly use structure similar get messagepassing system implement cqrs command event command represent demand intended system event represent action taken place following command configure information kernel logger handler opencensus traceloghandler openclosepairs key name open val close val type command event part request response trace start stop namekeys span loggerlevel info one work establishing keyword pair term represent respective startstop event potential field describing name span whenever event pair encountered logging handler automatically open close opencensus span since opencensus us process dictionary integrate fine span declared take following log example ping loginfo type command pingmany loginfo type command genstatem call module ping infinity loginfo type event result loginfo type command genstatem call module ping infinity loginfo type event result case pong pong loginfo type event pingmany result ok text ping working fine ok logwarning type event pingmany result error detail text could get two ping work error badping end nt particularly pretty bit code since log much use demonstrate point call see following zipkin distributed tracing tool choice pretty useful although nt yet opportunity try production system see viable think pretty neat able lift existing logging code suddenly get new visibility going essentially additional cognitive cost metric fan carrying metric log service architecture encourage one fancy thing log line filter remove add specific information log report must use log metric could single logging point map data think loginfo httpresponse status metric init dbstart dbend format response practice call might look like loginfo metric metric since would nt store timestamps literally like previous example get gist nt necessarily know ahead time metric interesting report might databasespecific information full request duration user implementers might important know long formatting take rather merging data ahead time calculating interval might relevant filter used transforms usermetricsfilter event msg report msg metric metric newmetrics dbdelay map get dbend metric map get dbstart metric responsetime map get response metric map get init metric filter old metric map add new value map instead newmsg map merge map without metric msg newmetrics substitute message report event msg report newmsg applying filter existing log line remove information focus user support engineer may need rather large data dump original developer would know make event could produce log entry levelinfo whathttpresponse filter modifies information minimal way might also couple handler extract metric publishes telemetry system statsd prometheus based log feed side note approach tag keywords monotonic timestamps later extract desired interval one cleanest functional way handle metric generation especially true perprocess counter gathering metric specific http request specific transaction handled varied abstraction level opposite would nodeglobal metric easier handle mutable counter one example vegur proxy library contains small http client handle proxying logic must report router know nothing generates internal queue metric keep memory client another one server side connection way server side client called interchangeably without caring metric fit whole picture done metric queue returned part handle proxy logic merge queue expose back router router maintain metric log fill routeselection metric data end router report metric merging known queue extracting desired relevant time interval various key end result rather fast wellscoped set composable data structure allow crosscutting metric reported multiple component without breaking layer abstraction requiring collaboration library would generally advise handle metric log case could reasonable flexibility reasonable us log filter kind scrubbing away stray password session cooky private detail might want avoid could slipped field log contain structured log useful define common field application respect term semantics kind annoying distributed system service use user userid uid id interchangeable manner querying analysing log near impossible log field team genetec adopted decided standardize name type needed description example note iso timestamp timezone information event taken place information available time output substituted try put key first final format log easily sorted fractional portion second millisecond microsecond optionally added timezonethe explicit metadata logger argument used override timestamp automatically inserted logger macro call level enum log level according rfc debug info notice warning error critical alert emergency debugwarningerror automatically generated logger call id uuid unique identifier log line event command parentid uuid unique identifier parent event command allows define hierarchy event build trace useful distributed tracing present let someone hand correlationid uuid unique identifier request log group command allows define family event related initial request user action useful distributed tracing present let someone hand string indicator code call log line emitted module function line class method line filenamescript routine duration integer unit event known duration value let output unit must included time duration avoid using float time unit instead use next smallest integer log enum value defining type information conveyed log line either event command trace eventcommandtrace event denotes something happened command order request given trace value internal log line meant either event command string subcomponent taking action logging data judged useful contain hierarchy myrel mylib otherlib mylibsubcomponent otherlibsomefunctionality category chosen based filtering need may represent domain concern operation string value defining purpose event command took place httpreq rest userinput connection connectionopen connectionclose value arbitrary since value provides context across component may help stick common term result string result given operation reported okerrorexceptiondenied clarify cause bad result followup field detail detail string additional information explaining result timeout privilege level insufficient diskfull invalidoption abc src map map containing information regarding source message request connection src src map field defined table dst map map containing information regarding destination message request connection dst dst map field defined table text quoted text human readable content could load item attempt attempt intint mechanism allowed retry multiple time set counter fraction starting limit attempt would mean final attempt allowed pid integer process identifier given worker resource o pid erlang pid userserviceaactor akkanet highest pid level possible abstraction layer proc integer process identifier o process use higherlevel pid exists also relevant srcdst map name type needed description example note host string domain name computer avoid specifying useless name like localhost port integer port number contacted ip address ip address mac string mac address aa bb cc dd ee ff another set standard adopted concern http request since frequent api call kind name type needed description example note code integer http response code mandatory response result request never managed get leave empty status string http status string ok found bad request humanreadable value supporting returned code may contain useful information case path string url path queried apiwhatever careful include personally identifiable information agent string user agent request window nt client name http library version likely useful server submitted user agent string useful well reqsize integer size request data byte respsize integer size response data byte defined feel free adapt tweak see fit prescriptive likely going work everyone everywhere help organization us log would help library kind easy patch thing fit together using filter showed metric rewriting dynamically costlier letting log go depending volume may want avoid patching thing way also becomes really difficult associate reported log initial location code fact might good idea kind show flexibility logger library conclusion hell yes use new logger get better log system today
138,Lobsters,erlang,Erlang development,Retiring old performance pitfalls,http://blog.erlang.org/retired-pitfalls-22/,retiring old performance pitfall,named fun recursion optimize named fun funwrapped macro list subtraction large operand operator cooperatively scheduled old algorithm efficiency guide optimize list subtraction b make yield large input lookahead bitsyntax matching match context rewrite bsm optimization new ssabased intermediate format,november john högberg erlangotp bring many performance improvement table broad impact affect way write efficient code post like highlight thing used surprisingly slow longer need avoided named fun recursion named fun neat little feature might obvious first glance name variable like free pas another function even return deepfoldl f l fun namedfun elem acc list foldl namedfun acc elem namedfun acc acc namedfun elem acc f elem acc end l cool bit headache compiler create fun pas definition free variable instruction include fun free variable created yet prior otp solved creating new equivalent fun inside fun made recursion surprisingly expensive term runtime memory use otp translate recursion direct function call instead avoids creating new fun case still require recreating fun far le common optimize named fun funwrapped macro list subtraction large operand operator erlang vm appears preemptively scheduled programmer cooperatively scheduled internally native function run monopolizes scheduler return longrunning one severely harm responsiveness system therefore written nearly function style break work short unit complete quickly enough steadily shrinking list function misbehave list subtraction one usually pretty straightforward rewrite function style old algorithm processed second list loop around first list problematic since list long resuming work nested loop often trickier expected case easier get rid nested loop altogether new algorithm start building redblack tree righthand side removing element lefthand side operation tree log n complexity know finish really quickly need care yielding outer loop also nice sideeffect reducing worstcase complexity n log n let u remove warning reference manual efficiency guide worth noting new implementation always faster proposed workarounds fall back old algorithm faster change rolled otp big thanks dmytro lytovchenko kvakvs github writing better half optimize list subtraction b make yield large input lookahead bitsyntax matching optimization pas bitsyntax matching completely rewritten otp take advantage new ssabased intermediate format applies optimization already welloptimized code unlikely see benefit manages apply far case familiar bitsyntax matching operates match context internally mutable object keep track current match position help lot matching complicated pattern zip back forth required saving u match component great matching several different pattern come real handy loop like following trimzero tailbinary trimzero tail trimzero b isbinary b b compiler see tail passed directly trimzero promptly begin bitmatch skip extracting tail subbinary pas match context instead pretty wellknown optimization called match context reuse greatly improves performance applied lot code written mind catch passing match context like maintain illusion dealing immutable binary whenever used nonmatching expression either need convert context equivalent binary admit defeat skip optimization compiler pretty good job prior otp gave bit easily many case trivial example almost funny callswrapper hello tailbinary countones tail simple wrapper prevents context reuse call countones bin bin tailbinary acc tail acc tailbinary acc tail acc acc acc trickier example found string module binrestbinary cont sep case binrest binary asciilist case sep binrest cont sep end snip looking fastpath ascii character ascii know part grapheme cluster thus avoid call unicodeutil particularly expensive function calling per character add quickly first glance might seem safe pas context made difficult returned context mutable change position whenever match succeeds naively converting back binary would give come instead might wondering simply restore position converting back binary obvious thing otp context tracked current position also previous one needed backtracking saved percontext slot mutable heavily reused match clobbered slot needed restore also meant context used passed another function entering trycatch made le impossible apply optimization code requires looking ahead otp position stored outside context need worry becoming invalid making possible optimize case rewrite bsm optimization new ssabased intermediate format
140,Lobsters,erlang,Erlang development,Diving Deeper into Consensus,https://blog.helium.com/diving-deeper-into-consensus-eaf20ddced92,diving deeper consensus,fair play truly decentralized,fair playa big consideration proofofcoverage ensure participant equal chance earning mining reward designed scoring system based quality wireless coverage system prevents people buying increasingly powerful hardware pooling together gain unfair advantageeven though individual purchase multiple gateway cluster gateway form mining pool close proximity one another suboptimal term coverage provided reflected scoreother blockchains continue increase difficulty proof work drive miner constantly invest faster powerful hardwaresince gateway score solely based quality wireless coverage challenge based computation advantage purchasing higher performing hardware component radio frequency transmission unlike computation hardware hard physical regulatory limit change timetruly decentralizedmaking wireless network truly decentralized fair one fundamental design goal guided project accomplish goal needed way reward anyone helping build wireless network infrastructure belonged everyoneblockchain approach achieve consensus depended computation resulted number unintended side effect would work networkproofofcoverage incentivizes participant unique approach mining work directly tied providing wireless coverage fair energy efficient way believe approach result ubiquitous reliable affordable network move internet thing forward enable exciting future
141,Lobsters,erlang,Erlang development,How many functions do you have in your Erlang/Elixir VM?,https://medium.com/erlang-battleground/code-server-erlang-elixir-6faa86206f70,many function erlangelixir vm,going interactive embedded code path boot script system principle inspectinteger inspectalgebra inspectopts inspect,going usual better try understanding challenge boot erlang vm try figure happeningi jump straight answer instead erlang dynamic code loading doc point code server load code according code loading strategy either interactive default embedded interactive mode code searched code path loaded first referenced embedded mode code loaded startup according boot script described system principlesalright mystery solved new function appear evaluate list comprehension second time loaded right needed evaluate first list comprehension print resultlet see observation match hypothesis fun let elixir first let see behavior experienced iex iex length codeallloaded export f mmoduleinfo f f f length codeallloaded export f mmoduleinfo f f f excellent let see function new one actually since module loaded ie code server load individual function load entire module need let see module new one need start new vm course m codeallloaded length m newms codeallloaded m inspectinteger pathtoelixirinspectintegerbeam inspectalgebra pathtoelixirinspectalgebrabeam inspectopts pathtoelixirinspectoptsbeam inspect pathtoelixirinspectbeam iex new module others one required print screen
142,Lobsters,erlang,Erlang development,16 Things I learnt using the BEAM,https://www.youtube.com/watch?v=pR_2289p19w,thing learnt using beam,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature thing learnt using beam erlang solution webinar youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature thing learnt using beam erlang solution webinar youtube
143,Lobsters,erlang,Erlang development,Removing Erlang dead code with Xref,http://tech.adroll.com/blog/dev/2018/10/09/remove-erlang-dead-code-xref.html,removing erlang dead code xref,removing erlang dead code xref erlangotp realtime bidding platform doc dynamically evaluated function xrefrunner dynamically generated code gpb ticket hacktoberfest function exported used externally function exported test legacy code eunit library facade conclusion dialyzer enjoy building highquality largescale system roll u,removing erlang dead code xref written brujo benavides october dead code function used anywhere tends pile big project leave unattended using one underrated feature able detect remove need anymore minute read already written several article blog explaining use erlangotp extensively build realtime bidding platform server among thing system big around long time like big old system contain piece code used anymore clear broken even properly covered test use production erlang piece dead code manifest unused function precise unused export since unused notexported function detected compile time finding unused export big system tough luckily erlangotp already give u tool xref xref cross reference tool used finding dependency function module application release manage project use xref simply running following command xref specified anything xref rebarconfig check entire project perform possible check since big project list warning generates tends long people usually something like configuration xrefchecks undefinedfunctioncalls localsnotused deprecatedfunctioncalls word list report include call function exist undefinedfunctioncalls unused notexported function localsnotused call deprecated function deprecatedfunctioncalls find full list available check doc want notice since last also detected compiler proper warning enabled effective check performed undefinedfunctioncalls fine check run help u original dead code issue take look check performing general undefinedfunctions report result undefinedfunctioncalls without reference actual function call useful go deprecatedfunctions deprecatedfunctioncalls exportsnotused exactly check looking adding exportsnotused list check emit warning function exported used anywhere amazing nobody using caveat using exportsnotused list tell solve least work around dynamically evaluated function xref report warning function exported could find used code fact xref find mean place function actually used actually exist instance xref deal dynamic function call perfectly valid say module look like following one ask module sample export somefunction someotherfunction anargument someotherfunction x called x module call sample somefunction sample xref smart enough detect sample actually used used dynamic evaluation one one way performing dynamic evaluation see others classic dynamic evaluation module function argument using erlang erlang apply module function argument using spawn link erlang spawn module function argument using timer timer tc module function argument supervisor spec childname module function argument permanent worker dynamic side note add xrefwarnings true rebarconfig file xref least print warning dynamic call could parse like one sample unresolved call case soon system becomes slightly bigger prototype start unused export everywhere panic actually way avoid warning come extra benefit use ignorexref ignorexref attribute add module prevent xref emitting warning certain function look like module sample export function dynamically invoked sample ignorexref module someotherfunction go check xref doc otp find mention official attribute ignorexref undocumented feature xref also xrefrunner attribute add module list function want xref complain syntax follows ignorexref module function arity module function using effectively remove warning related function exported dynamically evaluated bonus see example also use place code add documentation stating function expected used dynamically generated code might fan dynamically generated code sometimes way around instance use protocol buffer several place lead u use gpb plugin gpb writing module know used way tell certain function exportedare needed mean run xref get warning unused export generated avoid warning use ignorexref since writing module turn another way use dyslexically named xrefignores attribute rebarconfig basically allows global list function ignore everywhere look like xrefignores mygpbgeneratedmodule somefunction mygpbgeneratedmodule someotherfunction mygpbgeneratedmodule afunctionwithvariousarities way yet ignore function module already wrote ticket requesting maybe tackle hacktoberfest project function exported used externally function exported use shell log remotely server production used external script execute rpc call node stuff like well case encourage use ignorexref add proper comment stating howwhenwhere function expected used pay future promise function exported test different situation seen sometimes particularly people work legacy code function exported used test idea either mock access internal logic otherwise hidden system production first using eunit need export use notexported function test use common test framework require test written outside module test different story think important consider exporting function use test something undesirable general function exported unused detected compiler stated allowing find bug much earlier adding function available production andor stuff done production test simulating real scenario accurately may lead test passing code still work expected still sometimes way around need mock stuff otherwise invisible external world need verify data exposed complex format detect side effect really hard capture scenario ignorexref neat comment wonderful tool avoid surprise frustration future developer finding unused function decide remove library facade finally one scenario need export function actually use within application application library ie building app used dependency system case function constitute facade app used exposed user invoke apps function reported unused export nice write ignorexref xrefignores really nice cover test way avoid warning actually generate warning function exported unused tested run xref test xref using test profile include test module analysis since facade function used warn conclusion xref powerful tool need tweak extract full potential first use right check recommended list xrefchecks undefinedfunctioncalls exportsnotused use ignorexref attribute xrefignores configuration param appropriately identify function intentionally exported unused writing library also consider test analysis using test xref place expect warning reported therefore sure dead code project dead function unused export lot still dead code form unused function clause unused case clause xref detect problem need much powerful tool dialyzer cover article stay enjoy building highquality largescale system roll u
144,Lobsters,erlang,Erlang development,An Elm compiler for the Erlang Virtual Machine,https://kofi.sexy/blog/elm-beam,elm compiler erlang virtual machine,project github background website roadmap writeup go lua erlang hard part supporting domain compiler making good ecosystem putting typed functional language domain mean fun productive practice project overview codecbeam building project erlang virtual machine documentation elm process module elm mean javascript interop otp genserver design implication allows incrementally introduce elm erlangelixir system generating beam codecbeam getting beam without going erlang core erlang beam best elm roadmap writeup love hear elm slack,exploring idea elm compiler produce assembly erlang virtual machine find code project github essay document interesting part project background according website elm delightful language reliable webapps huge fan language goal encourage give try elm helped enjoy writing frontend code many community share experience elm ecosystem focused frontend webapp domain domain focus much make elm tooling documentation community largely coalesce around goal experience elm produce particular effect many folk heard called xisgreatsoweshouldusexeverywhere effect large part small community excited idea elm server though phrase likely mean different thing different people enjoy elm author responds idea roadmap writeup many folk tell elm compile x x thing like people suggesting go lua go ocaml c java scala f haskell c rust nodejs hard part supporting domain compiler making good ecosystem python nice scientific computing thing like numpy scipy whatever backend elm nice frontend ecosystem like html library elm architecture particular code generation putting typed functional language domain mean fun productive practice writing compiler backend like take make project like worthwhile echo idea completely project discussed elm server suggested direction elm team instead fun exploration compiler code generation excited share others perhaps work help someone interested building delightful language reliable web server project overview tree elmcompiler git submodule elm compiler src elmbeam bridge submodule src generate codegen module mainhs elmbeam haskell project major dependency elm compiler beam codegen library wrote called codecbeam integration elm compiler bit untraditional cabal file point file project file git submodule building project result executable take elm file produce file called elmbeam erlang virtual machine many way elm match semantics erlang elixir language feature immutable data structure pattern matching lambda function however similarity run even implementation elm runtime quote documentation elm process module right library pretty sparse example public api process communicate really important ability also something extraordinarily easy get wrong think trend towards erlang style concurrency every process event queue anyone send message internally elm runtime built upon process message seems implementation explicitly inspired erlang design elm programmer recognize design use port elm mean javascript interop order communicate javascript elm application send message much like interprocess communication erlang sending message appportsfromjssend x elm javascript apppid x erlang erlang receiving message appportstojssubscribe x f x elm javascript receive x f x end erlang erlang elmbeam embrace similarity compiled elm application beam module defines otp genserver starting genserver communicating us erlang function standard library see function action following demo genserver design implication since elmbeam commits genserver protocol elmwritten module exist within supervision tree may exciting aspect exploration imagine team spent several year writing software erlangelixir ecosystem time organization developed tooling workflow around erlang virtual machine interested exploring static type offer must forfeit tooling workflow try design project thus far suggests answer hypothetical concern elmbeam allows incrementally introduce elm erlangelixir system elmwritten genserver act like erlangelixirwritten genserver living inside supervision tree application generating beam elmbeam written haskell elm compiler written haskell erlang compiler however written erlang erlang toolchain expose api compiler program must written erlang order make use project decided generate beam file created codecbeam library assembling syntactically valid beam file though elmbeam experiment plan continue supporting codecbeam excited see haskell programmer use create compiletobeam language interested learning codecbeam please refer talk getting beam without going erlang previous version elmbeam compiled erlang intermediate form called core erlang could use erlc fromcore compile core file beam file decided experience would much nicer could generate beam abandoned direction like learn time core erlang please refer blog post core erlang beam best elm fact elm author suggests much aforementioned roadmap writeup ultimately ideal form project like bespoke backend going assembly directly agree many way going beam shortcut similarity erlang elm mean elm fit beam language elm certainly better instance elmspecific garbage collector could use precise strategy erlang natural difference language withwithout exhaustive type information compiletime erlang platform includes native compiler called high performance erlang hipe hipe read beam module produce native program generally run faster vminterpreted counterpart existence hipe support going assembly elm compiler exhaustive type information compiletime elm could create faster densely packed program beam even allows point feel like work elmbeam come end satisfied result exploration ready continue project hopefully found value idea love hear interested continuing exploration join u elmbeam channel elm slack finally want express sincerest admiration project referenced elm erlang particular language large project tend take granted thanks folk involved project spend time energy creating awesome tool use free
145,Lobsters,erlang,Erlang development,10 Lessons from Decade with Erlang,https://medium.com/erlang-battleground/erlang-lessons-fe800c51af4f,lesson decade erlang,higherorder construct sumorest higherorder construct higherorder construct build one article erlang solution opaque data structure hernán describes spanish opaque data structure test driven development module export mylists incrementally test driven development metatesting inakos borrowed hernán part test continuous integration process issue far easier dialyzer xref elvis constantly consistently katana test module includelib mixin export test speed test smoothly fast article behavior understanding behavior define one tool tool erlangotp avoid reinventing wheel article pluralsight debugging debugger debug trace ton article dimitris zorbas redbug recon engage community monika cole join community help mailing list erlang slack meetup near fun zen erlang enjoy amazing language beamolympics serpent spawnfest,higherorder constructserlang language pretty simple type keywords set basic operation building block huge system totally learn understand wellbut also learn build abstraction top think thing like higherorder function list comprehension otp behavior library like sumorest others encapsulate shared knowledge make life developer easier removing repetitive part letting focus specific stuff need systemthings like message passing receive recursion list parsing xml manually etc scarcely used large system instead use proper library framework syntax eg otp list comprehension xmerl etc find writing similar thing consider abstracting generic piece libraryuse higherorder construct library framework tool instead building everything scratch higherorder construct yet build onefind article wrote erlang solution blogopaque data structuressoftware development hernán describes spanish seen process building computable model reality particularly early stage development designing systemthose model include representation entity exist real world oop one would use object functional language like haskell would use type erlang pretty narrow set type principle allowed define onesso combine type represent entity instance using tagged tuples record etc get messy pretty quicklythat recommend using opaque data structure instead od module opaque exported type logic needed manage expose functional interface others consume without worrying internal representation typesuse opaque data structure represent entitieslearn topic two talk gave one codebeam sf driven developmentthis particular erlang tdd great methodology create software general go virtue say erlang make working tdd easyfor instance example assignment provide student teaching recursion module mylistsexport test mylists runlength mylists runlength mylists runlength b mylists runlength mylists runlength b okthat module compiles thanks dynamic nature erlang compiler blame function defined try run c mylists ok mylists mylists test exception error undefined function mylists function mylists mylistserl line go pure tdd fashion prompted define nowsee easy complex system tool like common test work exactly like function using patternmatching determine test pass failsin mind excuse work way building system erlangdevelop system incrementally using test driven developmentmetatestingmetatesting inakos borrowed hernán practice writing test validate particular property code instead behavior word idea check code tool like dialyzer xref elvis etc part test continuous integration processesif start using dialyzer xref elvis project spend lot time trying detangle cryptic meaning dialyzer warning never wrong warning emitted dialyzer mean bug somewheredialyzer may warn problem emits warning confusing may mean issue somewhere maybe warning reported something fixnow deciphering dialyzer found run first time codebase ten thousand line code challenging run dialyzer code first day keep code warningfree whenever get warning something changed far easier debuguse dialyzer xref elvis project constantly consistentlystart using tool soon start developing systemkatana test explained link make extremely easy use common test need add suite like one fact one usually first suite add projectsmodule yourmetasuite includelib mixerincludemixerhrl mixin ktnmetasuite export initpersuite config application yourapp config endpersuite oktest speedlarge system tend even larger battery test good practice go generally run test least every pull request andor every deploythat good kept unattended large battery test start making everyday development cycle longer longer goal test completeness ie covering much functionality system possible test balanced test speed easy thing dokeep test running smoothly fastin article find useful technique achieve balancebehaviorsbehaviors live core otp yet time people struggle come oop land probably somebody already told behavior like interfaceswhile generally true hide lot complexity sometimes lead false belief needlessly complicate codeinvest time understanding behavior use work define use onesbehaviors great powerful yet extremely simple learn unlock whole potential article wrote back erlang behave around themtoolserlangotp come many useful somewhat hidden gem help everyday life erlang developer boost productivity learn use themfrom erlang userdefault dbg xref observer checked sys module erlang et many hidden gem make life easierlearn tool erlangotp already provides work better avoid reinventing wheelyou find thing article wrote pluralsightno debuggingcoming oop world one first thing tried use started working erlang debugger turn great idea dealing concurrent distributed programming languagedon get wrong debugger work really well powerful mostly help debugging sequential code debugging big system application cumbersome bestdo debug inspect trace insteadon hand erlangotp come ton tool make tracing inspecting system easier find several article dimitris zorbas top one provided erlangotp amazing library like redbug reconengage communitythis easily common advice ever gave anybody asks erlang engage communitythe community huge know first name monika cole pointed long ago proactive always helpfulwhen start working erlang uncommon feel lost many thing new others unique someone never used language since main benefit erlang experienced build large system initial step challenging everyone community know thing helpjoin community hesitate ask helpjoin mailing list join erlang slack find u irc find meetup near youhave fun important lesson fact might end building massive highreliable backend system erlang seem really serious mean fun erlang designed faulttolerance concurrency mind day allows worry le thing interesting aspect building zen erlangenjoy time working amazing language besides want play erlang test knowledge language beamolympics challenge friend game build team win awesome prize spawnfest
146,Lobsters,erlang,Erlang development,Experiences with QuickCheck: testing the hard stuff and staying sane,http://publications.lib.chalmers.se/records/fulltext/232550/local_232550.pdf,experience quickcheck testing hard stuff staying sane,,obj endobj obj endobj obj endobj obj stream e ô w gzt j zq pa ݵ r jɩ fy oek endstream endobj obj endobj obj endobj obj endobj obj endobj obj endobj obj endobj obj endobj obj endobj obj endobj obj endobj obj stream yq j h z g x sk mlo 岚 e pp ct пx c n ng endstream endobj obj endobj obj endobj obj endobj obj stream mm b j adobe photoshop cc window h h adobecm adobe k k ϫu kz k ui z v u ޛ q fc
147,Lobsters,erlang,Erlang development,The Lasp Programming System,https://lasp-lang.readme.io/,lasp programming system,,id name lasp programming system subdomain lasplang version version versionclean codename isstable true isbeta true ishidden false isdeprecated false id releasedate currentversion versionclean version oauth enabled false api name url contenttype form auth explorer true proxyenabled true jwt false header authextra objectdefinitions apialt plandetails name open source isactive true cost version customdomain false custompages true whitelabel false error false password false landingpage true stylesheet true javascript false html true extrahtml false admins true intercom intercomsecureemailonly false flag false false migrationrun false oauth false swagger false correctnewlines false speedyrender false allowxframe false jwt false hidegoogleanalytics false stripe false disablediscuss false autosslgeneration true ssl false newapiexplorer false newsearch true assetbaseurl
149,Lobsters,erlang,Erlang development,Riak Core Tutorial – Build a Dynamo Style KV Store,https://marianoguerra.github.io/riak-core-tutorial/,riak core tutorial build dynamo style kv store,riak core tutorial riak core book riakcore http gitlabcommarianoguerratanodbcommitsmaster issue tracker,riak core tutorial welcome riak core tutorial shorter updated version riak core book focused implementation detail explanation check riak core book book show build application using riakcore building actual application called tanodb step step linking change description chapter branch repo http gitlabcommarianoguerratanodbcommitsmaster tutorial written mariano guerra find think something could improved report issue tracker
150,Lobsters,erlang,Erlang development,"Code Janitor: nobody's dream, everyone's job (and how Erlang can help) (2012)",https://ferd.ca/code-janitor-nobody-s-dream-everyone-s-job-and-how-erlang-can-help.html,code janitor nobody dream everyone job erlang help,code janitor nobody dream everyone job erlang help maintenance suck time spent software project spent trying understand system said code enter reverse engineering reengineering get done erlang otp matter turning jenga lego establish protocol component script written minute riak understanding system afar name wellknown standardized pattern type signature everyone us idiomatic code often best erlang support reverseengineering conclusion software maintenance gerardo canfora aniello cimitile software maintenance clarity code poll result erlang maintenance,code janitor nobody dream everyone job erlang help maintenance suck first programming job web developer decadeold dating site still went strong bad many point dead code thing nobody knew worked even worked idea thing built way whole job mostly maintenance developer team anxious hope might get work new bit system allowed rewrite component soon prospect able play new code programming equivalent walking forest cobweb great maintaining old code mandatory work receive writingnewcode pittance necessary evil programming universe entropy would sink energy untangling massive old code base little bit better much worse pretty sure alone lived experience long hour trying figure old code mostly fixing thing hope breaking undocumented behaviour someone relying possibly completely unrelated part system time even fixing thing keeping date changing rule adding number thing may fail rather improving state art world software believed percent developer time spent software maintenance leaving percent development source would confirm figure mentioning software maintenance take product total lifecycle cost time go one suggest lot time sunk browsing stuff online chatting irc time usually split major category defined ieee corrective objective fix bug adaptive change software keep going evolving environment perfective try make software better customer demand easier maintain emergency stuff real quick keep system working due unexpected circumstance turn adaptive perfective maintenance take vast majority maintenance time time total bug fixing wo nt consume much time generally speaking effort made write good program time spent trying improve likely due change requirement fixing full error program used user become dissatisfied due adapt see new need arise either world program evolves change way make obsolete specified lehman first law program used implementation specification reflects reality undergoes continual change becomes progressively le useful change decay process continues judged cost effective replace system recreated version idea program need change time time least come formal specification live rather immutable environment thing may become problem consider lehman second law evolving program continually changed complexity reflecting deteriorating structure increase unless work done maintain reduce basically time go program require change change require harder become change nt take action make sure maintenance easier time cruft tends accumulate ca nt dealt anymore becomes interesting start scratch insidious thing computer nt worry complexity executes tell people problem complexity complexity understanding something take time hurt fact time spent software project spent trying understand system maintenance development included without making explicit effort reduce complexity system without thinking making software maintainable beginning end instead obvious making change setup second picture take le time modifying first picture setup nobody claim opposite given perspective easy see longterm advantage making conscious effort keep thing maintainable yet business care much beath swanson report people maintenance student new hire pigoski confirms maintenance staff newly hired personnel maintenance still perceived many organization non strategic issue explain staffed student new hired people compound problem fact university teach software maintenance maintenance rarely taught corporate training education program hurt good part maintenance suck take lot time nobody care nearly enough biggest time drain project maintenance left afterthought time maintaining software spent trying figuring hell go whatever source available said code maintenance suck major part development really trying figure hell system solution seems simple right document stuff sitting large room ask people show hand whether trust documentation system working doubt get majority hand air generally speaking people tend mention documentation low list information source feel important likely generally outdated come gathering information trying understand stuff work programmer tend trust source following order code industrial development group looked code primary source information often developer already knowledgeable code base coworkers usually skipping code deciphering asking someone done help reusing acquired knowledge rather rediscovering thing tool keep knowledgebase bug tracker documentation kind huge portion people going code first code king long live code enter reverse engineering reengineering get step code best source information get reverse engineer system must maintain observe identify component identify dependency figure everything mesh tangle together deconstruct mentally figured system mentally reassemble make work way want take abstract concept got thing make happen reengineering system programmer getting maintenance right requires good understanding source going change everything nt understand potential become wart code making next round maintenance harder reengineering leave thing clean cleaner first got nt happen someone clean mess later otherwise project eventually become unmaintainable need rewritten scratch get done erlang hundred way thing right wrong hundred language going put full focus erlang title blog post say would mean lie late text principle discussed valid everywhere application languagespecific asked erlang programmer describing professional thought important maintenance answered follows first category importance technically specific erlang otp test grey area question mentioned specific framework graph alone good way know prioritize source control somewhat nobrainer tool getting much better last year source control let know wrote happened let search bug let manage complexity concurrent change code base time adapt also simple understand think back much time necessary understand code base maintenance across language test give confidence code base tell use code act documentation let confident new toaster assembled burn house toast family crisp likely expected quality test nobody like bad test wo nt get testing methodology crapload many way thing building erlang product investing learning test code rather essential long run case use otp behaviour erlangspecific top important one fact one want spend time come otp behaviour get important taking precedence many standard thing test coworkers documentation comment well first easy explanation otp behaviour code people trust code thus going important obviously thing like type specification comment code rank way lower still code otp matter know otp feeling application respect otp somewhat easy get otp component tend selfcontained cleanly defined interface think black box quite easily component called behaviour come flavour worker may act like message hub resource owner independent agent system also supervisor supervisor force worker fit neatly organized structure force think relationship subcomponents system started taken crash closely related one another one level otp application higher level behaviour force organize related supervisor tree single supervisor top supervisor force think worker fit together otp application force think cluster worker supervisor need organized help highlight part system interact together make code explicit application state application depends like block subsystem started loaded different priority vital application tell hard system crash need nutshell otp thus force common development pattern every single programmer component properly isolated clean interface dependency start order cleanly defined component building block cleanly sorted hierarchy based supervision tree related worker put together away turning jenga lego maintenance often sound like playing game jenga first build decent tower first version software long change thing top tower nobody anything complain deeper system go harder change make everything built likely assumption thing ought done optimal core whenever change requirement asks reconsider concept like removing one lowest jenga block replacing different one either restrict much possible make everything fit current format forced change bunch thing around absorb change inevitably general good practice help welldefined interface sharing implementation detail making assumption test make sure nt break anything careful choice data structure erlang something rather neat otp application different process process share nothing order keep distributed semantics local level establish protocol component whole programming model behind erlang assumes failure otp embrace erlang assumes going build jenga tower fall point everything isolated process message passing otp application support make change application somewhat easier average illustrate point let take look quick dependency graph generated script written minute riak regular processbased application represented circular node library application processbased represented rectangle also removed kernel stdlib graph given application depend even though see basho guy appear care much setting dependency library application kind hierarchy use respecting otp standard graph make instantly obvious app depends app given little shared application rather simple figure impact modifying application whole system without even needing go module level planning change behaviour riaksysmon need ask guy riakcore use idea impact look depends riakcore see tricky upgrading would nt change messagebased protocol whatever want innards app isolation also mean writing crap code picking terribly bad way represent data impact limited throughout system able change bad part limiting impact good part fact possible restart one application important change make hard upgrade without stopping run time basically erlang often make possible load new code vm upgrade system run sometimes desirable start fresh state otp application allow restart isolated component system independently allowing get clean state need without dropping state ca nt afford lose component usually kind stuff see done nonerlang system make extensive use web service generally distribution build system keep kind architecture mind change program bit become aware high latency possible failure netsplits bake possibility design program expecting thing nt control go bad assumption already core foundation erlang otp available without going distributed using web service make possible see software stack lego tower rather jenga tower understanding system afar structure otp imposes developer domainspecific people developing web application use way people developing modeler people writing script automate task writing database engine people using routing middleware use lowlevel enough general highlevel enough make development easier without large domainspecific framework top mean matter erlang code base end maintaining figure thing laid organized quickly take riak structure example yes useful figure dependency application also useful explore understand code get code base nt know application hierarchy give quick map system starting top high level logic code successively going lower lower level otp application application file contain description application specify dependency module contains common configuration variable module start toplevel supervisor following supervisor reveal hierarchy mentioned earlier given structure rather simple rapidly gain general abstracted idea erlang system built experienced erlang developer reading mean explicitly care app file let rebar handle way handle module wo nt nt supposed name wellknown standardized pattern course enough look otp apps call day got app structure figured idea change break go code many language get idea code via comment python docstrings javadoc block inline comment type signature looking haskellers name class method module andor function name design pattern wild factoryfactory appeared erlang got little something regarding design pattern common role erlang process respect lifetime server worker process hold state answer bunch request come returning dns data could done server example finitestate machine worker process react differently depending state happened far execution usually sign someone implementing protocol implementing kind agent behaves differently based state event handler set function plugged inside worker process act like message hub similar common event callback model used asynchronous framework like twisted nodejs supervisor process charge monitoring process denote relationship described earlier find pattern ever possible erlang tend fit one four category rather well behaviour attached genserver genfsm genevent supervisor give uniform interface point simple language design pattern rather ad hoc many different factory pattern singleton pattern implemented scratch project otp make everyone us implementation pattern across project little work need done understand high level worker role system likely huge part people feel otp reduces amount time need comfortable code base take system see genserver behaviour know process organized part interface process module call server server callback function dispatch message received private function implementing complex business logic course know server serverlike role compared language somewhat similar higher level interface protocol used everyone everywhere little conflict everyone us brings point everyone us necessarily obvious advantage anything else care us framework language erlang nobody us anyway fair counter point maintain advantage nearly library find online support least play well otp way compare asynchronous framework like nodejs twisted python framework support paradigm based idea necessarily mesh well material outside community still within host language mean library general language always reused framework clash respective model paradigm erlang otp logical continuation erlang principle nearly friction two level general compatibility guarantee mean given web framework developed logging tool would like incorporate project likely able without problem even currently logging stuff test framework charge black box testing one many computer car assuming least somewhat similar requirement exception someone writes library ca nt add project paradigm clash much one using also mean tool improved someone area industry academia everyone else benefit creates positive feedback loop people want improve tool everyone us people use tool get improved written blog post idiomatic code often best erlang hold belief everyone using improving set tool weight nt improve thing competition framework improve common effort support reverseengineering sometimes complex interaction many component system especially concurrent turn real hell hole sequential program often reasoned list action happening one concurrent parallel program require many list action actor combined differently based entirely nondeterministic factor bound messy point reverse engineering start becoming difficult debugger wo nt work presence alter way system work mess timing thing print statement debugging may serialize action way hide bug happens run time tool used longer cut fortunately people maintaining otp system otp worker fully inspectable traceable call sys return process internal state come short description thus take snapshot worker whenever wish calling sys trace worker true process implementing otp behaviour order start noting everything happens see input output related process real time even production system need special compile flag anything set bunch worker get see interact together turn tracing logging process file register tracing function perworker basis get finegrained control program process tracemonitoring also suspend change code worker resume execution sys module good case may good enough sometimes otp providing need thus go lower vm level nearly everything traceable process call given function function return get garbage collected get scheduled unscheduled message sent received much flexibility tracing done multiple node across network log file socket process careful though much information available careful tracing functionality easily crash production node overloading handle care conclusion still stuff make hard grow erlang product first annoying one likely inability multiple version single library used time within virtual machine cause overhead effort made keep software stack working sure fixed seems like otp guy ericsson outside scratching head hard everyone else tricky one issue namespacing erlang namespacing programmer tend adhoc prefix stuff module ets table registered process easy miss one two namespace clash definitely suck find rare practice community learned cope ago discipline discipline unreliable said erlang developer answered poll definitely seemed think otp greatly helped gave confidence soon could claim code base otp know le time expect take adapt code base clearly something otp likely put shortly common structure otp behaviour application tends give stricter modularity constraint system top wrapping common behaviour well known pattern make easier developer dive code base play around modify without requiring deep knowledge component system likely erlang developer judged otp essential definite value using erlang make maintenance easier le annoying fun hope post offered insight erlang offer grow software system could change pain maintenance mild discomfort worst tending garden best program life cycle law software evolution mm lehman software maintenance gerardo canfora aniello cimitile pdf software maintenance clarity code poll result erlang maintenance
152,Lobsters,erlang,Erlang development,What is wrong with gen_event?,https://pattern-match.com/blog/2018/08/31/what-is-wrong-with-gen-event-an-update/,wrong genevent,http patternmatchcomblogwhatiswrongwithgeneventanupdate,http patternmatchcomblogwhatiswrongwithgeneventanupdate
153,Lobsters,erlang,Erlang development,BEAM Bytecode Optimization Traps and Pitfalls,http://blog.erlang.org/opt-traps-and-pitfalls/,beam bytecode optimization trap pitfall,brief introduction beam assembly language zerobased optimizing code final straw delayed sub binary creation conclusion ssabased new ssabased intermediate format,august björn gustavsson back summer holiday blog change track start series blog post static single assignment ssa first installment set scene post follow looking trap pitfall one fall trying optimize beam assembly code brief introduction beam assembly language look beam code following function foo tag ok unoptimized beam code look like function foo line location funcinfo atom atom foo test istuple test testarity gettupleelement gettupleelement test iseqexact atom tag put atom ok put return putlist nil move atom functionclause line location extfunc erlang concentrate part code actual work test istuple test testarity gettupleelement gettupleelement test iseqexact atom tag put atom ok put return cause functionclause exception explain instruction test istuple test instruction test whether condition true next instruction executed otherwise branch failure label condition tested instruction istuple whether operand tuple operand register first argument function contain tuple execution continue failure label mean failure label code label cause functionclause exception test testarity testarity instruction test whether first operand must tuple size given second operand first operand second operand failure label previous instruction gettupleelement gettupleelement two instruction executed previous instruction established contains tuple arity gettupleelement take three operand first source tuple second zerobased index tuple third operand register element tuple stored note failure label fail first gettupleelement instruction fetch first element tuple store register second gettupleelement instruction fetch second element store register test iseqexact atom tag iseqexact test instruction test whether content exactly equal atom tag execution continue failure label concludes function header next instruction body function build ok tuple testheap instruction ensures sufficient free space heap construct term first operand first say following instruction need word heap tuple header word followed element tuple element need heap word total sufficient room heap testheap instruction garbage collection find fresh heap space second operand second number x register value must preserved garbage collection mean live value put atom ok put three instruction build tuple putting tagged pointer tuple return return function return value value optimizing code testing term tuple certain size specific atom first element common operation think record therefore beam machine istaggedtuple instruction work instruction using instruction code test istuple test testarity gettupleelement gettupleelement test iseqexact atom tag put atom ok put return rewritten like test istaggedtuple atom tag gettupleelement put atom ok put return nice reduction code size execution time however optimization safe consider instruction second say x register live namely clearly live removed gettupleelement instruction assigned value value undefined passing undefined register value garbage collector kind bug could take week track fact probably future blog post kind bug two tool born result bug reluctantly order make optimization safe must keep gettupleelement instruction assigns test istaggedtuple atom tag gettupleelement gettupleelement put atom ok put return another possibility case would assign empty list called nil beam assembly language test istaggedtuple atom tag move nil gettupleelement put atom ok put return however simple example another optimization actually allow compiler remove assignment test istaggedtuple atom tag gettupleelement put atom ok put return testheap gettupleelement instruction swapped note number live register adjusted testheap instruction instead general though compiler might abandon optimization keep instruction assigns register avoiding feeding garbage collector undefined value final straw development otp realized reached limit improving optimization operates beam assembly language particular wanted make optimization called delayed sub binary creation applicable circumstance turned would hard impossible substantially improve optimization working beam assembly language apart problem leaving undefined register illustrated previous optimization example also complexity traversing analyzing beam instruction beam instruction set designed optimizerfriendly conclusion tried show example one hardest part working beam code register allocation already done instruction may garbage collection testheap already added early year decided introduce new intermediate format alleviate problem optimizing beam code close enough beam code allow lowlevel optimization istaggedtuple optimization described blog post register allocation done testheap similar instruction added also regular make easier traverse optimization decided make new intermediate format ssabased next blog post revisit example blog post see look like new ssabased intermediate format
154,Lobsters,erlang,Erlang development,Fibonacci Algorithms in Elixir,https://stratus3d.com/blog/2018/08/18/fibonacci-algorithms-in-elixir,fibonacci algorithm elixir,look algorithm time complexity common fibonacci elixir gist dave thomas presented implementation first elixirconf mirrored mathematical formula function generates list fibonacci number fastest benchmarking benchmark script result conclusion resource,look algorithm time complexity recently asked write function elixir generate list fibonacci number forgotten typical implementation algorithm generating fibonacci number since function returning list knew could add two previous number list compute next number quickly threw together simple line function took number returned list many first fibonacci number writing testing realized function somewhat different implementation seen code looked like defmodule fibonacci def fibonacci number enumreverse fibonaccido number end def fibonaccido def fibonaccido def fibonaccido number number x fibonaccido x yall end end implementation function called three clause first two first second fibonacci number third generates rest number sequence adding previous two number list returning list new number added function actually generates list number reverse order defined function reverse list function generate first fibonacci number le second bad thought common fibonacci elixir went looked elixir implementation two defmodule fibonacci def fib def fib def fib n fib def fib prv prv def fib prvprv prv n next prv prvprv fib prv next end end ioinspect enummap fn fibonaccifib end gist dave thomas elixir implementation followed pattern def fib def fib def fib n fib fib variation far common seen implementation several slide deck elixir conference seen used example code many time unsure origin dave thomas presented implementation first elixirconf mirrored mathematical formula generating fibonacci number blog post call dave thomas implementation naively use function generate list fibonacci number likely something like call rosetta code example ioinspect enummap fn fib end function generates list fibonacci number fastest looking three algorithm clear similarity recursive function start base case first fibonacci number take single argument number fibonacci sequence generate algorithm key difference well function call recursively build list number sequence return list directly rosetta code function also recursively call generated number since generates single number must executed multiple time generate list number sequence dave thomas algorithm differs two others recursively call twice like rosetta code algorithm also must executed multiple time generate list number sequence line far succinct three benchmarking opted simple benchmarking three algorithm benchmark script feed function number n expects function return list containing first n number first fibonacci sequence algorithm returned list directly two algorithm created function would map range repeatedly call fibonacci function def fibonacci number enummap number fn n fib n end end result ran benchmark algorithm four time average run time shown table microsecond list size rosetta code dave thomas mine sure dave thomas algorithm slow computing list first fibonacci number guess cpu core busy something else number benchmarked skewed result see three algorithm perform differently length list must generate grows around item rosetta code algorithm dave thomas algorithm perform item run time dave thomas algorithm quickly climb list take nearly second list take two minute rosetta code algorithm performs much better taking around microsecond compute list first fibonacci number algorithm appears similar performance characteristic rosetta code algorithm time averaged le quarter run time rosetta code algorithm note timing code rounding nearest microsecond computation took le half microsecond algorithm decided little benchmarking algorithm rosetta code algorithm since algorithm seemed pretty fast tried using generate much larger list fibonacci number result shown table time microsecond list size rosetta code mine minute never returned clearly algorithm performs better generate number scratch time computes new number resulting list list must generate grows size rosetta code algorithm run time grows exponentially generating list fibonacci number clear algorithm performs best conclusion clearly three algorithm different performance characteristic generating single fibonacci number rosetta code function work fine function also work fine generating single fibonacci number use memory due list build dave thomas algorithm performs poorly anything beyond first fibonacci number probably used anything exercise like algorithm designed generate list fibonacci number turn best algorithm generating list fibonacci number looping fibonacci function algorithm greatly degrades performance better design new fibonacci function generates full list one recursive call rather reusing existing fibonacci function generates one number time build list resource
155,Lobsters,erlang,Erlang development,Mapping a decentralized wireless network with Uber H3 hexagons,https://blog.helium.com/mapping-the-world-with-hexagons-49f57d8b3df5,mapping decentralized wireless network uber hexagon,mapping world hexagon precision proximity uber hexagonal hierarchical geospatial indexing system hexagonal grid system http documentationoverviewusecases,mapping world hexagonshexagons everywhere honeycomb fly eye soap bubble popular german board game settler catan good reason hexagon spaceefficient regular polygon tile plane bee term le wax honeybut hexagon helium helium building world first decentralized machine network physical network coverage device provided gateway hosted throughout world consequently location core tenet networkin addition need represent position world network also unique geospatial requirement need encode precision proximity precision ie talking single point space larger le precise area let u approximate range coverage anonymize gateway location degree proximity allows u reason gateway close one anotheruber hexagonal hierarchical geospatial indexing systemwhile plenty coordinate system uber hexagonal grid system natural fit unique set requirementswhy hexagon make good grid system turn hexagon useful property bee among u already know want tile plane regular polygon three option equilateral triangle square hexagon three option hexagon shape distance neighbor comparison square two different distance triangle three simple property vastly simplifies math around calculating neighbor region key function networksource http documentationoverviewusecaseshexagonal grid without weakness example square subdivide perfectly parent child whereas hexagon mean small degree error moving hexagonal hierarchy tradeoff acceptable network
156,Lobsters,erlang,Erlang development,Erlang co-creator joins æternity,https://blog.aeternity.com/trustlessness-erlang-and-the-blockchain-revolution-an-interview-with-robert-virding-458c68664372,erlang cocreator join æternity,trustlessness erlang blockchain revolution interview robert virding without ado proud announce one latest addition æternity team robert virding decide join æternity team interest blockchain think blockchain potential change world main challenge erlang like erlang outside work passionate aboutinterested advice would give younger developer starting,trustlessness erlang blockchain revolution interview robert virdingwithout ado proud announce one latest addition æternity team robert virding robert represents major addition team worked past seven year senior system architect erlang solution ltd coinventor erlang language one original member ericsson computer science lab robert rich history forefront cutting edge technology research impressive body work extends eight year system engineer swedish defense materiel administration fmv modeling simulation group coauthor book concurrent programming erlang regular contributor academic world delivering presentation commentary worldwiderecently asked robert share u insight erlang prediction future blockchain decided join æternity teamwhy decide join æternity team idea blockchain always interesting gave chance work developing new system together highly qualified peoplewhat interest blockchain find trustless nature blockchains interesting different distributed system workeven distributed system paxos handle nonreliable system network fail node come go node lose sync underlying assumption trust everyone system blockchains built around assumption adapted handle thatdo think blockchain potential change world know yet much depends type application developed based itapplications make blockchain truly revolutionary fascinating parenthesiswhat main challenge erlang erlang problem us infrastructure tool like rabbitmq see people realize much actually used often hear people ask bother learn erlang seldom used another issue quite old people see bad thingbut like erlang like erlang please excuse buzzword massively concurrent truly faulttolerant scalablealso much like managed keep language base primitive simple avoid complexity level yes course build complex system base level quite simple great believer simplicity agree dijkstra wrote simplicity great virtue requires hard work achieve education appreciate make matter worse complexity sell better outside work passionate aboutinterested actually passionate programmer enjoy implementing language also free time fortunate able work area think fun consider hobby also house island gotland go summer spending time satisfying give great pleasure aside course standard thing everybody enjoys like book movieswhat advice would give younger developer starting would tell many different programming language different way viewing world single language good everything even erlang though lisp come closest prepared learning different language accept real system part different requirement best solution often make polyglot system
157,Lobsters,erlang,Erlang development,Building a truly decentralized system with a distributed key generator,https://hackernoon.com/building-a-truly-decentralized-system-with-a-distributed-key-generator-1cfe13af55e7,building truly decentralized system distributed key generator,building truly decentralized system distributed key generator whitepaper common coin distributed key generator lagrange interpolated share pairing based key secret sharing threshold cryptosystem github repo,building truly decentralized system distributed key generatorany system still requires trusted entity hold secret nature decentralized suffers number weakness including single point failure susceptibility denial service attack worst secret stolenwhen set build new wireless network machine helium number design goal key among truly decentralized nature goal included permissionless byzantine fault tolerance useful proof workidentity high confirmed transaction rate transaction censor resistant detail see helium whitepaper since centralized organization dictate network cost coverage decided decentralized approach would effective way provide broad affordable wireless coverage low power device long distancesto build decentralized machine network chose reward community provide wireless network coverage hosting gatewaysto ensure community member provide valid coverage created new proof work system call proof coverage proof coverage first proof protocol leverage radio wave validate network coverage us achieve consensus physical blockchaincommunity member providing coverage gateway rewarded helium token mining transaction fee user networkfor gateway mine need belong consensus group gateway elected consensus group earning score based providing legitimate wireless coveragein helium consensus group temporarily assigned task running consensus protocol accept transaction create block helium consensus protocol need use threshold encryption two task agree transaction next block without censoring provide common coin break deadlock agreement kind threshold cryptosystems require key shared member consensus group obviously single party knowing complete key big security hole needed build distributed key generatora distributed key generator way group node collectively agree publicprivate key pair without single party knowing private key everyone know public key actually hard achieve relies fact lagrange interpolated share homomorphic operation performed share even without knowing full value example add b get c add someone else c get full value c assuming b split share wanted explain dkg work pairing based key way understandable nontechnical audience played metaphor one come closest actually work based pintumbler locksa pin tumbler lock work key pushing several key pin right height shear line key pin driver pin line shear line part lock rotates core part lock fixed correct key inserted pin line shear line clear core rotate even one pin wrong lock openimagine design lock corresponding key know deep cut pin key need nobody else give peer share key pin information threshold number share need reconstruct original data share key pin information enough make key open lock called secret sharingnow fine everyone trust leak knowledge key however sufficient want property nobody know key look like distributed key generator come inin addition normal pintumbler lock lock exist cross key key several blade one corresponding set pin tumbler cross key key require two set combination bladesnow imagine key n blade n number people generating key member generates pin tumbler configuration blade share described everyone shared blade received share blade lock nobody know open member combine share construct key unlock distributed key generationblades combining form new keyin normal usage full key usually recovered rather holder key share work together perform operation threshold cryptosystem eg n required participate signing message n party required participate decrypting message building distributed key generator hard necessary work achieve secure system challenge excite team knowing building world first decentralized machine networkto follow progress dkg work check github reposubscribe get daily roundup top tech story
158,Lobsters,erlang,Erlang development,A Brief History of the BEAM Compiler,http://blog.erlang.org/beam-compiler-history/,brief history beam compiler,brief overview early erlang implementation prolog interpreter jam joe abstract machine mike williams joe armstrong robert virding team turbo erlang abstract machine beam bogdan erlang abstract machine threaded code interpreter lost translation exploring compiler front end vee virding erlang engine maturation beam interpreter beamc must die axd project everchanging beam instruction instruction tony rogvall beammakeops script otp new beam modern beam file format enter kernel erlang constant propagation constant folding implementation functional programming language enter core erlang richard carlsson hipe group core erlang constant propagation constant folding learning erlang robert,june björn gustavsson blog post brief history lesson erlang compiler beam machine provide context first quick look abstract machine erlang brief overview early erlang implementation prolog interpreter first version erlang implemented prolog version erlang used find feature language useful new language feature could added deleted matter hour day jam joe abstract machine soon became clear erlang needed least time faster useful real project jam joe abstract machine first implemented mike williams wrote runtime system c joe armstrong wrote compiler robert virding wrote library jam turned time faster prolog interpreter success team turbo erlang abstract machine soon became clear erlang still needed faster useful real project therefore bogumil bogdan hausman created team turbo erlang abstract machine compiled erlang code c code compiled native code using gcc significantly faster jam small project unfortunately compilation slow code size compiled code big make useful large project beam bogdan erlang abstract machine bogumil hausman next machine called beam bogdan erlang abstract machine hybrid machine could execute native code threaded code interpreter allowed customer compile timecritial module native code module threaded beam code threaded beam faster jam code bogdan original compiler beam shared compiler front end jam essentially front end time thing front end current compiler described lost translation exploring compiler front end source code bodgan original compiler far determine three compiler pass translated abstract format threaded beam code beamcompile translated abstract format beam instruction beamoptimize optimized beam instruction pas mandatory since necessary transformation beam instruction beamasm converted symbolic beam assembly format binary beam module vee virding erlang engine must mention vee virding erlang engine reason soon become clear vee experimental implementation different memory model compared jam beam instead jam beam separate heap process vee used single shared heap realtime garbage collector made message passing blindlingly fast compared jam beam overall though speed gain compared jam reason probably single shared heap decreased cache hit rate maturation beam otp group erlangotp created industrialize erlang make suitable huge realworld project first release otp released point history lesson may become little bit subjective joined erlangotp team end first small code contribution erlangotp included otp worked ert erlang runtime system team time lead kenneth lundin initially worked erlang runtime system microsoft window time maybe year kenneth asked help stabilizing improving beam gradually beam become main responsibility bogdan left ericsson become main developer responsible beam interpreter compiler blog post desperately try cover history beam compiler think historical context needed approach compiler overall goal work beam otp otp make stable enough fast enough useful real project two major obstacle reaching goal beamc native code via c code huge number everchanging beam instruction beamc must die soon became obvious beamc compiler pass compiled erlang code c code die time started working beam three distinct flavor beamc one gcc sparc one gcc nonsparc cpu intel one c compiler support gcc extension taking address label bug showed native code mere existence beamc complicated caused bug threaded beam interpreter unfortunately early career improving beam made optimization size c code generated beamc came back bite later suggested remove beamc size improvement made possible fit erlang code compiled native code system native code faster threaded beam code customer time axd project needed extra speed improvement beamc gave allow u remove beamc unless could improve performance threaded beam code similar better beamc performance everchanging beam instruction time beam interpreter instruction jam simple loader essentially loaded jam file memory loader beam translate every instruction byte format beam file threaded code format memory beam handwritten code loading every single instruction make worse instruction set constantly evolving bug fix performance improvement needed new instruction instruction implemented compiler threaded code interpreter processmain function beamemuc loader every minor major release erlangotp user beam recompile erlang code instruction set changed must better way thought started write simple perl script least automate mapping instruction name instruction number compiler interpreter loader tony rogvall suggested could ambitious generate code loader using perl script also suggested operand many instruction could packed single word would reduce load code size also improve cache hit rate improving execution speed started writing first version beammakeops script rewriting loader prefer work incrementally making minor change code base always working could rewrite loader incrementally hacked away frantically two three day bare bone version new loader working could relax little somewhat slowly add feature beammakeops loader new loader took task formerly done compiler example beam machine several specialized move instruction one instruction moving something x register another moving atom x register new loader compiler knew variant move instruction selected appropriate one new loader one move instruction compiler need care loader select appropriate specialized move instruction use load time another minor optimization done compiler combining common instruction sequence example move instruction followed call instruction would combined movecall instruction optimization also moved loader capability made possible significantly simplify reduce number instruction known compiler importantly made possible keep instruction set stable still allowing minor optimization performance tuning tweaking loader interpreter avoiding need recompile erlang code every time new release memory fail new loader introduced otp otp new beam moving forward otp otp last release supported jam otp also said first release featured new beam release modern beam file format introduced file format used today time beam instruction otp instruction actually active instruction obsoleted instruction longer used new instruction introduced needed obsolete instruction removed always possible load beam file compiled least two major release back execution threaded beam become fast enough beamc could dropped already think strangely enough customer still wanted speed beam compiler still bogdan original compiler optimization jam ever knew optimization possible enter kernel erlang meanwhile top floor robert virding busy writing new compiler vee machine new compiler robert introduced new intermediate format called kernel erlang idea optimization could applied code format generating code actual machine time actual interpreter could execute code emitted new compiler updated vee machine yet machine mind register machine similar beam except stack trimming wanted better performance could get robert compiler question implement new interpreter adapt beam execute code robert compiler adapt robert compiler generate beam code first time stable implementation beam decided rock boat thus decided adapt code generator part robert compiler beam part used robert name instruction example instruction load term register called original beam robert compiler used move major change handling stack robert compiler stack trimming remove rewrite handle beam fixed stack frame reintroduced limited form stack trimming later since jam supported otp customer previously used jam migrate beam minimize risk migration much possible one customer requested made battletested original beam compiler available option otp therefore added option choose version compiler use use old compiler one would write erlc somemoduleerl default robert new compiler called also undocumented unofficial compiler version called compiler shared front end beamasm pas created final beam module compiler following pass pass essentially beamcompile beamoptimize pass bogdan compiler change front end since pas hide change pass pas additional minor optimization pas think present otp well compiler robert new compiler following pass pas translated abstract format kernel erlang basic optimization kernel erlang code essentially constant propagation constant folding pattern matching compilation jam would match clause function head case expression sequentially old beam compiler would little bit better could match multiple integer atom single instruction robert compiler first erlang compiler properly compile pattern matching using algorithm described implementation functional programming language simon peyton jones would calculate lifetime information needed pas would generate beam assembly code enter core erlang meanwhile richard carlsson hipe group uppsala university come idea new intermediate format useful interchange format different erlang implementation optimizing erlang program new format called core erlang robert liked idea started implement core erlang compiler undocumented implementation compiler otp based draft version core erlang specification otp compiler removed remaining compiler compiler used core erlang following pass pas translated abstract format core erlang pas essentially called syscorefold constant propagation constant folding syscorefold still thing remaining pass thing today pas translates core erlang kernel erlang also pattern matching compilation way optimization done syscorefold pas despite name longer calculates lifetime information lifetime information instead calculated passed annotation reason still exists robert continued work version codegen change work beam implementing core erlang pass also many improvement codegen time integrate different version compiler robert looked horror change codegen avoid reintroduce adapations optimization beam new version codegen robert wrote adapter pas translated new kernel erlang format old format codegen would work adapter pas called thus essentially new name upcoming otp combined learning erlang robert time period robert worked together compiler usually worked pass robert worked pass occasionally would add optimization syscorefold give robert incorporate latest version syscorefold would look robert done code learn usually robert subtly improved code made slightly cleaner simpler one time handed robert optimization case clause code got back different robert broken apart optimization several simpler optimization achieved purpose complicated optimization
159,Lobsters,erlang,Erlang development,Configuring multiple endpoints in Phoenix Framework,https://pattern-match.com/blog/2018/06/19/multiple-endpoints-in-phoenix/,configuring multiple endpoint phoenix framework,http patternmatchcomblogmultipleendpointsinphoenix,http patternmatchcomblogmultipleendpointsinphoenix
160,Lobsters,erlang,Erlang development,Dark Corners of Erlang and Elixir Tracing,https://pattern-match.com/blog/2018/06/01/erlang-tracing-what-we-can-and-what-we-cannot-trace/,dark corner erlang elixir tracing,http patternmatchcomblogerlangtracingwhatwecanandwhatwe trace,http patternmatchcomblogerlangtracingwhatwecanandwhatwe trace
161,Lobsters,erlang,Erlang development,All For Reliability: Reflections on the Erlang Thesis,https://dockyard.com/blog/2018/07/18/all-for-reliability-reflections-on-the-erlang-thesis,reliability reflection erlang thesis,chris mccord phoenix making reliable distributed system presence software error mistake inevitable handling worst case since failure one process must corrected another process separate machine erlang us mechanism failure process property le reliability performance meet evidence reliability elsewhere cited subject debate performance described ease scheduling small erlang process v larger operating system process joked conference talk continued optimized,ask elixir developer got u interested language many say concurrency wanted make program faster making use core desire big part elixir exists creating elixir josé valim trying make rail threadsafe found frustrating remembered thinking future going many core needed better abstraction one working ruby rail going cut decided study language see study led erlang built elixir run erlang virtual machine similarly chris mccord wanted use websockets rail apps struggled create scalable solution ruby heard whatsapp using erlang get million connection single machine kind blew mind looking getting maybe hundred connection rail app got mccord interested erlang elixir went create elixir main web framework phoenix known submillisecond response time massively scalable websocket support personally worked travel search engine needed lot ondemand concurrent work written language made difficult learned elixir job though adopt knew tool want use future although call concurrencyoriented programming language erlang cocreator joe armstrong cite speed main reason creation phd dissertation making reliable distributed system presence software error purpose title reliability fascinating many erlang therefore elixir attribute direct consequence designing reliable mistake inevitable paper armstrong talk challenge team faced writing telephone switching system first needed write complex system several million line program code might team many hundred programmer varying experience level requirement demanding market pressure encourages development deployment system large number complex feature often system deployed interaction feature well understood lifetime system feature set probably changed extended many way constraint way could produce perfect software yet something approaching perfection required telephone call important emergency turn phone system night maintenance telephone system need continuous operation many year typically le two hour downtime year quite problem imperfectlywritten system get nearperfect result armstrong put central problem addressed thesis problem constructing reliable system program may contain error handling worst case solving problem armstrong make harder considering worst case hardware failure imagine perfectlywritten program running computer burst flame lot failure process recover ceasing exist one armstrong address situation simply guard failure entire computer need two computer specifically first computer crash failure noticed second computer try correct error might mean example creating new process elsewhere replace one died see first interesting property erlang made run system span multiple machine needed reliability even better since failure one process must corrected another process separate machine erlang us mechanism failure failure handled via monitor link way one process react failure another supported directly vm mechanism foundation supervision tool pattern otp fact erlang vm go far make hardware failure look like software failure process monitoring process b process b dy process notified happens whether process b divide zero loses connectivity dy fire last two case distress call faked vm loses contact process b armstrong say reason coercing hardware error make look like software error want two different method dealing want one uniform mechanism combined extreme case hardware error failure entire processor lead idea handling error occurred place system process property consider two process mentioned running separate machine certain thing sure share memory physically separated nice failing process corrupt memory process watching communicate passing message succeed fail independently separation analogous firewall construction firewall wall two part building keep fire spreading maximallysafe house would firewall around every room chair bed house impractical erlang system process boundary like firewall failure cost almost nothing uniformity firewalllike characteristic true whether two process run separate machine process machine share memory communicate passing message separate machine armstrong noted erlang process isolation perfect one process allocates inordinate amount memory atom example could crash erlang vm machine including process improve reliability several property needed first message must asynchronous armstrong say isolation implies message passing asynchronous process communication synchronous software error receiver message could indefinitely block sender message destroying property isolation second process must lightweight safety increased dividing system process want run lot creating quickly ondemand third process must take turn armstrong say concurrent process must also timeshare cpu reasonable manner cpubound process monopolise cpu prevent progress process ready run like operating system erlang vm us preemptive multitasking le mean process get fixed amount time use cpu process finished turn paused sent back line another process get turn also paused waiting read file get network response way erlang vm support nonblocking io well nonblocking computation get applied automatically sequentiallooking code reliability performance meet might noticed last two point reliability also performance concern two related imagine system handling large number small task call web request whatever come large task happens system overall performance take dive reliable call get dropped web request time reliable system must perform consistently logic behind erlang vm multitasking absolute term frequent taskswitching waste little time making performance suboptimal benefit performance consistent small task continue completing quickly large task get processed little time garbage collection work way although erlang immutable data mean lot garbage created divided tiny heap across many process process dy memory freed gc needed longrunning process gc performed concurrently stop world pause collect garbage entire system gc barrier consistent performance evidence reliability effort toward building reliable system armstrong tried find well several erlangbased system worked interviewed maintainer analyzed source code examined bug report armstrong elsewhere cited ericsson switch example nine nine reliability uptime describes switch designed carrierclass nonstop operation system duplicated hardware provides hardware redundancy hardware added removed system without interrupting service software able cope hardware software failure since system designed nonstop operation must possible change software without disturbing traffic system thesis treat nine nine figure uncertain evidence longterm operational stability system also collected systematic way ericsson information longterm stability system came powerpoint presentation showing figure claiming major customer run node system reliability though figure obtained documented particular figure subject debate however armstrong investigation seemed indicate erlang system examined indeed extremely reliable software system case study reliable people operating system inclined think errorfree case indeed software error occur runtime error quickly corrected nobody ever noticed error occurred performance recap erlang vm give u pursuit reliability lightweight sharednothing process communicate via asynchronous message builtin mechanism process react failure process ability quickly spawn large number process run multiple machine efficient contextswitching concurrent garbage collection wonder armstrong call erlang concurrencyoriented programming language feature created mainly reliability make easy write concurrent program scale horizontally across core computer write program using process message vm take care tricky part running scheduler per core giving process turn moving process scheduler balance throughput power consumption tiny process make easier armstrong described ease scheduling small erlang process v larger operating system process packing huge big rock container difficult pouring sand container really easy think process like little grain sand think scheduler like big barrel fill filling barrel sand pack nicely pour work course erlang vm pretty fast armstrong joked conference talk take program want go thousand time faster wait ten year go thousand time faster solved want million time faster wait twenty year problem solved erlang really fast today waited long time erlang created telephone switch handled many ten thousand people interacting simultaneously armstrong implied rode wave everincreasing chip speed even continued optimized onceacceptable speed became truly formidable wave passed future performance concurrency take advantage write concurrent program armstrong thesis correct concurrencyoriented programming also key reliability awfully nice get time
163,Lobsters,erlang,Erlang development,Comparison of Erlang Runtime System and Java Virtual Machine (2015),http://ds.cs.ut.ee/courses/course-files/To303nis%20Pool%20.pdf,comparison erlang runtime system java virtual machine,,institute computer science
164,Lobsters,erlang,Erlang development,Erlang OTP 21.0,http://www.erlang.org/news/123,erlang otp,otp potential incompatibility highlight ert compiler security standard library http http http http,otp erlangotp new major release new feature improvement well incompatibility potential incompatibility corba application moved otp repository new corba repository created http githubcomerlang new application ftp tftp moved inets ssl longer support cipher suite rsakey exchange cipher suite default erlang monitor primitive node erlinterface jinterface etc longer fail badarg exception instead monitor created supervise connection node highlight ert enhanced io scalability support usage distribution controller process alternative transport routing etc compact instruction system code le memory loaded code rewrite efiledriver nifs dirty scheduler resulting faster file operation nonsmp vm removed link monitor optimized scalability o getenvputenv work threadsafe emulation longer sync libc getenv manual synchronization needed compiler misc compiler optimization including contribution elixir team resulting improvement benchmark tuple call removed runtime system code f ok val ok val automatically rewritten f ok val tuple tuple reduces code size execution time removed gc pressure information stacktrace number operator erlang deprecated replaced try catch c r stacktrace creation small map literal key optimized new predifined macro otprelease preprocessor directive elif security dtls supported ssl application enhanced support distribution tl unsecure cipher removed default ssl ssh new option value defined facilitate implementing exec server old option kept compatibility give error stderror standard library new api logging logger new uristring module parsing uris according standard new function list search list ok value false changed default behaviour erlang loading escript erlc dialyzer typer longer load erlang detail see http pre built version window fetched http http online documentation browsed http erlangotp source also found github official erlang repository thank contribution
165,Lobsters,erlang,Erlang development,"Comparing Languages for Engineering Server Software: Erlang, Go, and Scala with Akka",http://www.dcs.gla.ac.uk/~trinder/papers/sac-18.pdf,comparing language engineering server software erlang go scala akka,,obj endobj obj filterflatedecodeid index info rlength rsize stream b bd endstream endobj startxref eof obj stream endstream endobj obj endobj obj endobj obj endobj obj stream pj b ypt z b v sn w
166,Lobsters,erlang,Erlang development,A Theory of Reversibility for Erlang,https://arxiv.org/abs/1806.07100,theory reversibility erlang,donate arxiv simon foundation member organization,donate arxiv please join simon foundation generous member organization supporting arxiv giving campaign september contribution fund improvement new initiative benefit arxiv global scientific community
167,Lobsters,erlang,Erlang development,Elchemy,https://wende.github.io/elchemy/,elchemy,,type language elixir elm perk language string perk language case language elixir easy concurrency elm runtime error elchemy elchemy let write simple fast quality type safe code leveraging elm safety elixir ecosystem
168,Lobsters,erlang,Erlang development,kvakvs/ErlangRT,https://github.com/kvakvs/ErlangRT,kvakvserlangrt,erlangrt runtime progress proof concept compiling rust cargo rustup editing code navigation reference material contributing license inspection,erlangrt runtime erlang replacement therapy attempt make erlang runtime beam emulator rust first attempt kinda know progress proof concept term library remaining progress external term format decoder encoder beam loader mostly done vm process vm loop opcodes basic bifs binary subbinaries binary heap binary opcodes test work running make test try run init produce output compiling source assumes erlang otp source git submodule otp stdlib preload beam file compiled ready makefile take care install latest rust cargo via rustup run make magic bash autocomplete see target support might like make run run executable test args whatever set developer expect show magical trick make doc build doc page targetdocerlangrt make test run test make build make buildrel build run debug release target respectively currently emulator expects preloaded beam module otp located otp git submodule makefile take care editing code navigation using strongly recommend intellij idea ce free version intellijrust plugin available repository tab inside intellij reference material contributing see contributingrst license inspection
169,Lobsters,erlang,Erlang development,Implementing SSH tunnels in Elixir,https://medium.com/@Drowzy/implementing-ssh-tunnels-in-elixir-e7ad9d1af01a,implementing ssh tunnel elixir,introduction application connecting ssh server available type tunnel source note,introductionerlang otp includes ssh application thought would attempt implement ssh tunneling elixir similar define tunnel using opensshwith openssh one define local tunnel using following command ssh nnt l user forward traffic word connect nnt option tell ssh run command redirect null stdin allocate tty possible run command tunnel l local bind address reverse also possible specifying r option even work socket ssh nnt l varlibmysqlmysqlsock user writing post alongside implementation sort recollection implemented gist part correct full source found hereconnecting ssh serverwe define module simple connect create connection ssh server libsshtexsince calling erlang host string binary need encoded charlisthere using username password authentication well allowing user interaction option requiring interaction fail connection attempt lot option available fine grained control u option sufficethe ssh application need started try connect server mixexsdef application extraapplications logger ssh endand try iex ok pid sshtconnect host user ubuntu password ok pid work ready start implementing tunnel type tunnelsthere two kind tunnel interested indirecttcpip allows u client connect ip port using ssh server directstreamlocal allows u connect unix domain socketdirecttcpip forwarding part erlang sshapplication past since removed however implement using sshconnectionhandler source function used internally creating channel instance reference look like sshconnection openchannel connectionhandler channeltype channelspecificdata initialwindowsize maxpacketsize timeout connectionhandler pid receive sshconnectchanneltype type message u either dirrecttcpip directstreamlocal opensshcom channelspecificdata messag construct message format belowinitalwindowsize initial tcp window sizemaxpacketsize max allowed packet sizeand directtcpip message format byte sshmsgchannelopenstring directtcpip sender initial window maximum packet sizestring host port connectstring originator ip originator portwe define function sshtexlibsshtexon line create message translating directtcpip message format binary due excellent bit syntax read basically original message format specificationsince host field variable size length prepended note sshmsgchannelopen sender channel field part message set internally sshconnectionhandleropenchannelif interested reading binary pattern matching think article good job explaining itthe type directtcpip defined module attribute remember since calling erlang application need represented charlist instead string maxwindowsize set specified maximum packet lengthall implementation must able process packet uncompressed payload length byte le total packet size byte le including packetlength paddinglength payload random padding mac iniwindowsize trickier since know impact setting value low high set since pretty sure seen set somewhere go thatif call successful receive open channel use channel connection pid call send data forwarded ip let try sending raw http message iex ok pid sshtconnect host user ubuntu password ok pid iex data get rnrn iex open ch sshtdirecttcpip pid open iex sshconnectionsend pid ch data handle data returned connection receive block iex receive sshcm data ch data ioputs data endendwe receive message using receive block creating channel inside process genserver instance receive using callback def handleinfo sshcm data ch data state ioputs received data length data noreply state endnote say required something actually responding forwarded ip otherwise fail vm setup private ip nginx running port
170,Lobsters,erlang,Erlang development,What is 42? …Or The Semantic of Function Arguments – Erlang Battleground,https://medium.com/erlang-battleground/what-is-42-4eb39b66ba16,semantic function argument erlang battleground,spec one thing let crash three combined entity new ultimatequestion new new list usort ultimatequestion three different entity new ultimatequestion new ultimatequestion new ultimatequestion new answer everything newultimate ultimatequestion want answer answer answer answertoultimatequestion answertoultimatequestion,specsif reading blog know huge fan dialyzer first step task write function described would write spec itthis may seem tedious lead u first important realization function answer produce answer one thing namely ultimate question mean function likely one answer question answer actually since provide answer ultimate question might well proper type answer question ultimate answer way need catchall clause image since dialyzer able let u know someone calling function something ultimate question case simply let crash great transferred problem need function build question something questionsexport new opaque ultimate spec new assuming question ultimate ie ultimate question question new generate ultimate question also regular one question mark exactly struggling ultimate question requirement clear course science fiction thing unheard real life right simplicity let assume module question generate question based solely topicssubjects represented atom ultimate question question module generate given right topic code blog header seems imply word many question different topic provide right one function generate ultimate questioneven superstrong assumption still many many option let ponder shall three combined entitiesone way look problem seems one erlangexplained us think life universe everything different topic ultimate question together case one way modeling would one seen header new life universe everything ultimatequestion new would spec function spec new topic topic topic mean build question topic course could also version new argument still modeling world question limited set subjectsalso happens someone alters order argument eg question new universe life everything generate ultimate question would personally recommend different approach scenario spec new topic new topic case list usort topic everything life universe ultimatequestion sortedsubjects endthis model represents world generate question many topic want choose three relevant one building ultimate questionthree different entitiesanother way interpret sentence would answer ultimate question life ultimate question universe also ultimate question everythingwith interpretation really need know one main topic build question build right one depending new topic new life ultimatequestion life new universe ultimatequestion universe new everything ultimatequestion everything new topic function let u build different ultimate question assuming accepts atom still evaluate answer everythingok everything individual entity way represent literally anything word ultimate question everything question everything generic question asked particular thing instance life universe stretch know maybe english native language maybe complicated like way understood book first read itin mind ultimate question topic mean ultimate property derive question topic need something like instead spec newultimate topic ultimate newultimate topic ultimatequestion topic exposing interface build ultimate question want particular build exactly one blog header question ultimate life universe everything want answer good nice actually implement well since already spec really need know anything question receiving except answer question ultimate answer answer ultimatequestion try compile erlc promptly tell ultimatequestion unused code actually answer question ultimate answer answer function one argument ignored clause argument except implementing behavior callback course safely remove update system calling function provide parameter maybe renaming function get level documentation answertoultimatequestion answer answertoultimatequestion whole goal system evaluate function require u produce question anymore get rid question module altogether right case would generated system provides answer ultimate question life universe everything regardless question actually fact system provides way u generate need different look alright alright said loonquawl please tell u question ultimate question yes life universe everything yes deep thought pondered moment tricky said cried loonquawl deep thought pondered another long moment finally said firmlyi think modeled deep thought perfectly module deepthoughtexport spec answertoultimatequestion answer answertoultimatequestion
171,Lobsters,erlang,Erlang development,Rethinking app env,http://www.theerlangelist.com/article/rethinking_app_env,rethinking app env,state live reconfiguration context conflation post config script execution time move execution config script runtime configuring runtime consolidating service configuration consolidating system configuration configuring phoenix endpoint deepmerge supporting runtime configurability library app env support runtime configuration final thought,app env use elixir doc state otp provides application environment used configure application experience app env moderately complex system typically contain following thing thing system configuration thing system configuration thing modified runtime affect system behaviour thing modified runtime affect system behaviour thing vary across different mix environment thing vary across different mix environment thing essentially code eg mfa triplet key implicitly connected module word app env tends degenerate bunch keyvalues arbitrarily thrown place article try reexamine way use app env closely related elixir cousin config script configexs friend propose different approach configuring elixir system idea present might sound heretical warn upfront point writing personal opinion community standard approach suggested elixir core team however keep open mind might find idea might lead nice benefit better organized configuration code complete flexibility fetch configuration data arbitrary source much le bloat config script app env long road ahead u let kick live reconfiguration technically speaking app env mechanism allows u keep application specific data memory data visible process app process change data hood app env data sits publicly accessible ets table named actab semantics ets really good let see simple example suppose need run periodic job want support runtime reconfiguration simple implementation could look like defmodule periodicjob use task def startlink arg taskstartlink defp loop config applicationfetchenv mysystem periodicjob processsleep keywordfetch config interval ioputs keywordfetch config message loop end end notice particular fetching periodic job parameter app env every step loop allows u reconfigure behaviour runtime let try iex defmodule periodicjob end iex applicationputenv mysystem periodicjob interval timerseconds message hello world iex supervisorstartlink periodicjob strategy oneforone hello world sec hello world sec let reconfigure system iex applicationputenv mysystem periodicjob interval timerseconds message hi world hello world sec hi world second later hi world second later example able reconfigure running system without restarting also worth noting thing system running production either via remote iex shell using observer tool important point live reconfiguration work code cache app env data local variable instead refetches configuration every iteration give u runtime configurability contrast piece data fetched app env changing runtime affect behaviour system let see example suppose writing web server want configure via app env simple plugbased code could look like defmodule mysystemsite behaviour plug def childspec arg scheme http plug module option port applicationfetchenv mysystem httpport end end let say http port initially set start system try reconfigure dynamically changing port iex applicationputenv mysystem httpport unsurprisingly affect behavior system system still listen port force change need force restart parent supervisor parent supervisor process case app env fetched invoked parent initializing plug example site theoretically dynamically reconfigured quite clumsy need intimate knowledge code reapply app env setting practical intent purpose port app env setting constant begs question app env value constant affect runtime behaviour keep app env first place one layer indirection justified somehow possible reason would varying configuration different mix envs dev test prod consolidating system configuration single place dependency library requires third scenario avoided believe first two app env config script far perfect understand let look config script issue context conflation suppose need use external database system say postgresql database want work via ecto scenario common enough even phoenix default generate ecto repo configuration invoke mix phxnew devexs config mysystem mysystemrepo adapter ectoadapterspostgres username postgres password postgres database mysystemdev hostname localhost poolsize testexs config mysystem mysystemrepo adapter ectoadapterspostgres username postgres password postgres database mysystemtest hostname localhost pool ectoadapterssqlsandbox prodsecretexs config mysystem mysystemrepo adapter ectoadapterspostgres username postgres password postgres database mysystemprod poolsize get different database configuration dev test prod prodsecretexs file gitignored freely point local database without fear compromising production committing production secret first glance look great varying configuration different mix envs way running prodcompiled version locally however approach without issue one minor annoyance since commit prodsecretexs repo every developer team populate manually big issue bit clumsy ideally development setup would work box important issue production setup running system otp release strongly advise need host secret file build server production server want manage separate staging server us different database need somehow juggle multiple secret configs build server separately compile system staging production approach becomes unusable deploying system client premise case aircloak brief description system see post scenario development team know configuration parameter system admins access code elixirerlang knowhow therefore config script really work let take step back root cause mentioned problem setting different db parameter different mix envs conflating compilation runtime context view mix env devtestprod compilation concern determines variation compiled version example dev might configure auto code recompiling reloading prod turn likewise dev test might disable system service eg fetching twitter feed use fake replacement however mix env assume anything execution context want able run prod compiled version locally local verification benching example likewise assemble otp release prod addition running production box want run staging server using separate database scenario easily handled config script follows config script good fit specifying difference different execution context config script execution time better way specify difference use external configuration source say o env externally supplied file kv etcd let say decided keep connection parameter o env configuration code could look like configexs config mysystem mysystemrepo adapter ectoadapterspostgres username systemgetenv mysystemdbusername password systemgetenv mysystemdbpassword database systemgetenv mysystemdbdatabase hostname systemgetenv mysystemdbhostname configure variation devtestprodexs set different o env var target machine compile prod version run different box using different database however lead another problem current elixir config script evaluated compilation runtime using otp release assemble separate build server practice recommend reallife project simply fly today env parameter retrieved compilation runtime end problem admittedly elixir team plan move execution config script runtime mean issue solved future however need fetch data external source json file etcd instance change help essentially chickenandegg problem app env value need resolved apps started even runtime config script need run dependency eg json decoder etcd client loaded consequently need fetch value using dependency library config script place thing config script evaluated soon worst case evaluated compilation build server best case evaluated dependency started contrast service system repo endpoint process started way later sometimes even conditionally consequently config script often force fetch config value much sooner moment actually need configuring runtime given issue outlined strong opinion connection parameter external service belong config script configure connection previously required trickery luckily ecto phoenix recently added explicit support runtime configuration shape callback one way could configure database connection params defmodule mysystemrepo use ectorepo otpapp mysystem def init arg appenvdbparams ok keywordmerge appenvdbparams dbconfig defp dbconfig hostname osenv mysystemdbhost username osenv mysystemdbuser password osenv mysystemdbpassword database osenv mysystemdbname end defp osenv name case systemgetenv name nil raise o env name set value value end end end approach moved retrieval connection params runtime repo process starting ecto first read app config configured config script invoke fill blank big gain running runtime application starting dependency already started therefore freely invoke systemgetenv jasondecode etcdclientget anything else suit purpose consolidating service configuration one issue code difficult use different database test environment could worked around systemputenv call placed testhelperexs however approach fly source truth file etcd instance really want ability bypass o env check test environment enforce database name different way config script give convenient solution problem could provide database name testexs testexs config mysystem mysystemrepo database mysystemtest adapt configuration code defmodule mysystemrepo use ectorepo otpapp mysystem def init arg appenvdbparams ok keywordmerge appenvdbparams dbconfig appenvdbparams defp dbconfig appenvdbparams hostname osenv mysystemdbhost username osenv mysystemdbuser password osenv mysystemdbpassword database keywordgetlazy appenvdbparams database fn osenv mysystemdbname end end end fix problem solution leaf lot desired point database configured different config script repo module personally find quite confusing grasp database configuration particular mix env need consider least three different file configexs mixenv ex repo module source file make matter worse config file bloated unrelated configuration eg endpoint setting database configuration could even dispersed throughout config shape configexs config mysystem mysystemrepo ten hundred line later config mysystem mysystemrepo let consider even use config script first place already pulled database parameter repo parameter still config script reason convenient encode variation mix envs config script put stuff desired mixenv ex good go however never get something nothing pay writing convenience sacrificing reading experience understanding database configuration becomes much harder better reading experience would entire database configuration consolidated one place since need determine parameter runtime place encode variation different mix envs luckilly fairly simple light touch elixir metaprogramming defp dbconfig database dbname end mixenv test defp dbname mysystemtest else defp dbname osenv mysystemdbname end code somewhat elaborate consolidated explicit code clearly state test env database name forced particular value ie configurable contrast previous version vague constraint leaf room mistake renaming repo module forget update config script might end running test dev db completely mess data worth noting ever invoke mixenv compilation either module level ie outside named function inside unquote expression mix available runtime even mixenv possibly give meaningful result remember mix env compilation context get runtime dislike ifelse noise last attempt introduce simple helper macro defmacrop envspecific config quote unquote keywordgetlazy config mixenv fn keywordfetch config else end end end defp dbconfig database envspecific test mysystemtest else osenv end notice change semantics compiled code since envspecific macro invoking make compiletime decision inject one code another constant value function call example test environment code osenv executed even make compiled version consequently freely invoke anything want json decoding fetching etcd example executed runtime desired mix env added bonus envspecific macro requires value specified current mix env else setting macro complain compile time value provided summarize touch metaprogramming achieved feature parity config script moved retrieval parameter runtime consolidated repo configuration expressed variation mix envs clearly stronger guarantee shabby consolidating system configuration one frequent argument app env config script allow u consolidate parameter system single place supposedly config script become goto place refer want see aspect system configured however soon want configure external service database left two choice shoehorn configuration config script move configuration runtime first case need resort sort improvisation make work soon need support multiple execution context ride fun might consider abandoning otp release completely run iex mix prod imo bad idea take advice go leaf second option system parameter retrieved runtime point config script cease single place system parameter defined bad thing though honest think config script poor place consolidate configuration anyway first config script tend quite noisy contain sort data including thing part system configuration consider following configuration generated phoenix config mysystem mysystemrepo adapter ectoadapterspostgres database adapter really configurable thing change say mysql everything magically work opinion unless explicitly worked support scenario fail spectacularly therefore adapter parameter system hence belong aside aircloak due nature system database adapter configurable parameter however configured ecto adapter rather particular setting specific system setting affect system work database internal variation way complex supporting different database required lot work beyond passing one ecto adapter needed support scenario invested effort make happen need need invest effort database adapter system configuration parameter theory change practice another example config bloat config mysystem mysystemwebendpoint rendererrors view mysystemweberrorview accepts w html json pubsub name mysystempubsub adapter thing configuration parameter theory could construct scenario need configurable case yagni parameter library system hence add bloat config script app env another problem config script tend populated arbitrary way personal sentiment content becomes function arbitrary decision made different people different point time best developer make sensible effort keep thing feel like system configuration config script often content config script determined demand library default established code generator convenient ability vary value across different mix envs summary place supposed consolidated system configuration contain thing system parameter thing system parameter let take step back consider even want consolidated system configuration one reason could make easier developer find parameter system need determine database connection parameter http port logging level open config script find personally hard time accepting argument first configuration imo naturally belongs place us interested db connection parameter first look repo module want know endpoint parameter look endpoint module approach also make easier grasp configuration read config script spammed bunch unrelated data neither care moment hold together head contrast read consolidated repo config isolation easily understand important reason system config consolidation assist administration external administrator people might access source code maybe fluent elixir consult code discover system parameter however reason stated feel config script suffice task mentioned database connection parameter likely part config script complete consolidation already lost addition external admins fluent elixir could problem understanding elixir script especially dynamic plan assisting administration consider using well understood external configuration source ini env json file kv etcd app env needed config script suffice anyway likely end variation configuration style proposed performed runtime reallife example system building aircloak running client premise configured client administrator access secret access source code facilitate administration fetch system parameter json file provided administrator explicitly carefully cherry picked parameter belong system configuration everything else implementation detail cause bloat config consequence know exactly piece data provided configuration validate config file schema fail fast key name misspelled data right type configuring phoenix endpoint let take look involved example blog powered phoenix endpoint completely configured runtime therefore endpointrelated config piece following config erlangelist erlangelistwebendpoint reason need empty config phoenix requires endpoint parameter provided defmodule erlangelistwebendpoint def init key phoenixdefaults ok erlangelistwebendpointconfigconfig phoenixdefaults end since lot parameter significant variation different mix envs decided move code another module separate plug chaining configuration assembly function look like def config phoenixdefaults phoenixdefaults deepmergedeepmerge commonconfig deepmergedeepmerge envspecificconfig configurehttps end starting default value provided phoenix apply common setting envspecific setting finally http specific tuning needed due auto certification let encrypt note deep merge since env specific setting might partially overlap common one since afaik deep merging available elixir resorted deepmerge library common config determines parameter vary mix envs defp commonconfig http compress true port rendererrors view erlangelistweberrorview accepts w html json pubsub name erlangelistpubsub adapter end notice http port hardcoded reason mix envs host machine always particular value constant config parameter production request arrive port however configured outside elixir using iptables forward port port allows run elixir system nonprivileged user since variation different envs significant use envspecific macro trick instead opted plain mixenv based switch case mixenv dev defp envspecificconfig dev parameter test defp envspecificconfig test parameter prod defp envspecificconfig prod parameter end complete version seen consolidation allows find complete endpoint configuration single place something case config script clearly see difference dev test prod without needing simultaneously look three different file bunch unrelated noise worth repeating code feature parity config script particular dev testspecific parameter make prodcompiled version supporting runtime configurability fun experiment also added bit runtime configurability allows change behaviour system without restarting anything site running keep aggregated usage stats see read count per article implemented quick dirty way using erlangtermtobinary storing data file use separate file day system periodically deletes older file relevant code sits erlangelistusagestats module also responsible configuration configuration specifies often inmemory data flushed disk often cleanup code invoked many file preserved cleanup relevant piece configuration code defmodule erlangelistusagestats def startlink arg initconfig end defp initconfig applicationputenv erlangelist module config defp config flushinterval envspecific prod timerminutes else timerseconds cleanupinterval envspecific prod timerhours else timerminutes retention end end like endpoint repo configuration encapsulated relevant module however since want support dynamic reconfiguration explicitly storing config app env start process finally ever access parameter directly invoking applicationfetchenv see without caching value variable therefore changing app env setting runtime affect future behaviour system result style configuration config script become lightweight configexs config logger console format time metadata level messagen metadata userid config erlangelist erlangelistwebendpoint devexs config logger level debug console format level messagen config phoenix stacktracedepth testexs config logger level warn full app env erlangelist app small consisting mostly parameter affect runtime behaviour system iex applicationgetallenv erlangelist erlangelistusagestats flushinterval cleanupinterval retention erlangelistwebendpoint includedapplications library app env sometimes dependency require app env setting provided need use config script example logging level logger application best configured config script logger actually support runtime configuration could set logger level app start callback however point app starting dependency already started setting might applied late thus configuration best done config script also many library erlang elixir one needlessly require parameter provided via app config library author cautious opting interface case plain functional interface take option function parameter suffice alternatively well could support callback similarly ecto phoenix invoke init callback function allowing client provide configuration runtime case requiring app config best choice good example aforementioned logger scenario far often plain functional interface superior option besides keeping thing simple giving maximum flexibility user also able better document enforce parameter type via typespecs also like caution keeping code reference config script mfa atom implicitly tied module compiled code accident waiting happen rename module forget update config thing break lucky break abruptly test silently work prod might face sort strange issue hard troubleshoot library author try enforce user set foobar app env key define module name rarely good approach ever occasional case eg module need provided via app config good example plugging custom log backends logger situation common think hard making choice case taking function callback module via parameter better option final thought impression elixir project tend overuse config script app env reason likely historic far remember even pure erlang library frequently required least promoted app envs particular technical reason feel overuse amplified elixir config script admittedly convenient simplify writing process also make easy add bloat app env consequently end config script describe complete system configuration frequently contain thing configuration since executed compile time config script cause lot confusion work need fetch parameter source o env even elixir team manages move config execution runtime still likely limited offer fetching source etcd external file json ini require different solution opinion better approach drive configuration retrieval runtime place actually need fetch site configuration endpoint module repo configuration repo module separate different configuration concern consolidate parameter naturally belong together importantly shift configuration retrieval runtime giving much higher degree flexibility keep mind app env another data storage central place config parameter storage pro con use accordingly read data app env startup need app env first place copying data o env app env skip app env always read o env instead need cache parameter avoid frequent roundtrips external storage consider using dedicated ets table caching library cachex since app env value changed runtime limit app env usage piece data used change system behaviour even case likely better without config script define configuration data place used common kv store dependency requires app env startup best option provide via config script use config script case much smaller easier grasp feel library needlessly requires app env setting contact maintainer see improved careful using config script vary behaviour different mix envs achieve effect bit elixir metaprogramming help consolidate configuration keep thing system parameter outside app env config script keep mind mix function invoked runtime mixenv meaning runtime make distinction compile time execution context compile mixenvprod compiled production version version run production box prod compiled code easily invokable dev box staging machine consequently variation execution context variation compilation context thus belong configuration script mechanism relying mixenv finally want consolidate system parameter assist external administrator consider using well understood format env ini json file storage etcd cherry pick parameter relevant leave one implementation detail keep configuration check make possible validate startup final parting gift recommended reading happy configuring
172,Lobsters,erlang,Erlang development,In Defense of gen_event,http://www.rkallos.com/blog/2018/05/22/in-defense-of-gen-event/,defense genevent,defense erlang blog post,defense genevent erlang genevent drawn ire erlang elixir developer many post written one conference talk given various alternative genevent post make case despite wart age genevent still useful module know also make case core design ultimately lot flexible many people give credit certain design decision give rise flexible system example erlang asynchronous sending message synchronous receiving message timeouts offer developer full range message passing behaviour synchronous sending send message ideally unique reference receive pattern matching reference sent basically go use gen call asynchronous receives use receive block instantly time message matched code syncsend pid msg ref makeref pid ref msg receive ref reply reply end asyncrecv receive ok none end question erlang gave synchronous sends asynchronous receives would go implementing asynchronous sends synchronous receives core design erlang message passing flexible enough express message passing semantics implement default please keep mind turn attention genevent unfamiliar genevent work moreorless like genevent startlink start called event manager process write module implement genevent behaviour writing called event handler event manager list installed event handler state process call genevent notify event manager invoke installed handler one time event manager one process repeat emphasis event manager process executes installed event handler one time decision draw ire particularly josé valim blog post replace genevent supervisor event manager bunch genservers event handler know strange think default behaviour genevent perfectly fine ultimately much flexible solution concurrent handler suggested jose want event handled concurrently trivally implement fanning installing event handler forward message existing process spawn process execute event handling code however conccurent handling event default behaviour would set implementing sequential handling event suspect basically wind implementing le efficient version genevent le efficient sending unnecessary message question genevent ran handler concurrently default would go running handler sequentially conclusion genevent much like erlang message passing provides flexible base upon easily implement different behaviour happy genevent exists decided sequential handling event would default behaviour
173,Lobsters,erlang,Erlang development,What Sucks About Erlang (2008),http://damienkatz.net/2008/03/what_sucks_abou.html,suck erlang,suck erlang take whole book describe properly,suck erlang language everyone complains language one us said time whine favorite language use quite extensively erlang love ya need word basic syntax erlang based originally prolog logic programming language briefly hot surely seen language based prolog right prolog suck as building entire application nt deterred erlang stealing dynamite syntax problem unlike c algol based language erlang syntax away nested statement terminator instead us expression separator everywhere lisp suffers problem erlang nt interesting property completely uniform syntax powerful macro system redeem sometimes flaw really strength sometimes flaw erlang expression terminator vary context editing code much harder conventional language refactoring cutting pasting moving code around particularly hard without creating bunch syntax error consider code blah true foo bar blah false baz let say want reorder branch blah false baz blah true foo bar change order foo bar called blah true bar foo blah false baz problem note example bar line different character ending line bar bar bar algol based language statement terminator everywhere usually semicolon newline javascript version function blah flag flag bar foo else baz erlang expression separator vary context context simply mental work get right expression might think branching something language could ever get wrong nt seem possible young first problem every time executes match least one conditional expression branch exception thrown example x foo foo x bar bar end x must foo bar ifclause exception thrown sorta make sense since nt statement like c language family like c ternary operator x foo foo bar must return value caller problem prevents simple code like logging log something happened end logging false throw ifclause exception instead forced something like logging log something happened true ok end purpose true ok line give else condition match weird taste back throat probably vomit erlang ifs could much useful would return sensible default conditionals match like empty list undefined atom instead blow exception erlang sideeffect free functional language restriction would make sense side effect free instead idiotic painful get worse even call user defined function conditional expression example wo nt even compile call user defined shouldfoo x shouldfoo x x foo bar shouldfoo x compile error line foo true ok end limitation due erlang clause pattern matching engine need certain guarantee expression static optimization erlang allows subset builtin function bifs conditional expression user defined function called whatsoever language butchered still useful well fortunately case expression erlang powerful damn useful decent substitute us case shouldfoo x true foo false ok end like expression case expression also limitation must match least one conditional exception thrown bleh say string character say list integer obvious problem erlang application sucky string handling erlang string type string list integer integer encoded character value string bad benefit taking builtin list operation library optimization reusing string processing also mean ca nt distinguish easily runtime string list especially string list integer erlang console get dog true erlang string operation simple easy language integrated string type personally would nt pick erlang frontend web application work probably choose php python scripting language integrated string handling functional programming mismatch erlang great fit couchdb network database server got erlang weirdness accepted wart almost could nt imagine using anything else much code seems want expressed recursive functional manner lightweight shared nothing concurrency great match network server database internals code typically much compact elegant reliable would conventional language came time write test suite code couchdb found erlang needlessly cumbersome verbose inflexible immutable variable erlang hard deal code tends change lot like user application code often performing bunch arbitrary step need changed need evolve c let say code int f int x x foo x x bar x return baz x want add new step function int f int x x foo x x fab x x bar x return baz x one line need editing consider erlang equivalent f x foo x bar baz want add new step requires editing every variable thereafter f x foo x fab bar baz erlang context dependent expression separator immutable variable end huge liability certain type code result far line edits otherwise simple code change couchdb test suite could feel syntax fighting every turn switched writing test javascript thing flowed faster edits easier erlang nt good match test reason nt think good match frontend web application record record feature provides cish structure facility surprisingly limited verbose requiring state type record reference code variable binding must state variable type every place member variable record referenced record foo bar f f fooa f foob f foo cf fooc f foo statement say record variable type foo enough say must say time use idiomatic use record us pattern matching extract member local variable bar foo aa bb cc f b f foo cc still noisy compared equivalent c struct foo int int b int c foo bar foo f fa fb fc return f another problem record often feel like tackedon hack compiletime static record member added removed runtime nt fit erlang otherwise dynamic nature record compile time feature vm feature statically compiled regular tuples first slot holding record name atom slot n corresponding nth entry record declaration compile time record member reference converted integer offset tuple operation noticeable problem nt usable repl command line wo nt accept record syntax without special step still nt show result record record syntax debugging dumping stack trace symbol record always look like tuples cover requiring mentally decode tuple slot corresponds record member erlang record give penalty static typing little benefit give memory give death update o x recent erlang vm emulator version longer reproduce problem yay couchdb discovered hard way erlang handle memory allocation error o exit vm get memory o commits harakiri nt kill virtual erlang process need memory kill whole vm taking along child o process least honorable death see try erlang console eshell abort g beam malloc vmallocate failed error snip stack trace crash dump written erlcrashdump eheapalloc allocate byte memory type heap abort trap problem might think given erlang robust failfast restart nature restart automatically barely miss beat well thought generally positive guy nope erlang wo nt restart automatically something build solution found create parent watchdog process monitor vm restart crash builtin heart child o process whose job monitor unresponsive erlang vm restart also killed vm exit roll restart dead vm solution deal crossplatform issue providing something still shocked erlang ca nt handle code organization code organization offered source file module class namespaces oo fanatic anymore see real value code organization every time time need create something resembling class like otp generic process create whole erlang file module mean whole new source file copyright banner plus erlang cruft top source file must added build system source control extra file creation artificially spread code file system making thing harder follow wish simple class facility nt need inheritance virtual method static checking monkey patching like encapsulation ability say hunk data use method taste tootsie center would satisfy unmet project organization need uneven library documentation core erlang well documented designed many included module buggy overly complex poorly documented three inets httpd server found incredibly frustrating use couchdb discarding party erlang http library xml processor xmerl slow complicated documented anything erlang using gui like debugger process monitor hideous window pretty much unusable o x otp build versioning system complicated verbose still nt understand like crufty know erlang evolving real world use long time nt make cruftyness accumulated year smell better coding standard core erlang library differ widely different naming argument ordering return value convention tolerable still must still deal erlang really suck yes way described nt also erlang amazing way would take whole book describe properly toy built satisfy urge academic used successful real world product good chance erlang good match us list nt meant put erlang honest assessment weakness think nt discussed enough posted march pm
174,Lobsters,erlang,Erlang development,Riak Core Tutorial Part 2: Starting,http://marianoguerra.org/posts/riak-core-tutorial-part-2-starting.html,riak core tutorial part starting,riak core tutorial part setup creating project riakcore building running relx exploring template file learn erlang great good building otp application section learn erlang man page app erlang documentation application behavior supervisor behavior documentation editorconfig website cuttlefish schema logging library release documentation playing clustering profile feature building production release wrapping,part series see previous one riak core tutorial part setup creating project tool template installed start asking create new project call tanodb using riakcore template installed new nametanodb fails saying ca nt find check path environment variable erlang activated output something like writing tanodbappstanodbsrctanodbappsrc writing tanodbappstanodbsrctanodberl writing tanodbappstanodbsrctanodbapperl writing tanodbappstanodbsrctanodbsuperl writing tanodbappstanodbsrctanodbconsoleerl writing tanodbappstanodbsrctanodbvnodeerl writing tanodbrebarconfig writing tanodbeditorconfig writing tanodbgitignore writing tanodbreadmerst writing tanodbmakefile writing tanodbconfigadminbin writing writing tanodbconfigadvancedconfig writing tanodbconfigvarsconfig writing writing writing building running explaining file mean get idea happened let run cd tanodb make make console make run command build release project us tool called relx initial build may take since fetch dependency build release built check result inspecting folder builddefaultreltanodb run run make console get noisy output end something like eshell abort g tanodb erlang shell something like repl connected system test system calling tanodb ping tanodb tanodb ping response atom pong huge number explain later make short id process replied u exploring template file template created lot file like nt like thing make magic nt explain going get brief overview file created first file created appstanodbsrctanodbappsrc appstanodbsrctanodberl appstanodbsrctanodbapperl appstanodbsrctanodbsuperl appstanodbsrctanodbconsoleerl appstanodbsrctanodbvnodeerl meat project source code start know little erlang recognice many let explain briefly think need information recommend awesome book read online learn erlang great good tanodbappsrc file application resource file read quite self descriptive read building otp application section learn erlang man page app erlang documentation tanodberl file main api application expose thing ask application handle ping command add future tanodbapperl file implement application behavior set callback erlang runtime call start stop application tanodbsuperl file implement supervisor behavior set callback erlang runtime call build supervisor hierarchy tanodbconsoleerl file specific riakcore set callback called tanodbadmin command tanodbvnodeerl file specific riakcore implement riakcodevnode behavior set callback riakcore call accomplish different task main file edit add new feature source code file template also created file let review rebarconfig file read get information project like dependency build configuration read documentation editorconfig file describes coding style project text editor understands editorconfig file change setting project one described file read editor config editorconfig website gitignore file tell git file ignore repository readmerst readme project makefile make file target make easier achieve complex task without copying pasting much configadminbin template tanodbadmin command cuttlefish schema file describes configuration application support start example configuration field use application grows configadvancedconfig file configure advanced thing application nt go tanodbconfig file configure riakcore logging library configvarsconfig file contains variable used relx build release read release documentation following file like varsconfig slight difference allow running one node machine normally cluster application one operating system instance run one instance application many operating system instance test clustering feature riakcore build release application using offset port changing application name avoid collision file follow link know playing clustering starting add feature let first play clustering understand config file work build release run machine make devrel build release application using different parameter file saw earlier place achived using profile feature open console run following command one console make make make start node wo nt know know need join tell one two achieved using tanodbadmin command run manually nt run cluster join cluster join tell join make easier le error prone run following command make devreljoin let check status cluster make devrelstatus read makefile get idea command case devrelstatus following memberstatus see something like membership status ring pending node joining joining valid say node joining check cluster plan make devrelclusterplan output something like staged change action detail join join note applying change result cluster transition cluster transition membership status ring pending node valid valid valid warning replica distinct node transfer resulting cluster change transfer transfer commit plan make devrelclustercommit say something like cluster change committed riakcore started internal process join node cluster involve complex process explore following chapter see console node running logging happening describing process check status cluster make devrelstatus see vnodes transfering mean content virtual node one tanodb node transferred another tanodb node membership status ring pending node valid valid valid point see something like mean node joined balanced membership status ring pending node valid valid valid bored stop make devrelstop building production release even application nt feature merit production release going learn since later step get full release app make prodrelease command run release task using prod profile configuration difference dev profile use build something unpack run another operating system without installing anything let package release cd buildprodrel tar czf tanodbtgz tanodb tanodbconfig cd mv buildprodreltanodbtgz copy clean o run tar xzf tanodbtgz tanodbbintanodb console run note build production release operating system version intending run avoid version problem main source headache c extension disagreeing libc version similar even could build version close test better build release version avoid problem packaging erlang runtime release wrapping know create riakcore app template build release run build release development cluster run node join inspect cluster status build production release run fresh server
175,Lobsters,erlang,Erlang development,The gen server simplified (how it works),http://erlang.org/pipermail/erlang-questions/2011-April/057777.html,gen server simplified work,erlangquestions gen server simplified work erlang redacted http information erlangquestions mailing list,erlangquestions gen server simplified work joe armstrong erlang redacted wed apr cest many user seem use genserver absolutely everything often force problem fit gensever even though genserver appropriate problem genserver extremely simple bit code easily changed fit problem though people nt often posting explain basic idea genserver work illustrate written minigserl mini genserver understand minigserl understood real genserver work real genserver add load bell whistle minigserl minigserl compatible interface genservererl subset genserver api module minigs export module behaves like genserver subset genserver command startlink local name mod args opts register name spawn fun start mod args end call name x name self ref makeref x receive ref reply reply end start mod args ok state mod init args loop mod state loop mod state receive tag x case mod handlecall x state reply r tag r loop mod end end nt painful client start calling ming startlink local name mod args opts ignored opts minigs also frozen name server form local name genserver general argument name server happens minigs call mod init args initialize server must return ok state state becomes initial state server minigs call loop mod state minigs receives message tag x call mod handlecall x state return repy r sent back client server call new state interface routine abstract interface client sever write simple client application module kv define client api export must defined called g export define g minigs define g genserver define client api start g startlink local someatom kv foo store key val g call someatom putval key val lookup key g call someatom getval key define internal routine init foo ok dict new handlecall putval key val dict reply ok dict store key val dict handlecall getval key dict reply dict find key dict dict module call either genserver minigs change define statement turned single process keyvalue store using dict global keyvalue store note kverl never us primitive spawnlink send receive ie kverl written pure sequential code made genserver abstraction write welltyped sequential code handlecall init function parametrize concurrent behavior ie need know nothing concurrency get job done abstracted concurrency thing become problematic entirely understand abstraction maybe abstraction inappropriate need seen many example code genserver inappropriate acid test gensever code look like spaghetti answer yes done shoe horn application inappropriate form case ditch genserver rollyour joe next part html attachment scrubbed url http information erlangquestions mailing list
176,Lobsters,erlang,Erlang development,Core Erlang by Example,http://blog.erlang.org/core-erlang-by-example/,core erlang example,previous blog post simplest function slightly le simple note one clause two clause three argument value list repeated variable exception primop binding variable using let binding one variable let three unedited core erlang code conclusion dialyzer learn core erlang core erlang language specification,may björn gustavsson blog post first core erlang format blog post introduce core erlang format example compare erlang code corresponding core erlang code used following command translate example module core erlang code erlc time tocore coreexampleerl compiling coreexample parsemodule kb transformmodule kb lintmodule kb expandrecords kb core kb syscorefold kb coretransforms kb listing kb previous blog post explored pass parsemodule expandrecords core pass translates abstract code core erlang talk core erlang pass future blog post slightly edited example make somewhat easier read unedited example end blog post lot cover let get started simplest function let start simplest possible function function argument returning atom core erlang fun ok example work following principle slightly le simple slightly complicated function core erlang fun note example compiled otp name generated variable different upcoming otp essentially variable named erlang translation core erlang compiler generates new variable name argument function head following code also valid core erlang one clause function one clause ok error core erlang fun case true ok true error end fun single clause pattern matching must done case fun head guard mandatory clause case valid variable name core erlang uninteresting value must bound new variable around pattern explained soon erlang multiple function clause also written case like b n case n ok error end core erlang code essentially core erlang code fun case true ok true error end two clause three argument let try multiple argument c inc base n basen c base base core erlang fun case inc base n true call erlang base n base true base end denote value list pattern clause case always part value list case expression value list unless one expression operator part core erlang language compiler translated use call bif erlang let see implemented b b greater true notgreater end core erlang fun case call erlang greater true notgreater end case expression pattern value list zero element action guard repeated variable erlang variable repeated clause within pattern indicate value must cmp cmp different core erlang allow repeating variable fun case call erlang true different end second occurence variable renamed new variable named guard added compare exception function fail functionclause exception called value core erlang fun case true ok true primop matchfail functionclause end case core erlang must fall end must always clause match example last clause variable pattern true guard guaranteed match body last clause call primop generate function clause exception primops primitive operation provided erlang implementation specified core erlang language specification similar function excepts us case therefore generate caseclause exception called argument f n case n ok end core erlang code similar code fun case true ok true primop matchfail caseclause end difference argument matchfail primop let rewrite function one time core erlang fun case true ok true primop matchfail badmatch end difference argument matchfail primop binding variable using let function bind variable h id core erlang fun let apply call erlang apply call fun local function return value apply bound variable variable used code follows keyword variable name value list let bind several variable binding one variable let erlang essentially scoping variable bound remains bound end function example variable bound case used case e case e x b x end x core erlang fun let x case true b true true primop matchfail caseclause end x case core erlang export variable variable used case must explicitly returned example first two clause case return value list three value first value return value case case ignored two value value assigned x variable respectively value returned case bound let ignored return value bound new variable never used exported value bound x variable unedited core erlang code far core erlang example edited make point trying make stand clearer let look unedited version previous example line fun case true ok true primop matchfail functionclause functionname compilergenerated end associate annotation core erlang construct meaning annotation specified core erlang language specification compilergenerated annotation associated last clause hint added compiler subsequent optimization pass generate warning clause found never match dropped comment line beginning actually annotation pretty printer turned comment avoid rendering prettyprinted code unreadable conclusion core erlang le complicated erlang therefore suited abstract format code analyzing tool dialyzer optimizers learn core erlang detail found core erlang language specification
177,Lobsters,erlang,Erlang development,Leibniz is a pure Erlang/Elixir math expression parser and evaluator,https://github.com/saulecabrera/leibniz,leibniz pure erlangelixir math expression parser evaluator,leibniz installation usage documentation example todo license,leibniz leibniz pure erlangelixir math expression parser evaluator installation defp deps leibniz end usage documentation leibniz provides two core functionality evaluating valid math expression evaluating valid math expression given context example evaluating simple math expression leibnizeval ok evaluating math expression given context leibnizeval foo foo ok leibnizeval baz error value expected following dependency baz todo license mit
178,Lobsters,erlang,Erlang development,Memory instrumentation in Erlang OTP 21,http://blog.erlang.org/Memory-instrumentation-in-OTP-21/,memory instrumentation erlang otp,,instrument allocation ok udpinet drivereventstate ttysl ioqueue drvinternal system dbsegment heap thrprgrdata dbterm code binary atomentry message spawnforker driverselectdatastate ramfiledrv drvbinary primfile processspecificdata niftrapexportentry monitorextended drvbinary binary primbuffer nifinternal binary
179,Lobsters,erlang,Erlang development,10 Ways to Stop an Erlang VM,https://medium.com/erlang-battleground/10-ways-to-stop-an-erlang-vm-7016bd593a5,way stop erlang vm,good c init thing doc init stop heart erlang doc jcl mode ctrlg q remsh break mode ctrlc ctrlc,goodthere several way shutdown erlang vm c init simplest cleanest one use c actually thing doc put function shorthand init stop cause node stop controlled fashionand init stop basically end running init stop understand command let check doc application taken smoothly code unloaded port closed system terminates calling halt status commandline flag heart specified heartprogram terminated erlang node terminates information see heart limit shutdown time time init allowed spend taking application commandline flag shutdowntime usedso cleanest shutdown possible also skip clean part jump straight erlang see doc erlang halt erlang halt erlang erlang halt run shutdown vm application properly terminated port properly jcl modethe previous method rely able run command shell remotely using distributed erlang instance blocked shell something well shell node want turn even receiving input still press ctrlg take jcl mode use command q quit erlang shellthis similar effect erlang halt way best way stop remsh node without stopping original break modeinstead ctrlg press ctrlc take break mode look like break bort c ontinue p roc info nfo l oaded v ersion k ill btables istributionyou two thing shut node press ctrlc againpress returnboth behave like erlang halt
180,Lobsters,erlang,Erlang development,The Erlang Runtime System,https://happi.github.io/theBeamBook/,erlang runtime system,,list sort list seq erlang list sort erlang list redbug done timeout
181,Lobsters,erlang,Erlang development,Lost in Translation (Exploring the BEAM Compiler's Front End),http://blog.erlang.org/compiler-lost-in-translation/,lost translation exploring beam compiler front end,previous blog post compiler stdlib compiler abstract format lost translation looking closer parsemodule pas tokenizing using erlscan token tokenization scanning erlscan preprocessing token parsing using erlparse parse parse tree abstract format prettyprinting using erlpp erlpp quick look preprocessor epp pass operating abstract format transformmodule pas qlc mstransform lintmodule pas erllint translating record erlexpandrecords tip producing single source file using p point ponder,april björn gustavsson blog post explore compiler pass make compiler front end previous blog post showed time option show information compiler pass executed erlc time trivialerl compiling trivial removefile kb parsemodule kb transformmodule kb lintmodule kb expandrecords kb explained removefile pas previous blog post today blog post discus pass listed output pass make compiler front end implementation module pass compiler application stdlib reason erlang shell also us module mean shell work embedded system include compiler application front end pass operate abstract format abstract format fairly close original erlang source code fact prettyprinting abstract format reconstruct original source code albeit perfectly lost translation see much lose translation compile prettyprint module module trivial export record rec mod func result example help explore compiler front end example b c rec mod module func functionname resulta b c use p option run parsemodule pas produce listing result erlc p time trivialerl compiling trivial parsemodule kb transformmodule kb lintmodule kb listing kb moment ignore transformmodule erllint pass change abstract code module listing pas pretty print abstract format converting back erlang source code creating file trivialp cat trivialp file trivialerl module trivial export record rec mod func result example b c rec mod trivial func example result b c comparing trivialp file original see lost translation module functionname macro invocation replaced trival example respectively done preprocessor comment disappeared also several difference amount whitespace surrounding variable operator abstract format include whitepace comment representation also note redundant pair parenthesis omitted expression b c parenthesis around still otherwise value expression would change abstract format direct representation parenheses looking closer parsemodule pas seen lost translation take closer look abstract format use expression b c example translate abstract format using module parsemodule pas us work tokenizing using erlscan first step translation erlang source code group character logical group called token process called tokenization scanning done erlscan module use erlscan tokenize example compiler use function erlscan principle ok token erlscan string b c token b c output list token second element tuple line number first element category token third element symbol within category see whitespace already lost comment would lost read detail token see erlscan preprocessing token compiler next step would run preprocessor token example macro invocation thus nothing preprocess skip next step parsing using erlparse next step parse token produce abstract format ok abstract erlparse parseexprs token abstract b c result list one expression expression list parse tree visualized like parenthesis lost structure tree make evaluation order unambiguous see abstract format detail abstract format prettyprinting using erlpp listing pas us erlpp module pretty print abstract format produce listing file pretty print abstract format example list flatten erlpp exprs abstract b c pretty printer inserted one pair parenthesis redundant pair parenthesis original expression lost whitespace also different original quick look preprocessor mentioned passing preprocessor epp module run tokenization parsing preprocessor go token looking question mark followed variable atom example module source file would tokenized like erlscan module assuming module name trivial preprocessor replace token token pass operating abstract format parsemodule explained let take quick look pass front end transformmodule pas transformmodule pas run parse transforms example qlc mstransform lintmodule pas lintmodule pas verifies code semantically correct variable must bound used clause function must number argument compile module problem erllint print error message terminate compilation cat bugerl module bug export main ab erlc time bugerl compiling bug removefile kb parsemodule kb transformmodule kb lintmodule kb variable unbound variable b unbound translating record expandrecords pas us erlexpandrecords translate record erlc e time trivialerl compiling trivial parsemodule kb transformmodule kb lintmodule kb expandrecords kb listing kb cat triviale file trivialerl module trivial export record rec mod func result example b c rec trivial example b c e option produce listing abstract format produced expandrecords pas record declaration still construction record replaced construction tuple similarly matching record translated matching tuples tip producing single source file using p p option used package source file includes multiple include file single selfcontained source file selfcontained source file useful want report compiler bug time minimize source code minimum example example compileerl file includes two header file compiling directly like work cd libcompilersrc erlc compileerl ca nt find include file erlcompilehrl must give path include directory kernel stdlib erlc kernelinclude stdlibinclude compileerl package source compileerl well content header file use p option generate compilep erlc p kernelinclude stdlibinclude compileerl compilep renamed compileerl successfully compiled without additional option mv compilep homecompileerl cd home erlc compileerl point ponder preprocessor run tokenization running parser functionname functionarity macro implemented example token simple function look like ok erlscan string foo tag x functionarity foo tag x functionarity
182,Lobsters,erlang,Erlang development,Bend it like gen_statem,http://blog.ikura.co/posts/bend-it-like-gen-statem.html,bend like genstatem,search ideal co web address,search ideal co web addressget gone
183,Lobsters,erlang,Erlang development,Erlang Scheduler Details and Why It Matters,https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html,erlang scheduler detail matter,erlang garbage collection detail matter scheduling green thread native thread preemptive cooperative erlang scheduling process reduction scheduling run queue scheduling scheduling migration logic controlling monitoring api scheduler thread process priority run queue statistic calculating prime number conclusion caf resource external link,underlying feature make erlang soft realtime platform one garbage collection mechanism talked previous article erlang garbage collection detail matter one scheduling mechanism well worth looking article explain history current status controlling monitoring api scheduling generally speaking scheduling mechanism assigns work worker work could mathematical operation string processing data extraction worker resource could virtual like green thread physical like native thread scheduler carry scheduling activity way maximizes throughput fairness minimizes response time latency scheduling main part multitasking system like operating system virtual machine divided two type preemptive preemptive scheduler context switching among running task power preempt interrupt task resume later time without cooperation preempted task done based factor like priority time slice reduction cooperative cooperative scheduler need task cooperation context switching way scheduler simply let running task voluntarily release control periodically idle start new task wait return control back voluntarily question scheduling mechanism suitable realtime system must response within specified time cooperative scheduling system satisfy realtime system running task system might never return control back return late deadline realtime system commonly use preemptive scheduling erlang scheduling erlang realtime platform multitasking us preemptive scheduling responsibility erlang scheduler selecting process executing code also garbage collection memory management factor selecting process execution based priority level configurable per process priority level process scheduled round robin fashion hand factor preempting process execution based certain number reduction since last time selected execution regardless priority level reduction counter per process normally incremented one function call used preempting process context switching counter process reach maximum number reduction example erlangotp maximum number reduction scheduling task erlang long history changing time change affected change smp symmetric multiprocessing feature erlang scheduling erlang smp support one scheduler run main o process thread accordingly one run queue existed scheduler picked runnable erlang process io task run queue executed erlang vm scheduler task task task task task n run queue way need lock data structure written application take advantage parallelism scheduling smp support added erlang vm could scheduler run one o process thread however version scheduler could pick runnable task one common run queue erlang vm scheduler task task task scheduler task task n scheduler n run queue resulting parallelism method shared data structure protected lock example run queue shared data structure must protected although lock provide performance penalty performance improvement achieved multicore processor system interesting known bottleneck version follows common run queue becomes bottleneck number scheduler increase increasing involved lock ets table also affect mnesia increasing lock conflict many process sending message process process waiting get lock block scheduler however separating run queue per scheduler picked solve bottleneck issue next version scheduling version scheduler run queue decrease number lock conflict system many scheduler many core also improves overall performance erlang vm scheduler run queue scheduler run queue migration logic scheduler n run queue n way locking conflict accessing run queue solved introduces new concern fair process dividing task among run queue one scheduler get overloaded task others idle based order scheduler steal task overloaded scheduler started many scheduler task concern lead erlang team introduce concept making scheduling fair efficient migration logic try control balance run queue based statistic collect system however depend scheduling remain exactly today likely changed future release order get better controlling monitoring api erlang emulator flag well internal controlling monitoring function scheduling behaviour scheduler thread number maximum available scheduler thread online scheduler thread specified passing two colonseperated number flag booting erlang emulator erl start script erl maxavailableschedulers onlineschedulers number maximum available scheduler thread specified boot time fixed run time number online scheduler thread specified changed boot time well run time example start emulator scheduler scheduler online inside shell online scheduler thread changed follows erlang systeminfo scheduler return erlang systeminfo schedulersonline return erlang systemflag schedulersonline return erlang systeminfo schedulersonline return also using sp flag set percentage process priority said scheduler select process execution based priority level priority specified inside process calling erlang function pid spawn fun processflag priority high end priority low normal high max atom default priority level normal max reserved internal use erlang runtime used others run queue statistic explained run queue hold process ready execution picking scheduler possible get count process ready execution available run queue erlang statistic runqueue function real example let boot erlang emulator online scheduler assign heavy cpubound process concurrently process could calculating prime number big number everything clean ready erlang statistic onlineschedulers erlang statistic runqueue spawn heavy number crunching process concurrently spawn fun calc primenumbers end list seq run queue remaining task erlang statistic runqueue erlang still responsive great calc primenumbers wait moment erlang statistic runqueue wait moment erlang statistic runqueue number concurrent process online scheduler take time scheduler execute process run queue make empty interesting thing spawning heavy process erlang emulator still responsive preemptive scheduling let heavy rogue process chew runtime without letting light likely important process execute great feature come implementing realtime system conclusion although implementing preemptive scheduling system could complex case erlang responsibility developer feature inside virtual machine hand extra processing cost tracking balancing selecting executing migrating preempting process totally affordable system need scale processing resource high level fairness also responds timely realtime system way worth mentioning fully preemptive scheduling feature nearly operating system support case high level platform language library claimed erlang virtual machine almost unique jvm thread depend operating system scheduler caf c actor library us cooperative scheduling golang fully preemptive also applies python twisted ruby event machine nodejs mean best option every possible challenge mean need implement realtime system low latency erlang good option resource external link
184,Lobsters,erlang,Erlang development,Calling Elixir from Erlang,https://joearms.github.io/published/2017-12-18-Calling-Elixir-From-Erlang.html,calling elixir erlang,,
185,Lobsters,erlang,Erlang development,What efficient pattern matching looks like at the bytecode level,https://dockyard.com/blog/2018/02/27/what-efficient-pattern-matching-looks-like-at-the-bytecode-level,efficient pattern matching look like bytecode level,intellij elixir beam chunk code tab map checking efficient pattern matching additional resource beam wisdom beam file format parser decompiler opcodes operation name genoptab,looking disassembled view module defmodule eextestwebuserview use eextestweb view end intellij elixir beam chunk code tab thought something wrong string inliner bsmatchstring call seemed missing prefix letter template name ormhtml instead formhtml ndexhtml instead indexhtml etc since bsmatchstring directly label looked back find jump came label selectval call label block selectval valuetolabel argument map integer label first saw thought number weird bitpacking bitstring match state looking ascii table matching label first character template name used selectval decimalcharlabelsuffix label jumped selectval match checking rest string match selectval generated label block group clause rendertemplate generated phoenixtemplatebeforecompile theory beam make pattern matching efficient general find prefix matched selectval corollary see selectval bytecode getting mostefficient pattern matching branching pattern check implemented separate bytecode instruction might make sense rearrange clause affect semantics see selectval pop generated bytecode sure compiler optimization pas enough prove clause rearranged get selectvals clause immediately next code written map bsmatchstring match suffix known template name keep referring label faillabel label give argument string instead check map argument looking elixir phoenixtemplate x used second argument two clause appear match order label label compiler using efficient istaggedtuple bytecode check module module template instead grab value gettupleelement iseqexact test istaggedtuple exists handle common either type ok value error reason record iseqexact appear label block check two template parameter line elixir code value since iseqexact allows left right operand mean repeating variable twice pattern probably requires additional bytecode operation check verified yet label block show map equivalent istaggedtuple check single map key value constant need get value register getmapelements test constant iseqexact wonder fused operation istaggedmap would make checking conn plugconn struct guard pattern faster also appears move compiler trace x already proved hold eextestwebuserview used moved x templateraisetemplatenotfound call code shown start x template x assigns x eextestwebuserview move source x destination x overwrite eextestwebuserview x template x assigns x assigns move source x destination x overwrites assigns x template x template x assigns move source eextestwebuserview destination x reloads eextestwebuserview litt literal table chunk x eextestwebuserview x template x assigns needed happen register rotation since bytecode operation done move eliminating reread litt would require using register x extra move long litt move cheaper register register move efficient checking efficient pattern matching want confirm compiler walking pattern match efficiently possible disassemble beam file check beginning function using selectval repeated usage variable pattern first stored separated register pairwise checked equality iseqexact although vm hundred x register call need argument starting x group move follow pattern match rearrange pattern register call argument position additional resource like learn beam format used beam wisdom beam file format guide development beam parser intellij elixir power decompiler beam chunk viewer shown screenshots opcodes operation name determined genoptab searching otp source code operation name
186,Lobsters,erlang,Erlang development,For goodness namesake,http://blog.ikura.co/posts/for-goodness-namesake.html,goodness namesake,search ideal co web address,search ideal co web addressget gone
187,Lobsters,erlang,Erlang development,Exploring the Compiler Using the 'time' Option,http://blog.erlang.org/compiler-time-option/,exploring compiler using time option,option useful undocumented option documented point ponder,april björn gustavsson first series blog post compiler blog post compiler work might work future historical note explain thing blog post talk one useful option exploring compiler namely time option first let see time action huge file many function many variable number get interesting erlc time nbappducontentserl compiling nbappducontents removefile kb parsemodule kb transformmodule kb lintmodule kb expandrecords kb core kb syscorefold kb coretransforms kb syscorebsm kb syscoredsetel kb kb kb kb beama kb beamreorder kb beamblock kb beamexcept kb beambs kb beamtype kb beamsplit kb beamdead kb beamjump kb beampeep kb beamclean kb beambsm kb beamreceive kb beamrecord kb beamtrim kb beamflatten kb beamz kb beamvalidator kb beamasm kb savebinary kb time option given compiler print line executing compiler pas first line name compiler pas often always name name erlang module implement compiler pas name followed time second compiler spent running compiler pas smaller file time usually zero nearly zero huge file time nonzero example syscorefold pas need one half second work time followed amount memory used compiler pas blog post talk compiler pass compiler pass later blog post removefile pas first pas run remove existing beam file outdated beam file case compilation fails last pas savebinary pas save binary beam code beam file let see output change give option erlc time nbappducontentserl compiling nbappducontents parsemodule kb transformmodule kb lintmodule kb expandrecords kb core kb syscorefold kb coretransforms kb syscorebsm kb syscoredsetel kb kb kb kb beama kb beamreorder kb beamblock kb beamexcept kb beambs kb beamtype kb beamsplit kb beamdead kb beamjump kb beampeep kb beamclean kb beambsm kb beamreceive kb beamrecord kb beamtrim kb beamflatten kb beamz kb listing kb see list pass changed last pas run listing produce listing beam assembly code file removefile pas beginning run beam file produced existing beam file preserved let try one many undocumented debugging option erlc nopostopt time nbappducontentserl compiling nbappducontents removefile kb parsemodule kb transformmodule kb lintmodule kb expandrecords kb core kb syscorefold kb coretransforms kb syscorebsm kb syscoredsetel kb kb kb kb beama kb beamclean kb beamz kb beamvalidator kb beamasm kb savebinary kb see far fewer pass run nopostopt option turn optimization run beam code ie optimization time option useful compilation module slow time show particular pass bottleneck much slower pass fact long time ago compiler needed several minute compile nbappducontents module used example blog post time option immediately pointed bottleneck needed fix compiler terminate compiling certain module time show last successfully run pas one culprit compiler ignores option recognize misremember misspell option compiler expect adding time option help verify expected compiler pass run undocumented option documented many option meant debugging allow skip certain optimization pass produce listing code certain pas option shown running compile erlang shell erl erlangotp source hipe kernelpoll false eshell abort g compile option dpp generate pp file p generate p source listing file dabstr generate abstr file debuginfo run saveabstractcode dexp generate expand file e generate e source listing file dcore generate core file run corelintmodule doldinline generate oldinline file dcorefold generate corefold file dinline generate inline file dcopt generate copt file point ponder name compiler pass begin follow blog might answer future blog post
189,Lobsters,erlang,Erlang development,A blog from the Erlang/OTP team,http://blog.erlang.org/,blog erlangotp team,contention adapting search tree read read persistentterm persistentterm read read scalable orderedset read read read ssabased intermediate representation read new ssabased intermediate representation introduction ssa read new ssabased intermediate representation erlangotp repository previous blog post read read read interpreter read read previous blog post read read read read read read read,august kjell winblad scalability ets table type orderedset writeconcurrency option substantially better erlangotp earlier release extreme case expect time better throughput erlangotp compared erlangotp cause improvement new data structure called contention adapting search tree ca tree short blog post give insight ca tree work show benchmark result comparing performance ets orderedset table otp otp read may kenneth lundin otp released may th long process three release candidate february march april final release thankful feedback got regarding release candidate revealed bug flaw internal testing find read september lukas larsson blog post go three different us persistentterm used since release explain bit work well persistentterm read may lukas larsson otp released long process three release candidate final release decided year try get one month testing major release think extra time paid received many bug report community large small bug internal test find read january lukas larsson working implementation new scalable orderedset came across strangeness guarantee iterating table inserting element parallel read november john högberg erlangotp bring many performance improvement table broad impact affect way write efficient code post like highlight thing used surprisingly slow longer need avoided read october péter dimitrov erlangotp important release ssl application working several new feature improvement support tl already master branch blog post present new ssl debug logging built new logger api read september björn gustavsson blog post look back development ssabased intermediate representation beginning year end august branch merged read september björn gustavsson blog post continues exploration new ssabased intermediate representation multiple example make sure read introduction ssa missed read september björn gustavsson blog post introduction new ssabased intermediate representation recently merged master branch erlangotp repository us example previous blog post first looking generated ssa code optimization read august björn gustavsson back summer holiday blog change track start series blog post static single assignment ssa first installment set scene post follow looking trap pitfall one fall trying optimize beam assembly code read june björn gustavsson blog post brief history lesson erlang compiler beam machine provide context first quick look abstract machine erlang read june lukas larsson beam interpreter ert completely rewritten otp instruction remained perl script used generate c code new implementation blog post look optimization possible change read may björn gustavsson blog post wrap exploration core erlang started previous two blog post remaining default core erlang pass described followed look core erlang represented internally compiler read may björn gustavsson blog post continues exploration core erlang looking optimization done syscorefold compiler pas core erlang language introduced previous blog post read may björn gustavsson blog post first core erlang format blog post introduce core erlang format example compare erlang code corresponding core erlang code read may lukas larsson release candidate released thought would go change excited likely mostly mean feature ert core library change familiar read may john högberg memory instrumentation module rewritten erlangotp make easier use post describe rationale behind new feature make use read april björn gustavsson blog post explore compiler pass make compiler front end read april björn gustavsson first series blog post compiler blog post compiler work might work future historical note explain thing blog post talk one useful option exploring compiler namely time option read april lukas larsson erlangotp introduce completely new io polling implementation new implementation come new set tuneable parameter used get system blog post describes parameter attempt describe used read
190,Lobsters,erlang,Erlang development,Property-based Testing Basics (2016),https://ferd.ca/property-based-testing-basics.html,propertybased testing basic,propertybased testing basic claim work regular test fsm validation long take run tip trick write suite additional reading material reference,propertybased testing basic quick introduction text regarding general concept behind propertybased testing claim diving propertybased testing work let go wild claim erlang factory last march slide set thomas art said used quickcheck canonical propertybased testing tool run test project fifo open source cloud project end result line production code line quickcheck test bug uncovered bug uncovered included timing error race condition type error incorrect use library api error documentation error logic system limit error error fault handling coincidentally hardware error quickly look possible work work magic propertybased testing two basic mode propertybased testing datastructure generation finite state machine model validation regular test datastructure generation fairly simple reimplemented many language initial haskell version quickcheck go type declaration generator declaration generate complex instance type pas function method rather going explicitly listing relevant case finding edge condition write specification say expect type data bit code say expect true matter data test tool generates test find edge condition would nt thought let say piece code find greatest value list value could write test maxtest assert max assert max show expect max value work float integer seems properly cover case mind problem nt check number stuff funky negative positive handle larger integer fine list iteration buggy list item greater item starting list condition costly thing find property max list trick figure say without implementation one way would example use existing min function say biggest number one one smaller could take sort function return item order picking last item mean greatest maxtest list max list last sort list propertybased test framework randomly generate list number run assertion max list last sort list one fails complains find bunch case first test nt consider empty list list single element function expected two maybe ca nt work empty list modify generator say nonempty whatever language notation one interesting instead say line test code kind interleavings max function effective line code cover data ask test framework generate longer complex case generate hundred million variation want iteration go forward framework add complexity type dataset let say example property failing input shrinking framework go back try simplify input could produce say even better mean max last sort obvious maybe code wrong maybe test case likely candidate could sort stable two value compared equal remain order final list whereas max could always favor leftmost item list greatest requires refine property want max stable care nt care need modify property either value good make sure true need modify implementation always return rightmost operand list greatest stuff would likely exposed manual testing propertybased testing uncovers kind gotchas like code seemingly simple straightforward basic propertybased testing nutshell fsm validation advanced kind exists frequently used erlang far tell one discussed thomas art presentation work special thing represent program execution sequence data structure use quickcheck big magical thing build framework define model consisting state machine containing initial state system data structure list command run interface precondition command valid operation order possible state transition command could enact adduser function mean model contains user nt exist postconditions command according current state function return ok userid user nt exist framework take model written pre post condition generate sequence operation data structure much like regular propertybased test case grows complexity operation iteration take sequence model run real code step step compare output model output real thing ensures post condition still hold one nt model disagrees implementation test failure much like regular test case try shrink result finding simpler sequence operation find problem bug went user add app remove app readds app scale move tier move tier scale scale run new release bug sequence move tier scale shrinking mechanism could possibly find big strength exactly fuzzing complete test suite like model validation generated command sequence although nonexhaustive basic test bit like fuzzing requirement propertiesinvariants maintained big distinction since exploration guided type command sequence generated ability shrink problem simpler form still spending bunch time toying framework specifically proper gpl variant quviq quickcheck framework use powerful feel force develop new way think program behave long take run tool like quickcheck proper let specify many iteration want default tend run test small run trivial change want safety check proper verifying dependency compiling shunk testing propshunktab propfirst ok passed test property testing propshunktab propthresholds ok passed test property passed period represents test usually shown real time know test execution progressing modify something trickier configure thing run test like pick single property doubt run time want given mostly running evergrowing test loop speed test case depends mainly long generate data set long test take run given data set time n iteration data generation generally fast stick basic type custom recursive generator sort way go deeply complex suite generate two data set keyval pair diff wanting difference sometimes easy write thing way generating data set eats everything think way use framework laziness macro balance probability speed thing upmake sure nt run infinitely usually worth possible bring also trick like knowing fancy property system vast majority distributed system error found node example write property test unlikely need run node let thing go faster time take test run long well usually hard optimize especially testing asynchronous system must insert pause thing sync test sometimes run parallel cope procedure particularly slow find pay look data generating function framework make sure cover lot ground proper statistical distribution running test time may dig many case simpler one run time example simple example writing parser tokenizer directing framework generate string character parser care may prove useful randomly generating string entire unicode space might otherwise generate string case exercising code much may later write specific property test unicode support end usually end sticking thing faster run common case gon na run whole suite large sample make sure nothing funny happened course change tip trick write suite hard part writing propertybased test difficult code react properly defined extracting property thinking hard always good may require lot exploration tdd propertybased testing difficult seems help figure property absence married specific implementation aside usual sit think hard approach usually good way generate test write model central part behind statemachine generation equally valid data structure simpler test write implementation code except want make simple wrong care efficiency make slow problem worry correctness take implementation pit actual production code behave know despite complexity production code tends behave way would expect regardless complexity gotchas tricky implementation interesting approach becomes also lot propertybased testing tutorial look daunting test case often look complex code tested tutorial try keep code sample simple propertybased testing valuable code complex case propertybased testing need tool find specific regression sneaked past model suite always help add literal regression test suite side another reminder volume never trump quality quality generated test may great thought still recommend trying tweak propertybased suite generate error since may help discover lot bug hiding code additional reading material reference
191,Lobsters,erlang,Erlang development,The BEAM needs an APL-y language,https://medium.com/@gordonguthrie/the-beam-needs-an-apl-y-language-6c5c998ba6d,beam need aply language,name god saint http enwikipediaorgwikiversionvector http online yer takeaway son mean prezzo http manual programming use case apl used used programming http gonnae write apl language beam,one like one unpopular opinion one top twitter game innit well mine beam already prology erlang algoly elixir lispy lfe language need aply language wut look like pic top postapl stand another programming language imagine brass neck eh old language designed expressivewhy name god saint good question let start tuck reason write new programming language able thing betterfasterway back day hired basho coding challenge company bankrupt let see version vector concise representation event tracking change data item distributed system read moreabout http enwikipediaorgwikiversionvector http attached file line twotuple containing two version vector version vector modeled list twotuples vc actorid countinteger first entry actor system case byte erlang binary b c e f g h second entry positive integer denotes latest event actor clock summarizesversion vector descends version vector b every event summarized b also version vector b equal descends b b descends b concurrent summarizes event seen b b summarizes event seen afor provided file write program output row table pair vector column output true false first clock tuple b seconda descends b b descends equal b concurrent bfor example generatesfalse true false falseas first version vector ancestor second version vectorprogram language choice may use external library choice please provide u program instruction run resulting outputplease email u need clarification good luck solution online basically raw line code total including test would look like apl something like forgive god apl noob b c c need isequal isunshared need doesdescend flow control inbrowser repl wrote version also probably bit long real apler could shorter yer takeaway son mean apl programme iswould much smaller erlangapl designed expressive whole programme written single page structure grasped programmer prezzo make case apl ably without written blog post read blew mindthe coding example key part crdts convergent replicated data type swatch one c paper might give clue short apl setbased math extract crdt paper http designed expressive expose many set operation developer quick write crdtlike thing designed way understand seemingly bizarre syntax actually simple languagebear mind apl experience reading manual hour flight programming another day experience topsby comparison erlang year full time beltso use case riak number gnarly problem elegant statement requirement whose implementation considerable accidental complexity written erlangsome promising place beam aply language could help might claim algorithm handle placement vnodes clusterpreflists read data cluster particularly stuff like rackawareness guaranteed writes multiple data centre stuffring resizing restructure data distribution cluster dynamicallywhat apl used used programming core technique apl taking two set information generating boolean matrix apply set rule reduce boolean matrix single boolean decision yesno essentially business rule languagemy dear friend mary kane informs left school join irish life insurance trained apl programmer taking set actuarial table apply individual data reducing resulting boolean matrix business decision buysell pricing calculate return etc etcthis pattern familiar spreadsheet user spreadsheet business function largely large set static data mapped boolean matrix presence scenario data reduced decisionsthe famous paper function spreadsheet user actually use make clear dumped every spreadsheet large company government department fingerprinted function use result stark sum vlookup win http basically turning spreadsheet business programme subject know long close heart gonnae write apl language beam jeezo naw ah run aff titssometimes pregnant whole programme see implementation suddenly blue sky need vom finger apl dialectbut really much plate new job thing anyone fancy could write would
192,Lobsters,erlang,Erlang development,A Tour Through the Distributed System Zoo,https://www.youtube.com/watch?v=L7OTjuCIZc0,tour distributed system zoo,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature mariano guerra tour distributed system zoo code beam sf youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature mariano guerra tour distributed system zoo code beam sf youtube
193,Lobsters,erlang,Erlang development,Beautiful Code – a bit of poetry… in Erlang,https://medium.com/erlang-battleground/beautiful-code-254a5f8ef958,beautiful code bit erlang,inakos eci original updated,believe developer closer artist engineer see software development creative endeavour one let express many different way generate much course program system artistically pleasant inakos needed flyer talk eci represented idea beautiful code wanted sure write something actually beautiful borrowed lyric one magnificent song history remixed using favorite language erlangit song mean lot meant lot father also programmer fully understand son first time sung song kid something clicked finally understood meant true wrote original post right son birthday day day sixth one still think one precious piece codethe original updated one favorite song time erlang actually read original notice updated thing learned year hope mind
194,Lobsters,erlang,Erlang development,"Implementing Raft in RabbitMQ - Michael Klishin, Karl Nilsson",https://www.youtube.com/watch?v=w-_1Wwymk58,implementing raft rabbitmq michael klishin karl nilsson,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature implementing raft rabbitmq michael klishin karl nilsson youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature implementing raft rabbitmq michael klishin karl nilsson youtube
195,Lobsters,erlang,Erlang development,The Hitchhiker's Guide to the Unexpected,https://ferd.ca/the-hitchhiker-s-guide-to-the-unexpected.html,hitchhiker guide unexpected,hitchhiker guide unexpected propertestingcom erlang anger http githubcomferdsups,hitchhiker guide unexpected transcript talk given elixirdaze codebeamsf conference march dealing supervision tree unexpected among thing system architect mean job mostly coming broad plan taking merit go well otherwise blaming developer go wrong seriously part job helping make abstract plan system way understandable leave room developer make decision locally mean structuring thing way biggest minefield one might encounter rubber hit road taken care kind critical genetec designing security system used supermarket coffee shop train station airport even citywide system something quite interesting designing system significant failure dude carrying submachine called back fair one designed story heard system often deployed customer site direct management access developer challenge coming solution require little active though must suffer little downtime must make right decision everything go bad system fully isolated hour plan survive whiteboard living document adapted whatever developer encounter work think one simple problem underneath know everything fact know much work trying help along way one thing noticed happening though vocabulary otp give u framework really help stuff barely remember build system without matter design otp approach seeps happens matter discussion erlang system language keep coming back principle using today bit want talk design system actual fault tolerance deal unexpected deal know bite u as specifically context erlang elixir system first think might useful try define bug system come brownorange area right thing know experience measured know fact smallish circle partially overlap code system code answer people writing software code know almost nothing stuff written dwarfed code library use virtual machine operating system cloud hypervisors service depend chance area significant however good thing whenever bug system brownorange circle deal pretty well easy know code know problem domain idea fix thing chance bug place knew find maybe around todo left behind missing error handling maybe found development already decided ship code anyway time budget pressure case simple enough purple area one interesting thing think know never really doublechecked extrapolate guess world work based thing know look part system make guess work go way could work would nt make sense never exactly think world nt make much sense wrong bug cause kind issue place happens top jenga tower system something like file logger deal overload may truncate data nt bad hand bottom jenga tower small wrong assumption dangerous overall stability system favorite example tcp stack tends behave differently loopback interface external one loopback interface error detection mostly instantaneous even sending data detect fault external interface basically real world nt happen built entire system local test possible production one plain broken rather important way alright annoying section one neither circle thing nt know fun category example give automatically leaf category bug take surprise little done good recent example meltdown processor issue side channel attack people ever considered possibility turned put security model necessary entire industry risk another example like thundering herd problem never heard thundering herd happens whenever large set client far limited server whenever big failure cause client disconnect may try connect back exact time whenever happens impact kill remaining server prevent system ever coming back never prepared control client may find tricky situation actual solution thundering herd writing client thing use exponential backoff random jitter factor whenever fail reconnect good know never seen quite simple get orangebrown area easy stuff fine purple one careful pay attention secondguess red area though one difficult one dig hard try gain knowledge people around maybe thought prayer thing usually nt seem effective big question worth lot money shift bug difficult category easier one nt really believe get rid easy handle probably significant improvement simple difficult solution increase knowledge developer know stuff got believe going bug fit thing know category simplest easiest way hire senior developer going know junior one circle thing know cover wider area people thing senior developer must resist temptation sending one corner code mine write difficult stuff eventually leave another place thing remains behind badly documented work answer way maintain operate properly instead aim fostering culture teaching mentorship training sign healthy team one poach senior people see leave poach senior people healthy team one input junior employee output senior employee mean people grow organization seek new challenge left bunch employee never took time train team overall could teach thing share knowledge ultimately prevent system becoming legacy legacy system one nobody know want maintain second way increase knowledge diverse team hiring someone friend year went school worked job good chance orangebrown circle knowledge overlap person orangebrown circle knowledge major way mean come general knowledge risk pretty similar perspective thing also share blind spot instead looking people different background whether term education professional experience different hobby different cultural background far bigger chance respective circle overlap le bug prevented even get programming think localisation internationalisation ever worked people speak one language lived town entire life good chance vastly underestimate kind challenge awaiting come making application available people country different culture lot wellknown error predictable one know different language need rediscovered team could saved time similarly easy software developer population generally welleducated used reading text forget north american considered functionally illiterate unable extract significant information paragraph text app system requires significant documentation usable losing huge amount people even got started put principle another way hire team people love bitcoin good chance come solution includes blockchain matter problem true distributed system engineer various quorum consensus protocol higher amount diversity perspective mean fewer prospective bug team overall knowledge world likely higher get within monoculture mix good culture sharing education engineer growing technical contributor people well necessarily take care code aspect thing though loving image pack laptop going production come code one effective approach take exploratory testing take experienced tester sit front program let go hog wild go around play thing try see program write report almost guaranteed come lot interesting bug nobody would thought downside approach generally time consuming make hard test sort regression lack repeatability also requires experienced tester often manual tester many industry skillset may difficult find instead interesting mechanical automated approach taken help find problem ahead time first one like mention fuzzing fuzzing great going take program instrument right way ask another program throw much garbage objective fuzzing cover much branching logic possible find input crash program one famous example american fuzzy lop asks instrument code give way write input try generate data let cover many branch code possible need generate megabyte w followed arbitrary binary data may point fuzzer like find input crash program would normally cause concern especially language without memory safety guarantee downside though try demonstrate program survives garbage input necessarily right thing drowning said garbage u erlang elixir world propertybased testing fun quickcheck proper triq streamdata used explore program strength approach rather showing whether program crash run propertybased testing attempt demonstrate matter kind garbage throw software still right thing necessarily search differently may tune seek crash nearly much one thing propertybased testing find corner case know existed point view framework really increase knowledge system work still get benefit knowledge without gain time get learn vague requirement know propertybased testing absolutely introduce one powerful testing methodology halfway fuzzing model checking use framework mentioned test basic stuff term data generation login mechanism still work fancy confusing unicode usernames blow log formatting upload picture real weird exif data still work part whole exercise look lot like fuzzing caveat use property looking crash also thing like system mangling usersubmitted data denote proper behaviour instead staying alive real interesting stuff come crossover model checking propertybased testing framework across language well erlang one python hypothesis always good streamdata elixir support none actually planned either although community member want particularly quickcheck let check work example let say service private image storage first come rule system user deletes entry account longer able see picture say nobody see entry belong something like entry duplicated within one account rule well maybe fourth one like user must logged upload entry tell program generate data user entry tell various thing program like log log add view remove entry framework go town system generates sequence operation data structure executes nearrandom walk code make sure rule invariant remain true find bug one rule broken framework shrink counterexample dropping step piece data much keeping failing find one simpler case easy analyze maybe bug system add entry delete readd one refuse duplicate maybe bug happens entry added deleted time maybe duplicate detection cross account boundary framework tell dropping operation simplifying data looking similar failure framework able remove superficial operation irrelevant complexity input end get rather minimal sequence operation required cause bug one much easier reason initial one initially sequence operation maybe shrinking gon na left cause bug one uniquely interesting thing approach look lot like automated exploratory testing find something application expect may clear cut bug also likely hit grey area system obvious whether test expectation need fixing whether system need fixing gain insight system may shine light emergent behavior nobody planned yet seen many nonformal testing method able impact system work mean believe technology much writing book right though cover yet ca nt show slide draft copy propertestingcom interested consequence expand area thing team know within system outside great one funny thing must hope happens team continuously learning proving wrong gap thing know thing think know shrink bump head real world hopefully start smell trap gap easily become accurate rather leave le stuff guessing course guarantee may oscillate keep proving right get inflate area thing think know bump head go next general approach take system prevent getting area unknown put safeguard prevent reduce chance something odd unpredictable easiest way write le code le code le know great system decision product folk engineer come agreement small change way thing result much user satisfaction far le code almost guaranteed make everything better overall course always possibility must end code end let talk handle risk factor powerful tool formal method formal specification like tla exhaustive model checking automated proof try reason strictly thing going ensure nothing system understood everything proven work tends work well difficult requires discipline way go thing way decrease unknown might le effortintensive strict assertion use type signature type analysis write le code observable software problem happen u erlang elixir world following worthwhile use dialyzer prevent unexpected type error invalid state use linters code formatters code uniform easy understand prevents issue importantly let crash try massage unusable data acceptable data result trying plow error end situation neither user system expected stuck instead bail fast unknown condition one component bubble unknown condition systemwide help prevent various class emergent behaviour really worthwhile afford use formal tool one last thing want point thing go wrong necessarily go wrong place planned planned go wrong chance already test logging around big error costly surprise u mean likely logging metric near zero insight around time happen figure customer control release cycle mean debugging one thing take multiple month observability practice turn hour poking around instead turn erlang vm built ground learn introspect vm use tracing dig information need even log metric written erlang anger help given vm language observable even code obtuse hard look still get data need blessing language embrace fully train engineer team know use okay next step picked painting absolutely love perfectly represents feeling irrelevance want talk making stuff nt know irrelevant bit shady trick know way class bug group together handle way matter bug covered intuitive one one redundancy multiple node handle traffic time one fails reason whatsoever hardware fault power loss running disk space memory fault covered redirecting traffic around whenever afford redundancy handle unknown condition crashing automated recovery even nt really know cause issue pathological case likely prevented created plenty architectural pattern worthwhile fairly easy find general literature instead want focus thing fairly unique erlang elixir supervision tree supervision tree otp framework give u let u create absolutely flexible structure care handle error without knowing going really get supervision pattern make sure thing work well first familiar supervisor type first one one one supervisor pretty basic restart failed child back known stable state second type rest one approach approach denotes linear dependency child child b c b must depend work c depends b even transitively b job depends none sibling successful one strategy kill child fails usually thing need supervisor child depend work say example twophase commit worker disappearing coming back may really difficult handle properly using one approach instead ask kill worker try clean slate something much simpler get right handling possible interleaving complex multiprocess protocol trying repair thing simple strategy need little bit make really useful question handle process dying regard sibling permanent process always restarted matter think critical service must always transient process process allowed shut disappear done job properly ever die unknown reason think unix process dying return value execution retried finally temporary process never get restarted bit odd use case example tracking process sake interesting one show soon make everything easy understand guide kind exercise project also every team work come building system exercise code written really help deal everything first thing keep mind kind whiteboard session supervisor always start child order depthfirst left right let see one design session go let start identifying resource empty system resource left database queue invisible network boundary system bit local storage node represented small cylinder side network right ip device device anything camera elevator web server handling http request maybe proxy iot device possibly bunch cellphone nt really matter life role box take data left operate configuration data example possibly bring right gather data right bring left gon na cover incredible majority networked middleman application something large amount elixir erlang team aim develop first thing start going left since probably contains configuration data need rightside thing know connect allowed connect going need side first probably need connect either storage endpoint would postgres maybe start supervisor worker pool start pool worker may try establish db connection system get back starting child queue side thing likely work boot pool kafka consumer publisher ready go back need well probably want metric even want observability always good metric want anything proxy problem detection stuff like latency load number request handled next bit since working network must expect network fail probably cache configuration data memory save costly roundtrips reading fact might want store configuration disk well crash come back network come back may actually want depending nature app dealing edge device report state upstream outdated piece config may better running system start looking polling communicating right side going start supervisor many child let see single one may implemented probably middleman supervisor take care two stateful part polling state machine tracking ip device state process holding connectionspecific data two process gather relay device state bring one storage worker value reported also publish metric since worker already virtue structure supervision tree said done described implicit dependency system component specified system boot also system reverse order asking process stop give u pretty good idea system work unfortunately system work easy stuff interesting asking want system fail optimistically want work everything around failing one easy way handle stuff kill everything mind okay let explain bit team work pick random worker sql db worker ask happen process dy sibling die kept alive answer usually oh nt want db worker die one fails take parent supervisor mark one one process kafka worker repeated likely give result go ask question process supervisor db went hard often possible worker died te sql supervisor dy kafka subtree die well answer probably subtrees parent also marked one one repeat kind thing process happens connection device dy fsm die maybe working web server state persist across query maybe die polling iot device probably want stay alive report state change accumulate even period downtime mark supervisor rest one probably take link two worker well since supervision structure encodes ask question one device pollers die others well nt really think since may number device maybe hundred marking supervisor simple one one highly optimized variant one one case many process run code slightly different configuration get want eventually may reach point obvious answer dealing death process way encode answer example may ask database still write accumulate metric maybe database local cache die probably since cache added especially purpose config worker dy poller able still work probably db config pollers work probably yeah give u one conflict already one one relationship two worker level rest one relationship wrong thing give write fancy code handle weird corner case instead suggest patch supervision tree even whiteboard necessarily obvious took year experience take step back think system rather component figure moving subtrees around good enough fix major production incident good look like adding supervision level declare new subtree left one one strategy metric db pool independent also declare relationship config poller rest one relationship allowing keep running even entire left side node vanishes local cache possible maintain make final relationship subtrees official root supervisor use one one strategy like figured handle broad type outage let get back kill process approach interesting question ask happens ip device interacting go bonkers throw garbage point fsm handling keep dying default worker restarted reach max capacity supervisor die happens often enough error bubble towards root tree entire system shut bad single bad device interrupted talking device opposite initially wanted usually point people go mailing list slack channel ask smarter supervisor cooldown period kind fancy retry logic say want supervisor remain simple predictable smart system make stupid mistake want able easily reason system want reduce knowledge required figure thing work instead making kind supervisor variant configure supervisor directly charge fsm connection exactly error tolerance limit want threshold exceeded give device mark poller supervisor temporary setting one mentioned earlier nobody really know beginning well temporary setting buffer mechanism go enough stop retrying already add little highlighted configuration manager grafting brain onto supervisor process go supervision tree possibly compare configuration regular interval repair supervision tree may decide second minute day ip device worker restarted retried fancy logic possibly want within worker tailored specific business concern also happened created central point interaction subtree kafka queue want talk live system create kind pubsub group say gproc config worker andor config manager listen update respective part subtree hell even add additional access point web interface really want also make system lot easier test operate gather metric let selfrepair thing allows stick giant onoff switch system change tricky operation run super interesting approach designing system dependency runtime whatnot encoded supervision tree let u create inline circuit breaker something break know kind work halt must stuff place writing system charm found wrong dependency class bug vocabulary use one adapt supervision tree rather one figuring locally handle error case reaction say know afford error component critical test hell one make sure always maybe possible small part system nearly impossible everywhere least theory difference designing tree work exactly way want first try common pattern may need implement make thing easier written entire blogpost topic titled guarantee nutshell worker expose interface represent failure mode expect let caller know expect time local database running even start probably fine worker die violently access database remote however crash disconnection make caller die well think remote database may go away network time time hint think caller deal failure crash take away option caller easily deal thing instead plan return value expressing error condition let client choose die pattern matching success case implement retry policy cope failure data important give enough detail allow decision think could relevant people let context make decision make one thing want happen blindly retrying action definition insanity particularly critical case consume data way report back client directly reading queue like rabbitmq kafka error totally natural introducing new message type middeploy half node system ready handle nt want stall half cluster case tell client something went wrong need drop message request never work nt must really handle everything like data replication system dropping unforeseen message mean fail job require process everything plan dead letter queue dead letter queue system abdicating going need adult human go make judgment call fix thing drop message reenqueue figure system buggy hold bit longer maybe rollback component introduced finally want mechanism frame retries one example using incremental backoffs jitter factor prevent using many resource thundering herd mentioned earlier may want look circuit breaker let capture many fault happen trip breaker prevent call know likely fail actually interesting thing even include softer metric average request slow take foot gas pedal let create system slow leave space component even fail let create system operate lot smoothly fail shorter period time get going back much easily well supervision tree sadly thing wellbehaved supervision tree know tree right process implement right stuff work structure want bulletproof solution fact one know work well experience use chaos engineering chaos engineering mostly known netflix chaos monkey would piece software would unleash production system let take component see system adapt cope failure nowadays even datacenter level practice include fault injection incident simulation aim define steady state throw failure see stick used erlang elixir system given supervision tree interesting stuff fact use tree model steady state left simulate mock failure kill random process buggy see tree behaves desired little propertybased testing suite thing rather conceptually simple system running active traffic likely load simulator library take snapshot set whitelisted otp application running system library number tree process starting depthfirst right left newer process likely killed first library pick random number wrap around need find process match tag used narrow restrict process process killed library navigates model created snapshot propagates death way taking place without actually side effect two process live one supervisor second one expected die restart well example restart threshold hit expectation direct supervisor also die possibly restarted snapshot system taken bit time stabilize right bit hackish new supervision tree compared old one similar mechanism used fault injection mock fake process circuit breaker put within system test ondemand return specific error message like error disconnected supervision tree still get compared two type property looking supervision tree comparison simple process expected die actually die supervisor within different supervision subtree die image example database worker start returning error busy entirely possible specific fsm process die however many die often supervisor poller supervisor dy test suite considers failure supervisor tree implementation since distinct subtrees either failure case handle error condition currently considered catastrophic choose live find interesting bug fairly easily limited effort developer assuming understand proper test framework project still kind janky prototypelike take look http githubcomferdsups let say got solid supervision tree fully embraced mechanism stretch thing bit something dealing erlang process since supervision tree wellstructured interesting stuff left side put thing consider prerequisite system maybe nt want boot without initial networkbased configuration put worker left root subtree check disk cache network connection available maybe third party service case check ensures unless satisfy prerequisite system dependency place system refuse boot start trying serve traffic go permanent also shut system prevent thing nt example transaction financial stuff lose ability publish audit log possible want entire node go ca nt audit financial stuff may want bam handled right subtree put healthrelated stuff register router service discovery mechanism respond healthchecks make specific worker interesting approach system break due developer mistake transient network condition planned act circuitbreaker fact put anywhere supervision tree farright moment subtree go bad ca nt specific task encoded structure program system unregisters stop ingesting traffic stabilizes automatically reregisters thing get back normal let u take kind guarantee dependency partial failure get within erlang elixir system encode various component gain insight system level ask question whether applied language maybe architecture microservices yes probably look approach used supervisor ask whether could applied stream processing system microservices quickly end messy spiderweb dependency system architecture clean enough clearly see linear dependency individual component could easily represented supervision tree go design exercise microservices may become far easier understand impact component system figure read exception alarm identify root cause overall make everyone life easier unfortunately bit complex encode supervisor service mechanism pattern hopefully replaced service registry local circuit breaker event feed tool like kubernetes already way encode dependency get bit harder example define specific failure rate way break circuit directly nutshell gain knowledge reduce amount unknown system seek broader architectural pattern cope error rather trying prevent first place learn love supervision tree pretty unique pretty powerful thanks
196,Lobsters,erlang,Erlang development,Implementing Languages on the BEAM,https://www.youtube.com/watch?v=lkAbwmn5Rv8,implementing language beam,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature robert virding mariano guerra implementing language beam code beam sf youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature robert virding mariano guerra implementing language beam code beam sf youtube
197,Lobsters,erlang,Erlang development,Natively Implemented Functions in Erlang,https://rhye.org/post/native-methods-in-erlang/,natively implemented function erlang,natively implemented function erlang natively implemented function man page erlnif github update,natively implemented function erlang sat mar erlang surprisingly performant language something provides many high level primitive occasionally come time need perform complex calculation fast immutability erlang data slight overhead beam becomes annoyance example recently working project requires calculating edit distance streaming pair data real time erlang excellent fit streaming data network many parallel worker levenshtein distance calculation somewhat taxing first pas adapted memoized distance calculation using plain erlang erlangleven binbinary ed cache erlangleven bin dict new ed erlangleven binbinary cache bytesize bin dict store bin bytesize bin cache erlangleven binbinary cache bytesize bin dict store bin bytesize bin cache erlangleven cache erlangleven cache erlangleven cache case dict iskey cache true dict fetch cache cache false erlangleven cache erlangleven erlangleven l list min l dict store l end create simple test function see performs midsize input perftest iteration method start o systemtime methodloop iteration method diff o systemtime start iteration diff methodloop ok methodloop method method methodloop method c srcperftest ok perftest perftest perftest fun perftest slightly iteration per second stellar even parallelism going struggle even moderate amount realtime data time turn nifs natively implemented function erlang like many language support foreign function interface ffi allowing simple integration code written cc runtime order add native code project let first create simple library using rebar template ross mjolnir hrperlang new lib levenshtein writing levenshteinsrclevenshteinerl writing levenshteinsrclevenshteinappsrc writing levenshteinrebarconfig writing levenshteingitignore writing levenshteinlicense writing levenshteinreadmemd need update project reflect fact including native code rebar invocation well ross mjolnir hrperlang cd levenshtein ross mjolnir hrpelevenshtein new cmake writing csrcmakefile touch makefile since default work well enough one wanted specify extra compilerlinker flag may need need start writing c code though let create file csrclevenshtein c h add basic glue code first thing want header except include guard include method structure need interact erlang runtime include erlnifh second thing define module callback native module registered may specify three optional callback system invoke different part code lifecycle method required specified ert allow module upgraded inplace keep state module method noops int load erlnifenv env void privdata erlnifterm loadinfo int upgrade erlnifenv env void privdata void oldprivdata erlnifterm loadinfo void unload erlnifenv env void privdata came native method native method signature pointer erlang environment called number argument passed argument type erlnifterm method must return value also erlnifterm actual argument verification must occur method static erlnifterm erllevenshtein erlnifenv env int argc const erlnifterm argv define exported method native module would normal erlang source file case function list erlniffunc structs contains name function number argument arity function pointer flag field flag field left zero case used indicate whether nif dirty info see erlang doc http erlangorgdocmanerlnifhtml dirtynifs static erlniffunc niffuncs levenshtein erllevenshtein finally invoke macro seal pact ert register module given name export list given callback method erlnifinit levenshtein niffuncs load null upgrade unload far good glue need c side handfule line implement function let switch csrclevenshteinc get started full rundown erlang c api take look man page erlnif static erlnifterm erllevenshtein erlnifenv env int argc const erlnifterm argv first thing want function check called correct arity argc nt get two argument expecting need raise badarg error provided function precisely return enifmakebadarg env know two argument argument provided type erlnifterm need make sure expect case two binary enifisbinary env argv enifisbinary env argv nt binary return error tuple error notabinary however need possibly create atom well manually wrap tuple implementation mkatom seen return env mkatom env error mkatom env notabinary point know argument binary safely query load data erlnifbinary struct contains length binary pointer byte erlnifbinary enifinspectbinary env argv enifinspectbinary env argv call actual c implementation levenshtein distance omitted unsigned int editdistance levenshtein ca nt return number directly though need convert erlang term first return enifmakeint env editdistance convert c string atom erlnifterm mkatom erlnifenv env const char atom erlnifterm ret enifmakeexistingatom check atom table see already created atom string representation atom already exists return true ret contain valid atom data always try fetch atom first make new one time risk exhausting finite space allocated atom table enifmakeexistingatom env atom ret atom already part atom table safely create new atom return enifmakeatom env atom return ret done c portion integration need wire erlang side taking advantage onload directive specifies method invoked module code loaded ert case want load file native code soon module added module levenshtein export onload need include dummy method compiler something work implementation replaced native code loaded raise error exceptional case actually get invoked levenshtein exit notloaded module module line line define code loading init method init find priv dir file module name soname case code privdir module error badname exit error missingprivdir dir filename join dir module end attempt load code second parameter passed module load callback loadinfo use ok erlang loadnif soname place left open shell test running shell successfully compile link c library place priv dir let see much speed benefit picked rewriting algorithm natively c srclevenshtein c srcperftest perftest perftest fun levenshtein three order magnitude faster much like hopefully shown implementing something nif excellent performance choice case also daunting task might think want take full look natively implemented library view complete code project github update followup post also written little make nif behave nicely regard erlang scheduler
198,Lobsters,erlang,Erlang development,"The Wide World of Actors, or, Can I Have an Erlang Pony?",https://github.com/slfritchie/wide-world-of-actors/blob/master/can-i-have-an-erlang-pony.pdf,wide world actor erlang pony,permalink join github today sign reload reload reload,permalink dismiss join github today github home million developer working together host review code manage project build software together sign retrieve contributor time sorry something went wrong reload sorry display file sorry file invalid displayed perform action time signed another tab window reload refresh session signed another tab window reload refresh session
199,Lobsters,erlang,Erlang development,"The Wide World of Actors or, Can I Have an Erlang Pony?",https://www.youtube.com/watch?v=uv-3ptTD8hg&feature=youtu.be,wide world actor erlang pony,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature scott lystig fritchie wide world actor code beam sf youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature scott lystig fritchie wide world actor code beam sf youtube
200,Lobsters,erlang,Erlang development,Kapok is a Lisp dialect for the Erlang VM with Clojure inspired syntax,https://github.com/kapok-lang/kapok,kapok lisp dialect erlang vm clojure inspired syntax,kapok documentation,kapok kapok dynamic functional generalpurpose programming language dialect lisp share lisp codeasdata philosophy powerful macro system kapok leverage erlang vm known running lowlatency scalable faulttolerant system kapok designed goal syntax like clojure keep max compatible erlang ecosystem compatible elixir leverage protocol lazy interface rich set useful library term unicode string file etc todo shipped powerful tool eg project management tool editor integration etc documentation
201,Lobsters,erlang,Erlang development,Trustworthy Refactoring via Decomposition and Schemes: A Complex Case Study (2017),https://arxiv.org/pdf/1708.07225.pdf,trustworthy refactoring via decomposition scheme complex case study,,obj length filter flatedecode stream b c pm hi nx yd iy n wg cv xz endstream endobj obj length filter flatedecode stream pjߑ k ie endstream endobj obj length filter flatedecode stream z kh l
202,Lobsters,erlang,Erlang development,Files with Extinct,http://blog.ikura.co/posts/files-with-extinct.html,file extinct,search ideal co web address,search ideal co web addressget gone
203,Lobsters,erlang,Erlang development,The Missing Testing Tip – Erlang Battleground,https://medium.com/erlang-battleground/the-missing-testing-tip-628686ebbbda,missing testing tip erlang battleground,symptom timer sleep wrong instead ktntask github waitfor exit timeout waitfor timer sleep sleeptime ok waitfor ktntask waitfor lesson learned guideline get elvis validate u,symptomso test taking long time run go try figure find many instance timer application spread around different test case suite true story seen timer sleep even wrote course test slow stalling second sleepingwhy might multiple reason leading u introduce timer call test case general structure test something like test config something inbackground timer sleep verifytheexpectedresult evaluate function return immediately also triggering background task wait enough time background task complete check fact completed correctlywe wait ie remove call timer entirely given concurrent nature erlang likely expected side effect happened time test evaluates next line sobut timer best way write kind wrong timer use timer need choose number ie many millisecond wish process sleep choosing right number parameter generally hard plainly impossiblelet assume know background task never last second hard timeout somewhere within need decide long test sleep choose number test may report error system actually working expected even choose wait exactly sure test fails system working expected might schedulerelated delay maybe message got queued bit etcso choose number larger larger let choose sure test run second longer reality upper bound likely background task particularly test mode take soin word using timer force make trade unpredictable test result wasting lot timebut better instead basic idea solution proposed fred also implemented ktntask periodically check see get expected result fail get long timethe implementation ktntask github bit complex since generic simpler task expectedresult sleeptime exit timeout waitfor task expectedresult sleeptime retries timer sleep sleeptime case task expectedresult ok somethingelse waitfor task expectedresult sleeptime retries endyou would use like test config something inbackground ktntask waitfor fun ok key last parameter instead simply waiting checking wait round check time expected correct result obtained second move like bos learned plan add guideline get elvis validate u pr public repos feel like guideline submitting pr elvis repo highly appreciate
204,Lobsters,erlang,Erlang development,Testing at warp speed: Why you should care about your test speed,http://tech.adroll.com/blog/dev/2018/02/27/erlang-speed-tests.html,testing warp speed care test speed,testing warp speed care test speed previous blog post erlangotp realtime bidding platform need keep test running fast development test driven development context switching continuous integration overly careful code modification including many unrelated change single pr deployment testing rtb server unit test eunit integration test common test blackbox test common test integration test meck unit test common test benchmarking common test cthooks lesson learned mocking meck meck meck common test meck common test common test meck meck lesson learned common test lesson learned parallelization common test blackbox test common test lesson learned enjoy building highquality largescale system roll u,testing warp speed care test speed written brujo benavides february reduced test run time thus speeding development deployment considerably application generic tip use system well minute read read previous blog post adroll use erlangotp extensively particular use build realtime bidding platform system central business rigorous writing test making sure run smoothly every pull request every deploy fairly complex test structure proven useful keeping system maintainable test truly helpful need run quickly run time balancing test completeness test speed easy task effort keep balance discovered quite thing article describes lesson learned ensuring test run fast enough allow developer work top speed without compromising quality software need keep test running fast uncommon find project single test run could last well minute since test run tend grow steadily time system testing also huge even everybody know test slow nobody notice slow becomes critical new developer come along wait forever test complete first time test run lasting minute serious development many test round need develop new feature fix bug practice test driven development need least three initial red one first green one implementing code second green one refactoring even practice tdd probably still want test code write submitting pull request three test run several minute mean lot time spent waiting test run often wait test run much else even start working something else parallel test run context switching generally good developer besides new task likely also require running test top configured continuous integration tool run full round test pull request branch merged master merging even smallest pr would take least two full test run sometimes many depending many pr open time fast parallelizable ci scenario lead two opposite approach dealing longrunning test overly careful code modification touching anything related implementing fear making passing test fail behaving like slows refactoring process considerably affecting overall code quality system including many unrelated change single pr goal run ci test avoid waiting many pr green light affect ability properly review understand revert change needed code review also affected since reviewer wary requesting change explicit mergeblockers change request might require author spend another hour running test machine ci spending amount time running test reducing code review blatant problem affect culture team also overall coherence code drastically reducing maintainability deployment general policy deploying often case deployment impact system performance detect source issue quickly idea since spend much time deploys introducing many change therefore detecting one causing problem easier might find similar situation deploy want make sure deploying actually work expected achieve include least one full test run deployment process word deploy something would least need time full test run process slow also make people overly cautious deploys reduce available timeframe since nobody would want deploy anything last three four hour day deploy go south redeploy ie rollback deploy patch may well require multiple hour work need time run test computer ci corresponding pr build system deploy assuming comment failing test find fix bug almost immediately nutshell good long test run keeping test run time check important system team mind let show learned testing rtb server system multiple level testing write unit test module eunit write integration test common test tool run blackbox test run client simulation one server also included common test suite integration test need mock one underlying piece particularly manage connection database download file internet connect external service use meck full test run would run aforementioned test starting unit test way integration one finally black box suite article forget unit test predictably fastest one anyway focus run common test benchmarking trying improve test speed first step always benchmarking test run find test taking longest luckily common test complete flexible framework allows u define hook using cthooks implemented hook module actually implemented two one regular test run one benchmarking code within benchmarking module look doc common test hook module benchmarking module timercth export export export required callback record state timeinitsuite o timestamp posinteger timeendsuite o timestamp posinteger timeinittestcase o timestamp posinteger timeendtestcase o timestamp posinteger init id opts ok state doc called initpersuite called preinitpersuite suite config state config state state suite suite timeinitsuite o timestamp doc called initpersuite postinitpersuite suite config return state io format cttime p initpersuiten timediff state statetimeinitsuite suite return state timediff init timer nowdiff o timestamp init function simple one shown measure print much time spent different stage test suite test case use easily greppable string case cttime pipe test run grep extract info need future analysis lesson learned use cthooks benchmark test remember multiple cthooks module use benchmarking one interested performance test mocking write integration test uncommon require fair share mocking erlang usually accomplished using meck meck flexible mocking library allows temporarily replace existing module new implementation function usual lifecycle mock built meck look something like initialize mock meck new yourmodule passthrough meck expect yourmodule afunction fun arg returnsomethingtrivial arg end run test using mock maybe check stuff meck instance meck numcalls yourmodule afunction someexpectedarg destroy mock meck unload yourmodule write exactly code test case may run trouble test fails calling meck module remain mocked may affect test case depending configured test suite common test sometimes boot different process different test sometimes reuses process default meck link mock creating process process crash stop mock removed common test us process run next test case module remain mocked good usually want put mocking initialization unloading outside main test case function common test initpertestcase thetestcase config initialize mock meck new yourmodule passthrough config thetestcase config meck expect yourmodule afunction fun arg returnsomethingtrivial arg end run test using mock maybe check stuff meck instance meck numcalls yourmodule afunction someexpectedarg ok endpertestcase thetestcase config destroy mock meck unload yourmodule config also handy want mock module test need replace initpertestcase endpertestcase function clause head something like initpertestcase testcase config et voilã performance mocking module worth asking unloading recreating pair test case affecting overall time test run turn meck dynamically compiles new module time create mock boot new genserver track history call function among thing compiling erlang code something consumes several millisecond per module maybe even second module long enough well create mock beginning suite unload end avoid issue mentioned namely modulesfunctions remain mocked test case solution currently using initialize mock whole suite notice nolink want mock stay u end suite regardless many process commontest want use initpersuite config meck new passthrough nolink nt much except function want always mock way eg db connection initpertestcase testcase config meck expect config test case remain thetestcase config meck expect yourmodule afunction fun arg returnsomethingtrivial arg end run test using mock maybe check stuff meck instance meck numcalls yourmodule afunction someexpectedarg ok remove expects module even mocked basically clean ie work nt mocked thanks passthrough option provided initpersuite endpertestcase testcase config module meck reset module meck delete module fun arity false module fun arity meck expects module true config destroy mock endpersuite config meck unload thing notice meck deleteall function list comprehension endpertestcase need clean module statistic well expects calling meck call meck cheap way cheaper meck want call function actually mocking use meck expects module true instead meck expects module would include passthrough function module moduleinfo export would include function module lesson learned going reuse mock test create initpersuite delete expectation endpertestcase destroy endpersuite common test come little known secret one favorite ct comment let add context test end generated html summary test run let understand test failed glance instance consider test failingtest config ct comment dividing zero using div fail infinity div ct comment dividing zero fail infinity comment test obviously fail thanks ct get something like test report really nice feature might already guessing point performance issue ct really bad take write test like following failingtest config list foreach fun ct comment dividing p using div fail infinity div ct comment dividing p fail infinity end list seq comment case like one successful run test us ct comment time certainly add lesson learned going use ct make sure using within recursive functionloop parallelization common test let choose run test run test multiple time sequential order parallel etc sometimes instance blackbox test run test parallel speed process whole case test booting different instance server different configuration parameter hitting client simulator verify produce response expect theory could run test parallel booting many server need etc practice requires lot isolationrelated effort worth nevertheless worth considering parallelism common test give certainly one take advantage check test looked realized initpertestcase exchange config folder localfolder exchange exchange folder bootupserver exchange config foo config run client test server ok bar config run client test server ok endpertestcase exchange config folder localfolder exchange deletefolder folder teardownserver exchange config see performing operation ie download server start test run folder removal server stop sequentially testcase also file download one expensive operation suite refactored code something like initpersuite config downloadallsamples config initpertestcase exchange config bootupserver exchange config foo config run client test server ok bar config run client test server ok endpertestcase exchange config teardownserver exchange config endpersuite config deletefiles made sure downloaded many file could parallel spawning several erlang process waiting done signal lesson learned use suite parallelize test even parallelize whole test case still use pure erlang simultaneously run part found thing constant effort quick test agile development methodology sure alone let u know speed test comment enjoy building highquality largescale system roll u
205,Lobsters,erlang,Erlang development,"Riak core tutorial: an up to date using the riak_core_ng fork, Erlang/OTP 20 and rebar3",https://github.com/lambdaclass/riak_core_tutorial,riak core tutorial date using riakcoreng fork erlangotp,riak core tutorial riakcoreng fork tutorial little riak core book create riakcore application elixir content example application usage riak core tutorial riak core riak data store use riak core amazon dyamo tutorial riakcoreng little riak core book riakcore elixir useful link riak core overview consistent hashing dynamo paper setup template riak core fork warningsaserrors release configuration file vnode overview riakvnode behavior application supervisor setup sending command vnode setting cluster rebar profile building distributed keyvalue store testing common test ctslave rpc test implementation ctslave magic thread coverage command handle coverage command vnode coverage fsm introduced fork coverage fsm supervision supervisor strategy putting together coverage test redundancy faulttolerance handoff little riiak core book elixir series handoff riakcore wiki handoff occur vnode implementation riakkv riaksearch callback specification ownership handoff example hinted handoff example faulttolerance section,riak core tutorial repository contains example riakcore application using recent version riakcoreng fork running erlangotp detailed tutorial explains stepbystep process produce code base scratch project tutorial structure largely based little riak core book create riakcore application elixir series content example application usage run three separate terminal make make make join node ping riakcore join rcexample ping riakcore join rcexample ping check ring status rcexample ringstatus try keyvalue command rcexample put ok rcexample put ok rcexample get riak core tutorial riak core distributed system framework used riak data store distribute data scale generally thought toolkit building distributed scalable faulttolerant application practical term riak core erlangotp application user defined work done riakcorevnode behavior use riak core make riak core interesting useful implement idea amazon dyamo architecture expose infrastructure reusable library allowing easily apply context benefit decentralized distribution work including limited data store see provides basic block build distributed service consistent hashing routing support sharding replicating distributed query etc need used example game server handle request player could partition player handle load ensure player request always handled vnode ensure data locality distributed batch job handling system could also use consistent hashing routing ensure job batch always handled node distribute job across several partition use distributed mapreduce query gather result tutorial basho company originally developed riak riak core put receivership introduces uncertainty future product although community shown interest taking maintenance moment writing riakcoreng fork actively maintained fork riak core hopefully work done eventually merged back canonical repository part interest technology intention use new project struggle bit scarce outdated documenatation stale dependency etc intention thus provide tutorial use riak core today erlang project minimal dependency operational sugar notice structure borrows heavily little riak core book riakcore elixir series main reference useful link riak core overview riak core based dynamo architecture meaning scale distributes work decentralized manner using consistent hashing operation applied object identified data value context keyvalue store example identifier key used get put delete operation performing operation hashing function applied key key hash used decide node cluster responsible executing operation range possible value key hash take keyspace usually depicted ring partitioned equally sized bucket assigned virtual node also known vnodes number vnodes fixed cluster creation given hash value always belong partition ie vnode vnodes turn evenly distributed across available physical node note distribution nt fixed keyspace partitioning vnode distribution change physical node added cluster go find detailed demonstration consistent hashing architecture enables several desirable property system high avalability incremental scalability decentralization low operational cost find detailed discussion property dynamo paper setup tutorial build inmemory distributed keyvalue store let start creating new project new app rcexample writing rcexamplesrcrcexampleapperl writing rcexamplesrcrcexamplesuperl writing rcexamplesrcrcexampleappsrc writing rcexamplerebarconfig writing rcexamplegitignore writing rcexamplelicense writing rcexamplereadmemd note template riak core reason nt use outdated generates lot operational code would take lot effort figure fix instead start empty project build way although code generated template serve good reference along way next fill rebarconfig file add riakcore dependency lager use logging erlopts debuginfo parsetransform lagertransform deps riakcore pkg riakcoreng lager note using riakcoreng fork date version introduced support erlang previously work required avoid deprecation warningsaserrors point able compile project running compile project compiles let try build run release first need add lager riakcore srcrcexampleappsrc started along application also need add cuttlefish system riak us internal configuration application kernel stdlib lager cuttlefish riakcore add release configuration development rebarconfig relx release rcexample rcexample devmode true includeerts false sysconfig confsysconfig vmargs confvmargs extendedstartscript false note wo nt using shell command nt play along nicely riakcore need proper release instead although use devmode thus build run release release builddefaultrelrcexamplebinrcexample go ahead run see error like failed load ring file file directory need add configuration confsysconfig confvmargs properly start riakcore vmargs name rcexample confsysconfig riakcore ringstatedir dataring webport handoffport schemadirs vmargs set node name sysconfig set data directory riak core ringstatedir couple port also need point riak schema setting schemadirs work copy file privriakcoreschema point runnable release see error try removing build directory release builddefaultrelrcexamplebinrcexample vnode far got single erlang node running release riakcore nt really write code test getting distributed aspect riakcore let add simplest possible functionality ping command recall overview keyspace range possible result hashing key partitioned partition assigned virtual node vnode worker process handle incoming request known command implemented otp behavior initial example create empty vnode know handle ping command detailed explanation vnodes found riakvnode behavior let add srcrcexamplevnodeerl module implement riakcorevnode behavior module rcexamplevnode behaviour riakcorevnode export startvnode riakcorevnodemaster getvnodepid module init partition ok partition partition handlecommand ping sender state partition partition log received ping command p partition state reply pong partition state handlecommand message sender state log unhandledcommand p message state noreply state first startvnode function riakvnode behavior callback nevertheless required vnode work function nt documented knowledge always implementation riakcorevnodemaster getvnodepid module could probably handled internally riakcore since nt copy paste line everytime ツ init callback initializes state vnode much like genserver code intialize state map contains id partition assigned vnode next interesting callback handlecommand may expect handle request assigned vnode nature command defined message parameter case simple ping command add new handlecommand clause reply partition id vnode need get started rest riakvnode callback dummy implementation get back following section handlehandoffcommand message sender state noreply state handoffstarting targetnode state true state handoffcancelled state ok state handofffinished targetnode state ok state handlehandoffdata data state reply ok state encodehandoffitem objectname objectvalue isempty state true state delete state ok state handlecoverage req keyspaces sender state stop notimplemented state handleexit pid reason state noreply state terminate reason state ok internal lager info prepends partition log string state log string state log string args partition partition string partition args lager info ok also added small log helper prepends partition vnode log application supervisor setup moving need add boilerplate code riakcore find manage example vnode update start callback srcrcexampleapperl start starttype startargs ok riakcore register vnodemodule rcexamplevnode ok riakcorenodewatcher serviceup rcexample self rcexamplesup startlink first line initialises ring telling riakcore use rcexamplevnode vnode module second one start nodewatcher process responsible tracking status node within riakcore cluster also need update supervisor srcrcexamplesuperl start vnodemaster process coordinate distribution work within physical node start worker vnodes receives request particular physical node route vnode handle init vmaster rcexamplevnodemaster riakcorevnodemaster startlink rcexamplevnode permanent worker riakcorevnodemaster ok oneforone vmaster sending command vnode far vnode know respond incoming ping request still need api able send request add srcrcexampleerl file contain public interface application module rcexample export ping key o timestamp docidx hashkey key preflist riakcoreapl getapl docidx rcexample indexnode preflist command ping riakcorevnodemaster syncspawncommand indexnode command rcexamplevnodemaster internal hashkey key riakcoreutil chashkey rcexample termtobinary key let go ping implementation line line stated operation performed single object exception aggregation operation like listing available key keyvalue store object usually identified key hashed decide partition vnode physical node receive request case ping nt actual object involved thus key make random one using o timestamp nature hashing algorithm distributes value uniformly ring new timestamp assigned random partition ring hashkey helper call riakcoreutil chashkey produce hash key note chashkey receives tuple two binary first element called bucket value riakcore use namespace key choose single one per application many according need result hash passed riakcoreapl getapl return active preference list apl given key list active vnodes handle request amount offered vnodes determined second argument function try function release shell get better sense work rcexample riakcoreutil chashkey rcexample termtobinary o timestamp rcexample riakcoreutil chashkey rcexample termtobinary o timestamp riakcoreapl getapl rcexample rcexample riakcoreutil chashkey rcexample termtobinary o timestamp rcexample riakcoreapl getapl rcexample rcexample rcexample riakcoreapl getapl rcexample rcexample rcexample rcexample get different partition every time always physical node still running single one last line sends ping command selected vnode riakcorevnodemaster function used syncspawncommand act bit like genserver call sense block calling process waiting response function send command vnode riakcorevnodemaster work asynchronously like genserver cast riakcorevnodemaster like syncspawncommand block vnodemaster process find detail function used section wrap let run ping function shell rcexample rcexample ping info received ping command rcexample rcexample ping info received ping command setting cluster point execute simple command none previous effort would make sense keep running stuff single node whole point riakcore distribute work faulttolerant decetralized manner section update configuration run project threenode erlang cluster practical reason node reside local machine moving separate server fairly simple review codebase note one spot fixed node configuration confvmargs set node name rcexample want instead running node machine also need use different port riakcore node webport handoffport tuples confsysconfig since almost identical configuration node use overalys feature inherits relx read although strictly necessary purpose tutorial first tell confsysconfig confvmargs treated template adding overlay tuple relx configuration overlay template confsysconfig release defaultreleaseversion sysconfig template confvmargs release defaultreleaseversion vmargs template variable value taken overlayvars file define three different rebar profile rebarconfig pointing different overalyvars file profile relx overlayvars relx overlayvars relx overlayvars create conf directory follows node webport handoffport node webport handoffport node webport handoffport lastly update sysconfig vmargs refer template variable instead concrete value confsysconfig riakcore ringstatedir dataring webport webport handoffport handoffport schemadirs confvmargs name node run release need tell rebar profile use example release let add makefile easily run node phony cleandata release release release cleandata rm rf rm rf rm rf also include cleandata target case want start fresh cluster riakcore persists cluster information run may need remove make change configuration testing cluster let add function inspect status srcrcexampleerl export ringstatus ok ring riakcoreringmanager getmyring riakcorering prettyprint ring legend open three terminal run one command make make make try ringstatus function see something like rcexample ringstatus node node ring aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ok node know fix making node join node riakcore join used single node join cluster node riakcore join info changed joining valid node riakcore join info changed joining valid ringstatus show three node third keyspace may take second percentage settle rcexample ringstatus node node node b node c ring abccabccabccabccabccabccabccabccabccabccabbcabbaabbaabbaabbaabba ok call rcexample ping couple time see log output received ping command printed different terminal every time vnodes physical node receive command building distributed keyvalue store project layout distribution setup start working inmemory keyvalue store may imagine mean modifying worker vnode support new set command put get delete relevant part init partition ok partition partition data handlecommand put key value sender state data data log put p p key value state newdata data key value reply ok state data newdata handlecommand get key sender state data data log get p key state reply map get key data notfound state handlecommand delete key sender state data data log delete p key state newdata map remove key data reply map get key data notfound state data newdata init update state map include data map use humble data store add new handlecommand clause operation put get set command received named tuple result returned reply like genserver like ping create public function srcrcexampleerl execute new command module rcexample export ping synccommand o timestamp ping ringstatus ok ring riakcoreringmanager getmyring riakcorering prettyprint ring legend put key value synccommand key put key value get key synccommand key get key delete key synccommand key delete key internal hashkey key riakcoreutil chashkey rcexample termtobinary key synccommand key command docidx hashkey key preflist riakcoreapl getapl docidx rcexample indexnode preflist riakcorevnodemaster syncspawncommand indexnode command rcexamplevnodemaster hashing vnode selection command execution case extracted synccommand helper function let test new command stop three node still running run make make make refresh code release note node join cluster without need call riakcore join shell try keyvalue store rcexample put info put ok rcexample put info put ok rcexample get info get rcexample delete info delete rcexample get notfound info get rcexample put rcexample get example key stored vnodes reside first node thus get log output shell another one see even initial setup little burdensome get distribution work faulttolerance little effort handling applicationspecific logic vnode module testing application already basic functionality start thinking test distributed system requires multiple node work manual test become difficult grows moreover since complexity resides interaction component wo nt benefit much isolated unit test instead write integration suite provides endtoend verification feature accomplish use common test combination ctslave rpc start multiple node interact test implementation start let add new make target run test remember add phony target phony cleandata test test ct name test create test directory single module testkeyvaluesuiteerl module keyvaluesuite includelib commontestincludecthrl compile exportall pingtest keyvaluetest initpersuite config startnode startnode startnode buildcluster config endpersuite config config config config config config config stopnode stopnode stopnode ok include ct header file declare two test callback define shortly initpersuite create three node using startnode helper make join cluster buildcluster keep node name test configuration later use remotely execute function node finally stop node endpersuite using another helper leave implementation contain ctslave magic end section let focus test pingtest config config config config config config config pong rccommand ping pong rccommand ping pong rccommand ping ok keyvaluetest config config config config config config config ok rccommand put ok rccommand put ok rccommand put get node rccommand get rccommand get rccommand get notfound rccommand get rccommand get rccommand get rccommand get notfound rccommand get rccommand get rccommand get rccommand get notfound rccommand get test reset delete ok rccommand put vnew vnew rccommand get vnew rccommand delete notfound rccommand get ok rccommand put vnew vnew rccommand get ok pingtest sends ping command node make sure get pong response every time note use rccommand helper executes command rcexample application given node keyvaluetest put key store first node make sure key retrieved node regardless actually stored test delete command make sure store generally work expected nothing special test abstract away detail setting node riakcore cluster ctslave magic let look implementation different helper used previous section need startnode helper create new erlang node given name need start rcexample application much like happens run development release work also set required riakcore application environment startnode nodename webport handoffport need set code path module available slave codepath code getpath pathflag pa list concat list join codepath ok ctslave start nodename erlflags pathflag set required environment riak core datadir data atomtolist nodename rpc call nodename application load riakcore rpc call nodename application setenv riakcore ringstatedir datadir rpc call nodename application setenv riakcore platformdatadir datadir rpc call nodename application setenv riakcore webport webport rpc call nodename application setenv riakcore handoffport handoffport rpc call nodename application setenv riakcore schemadirs librcexamplepriv start rcexample app ok rpc call nodename application ensureallstarted rcexample ok stopnode nodename ctslave stop nodename ctslave make pretty simple manage erlang node ctslave start ctslave stop function gotcha start new node need point code path erlang order node know look code dependency best way found based thread get path master node run test pas erlang pa flag probably succint way example using code setpath could nt make work node start running function rpc call order riakcore work need load application fill environment application setenv set variable confsysconfig addition platformdatadir directory riakcore us store metadata need set explicitly otherwise three node would conflict trying write default directory configuration place start rcexample app remotely calling application ensureallstarted lastly stopnode helper need call ctslave stop three node application running need connect build cluster like shell buildcluster rpc call riakcore join rpc call riakcore join ok last helper rccommand simple one remotely call one function rcexample module rccommand node command rccommand node command rccommand node command argument rpc call node rcexample command argument coverage command far working command operate single object like single key keyvalue store case key hashed key hash determined vnode responsible handling operation case ping command discussed nt key faked one using current timestamp another kind command one involves vnodes ring happens example want list key keyvalue store vnode contains subset key get full list need ask vnodes join result coverage command consist riakcore sends command vnodes process result arrive section going implement two new command key value may guess return list key value currently present datastore handle coverage command vnode vnode easy part vnode need return list key value contains data field state done handlecoverage callback handlecoverage key keyspaces reqid state data data log received key coverage state key map key data reply reqid key state handlecoverage value keyspaces reqid state data data log received value coverage state value map value data reply reqid value state coverage fsm need introduce new component one charge managing coverage command starting gathering result sent vnodes riakcore provides riakcorecoveragefsm behavior purpose finite state machine let create srcrcexamplecoveragefsmerl module implementing behavior go function module rcexamplecoveragefsm behaviour riakcorecoveragefsm export startlink reqid clientpid request timeout riakcorecoveragefsm startlink module pid reqid clientpid request timeout far nothing special startlink called supervisor start process see next section parameter le forwarded riakcorecoveragefsm startlink init pid reqid clientpid request timeout lager info starting coverage request p p reqid request state reqid reqid clientpid request request accum request allup rcexample rcexamplevnodemaster timeout riakcorecoverageplan state init initialize process state usual create state map put request metadata client process id later reply result command accumulator list update result coming vnode init return big tuple bunch parameter control coverage command work let briefly explain mostly taken dig around detail request opaque data structure representing command handled vnodes case either key value atom vnodeselector atom specifies whether want run command vnodes reachable allup replicationfactor used accurately create minimal covering set vnodes primaryvnodecoverage number primary vnodes preference list use creating coverage plan typically nodecheckservice service used check available node atom passed nodewatcher application startup vnodemaster atom use reach vnode master module rcexamplevnodemaster timeout timeout coverage request plannermod module defines createplan function used define cluster vnodes covered command usually riakcorecoverageplan state initial state module note plannermod argument introduced riakcoreng fork nt present original basho codebase thus using older riakcore version omit parameter processresults reqid partition node state done state processresults reqid partition node data state accum accum newaccum partition node data accum done state accum newaccum processresults callback get called coverage module receives set result vnode key value command store partition node identifier along data see piece came final result since test vnodes empty filter handling empty list case separate processresults clause leaf accumulator unchanged finish clean state reqid reqid accum accum lager info finished coverage request p reqid send result back caller reqid ok accum stop normal state finish error reason state reqid reqid accum accum lager warning coverage query failed reason p reason reqid partial reason accum stop normal state finally finish function called coverage command done go well first argument clean case reply accumulated data caller pid stored error handle second finish clause coverage fsm supervision need supervise rcexamplecoveragefsm process since created demand one per command need executed going use simpleoneforone supervisor strategy create srcrcexamplecoveragefsmsuperl module module rcexamplecoveragefsmsup behavior supervisor export startlink supervisor startlink local module module init coveragefsm undefined rcexamplecoveragefsm startlink temporary worker rcexamplecoveragefsm ok simpleoneforone coveragefsm startfsm args supervisor startchild module args coverage command need executed startfsm called create new child supervisor also need add rcexamplecoveragefsmsup main application supervisor srcrcexamplesuperl init vmaster rcexamplevnodemaster riakcorevnodemaster startlink rcexamplevnode permanent worker riakcorevnodemaster coveragefsm rcexamplecoveragefsmsup rcexamplecoveragefsmsup startlink permanent infinity supervisor rcexamplecoveragefsmsup ok oneforone vmaster coveragefsm putting together component place let add key value function srcrcexampleerl key coveragecommand key value coveragecommand value internal coveragecommand command timeout reqid erlang erlang monotonictime ok rcexamplecoveragefsmsup startfsm reqid self command timeout receive reqid val val end create reqid identify request call rcexamplecoveragefsmsup startfsm create new child supervisor passing parameter rcexamplecoveragefsm need execute command finally receive result value identified reqid restart release fill store value try new command rcexample put ok rcexample put info put ok rcexample put ok rcexample put ok rcexample put ok rcexample key info starting coverage request key info received key coverage info received key coverage info received key coverage info received key coverage info received key coverage ok expected result contains inserted key vnode physical node come also see received key coverage output every vnode receive command coverage test need test new functionality writing integration test let quickly add clear coverage command empty database come handy next add new handlecoverage clause srcrcexamplevnodeerl handlecoverage clear keyspaces reqid state log received clear coverage state newstate state data reply reqid newstate clear command received vnode empty data map internal state note return empty list coverage fsm expects get list vnode new command required different result manipulation could consider adding another processresults clause fsm even entirely separate fsm module case nt really care result processing side effect clearing vnode data also add clear function public api srcrcexampleerl call coveragecommand return ok export clear ok coveragecommand clear ok place let test coverage command testkeyvaluesuiteerl pingtest keyvaluetest coveragetest coveragetest config config config config config clear contain key value ok rccommand clear rccoverage key rccoverage value tokey fun n key integertolist n end tovalue fun n value integertolist n end range list seq list foreach fun n ok rccommand put tokey n tovalue n end range actualkeys rccoverage key actualvalues rccoverage value length actualkeys length actualvalues true havesameelements actualkeys list map tokey range true havesameelements actualvalues list map tovalue range store empty new clear ok rccommand clear rccoverage key rccoverage value ok internal rccoverage node command ok list rccommand node command convert coverage result plain list list foldl fun partition node value accum list append accum value end list havesameelements set fromlist set fromlist set issubset andalso set issubset coveragetest first call clear empty store make sure key value return empty result note integration suite ideal sense test isolated share data store could nt example run concurrently real world project could consider creating new node test although could slow likely introduce sort namespacing data store perhaps use bucket purpose tutorial though enough clear store particular test test continues storing range key value database calling key value command assert result contain element use set logic check element originally inserted finally clear store check key value come back empty rccoverage helper call command clean result removing partition node annotation redundancy faulttolerance nonideal world distributed system need account fact software hardware fail network unreliable word need build distributed system keep functioning one node becomes unavailable riakcore provides useful building block achieve monitor cluster redistribute partition node go even expose mechanism move data around come back online see handoff work implementation specific system work distributed database vnodes hold state survive node outage replicate piece data multiple vnodes fallback vnode take primary available keyvalue store example mean put command sent multiple vnodes replicate data delete command sent replica introduces room lot design decision tradeoff many physical node cluster consist many replica key stored many successful response required write operation succeed many read data handle write conflict replica etc related database design tuning riakcore riakcore distribution mechanic wo nt go fair specific sake completeness let briefly mention riakcore api allows u introduce redundancy review srcrcexampleerl module recal use riakcoreaplgetapl obtain list vnodes handle given command let say want replicate data three node request amount k riakcoreutil chashkey rcexample termtobinary o timestamp riakcoreapl getapl k rcexample actually send command instead using riakcorevnodemaster syncspawncommand turn generic riakcorevnodemaster command take preference list instead single target vnode replicatedcommand key command docidx hashkey key preflist riakcoreapl getapl docidx rcexample reqid erlang erlang monotonictime sender raw reqid self riakcorevnodemaster command preflist command sender rcexamplevnodemaster receive reqid reply reply end note need create request id pas current process sender argument riakcore know send reply case demonstration purpose blocking receive return first message arrives serious implementation could use genserver fsm gather response achieve sort quorum interested topic review little riiak core book elixir series implement solution problem handoff part strength dynamo architecture thus riak core enables scalability small operational effort keyspace designed ring virtual node adding removing physical node cluster mean changing distribution vnodes across physical node vnode always handle segment keyspace chunk key hash vnode resides physycally change example onenode cluster necessarily contain entire ring vnodes start second physical node join cluster half vnodes handed new physical node keyspace kept evenly distributed across cluster riak core provides necessary infrastructure decide vnode need moved need fill specific iterate particualr vnodes state encode giving end decode receiving vnode process called handoff go required step support scenario application walkthrough handoff implemented internally check riakcore wiki note vnodes stateless example use riakcore mechanism distribute work nt need keep internal state nt need worry handoff leave related callback empty handoff occur ownership handoff happens physical node join leaf cluster scenario riakcore reassigns physical node responsible vnode executes handoff move vnode data old home new home hinted handoff occur vnode redundancy see previous section primary vnode particular part ring offline riakcore still accepts operation route secondary vnode primary vnode come back online riakcore us handoff sync current vnode state secondary primary primary synchronized operation routed also repair resize related handoff advanced topic wo nt cover read vnode implementation check vnode implementation notice half callback deal handoff let go implementation order called first need include riakcorevnode header file refer macro defined includelib riakcoreincluderiakcorevnodehrl handoffstarting called sending vnode handoff begin function return true handoff proceed normal path return false handoff cancelled nt need special action log move forward handoffstarting targetnode state log starting handoff state true state handoffcancelled called sending vnode case process cancelled usually explcitly admin tool log handoffcancelled state log handoff cancelled state ok state isempty return boolean informing data migrate vnode handoff finished calling handofffinished isempty state data data isempty map size data isempty state bulk work done handlehandoffcommand callback function bit confusing serf two different purpose depending calling argument handle request fold vnode data need transferred handle regular vnode command eg ping put etc arrive handoff would otherwise passed handlecommand let focus first case riakcore know need piece data vnode hold encode transfer network new vnode decode data look like stored case keyvalue pair map give u function encapsulates processing need apply data handlehandoffcommand foldreq foldfunfoldfun sender state data data log received fold request handoff state result map fold foldfun data reply result state nevermind weird macro wrapper foldreq record care extract fold function foldfun initial accumulator command shape arrives iterate vnodes data applying given fold function note function expects passed three argument key value accumulator mean data structure nt already support form fold function wrap case need call map since data map result fold included reply tuple foldfun synchronous case result command replied right away also option return async tuple check riakkv riaksearch implementation reference note go route may need handle incoming command modify vnodes data iterating second situation handlehandoffcommand called regular command arrives handoff check callback specification see result handlecommand two additional return type forward drop forward reply send request target node drop reply signifies wo nt even attempt fulfill one use depends application nature command let reason possible situation case keyvalue store handlehandoffcommand arrives ca nt tell handoff started finish ca nt tell value associated command key migrated receiving vnode already copy one strategy take stay consistent avoid unnecessary effort command write put delete change local copy code forward receiving vnode way already migrated change applied copy command read get reply local copy data know date applied writes locally let see look code handlehandoffcommand get key sender state log get handoff handling locally p key state handlecommand get key sender state handlehandoffcommand message sender state reply result newstate handlecommand message sender state forward newstate added extra handlehandoffcommand clause case first one handle get read operation implementation call handlecommand since want reply local copy data usual second clause catch rest command put delete write operation case call handlecommand well modify local copy data instead using result return forward command sent receiving vnode well handlehandoffcommand deeper understanding different scenario suggest checking comment along relevant code moving remaining callback encodehandoffitem called sending vnode time keyvalue pair sent wire use termtobinary encode end handlehandoffdata called receiving vnode decode key value use binarytoterm update data map new pair encodehandoffitem key value erlang termtobinary key value handlehandoffdata bindata state data data key value erlang binarytoterm bindata log received handoff data p key value state newdata data key value reply ok state data newdata finally handoff done handofffinished called sending vnode deleted necessary cleanup done delete callback nt special work two callback log return handofffinished targetnode state log finished handoff state ok state delete state log deleting vnode state ok state data ownership handoff example handoff slow process would inconvenient test part integration suite instead let shell experiment see action clean cluster start three node terminal make cleandata make terminal make terminal make node running join cluser node riakcore join info changed joining valid node riakcore join info changed joining valid may see bunch handoff message eventually cluster settle ring evenly distributed across node rcexample ringstatus node node node b node c ring abccabccabccabccabccabccabccabccabccabccabbcabbaabbaabbaabbaabba ok let add key use key function find node end rcexample put hello ok rcexample key ok case routed second node different one machine let see happens make node one hold keyvalue pair leave cluster riakcore leave ok get bunch handoff log screen period rcexample ringstatus show percentage ring assigned node decreasing reach zero node shutdown remaining node see something like info changed leaving exiting info removed cluster previously exiting rcexample ringstatus node node node b ring abababababababababababababababababababababababababababababababab ok entire ring distributed among two remaining node query confirm another one took ownership key rcexample get hello ok case took part ring hinted handoff example previous section demonstrated happens intentionally change cluster removing node let see happens failure node becomes unexpectedly unavailable nt add replication discussed faulttolerance section ca nt expect preserve data failing node see hinted handoff mechanic anyway failing node wo nt lose ownership partition command arrive temporarily routed available node failing node come back online receive handoff data created repeat step previous section clean data restart node join cluster set key check node resides rcexample put hello ok rcexample key ok case physically resides kill node ctrlg q similar command point key value lost nt kind data replication put key notice saved one live node rcexample get notfound rcexample put newvalue ok rcexample get newvalue start killed node try retrieve rcexample get notfound second node recovered ownership partition belongs nt yet value wait around minute laptop see something along line info starting handoff info starting hinted transfer rcexamplevnode info received fold request handoff info hinted transfer rcexamplevnode completed sent b byte object second kbsecond info finished handoff fallback node temporarily held handed data back vnode get key see new value time coming rcexample get newvalue rcexample key ok
206,Lobsters,erlang,Erlang development,"Partisan is a flexible, TCP-based membership system for Erlang/Elixir",https://github.com/lasp-lang/partisan,partisan flexible tcpbased membership system erlangelixir,partisan,partisan partisan flexible tcpbased membership system erlangelixir partisan feature single node testing facilitated disterl control channel figuring port peer service operating message sent via tcp connection maintained cluster member failure detection performed tcp connection verified gossip round configurable fanout join gossip performed immediately instead wait next gossip round hyparview implementation partisan many available peer service manager full membership tcpbased failure detection partisanpluggablepeerservicemanager clientserver topology partisanclientserverpeerservicemanager hyparview hybrid partial view membership protocol tcpbased failure detection partisanhyparviewpeerservicemanager static topology partisanstaticpeerservicemanager
207,Lobsters,erlang,Erlang development,"lambdapad - Static site generator using Erlang. Yes, Erlang.",https://github.com/gar1t/lambdapad,lambdapad static site generator using erlang yes erlang,join github today sign file permalink lambdapad erlang powered site generation ftw lambdapadio resource license reload reload,static site generator using erlang yes erlang dismiss join github today github home million developer working together host review code manage project build software together sign file permalink failed load latest commit information type name latest commit message commit time lambdapad erlang powered site generation ftw check lambda pad generated doc lambdapadio recursion static site generator using erlang yes erlang resource license perform action time signed another tab window reload refresh session signed another tab window reload refresh session
208,Lobsters,erlang,Erlang development,Erlang Cheatsheet,https://stratus3d.com/blog/2018/01/20/erlang-cheatsheet,erlang cheatsheet,http github email twitter reference,writing erlang year still thing struggle remember remembering core concept easy hard remember nuance exit signal exit trapping year cobbled together note thing found hard remember finally compiled presentable format created printable cheatsheet note document easily forgotten quirk language cheatsheet intended beginner cover fundamental language cheatsheet available freely print download http source code released mit license available github really like hear thought cheatsheet something cheatsheet missing something simplified removed think design let know via email twitter want contribute directly feel free create issue pull request github repository reference
209,Lobsters,erlang,Erlang development,Surfing on Lava – Feedback control & tuning the BEAM VM,https://medium.com/@GrindrLabs/surfing-on-lava-a61124bf7c7,surfing lava feedback control tuning beam vm,surfing lava stack since last talked warning sign system go bad good figuring rootset singleblock carrier erlang anger ert manual moment truth mhsbct multiblock carrier takeaway,surfing lavahow feedback control tuning beam helped u weather meltdownpatching stormby rafal studnicki simon zelaznyour stackwe run several erlang elixir service grindr among geopresence service moved forward bit since last talked nowadays handling much trafficthe soft realtime property erlang vm allow u set high standard service term tail latency maximum depending operation type usually expect response time m monitor closelywarning signswhen tail latency response time rise normal stable state level usually good early indicator something going wrong systemin november experienced occurrence tail latency going much higher usual event seemed unrelated change client server code abated couple hoursfig november anomalously high tail latency mysteriously came went note logarithmic scale system go bad goodright christmas mysterious hiccup state become new normalas automated deployment freeze mode holiday season decided put faith selfregulating capability system deploy change manuallyfig bad timesthe call protected feedback control wrapper keep track response time recent call throttle input way maintain target figure mean even though something system slowing particular response large factor average response time kept check regulatorif average metric shot high regulator mechanism would refuse fraction inbound call average fell appropriate levelsfig price paid stability controlled rejection request loadshedding figuring outwith holiday behind u dived launched favorite beam inspection tool systemmonitor fig session systemmonitorif something ruining system softrealtime property likely revealed starting system monitor waiting couple second alert come inin abbreviated session got information longgc long garbage collection happening one type process phoenix tracker made u think something going data process storing stateprocess heap clocked around megabyte enough cause slowdown sheer amount copying done gc time additionally process message queue empty meant large message structure contributing rootsetthe tracker process differ significantly process system heap size also different process consistently using kilobyte memory per process heap size allocated using called singleblock carrier see erlang anger chapter ert manual mean erlang vm call operating system extra memory whenever need adjust tracker heapsthis gave u hint perhaps de allocating memory directly system taking longer time usual perhaps infrastructure work conducted underlying hardware stack cloud made big iron allthe moment truthwe working hypothesis reproduce symptom laboratory condition even simulating production traffic memory allocation slowness seemed occur production presence cluster last recourse actually put skin game deploy change production test assumption realworld conditionswe gave bumping singleblock carrier limit shot goal force garbage collection particular process reuse memory multiblock carrier allocated upfront vm instead singleblock carrier way garbage collection tracker heap would require calling operating system remain within userland codemhsbct singleblock carrier threshold kb absolute singleblock carrier shrink threshold scaled proportionally mhlmbcs largest multiblock carrier size scaled proportionally fig emulator flag vmargsthe result immediately visible form drop subscription processing time effectively bypassed linux kernel managing large tracker heapsfig drop tail response time reconfiguring memory allocator erlang vm note logarithmic scalethe cost improvement one could expect increase memory usage since multiblock carrier much larger memory block inside le efficiently utilized leading higher memory fragmentation case memory consumption went approximately definitely price pay reducing tail latency two order magnitudefig memory usage changetakeawaysthe cloud computing environment full uncertainty sometimes understand root cause sometimes system underlying complexity opacity work maintain secret case described could plausibly attribute instability meltdown spectre mitigation work amazon hard evidence hard procurewhat end crucial helping u power holiday season builtin load regulator based principle feedback control load regulator treat entire system black box measuring average response time make difference part stack slowing application code vm code network hardware itselfby treating whole system black box able maintain uptime reasonable responsiveness face instability unknown origin additionally access erlang great introspection tool systemmonitor foremost among gave u good hint look concrete mitigation step
210,Lobsters,erlang,Erlang development,Juggling & gluing with Extinct,http://blog.ikura.co/posts/juggling-and-gluing-with-extinct.html,juggling gluing extinct,search ideal co web address,search ideal co web addressget gone
211,Lobsters,erlang,Erlang development,The Asymmetry of ++ Validations,https://medium.com/erlang-battleground/the-asymmetry-of-validations-1ccdf2457293,asymmetry validation,going fede following one typer,going time hard see validates first argument list second argument anything whatever added tail generated list check something work fede found edge case resulting list head therefore tail would constructed headsomething requested tl headsomething mystery solved fair slightly relevant documentation could find following one list concatenation operator appends second argument first return resulting listit might good thing add implementationspec detail erlang docsin case typer consequently dialyzer seems aware check module annotated typer spec note typer clearly understands return atom something since resulting improper list head fail therefore result none return improper list actually typer precise non empty improper list element something tail
212,Lobsters,erlang,Erlang development,Quaff that potion: saving $millions with Elixir and Erlang,http://tech.adroll.com/blog/dev/2018/01/08/quaff-that-potion-saving-millions-with-elixir-and-erlang.html,quaff potion saving million elixir erlang,quaff potion saving million elixir erlang erlangotp realtime bidding platform amazon kinesis dynamodb stream flow elixir background realtime bidding doubleclick ad exchange taboola secondprice ad targeting largescale machine learning stored dynamodb retargeting upperfunnel profile data system overview original design new design dynamodb stream aggregator kinesis stream processor implementation scalability robustness correctness enough erlang kinesis client library languageagnostic interface erlang multilangdaemon interface new opensource library erlmld opensource erlang library kinesis dynamodb stream processing erlmld beyond good erlang new opensource library exmld opensource elixir library kinesis dynamodb stream processing exmld erlmld flow elixirerlang sample processing code exmld impact conclusion flow http githubcomadrollerlmld http githubcomadrollexmld enjoy working largescale system roll u,quaff potion saving million elixir erlang written mike watters january slashed dynamodb cost using kinesis dynamodb stream erlangotp elixir implement global cache warming system present system two new opensource library processing kinesis dynamodb stream similar way using elixir erlang minute read adroll us erlangotp basis several internal product including realtime bidding platform running amazon erlangotp king robust highlyconcurrent soft realtime system article describes substantially reduced cost element realtime bidding platform dynamodb usage implementing global cache warmer using kinesis dynamodb stream written erlang later doubled performance component adapting use flow framework author elixir also present two new opensource library kind processing using elixir andor erlang background realtime bidding publisher website mobile app author want monetize inventory sell ad space buyer done using variety mean one programmatic auction conducted behalf publisher advertising exchange clearinghouse publisher integrated doubleclick ad exchange taboola inventory programmatic auction multiple interested buyer much time buyer notified exchange integrated whenever opportunity buy ad space occurs adroll currently participates well one million programmatic auction per second substantial part day addition supporting high request volume buyer must also respond quickly typically le hence auction may occurring resource web page video etc process loading response may include bid price maximum price buyer willing pay particular ad space shown specific user barring special circumstance highest bidder win auction may display ad space paying amount determined dynamic auction often secondprice ad targeting order bid auction ad space buyer need able determine much value particular impression adroll able value impression specific user combining largescale machine learning keeping profile billion user generally cooky know web mobile app inventory maintain period time set targetable user visited adroll site opted tracking segment could something like visited n page placed item shopping looked brown purchased profile set segment along timestamps certain information stored dynamodb retargeting product allows adroll customer show ad user previously visited site along restriction example customer could show brown promotion thursday friday pm pacific time user san francisco previously added shopping cart purchase plus general promotion similar user anywhere california excluding san francisco upperfunnel product allows customer show ad new likely act similar way existing desirable converting user would otherwise reachable via across web social medium facebook opportunity buy ad space present associated opportunity identifier user would see ad auction using identifier look profile data find ad relevant advanced machine learning model price real time set possible bid using ad profile data system overview described dynamodb effective source truth advertising profile data work well unfortunately also expensive order meet lowlatency requirement need replicate profile data globally aws region operate due design constraint could limit replication subset profile data scheme dynamodb cost dominated write capacity cost multiplied number region use original design access profile data bidding system initially implemented straightforward setup like following replicated globally perspective work like readthrough cache diagram box left represent user profile update occur constantly throughout day update written various dynamodb table every region separate data processing pipeline bidder instance seek obtain profile check local cache reading dynamodb recent cached data found used otherwise instance read dynamodb cache data next time described eventually created similar system allowing removal usage dynamodb one region cutting dynamodb cost large degree new design dynamodb bidding source truth profile data found actually need read time data user interest made reside cache increasing cached item ttl course alone would lead stale data inaccurate user targeting bid pricing could longlived cache data user also kept date need consult dynamodb time devised solution support set large r cache exists region region constantly receives depending set master table single region kinesis dynamodb stream natural choice workload dynamodb stream aggregator dataagnostic aggregator component observes update occur set relevant dynamodb stream batch update together replicates kinesis stream target region formerly dynamodb table master region kinesis stream processor target region operates kinesis stream reader cache writer component update longlived item set cache realtime bidding system fall back reading table master region relatively slow rare operation data missing cache incomplete writing back local cache using ca operation ensure consistency allowed u keep conceptual design multiple involved system still realizing substantial saving tolerate slower source truth data accurately cached longlived case implementation chief among concern designing system correctness bad data make good bidding decision robustness system bad missing data scalability need handle arbitrary volume data secondarily speed also consideration successful scalable proofofconcept used python elected implement complete solution using erlang building expertise area also good fit general type problem scalability essence scalability able efficiently apply repeatable formula arbitrary load realm software system erlangotp make easy set robust building block otp system comprised sharedalmostnothing sequential blocking process easily importantly behavior easily understood process independence enables arbitrary horizontal scaling contrast example deferredpromises asynchronous callback model common environment cumbersome concurrency sharedstate thread bring issue robustness erlangotp promotes robust system design supervision tree make simpletounderstand control flow process behavior process always part greater whole stuff crash burn knowing part system designed ground appropriate failure mode appropriate failing process may restarted supervisor somewhere system try correctness syntax design promotes succinct functional expression program avoids unnecessary defensive programming le code written mean le code read understood later fewer place bug hide enough erlang ensure correct ordered processing data abstract away handling detail like work distribution instance failure elected use existing javabased kinesis client library provided amazon kcl provides jsonbased languageagnostic interface multilangdaemon allows kinesis processing dynamodb stream processing using adapter done language environment without writing java code unfortunately kclmultilangdaemon expects driver resulting processing system emits event processor reacts launch one processor executable per owned stream shard effect processing make simple processing code need efficiently process thousand shard across multiple stream launching thousand beam node would wasteful partly defeat purpose using erlang also wanted manage kcl process erlang multilangdaemon interface erlang system pretty good network server turned problem around creating adapter launch multilangdaemon whose worker subprocesses become lightweight network client erlang node stream processed erlang node launch multilangdaemon subprocess port program subprocess configured launch netcatlike program socat shard processing program simply map stdinstdout back port node listening stream thus owned shard mapped independent erlang process genstatem state machine single node process concerned handling single stream record time deciding periodically checkpoint result look like give benefit using kcl result processing application similar javabased kcl processing application work multiple thread execution within single vm without requiring user write java code allows simple shard processor like minimal example module noisyworker behavior erlmldworker export includelib erlmldincludeerlmldhrl record state shardid count initialize opaque shardid state state shardid shardid io format p initialized shard p pn self shardid ok state ready state ok state processrecord state shardid shardid count count state streamrecord sequencenumber sn record io format p p got record pn shardid count record case count true ok state state count checkpoint sequencenumber sn false ok state state count count end shutdown state shardid shardid count count reason io format p p shutting reason pn shardid count reason case reason terminate ok checkpoint ok end new opensource library erlmld created opensource erlang library kinesis dynamodb stream processing erlmld using multilangdaemon also includes support compressed kplstyle record aggregation additional behavior turned common pattern usage library accumulating batch record flushing periodically allows even simpler shard processor definition module noisyflusher behavior erlmldflusher export includelib erlmldincludeerlmldhrl record state shardid buf init shardid opaque state shardid shardid addrecord state buf buf length buf error full addrecord state buf buf state record token ok state state buf token record buf flush state shardid shardid buf buf state kind processedtokens record list unzip buf io format p processing batch pn shardid record timer sleep nstate state state buf ok nstate processedtokens processor build batch record processed backpressure mechanism exists ensure record supplied fast processor handle batch full processor instructed flush ie perform batch work take arbitrary amount time flushing processor return opaque token corresponding successfullyprocessed record allows system periodically checkpoint highest contiguous completed record stream worker dy new one come online steal lease work might repeated none lost beyond good erlang arrangement described scalable work well processperownedshard model mean concurrency limited number stream shard processing system core processing stream shard least half computing resource wasted unless take special measure make simple processing code simple use case turn scale processing independently stream shard preserving approximate ordered cookie inorder processing simple processing code especially helpful iobound task like new opensource library exmld created opensource elixir library kinesis dynamodb stream processing exmld build erlang library erlmld used elixir erlangbased processing system make use flow framework set mapreducestyle processing pipeline inside beam instead set worker process handle single shard data shard owned current node feed pipeline sends data downstream set reducer arbitrary number reducer consistently handle partition key space ie record key hashed distributed among reducer reducer always receive record key approximate order erlangbased system elixir flowbased processing pipeline using flow framework shard worker longer directly process record instead feed record set mapper extract zero item processed item associated key used distribute among set reducer actual processing work work completed worker originated record notified checkpoint make progress shard configuration allows reuse existing processing code minor modification greatly increased concurrency unrelated number stream shard owned current node use arbitrary number mapper reducer help u io bound task processing occur independently cookie seen ordering event generally preserved single cooky within single worker different cooky elixirerlang sample processing code complete example using erlang processing code new elixir library concept used keep track status event processing support stream checkpointing provide backpressure see exmld doc detail real application actual supervision tree would used organization code would also apply elixir processing application using library module exmldexample export record state count includelib erlmldincludeerlmldhrl result call item extracted record seen streamname streamregion run erlmldprivdownloadsh running download needed jar start streamregion affect kcl state table name appname yourerlangkclapplication streamname yourstreamname ok stage elixirexmldkinesisstage startlink flowspec stage stage extractitemsfn fun use first extracted item element reducer partition key partitionkey elem fun state end processfn fun flowopts ok flowworker elixirexmld startlink flowspec producerconfig recordprocessor erlmldbatchprocessor recordprocessordata flushermod elixirexmldkinesisworker flushermoddata stage stage flushintervalms checkpointintervalms watchdogtimeoutms description streamname streamregion oncheckpoint fun kclappname appname streamname streamname streamregion streamregion streamtype kinesis would normally set via app env listenip loopback listenport appsuffix undefined initialposition latest idletime metricslevel summary metricsdimensions operation failovertime ignoreunexpectedchildshards false workerid undefined maxrecords maxleasetheft shardsynctime ok producersup erlmldsup startlink producerconfig ok stage flowworker producersup oncheckpoint description shardid io format p checkpointed pn description shardid function normally return list item processed record using kplstyle aggregation supported erlmld return singleelement list due definition partitionkey return first element partition key use distributing work among reducer example us record partition key extractitems struct elixirexmldkinesisstageevent stage stage worker worker event struct elixirexmldkinesisworkerdatum streamrecord r value case r heartbeat x x heartbeat streamrecord partitionkey k k stage worker r end value function used flow reducer accepts extracted item reducer state return updated state needed processing processevent key value state count c state case value stage worker streamrecord sequencenumber sn notify upstream stage disposition processing originating worker make progress checkpoint real application would done batch work completed status would vary based processing outcome workermap worker struct elixirexmldkinesisworkerdisposition sequencenumber sn status ok ok elixirexmldkinesisstage disposition stage workermap work return updated state io format p processing p seen p n self key c timer sleep state state count c heartbeat heartbeat used prevent stall worker waiting processing happen disposition returned io format p ignoring heartbeat eventn self state end impact using new arrangement existing erlang code doubled performance system snapshot happened stream delay metric deployed elixir flowusing version application following service degradation erlangonly system fallen behind entered unhealthy behind tip state scaled maximum size recovering quickly elixirusing version deployed gauge performance recovery stream processing delay fell cliff elixirusing version running since conclusion using erlang elixir able implement scalable system cut dynamodb cost using elixir glue code enabling use flow framework doubled performance previously erlangonly system minor modification also opensourced code using process highvolume kinesis dynamodb stream data erlang elixir enjoyed working system elixir firmly toolbox use future http githubcomadrollerlmld http githubcomadrollexmld enjoy working largescale system roll u
213,Lobsters,erlang,Erlang development,Spawnfest Retrospective (Beamcraft),http://technology.customink.com/blog/2018/01/06/spawnfest-retrospective/,spawnfest retrospective beamcraft,spawnfest retrospective spawnfest server classic minecraft server client protocol game server map server went well communication client go well map attempt one attempt two still perfect,spawnfest retrospective year participated spawnfest two day hackathon focused around beam virtual machine judging finished felt appropriate time reflect architecture process submission submission server classic minecraft written elixir unlike current version version minecraft limited feature set supporting chat placing block moving fluid simplistic protocol availability open source client seemed like perfect project two day contest server unlike ruby c java elixir actor based language actor based language communication across boundary happens via message passing instead function call roughly equivalent service oriented architecture replacing network boundary service memory communication pattern lead highly concurrent software requires different way thinking high level server submitted three kind actor client protocol game server map server ranch socket acceptor pool would spin instance client protocol manage connection server client instance decoded message client passed game server game server sent update back client game server kept track connected client ensuring change map chat message player connection disconnection seen everyone server finally map server kept track update game map went well communication client actor model nice use project helped cleanly separate encoding decoding logic provided process id make tracking connected client simple also helped u avoid concurrency issue traditional approach multithreading suffer actor connected client game server needed validate input correct send message client actor logic involving speaking protocol contained client actor made game server much cleaner since work construct binary separate game server logic also good way keep track connected client free since actor assigned process id actor run game server needed keep mapping username player id process id made implementing whisper chat command despawning logged player trivial whisper server map target player username pid send chat message along get despawning working player logged server take process id disconnecting player released player id back pool broadcasted despawn message rest connected client importantly using actor based concurrency removed cognitive burden associated traditional threading approach need manage mutexes deal deadlock thing focus message structure runtime took care rest go well map getting performant way representing map proved challenge little understanding built sent client think see minecraft classic map made block get sorted x z matrix unsigned bit integer byte matrix represents corresponds type block index position world data sent client matrix converted one dimensional array byte header number element array added gziped sent chunk byte client largest map block mean take memory map data store one byte per block also needed ability update arbitrary block meant treated binary would lot work access update single block overcome implemented two version erlang term storage based map issue attempt one erlang term storage ets really appealing way deal map update provides key value table contain arbitrary element multiple storage option provides constant lookup logarithmic lookup time block map stored tuple like x z blocktype could update quickly little overhead two issue approach large memory needed build array send client block map required table feel best since using malloced c could get fiftieth pressing issue building array map data send client default ets table unsorted set meant process building array load term table memory sort key correct order concatenate value new array send array client largest map size ended sorting concatenating item proved slow switching storage option provide appreciable speed boost another solution needed attempt two good night sleep bit googling decided add runlength encoding map internal structure helped tremendously performance size unfamiliar runlength encoding rle lossless form compression store consecutive element single value number repetition mean could become since map data lot consecutive element compressing row column rle mean save lot space cut amount sorting need memory instead storing x z blocktype use z xrowcompressed mean sort item decompress concatenate entire row time rle approach proved good enough given time constraint one made final submission still perfect quite proud able get done two day still feel like area could make better given time gameserver ended large taste feel would cleaner split tracking player passing player change around chat message currently use send pas message back client would intention revealing public api provided clientprotocol encapsulate behavior map built gzip stream read ets table current list binary gzip process performant unhappy way fluid work feel like want treated player like thing live inside simpleoneforone supervisor outside small issue area want correct contest enjoyable time big thanks brujo rest organizer judge sponsor putting wonderful event
214,Lobsters,erlang,Erlang development,Call for Presentations: BuzzConf '18,https://github.com/lambdaclass/buzzconf,call presentation buzzconf,join github today sign file permalink zruput ticket buzzconf topic code conduct code conduct cómo organizar una conferencia me ante me ante me ante me ante me ante me ante me ante días ante justo ante de la conf durante la conf después de la conf http githubcomrustcommunityeventsteamblobmasterguidelinestimelinemd topic resource reload reload,conference devs devs functional programming distributed system big data machine learning conference buenos aire argentina dismiss join github today github home million developer working together host review code manage project build software together sign file permalink failed load latest commit information type name latest commit message commit time buzzconf consists buzzconf workshop buzzconf talk also sister conference zruput telecommunication ticket buzzconf talk workshop available buzzconf topic functional programming distributed system embedded system big data artificial intelligence machine learning profilingdebugging programming language design code conduct please read follow code conduct conference cómo organizar una conferencia me ante definir nombre logo estética crear presencia online armar una página web de la conferencia github redes sociales reservar el lugar armar el evento en eventbrite poner la entradas initial offer la venta abrir la call presentation empezar subir algún contenido redes sociales me ante empezar contactar speaker empezar contactar sponsor en redes sociales tratar de conseguir la mayor cantidad de seguidores difusión me ante confirmar algunos speaker subir la entrada earlybird reservar alojamiento para todos pasajes para speaker locale me ante confirmar todos los speaker armar la grilla de la conferencia con los tiempos de charlas break confirmar cada orador cuanto tiempo va tener para hablar subir la entrada al precio normal aumentar la difusión completar la información de la web me ante comprar pasajes para speaker de afuera segunda ronda de sponsor me ante planificar fotografía video durante la conferencia pedir los speaker que envíen sus diapositivas para exponer durante la conf preguntarles si quieren hacerlas públicas en internet si esa e la política de la conf me ante imprimir folletería carteles mandar hacer swag bolsas pedir la empresas que manden su swag imprimir entradas si se hacen en papel ver el disenio del espacio donde se va desarrollar la conf planificar donde van los banner los stand la mesa de inscripciones la comida etc hacer descuentos sorteos de entradas si sobra lugar aumentar la difusión porque hay mucha gente que espera estar muy cerca de la fecha para anotarse mandar mail la mailing list considerar publicidad paga se pueden publicar la slide anticipadamente para que el público la conozca armar horarios de la conferencia publicar online e informar los speaker qué hora e su charla días ante armar la bolsas de swag hacer backup de todo el material audiovisual que se va proyectar en una laptop para llevar ese día tener listo todo lo que se va llevar la conferencia sticker banner sonido computadoras cámaras etc avisar al catering cuánta gente eligió menú especial chequear con los speaker que todo está bien justo ante de la conf ante de que empiece todo probar el livestreaming si lo hay probar equipos de sonido durante la conf publicar fotos actualizaciones durante la charla para la gente que pudo venir prestar atención al bienestar de los asistentes al cumplimiento del code conduct una persona controla la entrada en todo momento después de la conf enviar una encuesta los asistentes que dejaron mail para ver en qué podemos mejorar publicar los video fotos del evento enviar agradecimientos los speaker inspirado en http githubcomrustcommunityeventsteamblobmasterguidelinestimelinemd conference devs devs functional programming distributed system big data machine learning conference buenos aire argentina topic resource perform action time signed another tab window reload refresh session signed another tab window reload refresh session
215,Lobsters,erlang,Erlang development,SSH distribution for Erlang,https://github.com/geocar/inet_ssh_dist,ssh distribution erlang,inetsshdist epmd erlang ssh server using roadwarrior using clustercommunication creating user restricted port forwarding reload sshd add key manually adding ssh key used erlang verifying got restricted ssh setup,inetsshdist inetsshdist erlang distribution network protocol run ssh configuration could simple protodist inetssh everything go ssh even epmd nt need special ssh server nt need erlang ssh server fact nt even supported yet ssh knownhosts must already populated since distribution refuse accept new host adhoc basis using roadwarrior erlang cluster already using inetdisttcp ssh node nt anything except use protodist inetssh roadwarrior machine tell erlang node username eg protodist inetssh sshdefaultuser erlang using clustercommunication note nt fast ca nt get ipsec working lot easier getting tl working right creating user restricted port forwarding first make sure know port erlang going use adding following command line sshdefaultuser erlang inetdistlistenmin inetdistlistenmax edit etcsshsshdconfig match user erlang allowtcpforwarding local permittunnel permittty gatewayports allowagentforwarding allowstreamlocalforwarding permitopen forcecommand echo restricted account reload sshd create user sudo useradd erlang add key manually using sshcopyid adding ssh key used erlang nt root share application user release team ha ha ha enterprise want add ssh key directly user account first make sure know port erlang going use adding following command line sshdefaultuser erlang inetdistlistenmin inetdistlistenmax add beginning every restricted key sshauthorizedkeys file command echo restricted account noagentforwarding permitopen complete example obviously use key command echo restricted account noagentforwarding permitopen sshrsa verifying got restricted ssh setup first make sure nt work ssh erlang host connection closed ssh erlang host bindate connection closed date executed ssh n erlang host wrong forwarding type ssh n l erlang host wrong port number sftp erlang host wrong subsystem verify work ssh n l erlang host
216,Lobsters,erlang,Erlang development,All repos from spawnfest 2017 are public now,https://goo.gl/RfaLwJ,repos spawnfest public,search help section basic search repository search code search issue search user search,github search support variety different operation quick cheat sheet common search information visit search help section basic search search find repository cat star find cat repository greater star user defunkt get repository user defunkt tom location san francisco ca find tom user san francisco ca join extension coffee find instance join code coffee extension cat excludes result containing cat repository search repository search look project access github also filter result search find repository cat star find cat repository greater star user defunkt get repository user defunkt pug pushed pug repository pushed since jan nodejs fork find nodejs repository le fork jquery find jquery repository size kb gitx fork true repository search includes fork gitx gitx fork repository search return fork gitx code search code search look file hosted github also filter result search find repository install repo charlesprivaterepo find instance install code repository charlesprivaterepo shogun user heroku find reference shogun public heroku repository join extension coffee find instance join code coffee extension system size find instance system code file size greater example path doc find example path doc replace fork true search replace source code fork issue search issue search look issue pull request github also filter result search find encoding user heroku encoding issue across heroku organization cat open find cat issue open strange comment issue comment hard label bug hard issue labeled bug author mojombo issue authored mojombo mention tpope issue mentioning tpope assignee rtomayko issue assigned rtomayko exception created created since beginning exception updated last updated user search user search find user account github also filter result search find repository fullname linus torvalds find user full name linus torvalds tom location san francisco ca find tom user san francisco ca chris find chris user follower ryan repos find ryan user repository
217,Lobsters,erlang,Erlang development,spawnfest/beam-craft -- Minecraft Classic server in Elixir,https://github.com/spawnfest/beam-craft,spawnfestbeamcraft minecraft classic server elixir,beamcraft introduction classicsharp client running server running client window classicsharp website mac o x linux classicsharp website wine useful link,beamcraft lobster introduction simple minecraft classic server written elixir compatable classicsharp client current test server live minecraftburnwillowsnet running server git clone http githubcomspawnfestbeamcraft cd beamcraft mix depsget mix run nohalt default server start port listens running client window use window release provided classicsharp website mac o x linux use mac o x linux release provided classicsharp website wine get asset first run launcher invoke client directly like wine classicalsharpexe username password ip port useful link
218,Lobsters,erlang,Erlang development,Vagrant for Erlang Development,http://stratus3d.com/blog/2017/12/10/vagrant-for-erlang-development,vagrant erlang development,vagrant asdf installation virtualbox vagrant website installation hiccup setting environment vm vagrant website vagrant documentation vagrant running tighter integration local environment asking question shell alias vagrantexec vagrantexec script dotfile repo github conclusion reference,typically like development work local machine locally got favorite tool script alias along custom mapping editor local development much pleasant sshing server running command without custom tool configuration environment feel foreign generally try avoid solution development problem involve virtual machine even though vm running laptop really much easier develop regular server known vagrant long time really interested using easy setup development environment laptop asdf encountered project work able get working laptop spent hour trying figure misconfigured avail reluctantly figured would give vagrant try seemed like better option using plain vm turned effective development vagrant almost seamless blog post cover issue ran setting vagrant erlang project well thing discovered improved workflow vagrant installation first need install vagrant hypervisor running actual vm like virtualbox free open source linux may able use package manager install virtualbox version latest version vagrant support install virtualbox debian using aptget sudo aptget install install vagrant download vagrant website linux use package manager install installation hiccup installing vagrant trying start one project realized issue virtualbox installation turned due option called vtx disabled bios error got tried boot vm looked like error executing vboxmanage cli used vagrant controlling virtualbox command stderr shown command startvm type headless stderr vboxmanage error vtx disabled bios cpu mode verrvmxmsrallvmxdisabled vboxmanage error detail code nserrorfailure component consolewrap interface iconsole rebooted machine went bios enabled option booted virtualbox installation worked error printed setting environment vm vagrant installed begin setting erlang project navigate project command line run vagrant init box generate vagrantfile project blog post chose box ubuntu seems default box used vagrant documentation box package format vagrant environment box contain base vm image metadata available box listed vagrant website vagrantfile project root specify configuration value project box typically much need change plenty option available set option network interface synced folder base box image used vm going cover vagrant documentation book vagrant running great resource vm running need provision box erlang development need erlang optionally elixir vagrantfile allows u specify provisioning script run vm created install tool need use asdf locally figured would use vm well provision script needed would need install asdf install necessary asdf plugins install correct version erlang rebar elixir project script came usrbinenv bash unoffical bash strict mode http redsymbolnetarticlesunofficialbashstrictmode set euo pipefail originalifs ifs ifs tn stricter ifs setting install git asdf dependency sudo aptget install git automake autoconf libreadlinedev libncursesdev libssldev libyamldev libffidev libtool unixodbcdev buildessential autoconf curl install asdf git clone http githubcomasdfvmasdfgit homeasdf cd homeasdf git checkout echo e n homeasdfasdfsh homebashrc echo e n homeasdfcompletionsasdfbash homebashrc make asdf available script set u source homeasdfasdfsh set u install necessary asdf plugins asdf pluginadd erlang http githubcomasdfvmasdferlanggit asdf pluginadd rebar http asdf pluginadd elixir http githubcomasdfvmasdfelixirgit navigate directory containing project vagrant directory synced project dir host cd vagrant make version defined toolversions file version used vagrant user directory cp toolversions home install correct version package project asdf install echo completed setup erlang environment asdf expects toolversions file project root vagrant run provision script toolversions file must exist project project needed latest erlang version elixir mine looked like erlang rebar need tell vagrant use script provision vm configvmprovision parameter allows u specify provision method vagrant box shell script like need add configvmprovision line like vagrantconfigure config omitted option configvmprovision shell path provisionsh privileged false end vagrant run provision script creating vm already vagrant box running run vagrant destroy vagrant vagrant setup new vm run provision script provision script finish without error running vagrant vm configured erlang development tighter integration local environment sshing onto vm run command something wanted avoid turn easy avoid running command directly vm vagrant provides vagrant ssh command used ssh onto server treated regular ssh client meaning use run arbitrary command server like could regular ssh client run arbitrary command use vagrant ssh command example see ip address vm run vagrant ssh ip address also run script vm like vagrant ssh script lot type simple thing eager find better way would nice type much asking question found three way make running command vm easier shell alias first way simplify command create shell alias vagrant ssh easy make command lot shorter add bashrc alias vc vagrant ssh use run command vm vc ip address downside still quote command want run vagrantexec vagrantexec nice vagrant plugin aim make easier run command vm offer nice feature us synced folder map command right directory vm allowing navigate around local environment run command equivalent vm option generating shim add path run command locally without prefix option prepending command command example prepend aptget sudo vagrantexec much better choice shell alias offer feature tighter integration downside often requires work configure vagrantexec complicated wanted see could write simplified version shell script va script able write simple bash script work similar vagrantexec lack many feature provided vagrantexec still make running command easy named script va make short enough alias would needed using script easy going back ip address example would va ip address basically script look synced folder mapping configured project map current directory host machine equivalent directory vm allows easily run directoryspecific command host without worry directory used vm output command printed run locally source script found dotfile repo github need put path conclusion overall vagrant big help surprised much searching find good way seamlessly running command vm local environment va script pretty happy always use vagrantexec future find va script insufficient still really like developing locally time run project locally going use vagrant hard beat ease use tight integration vagrant provides reference
219,Lobsters,erlang,Erlang development,"Construction and Formal Verification of Fault-Tolerant, Distributed, Mutual Exclusion (2017)",https://icfp17.sigplan.org/event/erlang-2017-papers-construction-and-formal-verification-of-a-fault-tolerant-distributed-mutual-exclusion-algorithm,construction formal verification faulttolerant distributed mutual exclusion,use conference time zone greenwich mean time belfast,use conference time zone greenwich mean time belfastselect time zone aoe anywhere earth midway island samoa hawaiialeutian hawaii marquesas island gambier island alaska tijuana baja california pitcairn island pacific time u canada mountain time u canada chihuahua la paz mazatlan arizona saskatchewan central america guadalajara mexico city monterrey easter island central time u canada eastern time u canada cuba bogota lima quito rio branco caracas santiago la paz faukland island manaus amazona brazil atlantic time goose bay atlantic time canada newfoundland montevideo miquelon st pierre greenland buenos aire brasilia distrito federal brazil midatlantic cape verde gmt azores utc coordinated universal time greenwich mean time belfast greenwich mean time dublin greenwich mean time lisbon greenwich mean time london gmt monrovia reykjavik amsterdam berlin bern rome stockholm vienna belgrade bratislava budapest ljubljana prague brussels copenhagen madrid paris west central africa windhoek beirut cairo gaza harare pretoria jerusalem minsk syria moscow st petersburg volgograd nairobi tehran abu dhabi muscat yerevan kabul ekaterinburg tashkent chennai kolkata mumbai new delhi kathmandu astana dhaka novosibirsk yangon rangoon bangkok hanoi jakarta krasnoyarsk beijing chongqing hong kong urumqi irkutsk ulaan bataar perth eucla osaka sapporo tokyo seoul yakutsk adelaide darwin brisbane hobart vladivostok lord howe island solomon new caledonia magadan norfolk island anadyr kamchatka auckland wellington fiji kamchatka marshall chatham island nukualofa kiritimati
220,Lobsters,erlang,Erlang development,Verification of Erlang Programs using Abstract Interpretation and Model Checking (2001),https://pdfs.semanticscholar.org/8174/3408a73d77c83cc88d6d9be8f994a0d2f4f2.pdf,verification erlang program using abstract interpretation model checking,,automatic verification erlangstyle concurrencyemanuele dosualdo jonathan kochems ch luke
221,Lobsters,erlang,Erlang development,Erlang Garbage Collector,https://www.erlang-solutions.com/blog/erlang-garbage-collector.html,erlang garbage collector,erlang garbage collector update previous blog post erlang garbage collector erlangotp thing changed reason updated blog post erlang garbage collector tracing garbage collector cheney overview meet creating data immediate term boxed term young heap collector scanning rootset see move marker term catch deallocate generational garbage collection overview hypothesis erlang garbagecollect spawnopt fun fullsweepafter n young heap sizing heap grows variation fibonacci sequence grows increment literal two quick pointer check lookup array special tag literal binary heap reference counted mso list swept move marker decremented potentially freed encounter offheap binary old heap virtual binary heap trigger message large allocate enough space copy insert message queue message allocating strategy learn work erlang elixir thought might also interested go back blog,erlang garbage collector lukas larsson update previous blog post erlang garbage collector erlangotp thing changed reason updated blog post erlang garbage collector erlang manages dynamic memory tracing garbage collector precisely per process generational semispace copying collector using cheney copy collection algorithm together global large object space overview erlang process stack heap allocated memory block grow towards stack heap meet garbage collector triggered memory reclaimed enough memory reclaimed heap grow creating data term created heap evaluating expression two major type term immediate term require heap space small integer atom pid port id etc con boxed term tuple big num binary etc require heap space immediate term need heap space embedded containing structure let look example return tuple newly created data data foo con literal text hello world tag con literal example first create new con cell integer tuple text tuple size three wrapping value atom tag created returned heap tuples require word size element well header con cell always require two word adding thing together get seven word tuples word con cell string hello world list con cell thus requires word atom tag integer require additional heap memory since immediate adding term together heap space required example word compiling code beam assembly erlc show exactly happening putlist put atom tag put put literal text hello world return looking assembler code see three thing heap requirement function turn six word seen instruction allocation combined single instruction bulk data text hello world literal literal sometimes referred constant allocated function since part module allocated load time enough space available heap satisfy testheap instruction request memory garbage collection initiated may happen immediately testheap instruction delayed later time depending state process garbage collection delayed memory needed allocated heap fragment heap fragment extra memory block part young heap allocated contigious area term normally reside see young heap detail collector erlang copying semispace garbage collector mean garbage collection term copied one distinct area called space new clean area called space collector start scanning rootset stack register etc follows pointer rootset heap copy term word word space header word copied move marker destructively placed pointing term space term point already moved term see move marker copy referring pointer instead example following erlang code foo arg test arg wrapper one copy exists heap garbage collection first time encountered copied term referenced rootset copied collector scan space copy term term reference scanning collector step term space term still referencing space copied space term contain nonterm data payload heap binary instance encountered collector value simply skipped every term object reach copied space stored top scan stop line scan stop moved end last object scan stop marker catch scan start marker garbage collection done point deallocate entire space therefore reclaim entire young heap generational garbage collection addition collection algorithm described erlang garbage collector also provides generational garbage collection additional heap called old heap used long lived data stored original heap called young heap sometimes allocation heap mind look erlang garbage collection copy stage anything copied young space instead copied old space highwatermark highwatermark placed previous garbage collection described overview ended introduced new area called old heap normal garbage collection pas term located highwatermark copied old space instead young next garbage collection pointer old heap ignored scanned way garbage collector scan longlived term generational garbage collection aim increase performance expense memory achieved young smaller heap considered garbage collection generational hypothesis predicts term tend die young immutable language erlang young term die even faster language usage pattern data new heap die soon allocated good limit amount data copied old heap also garbage collection algorithm used proportional amount live data heap one critical issue note term young heap reference term old heap term old heap may refer term young heap due nature copy algorithm anything referenced old heap term included reference tree rootset follower hence copied data would lost fire brimstone would rise cover earth fortunately come naturally erlang term immutable thus pointer modified old heap point young heap reclaim data old heap young old heap included collection copied common space space young old heap deallocated procedure start beginning type garbage collection called full sweep triggered size area highwatermark larger size free area old heap also triggered manual call erlang garbagecollect running young garbage collection limit set spawnopt fun fullsweepafter n n number young garbage collection forcing garbage collection young old heap young heap young heap allocation heap consists stack heap described overview however also includes heap fragment attached heap heap fragment considered highwatermark part young generation heap fragment contain term either fit heap created another process attached heap instance bif binarytoterm created term fit current heap without garbage collection create heapfragment term schedule garbage collection later also message sent process payload may placed heapfragment fragment added young heap message matched receive clause procedure differs worked prior erlangotp contiguous memory block young heap stack resided considered part young heap heap fragment message immediately copied young heap could inspected erlang program behaviour introduced superior many way significantly reduces number necessary copy operation root set garbage collection sizing heap mentioned overview size heap grows accommodate data heap grow two stage first variation fibonacci sequence used starting word mega word heap grows increment two occasion young heap grows total size heap message heap fragment exceeds current heap size fullsweep total amount live object greater two occasion young heap shrunk young collection total amount live object le heap young heap big fullsweep total amount live object le heap old heap always one step ahead heap growth stage young heap literal garbage collecting heap young old literal left place copied figure term copied garbage collection following pseudo code used ertsisliteral ptr onoldheap ptr fullsweep literal non fullsweep copy else copy ptr ertsisliteral check work differently different architecture operating system bit system allow mapping unreserved virtual memory area operating system except window area size gb default mapped literal placed within area done determine something literal two quick pointer check system relies fact memory page touched yet take actual space even gb virtual memory mapped memory actually needed literal allocated ram size literal area configurable miscs ertsalloc option bit system enough virtual memory space allocate gb literal instead small kb sized literal region created demand card mark bitarray entire bit memory space used determine term literal since total memory space bit card mark bitarray word large bit system bitarray would tera word large technique viable bit system lookup array little expensive pointer check done bit system extremely bit window ertsalloc unreserved virtual memory mapping special tag within erlang term object used determine something literal cheap however tag available bit machine possible great deal nice optimization tag future like instance compact list implementation used operating system needed behaviour different worked prior erlangotp literal check done checking pointer pointed young old heap block considered literal lead considerable overhead strange memory usage scenario removed binary heap binary heap work large object space binary term greater byte called offheap binary binary heap reference counted pointer offheap binary stored process heap keep track decrement reference counter offheap binary linked list mso mark sweep object list containing fun external well offheap binary woven heap garbage collection done mso list swept offheap binary move marker written header word reference decremented potentially freed item mso list ordered time added process heap minor garbage collection mso sweeper sweep encounter offheap binary old heap virtual binary heap process virtual binary heap associated size current offheap binary process reference virtual binary heap also limit grows shrink depending offheap binary used process growth shrink mechanism used binary heap term heap first fibonacci like series growth virtual binary heap exists order trigger garbage collection earlier potentially large amount offheap binary data could reclaimed approach catch problem binary memory released soon enough catch lot message message become part process heap different time depends process configured configure behaviour process using processflag messagequeuedata offheap onheap set default process start using option hmqd different configuration use let start going happens one erlang process sends message another sending process need couple thing calculate large message sent allocate enough space fit entire message copy message payload allocate message container meta data insert message container receiver process message queue process flag messagequeuedata receiver process control message allocating strategy sender process step also message data treated garbage collector procedure different worked prior configuration option behaviour always similar onheap option message allocating strategy set onheap sending process first attempt allocate space message directly young heap block receiving process always possible requires taking main lock receiving process main lock also held process executing possibility lock conflict thus likely intensely collaborating system sending process acquire main lock heap fragment instead created message message payload copied onto offheap option sender process always creates heap fragment message sent process bunch different tradeoff come play trying figure strategy want use using offheap may seem like nice way get scalable system get little contention main lock however allocating heap fragment expensive allocating heap receiving process unlikely contention occur efficient try allocate message directly receiving process heap using onheap force message part young heap increase amount data garbage collector move garbage collection triggered processing large amount message copied young heap turn lead message quickly promoted old heap thus increase size may good bad depending exactly process large old heap mean young heap also larger turn mean le garbage collection triggered processing message queue temporarly increase throughput process cost memory usage however message consumed process enters state lot le message received may long time next fullsweep garbage collection happens message old heap happens onheap potentially faster mode us memory longer time mode legacy mode almost message queue handled erlangotp one strategy best depends lot process interacts process always profile application see behaves different option c j cheney nonrecursive list compacting algorithm commun acm nov ungar generation scavenging nondisruptive high performance storage reclamation algorithm sigsoft softw eng note apr learn work erlang elixir thought might also interested go back blog
222,Lobsters,erlang,Erlang development,The Final Countdown,https://medium.com/erlang-battleground/the-final-countdown-4da33b134b99,final countdown,going doc love andalso orelse andalso isinteger first isinteger last last inc first inc last inc first inc last inc first last first last last element list,going let look doc shall according list sequence integer start contains successive result adding incr previous element reached passed latter case element sequence incr default translating example list seq return sequence integer start contains successive result adding previous element reached passedthat fine first example greater well doc continues tell u failure condition list incr incr incr incr incr toi love last scenario basically tell u evaluate stuff like list seq get awesome anyway case since incr care function fail exactly happens value ok properly documented said everything seems bit contradictory say function return sequence integer start let function return empty list fail incr analogous case incr hand list going return empty list simply return empty list always instead failure scenario ie return empty list incr andalso incr orelse incr andalso incr figure let code see validation failure condition clearly stated specifically set outside recursive function performs list generation ie seqloop seq first last isinteger first isinteger last last seqloop last first last inc isinteger first isinteger last isinteger inc inc first inc last inc first inc last n last first inc div inc seqloop n inc first inc inc first last seqloop first inc endthe reason validation lie wayseqloop function work clearly implemented naïve way item last acc item last reverse acc seqloop item last acc seqloop last itemacc implemented optimized fashion instead counting first last count last element list way seqloop count importantly avoid call endbut recursion style change base case recursion naïve approach base case item last actual implementation base case n n naïve method start already larger last function return empty list actual seqloop function remove initial validation seq provide would generate negative list length eg seqloop fail functionclause error since clause handle negative value fornwhat author seq raise error calling seqloop hiding user implementation detail function error raised think good practice validating user input api level let implement internal function assuming input already validnow reject input value make seqloop fail instead either rejecting seemingly invalid input ie andalso incr orelse andalso incr returning empty list
223,Lobsters,erlang,Erlang development,"HydrOS: A Massively-Fault-Tolerant, Operating System",http://hydros-project.org/,hydros massivelyfaulttolerant operating system,,
224,Lobsters,erlang,Erlang development,Holiday Ping: how we implemented our first open source app with Erlang and Clojurescript,https://notamonadtutorial.com/holiday-ping-how-we-implemented-our-first-open-source-app-with-erlang-and-clojurescript-fad5b66fc325,holiday ping implemented first open source app erlang clojurescript,holiday ping implemented first open source app erlang clojurescript lambdaclass holiday ping github unbalancedparen monad tutorial stay tuned background project holidayping open source spinoff project throttle reconnections backend language erlang v elixir new ruby literature guide process learning erlang application supervisor structure rest api cowboy rest handler reminder checker error kernel app reminder router genevent erlang anger book provide much benefit worker pool avoiding throttling issue still open database hiding database behind orm want explore handle configuration difference channel inheritance table inheritance limited plain table hstore hstore jsonb json rest api identifier still work authentication authorization jwt suspicious fond json several article store random string database le issue may simpler nested resource test,holiday ping implemented first open source app erlang clojurescriptafter almost ten year working developer different company two year ago started company lambdaclass wanted freedom choosing type project team work withthat today special day take break regular interview celebrate release first open source application holiday ping facundo olano main developer application application written two best programming language know clojure erlang favorite database postgresql post written tell journey lesson learned backend side similar post frontend forthcoming find issue want help check githubreach via twitter unbalancedparen comment interview request monad tutorial stay tuned discus vote lobster reddit hnbackgroundearlier year joined lambdaclass buenos airesbased software consultant founded ago colleague schoolmate lambdaclass special interest distributed system exclusively erlang shop project implemented beam languagesalthough recent background microservices functional language mainly clojure needed time ramp gain experience otp platform underlying philosophy started working lambdaclass project right away aspect learning process specially related architecture design best experienced greenfield project company also goal strong open source presence thus decision spend part time public side projectswe considered couple mid sized project implemented one arguably looked smaller scope ended purpose document share experience put discussion word wrap understanding make conclusion help u future projectsthe projectholidayping small web application sends holiday reminder different service like email slack mainly aimed consultant freelancer used work client abroad free charge open sourcespinoff projectsas part holidayping effort started design implement open source tool solve couple problem identify recurring throttle perform access control resource api endpoint reconnections initiate maintain connection external service otp idiomatic waythe backendlanguage erlang v elixirthe first decision programming language erlang elixir use lambdaclass eventually learn question effective learn first considering goal productive properly understanding erlang platform long runelixir would probably easier considering previous background syntax closer modern language learning first carried risk scratching surface otp using language like new ruby hiding going underneath seem like simpler get good understanding otp way starting erlang especially since literature guide process switching elixir would mostly consist getting familiar new syntax language featureswe understand elixir gaining popularity elixir code written deeper understanding erlang otp become valuable asset company addition many robust useful library written erlang able dive code importantlearning erlanga quick note impression language found expressive mostly pattern matching coming clojure issue grasp erlang functional aspect contrary lot people mind syntax actually like lot exception notable quirk one come mind binary literal powerful inconvenient string replacement coworkers kept telling later confirmed otp big deal language itselfapplication supervisor structureat high level application divided following componentsa restful api mostly crud operationsa process periodically check whether reminder sent eg today holiday bob country bob asked send reminder slack email channel worker process send remindersrest apithe crud api require much thinking least otp point view implemented cowboy rest handler note library great job forcing define well behaved rest server without much codereminder checkerthe process involved reminder interesting obviously important since value application depends working properly error kernel app process check whether holiday sent remindchecker genserver us timer sendinterval periodically query database asking reminder sent trigger worker creation necessary data send remindershow often checker run information passed worker thing changed model implementation got sophisticated general idea always isolate decision send reminder act sending failure specific channel affect channel user checker processreminder routerthe reminder sent genserver process called reminder router child supervisor simpleoneforone strategy different channel module implement specific send message service email slack webhook genevent first studying otp behavior coworkers suggested defer reading genevent since used much practice started work holidayping though almost entirely setting triggering event sounded like genevent would something consider indeed superficial overview confirmed quoting erlang anger book genevent act event hub callback way deal notification sortso went back coworkers come using genevent turn behavior provide much benefit one would expect event hub term discussed beginning section genevent provide isolation event slow crashing event would affect restwhy worker pool certain point development router sending reminder channel user given holiday wanted separate processing isolated channel request eg bypass email sending crash requesting slack obvious option add second simpleoneforone supervisor new genserver briefly considered worker pool instead language ecosystem thread expensive pool usual option erlang though story different process cheap reason upfront force limit amount process created exception maintaining pool connection database hit point much work amount concurrent process becomes expensive likely need something fancier pool overcome ie pool manager become bottleneck queue grow faster worker process admittedly situation atypical sense potential overload come request constantly arriving burst reminder need sent checker run currently every minute could easily alleviate load spreading reminder time one checker run next would useless optimization upfrontavoiding throttling issueswhich brings issue notice writing line still open reason expect system able handle sending reminder likely third party service hit enforce throttling limit uslet say hopefully thousand developer argentina find project useful set slack channel default reminder setting case christmas morning reminder checker attempt send thousand request slack le time slack likely reject request retries next time checker run one way reduce chance happening would mentioned previous section spread reminder sending across available time one run next course enough user limit could hit anyway resort finer grained queuing throttling mechanismsdatabasethe database pick simple postgresql default databasefor year either hiding database behind orm using schemaless store like mongodb although lazy developer inside grumbled bit define schema upfront eventually came remember amazingly flexible powerful postgresql point found pushing stuff eg time arithmetic database level easier work available erlang library even want explore domain integrity constraint implement longpostponed input validation backendhandle configuration difference channelsour model spot hard fit database schema user creates channel different type slack email webhook different configuration parameter email channel take list email address webhook take single url slack take hook url list channel user emoji etcwe care difference end application validate user input execute typespecific logic send reminder everywhere else want treat channel equally regardless configuration tried several postgresql feature save channel configurationinheritancethis use case seemed like good fit table inheritance wrote base channel table common field user name type separate table inheriting adding typespecific configuration soon found inheritance feature limited provide feature would justify choice unique constraint enforced across child get child data querying parent etcplain tablesgiven inheritance provide much operational value using separate table configuration managing manually made sense way go long run since want benefit type validation constraint compared schemaless storage would induce lot overhead early stage development considering channel type model general far stablehstorewe started looking unstructured postgresql data type hstore keyvalue type array eg one value per key needed channel option hstore trickjsonbso turned json jsonb field let u store arbitrary configuration inside channel table treat like opaque value except spot actually use configuration send reminder arguably convenient option never got point thoroughly validating channel input backend get make sense define properly structured table firstrest apiidentifierswe spent time discussing way identifying resource across project relevant discussion since applies project may well settle one design consistent onas see flexible method use serial id postgresql every table use foreign key join want expose api since implementation dependent something may reusable want switch database add extra one separate id uniquely identify resource uuid never change reused across databaseswhen make sense model id resource user email unique name etc may use identifier user facing api ie rest uris ui route make user friendly rely internal storage correlation even start email change assumption business rule like change benefit relying heavily implementationthe last one something get entirely right still work current implementation model id user email channel name holiday date external uuids use case like changing channel name supportedauthentication authorizationto manage authorization api went bearer token based previous experience convenient token authorization opposed say requiring basic auth every request allows u decouple authentication authorization want support new authentication method added github login add new auth endpoint return access token authorization rest api remains untouchedregarding token format initially went jwt without giving much thought seen commonly used authorize web apps accessing rest backend coworkers heard suspicious understand totally sound like fond json digged little bit make sure decision made sense several article expressing concern using jwt although apply use case assuming want stick bearer token alternative jwt would store random string database associated user check value every request quick comparison two option jwt let identify user without need hit database every request server decodes token secret used generate check claim fair least use case evidence going database request would problemjwt stateless seems inline rest principle session client sends token request enough identify itdatabase stored token require bit extra effort need manage expiration delete old token make sure pick secure enough method generate hand blacklisting compromised token easier jwt since flag database although le issue using short expiration conclusion jwt easier although may simpler database stored token either option work see strong enough reason drop jwt already workingnested resourcesthis one thing debated get definite answer restful resource apichannels nameapichannels nameholidaysapichannels nameremindersand point ui need display summary view list channel including holiday reminder informationwhat obviously want force ui collect data making two extra request per channel list want api tailormade specific client either say graphql nowhere near big enough call view saw two acceptable solution use generic query parameter like childrentrue indicate child resource included response problem allornothing approach big enough resource may want child seen apis suffer coming weird dsl recursively pick nested child response case look graphql nowadays consider detailed version channel one includes child information separate resource altogether first felt bit like forcing backend fit client need honest looking uris apichannels apichannelsdetail help thinking better let resource reproduce keep interface dumb possible ie magic query parameter could gone either way chose separate resource easier implementtestsi think write serious software without sort testing point inefficient try make progress without test back also think situation obligated add test counter productive apart one commandment thou shalt test thy shit like kind religiousness testing type software benefit lot unit test testing specific function isolated rest system much coverage good indicator forcing specific coverage level suck people work better tdd people work better adding test working code stuff call testing every possible scenario generative testing etceterain experience last year working small apis mostly deal connecting integrating external service little benefit making pure unit test spend lot time building mock test glue code still common scenario totally fail software deal mostly integration need integration test sort confidence project work break modify change lot time something religious breaking apis time know put code better shape every time canfortunately coworkers share vision holidayping focused integration test make sure project work whole real database sending actual reminder first lot shortcut make sure internal part working eventually development moved forward api stabilized able rewrite test mostly talk external apito
225,Lobsters,erlang,Erlang development,An Erlang node implemented in Python,https://github.com/esl/Pyrlang,erlang node implemented python,pyrlang erlang node python documentation http pyrlanggithubiopyrlang support question http http erlangerslackcom feature,pyrlang erlang node python dropin erlang node implementation python implementing network erlang node protocol designed allow interoperation existing python project beam language erlang elixir alpaca luaerl lfe clojerl line startup code python program becomes erlang network node participating erlang cluster documentation browse http pyrlanggithubiopyrlang build running make doc generated sphinx support question time absolutely need assistance email slow discord channel http slack channel pyrlang http erlangerslackcom feature switchable async engine backends gevent asyncio erlang distribution protocol erlang version registry python process erlangcompatible process identifier optional registered name send receive message locally remotely pid name link monitor erlang python python erlang netadm ping supported rpc call python erlang rpc call exception propagated python back erlang pyrlanggenserver descendant pyrlangprocess allows accepting generic call mapped python class member
226,Lobsters,erlang,Erlang development,Overview of Elixir executables,https://monades.roperzh.com/overview-elixir-executables-escripts/,overview elixir executables,escripts archive phoenix well documented mix escript mix escriptbuild mix escriptinstall subscribe,escripts good way distribute selfcontained applicationsscripts executed command line consumer requirement erlang installed described valid erlang escripts erlang feature article focus escripts elixir perspective scenario constructing executable mean bundle entire project file arbitrary extension invoked command line accept argument erlang provides functionality box escripts elixir leverage escripts allows package entire otp application including dependency single executable file every time escript boot trigger independant erlang node therefore everything erlang thus elixir done escripts may find elixir library support option installed globally execute command commandline via archive notable example phoenix worth clarify archive always try stick escripts whenever possible erlang archive zip file extension ez file contain application part application well compiled beam file include application dependency elixir archive installed mix several peculiarity pollute every mix project system module archive accessed application consumer archive elixir installed run mix come bunch builtin task help build manage distribute escripts well documented official documentation summary used command mix escript list escripts installed directory listing mixescripts mix escriptbuild compiles project dependency package escript invoking mix escriptbuild necessary define escript key mainmodule option mixexs file escript mainmodule myappcli mix escriptinstall argument provided try install project current folder otherwise argument local path url prebuilt escript git repository git url github repository github url hex package hex packagename installing escript mean compiling placing binary mixescripts subscribe try post week interesting stuff programming nix web like notified new post go subscribe form
227,Lobsters,erlang,Erlang development,Tricky Question,https://medium.com/erlang-battleground/tricky-question-25a956298b9d,tricky question,going iraunkortasuna pro tip,going said might surprising actually pretty obvious well documented matching variable case clause header perfectly valid used stuff like b case rand uniform c c low c c high end b c convoluted way thing recommend even make bit rand uniform c c b low c c b highend b c style maintainability concern aside code totally valid mean variable bound case clause head body remain bound evaluation case expression know academic way express situation using word like closure scope leave explanation folk like iraunkortasuna much capable mewith mind reasonable original example either c bound evaluation whole expression wonder code extremely erlang warn erlang prevent writing nondeterministic thing course erlang compiler shell one warns thing like really smart check following module instance original code case even either c unbound case statement since used compiler say nothingbut check module case compiler even compile module instead fail following error variable c unsafe case line go tangent talking usable readable error message fact module compiled undeniably usefulpro tip see error like trying compile erlang module pay attention two line number warning unsafe variable used might bound
228,Lobsters,erlang,Erlang development,A Case Study in LASP and Distribution at Scale,https://www.youtube.com/watch?v=lhHtiBpDa54,case study lasp distribution scale,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature case study lasp distribution scale london erlang user group youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature case study lasp distribution scale london erlang user group youtube
229,Lobsters,erlang,Erlang development,Advanced List Incomprehensions,https://medium.com/erlang-battleground/advanced-list-incomprehensions-6957863dfb4f,advanced list incomprehension,going rather obscure part compiling file core bsm dcbsm warning warning x true x true true id nothing true false evaluating expression shell back erleval expr previously x nothing x x id nothing erleval clause evalfilter f q look like erllint isguardtest within try catch statement value acc final word trust shell mind guard,going usual first try find happening let show found farthe first thing notice rather obscure part erlang documentation list comprehension expr e e list basically translated local function etail expr expr e tail expr expr although exactly root cause behavior seen look like promising starting point hypothesis code translates lcs function particularity treat function application generator filter let see prove fileas saw different thing happen code file evaluated shell let first check list comprehension translated module compiled filein case x c fails caseclause whilex x e nothing return empty list adding weirdness erlang even produce warning see trick understand going check code look like core bsm compile module like erlc dcbsm warning clause ever warning guard clause evaluates falsedespite warning command generated following fileif translate important function something erlangy get case compiler smart enough know lc always result empty list hence warning compiled code function return e x case x true x x x true x true endin word erlang transforming lc simple caseif x true return list one element otherwise return empty list le expected considering already knew farc case id nothing true x false generated code another clause clause one added case statement without catchall clause endin case erlang compiler us patternmatching directly result function application instead using guard explicitly match boolean value know second clause could catchall clause consistent guard behaviorevaluating expression shellas seen back shell compile expression like compiler evaluates erleval expr procedure used previously try see expression evaluated look like case achieve put expression anonymous function use erlang f fun x nothing x x id nothing end fun f exception error bad filter rp erlang funinfo f pid module erleval newuniq name env eval fun value fun x nothing x x id nothing type local oki highlighted important piece one represent two lcs see lcs translated case ifs anything else tuple representationchecking code erleval see lc tagged tuples evaluated particular matter u clause e fqs lf ef acc compfun fun b e q b lf ef acc end evalfilter f lf ef compfun acc evaluated lc tuple one f list q declarative variable naming priority erleval let see look f lf ef compfun acc case erllint isguardtest f true case guardtest f lf ef value true compfun value false acc end false case expr f lf ef none value true compfun value false acc value v erlang raise error badfilter v stacktrace end endthe tricky part erllint nothing guard x id nothing evaluates guard within try catch statement always result either true false expression guard evaluated recursively using therefore may result something boolean might even raise error return something boolean erleval raise badfilter errorthe question distinction evalfilter implemented follows evalfilter f lf ef compfun acc case erllint isguardtest f false case expr f lf ef none value true compfun value acc end case try precisely match behavior distinguish guard regular expression find let know comment pleasefinal wordsin conclusion lcs still one favorite feature erlang couple thing remember working content article apply lcs without generatorslcs syntactic sugar require extra translation phase lcs functionsdon trust shell may get different result evaluate lc shell compiled module go escriptsmind guard writing lc filter remember behave differently particularly case error non boolean result guard regular expression
231,Lobsters,erlang,Erlang development,fez an Fsharp to core Erlang compiler,https://github.com/kjnilsson/fez,fez fsharp core erlang compiler,fez f core erlang experiment fsharp beam core erlang thoughtsmd getting started requirement self contained release release page work basicsfs functional object programming imperative erlang interop help,fez f core erlang experiment fez early door experiment compiling fsharp beam compatible core erlang primary aim implement enough language evaluate well ml type language could become practical language writing code run beam experiment succeed may lead fuller usable fsharp backend see thoughtsmd discussion potential implementation approach getting started requirement buildsh linuxmac buildcmd window fezc filefs linuxmac fezccmd filefs window try compile fsharp module beam use nobeam parameter want compile core erlang file run test runtestssh self contained release see release page download extract zip operating system run fez help see available command option compile fez compile file module run used erlang shell release ship set beam file need included eg erl pa pathtofez ebin work fsharp multiparadigmatic language fez targeting solely functional language core erlang given impedence mismatch reasonable expect fez adequately cover functional language construct fsharp said aspect imperative object oriented paradigm covered certain extent uptodate resource language construct covered look basicsfs fairly unstructured list list feature implemented one following degree complete feature reasonably complete unsupported apis construct either generate appropriate compiletime runtime error strange behaviour need reported partial feature tried proven viable yet fully implemented prototype feature present limited degree likely unexpected unusual constraint feature may kept unstarted feature started investigated feasibilty functional module complete fsharp module compiled erlang module nested module compiled indiviual erlang module fullyqualified name function complete private function included erlang export statement function application currying inner function lambda supported operator partial common operator snd fst implemented completion please report omission pattern matching control flow complete pattern matching including guard supported else expression listseq comprehension partial list seq comprehension supported nt verified completeness list complete list api complete apart function including array seq partial set partial option partial result complete map partial string complete array unstarted tuples complete record complete discriminated union complete active pattern partial limited testing please report issue tryfinallywith partial primitive type partial currently integer translated erlang integer float type erlang float erlang integer big ints hence thing like overflow bitshifting probably wont work expected sprintf printfn partial query expression prototype work seq async partial asyncstart asyncstartchild execute computation separate process rest mostly erased io already nonblocking erlang computation expression partial limited testing object programming member method record discriminated union complete nb type based method overload work static member record discriminated union complete extension method complete interface implementation record union complete use expression complete constructor prototype inheritance prototype imperative erlang interop ffi partial modcall attribute used generate function stub delegate configured erlang function erlangterms partial erlangterm attribute used decorate discriminated union erlang compatible encoding generated instead standard du representation case without field lowercased generated atom case field generated tuples help try right need people try stuff find construct break nt behave expected especially functional code find something sure please raise issue including smallest possible repro code code also welcome course especially standard library erlang module
232,Lobsters,erlang,Erlang development,SpawnFest is Back!,http://spawnfest.github.io,spawnfest back,,tweet spawnfest status event
233,Lobsters,erlang,Erlang development,Concurrency vs Parallelism and the Erlang Advantage,http://nathanmlong.com/2017/06/concurrency-vs-paralellism/,concurrency v parallelism erlang advantage,burrito shop burrito strategy serial burrito strategy concurrent two burrito partial state completion moment burrito strategy parallel two burrito actively worked back computer two way scheduling cooperative multitasking preemptive multitasking make whole system hang erlang advantage beam book caveat starting talk solid ground,concurrency parallelism term get used lot development discussion especially elixir erlang circle mean let talk using burrito burrito shop suppose work burrito shop two customer come order burrito get work done burrito strategy serial work serially get one tortilla fill yummy stuff close get next tortilla neither concurrent parallel burrito strategy concurrent work concurrently get one tortilla spread get another tortilla spread making two burrito concurrently two burrito partial state completion moment switch burrito bit work first second first second however one set hand actively working one burrito given moment nt increase amount work per second may increase number productive second get instance suppose ca nt finish first burrito coworker make guacamole concurrent strategy allowed put aside minute work second burrito without concurrency stand staring awkwardly customer guacamole ready burrito strategy parallel work parallel get coworker help spread tortilla filling first one coworker would filling second took photo moment notice two burrito partial state completion work concurrent also two burrito actively worked moment mean work done parallel actually getting burritomaking done per second notice scenario ability work concurrently precondition parallel example nt enough counter space two burrito coworker ca nt work time nt coworker counter space world wo nt turn concurrency parallelism back computer computer operating system generally supported concurrency long got true parallelism one cpu could still running multiple program one appeared running simultaneously truth computer switching task quickly individual burst work seemed slow human eye blur one continuous activity like page flip book later got multiple cpu per machine computer could actually multiple task time cpu task still switching task create illusion switching task called scheduling computer decide task work given moment done important two way scheduling one way scheduling done one way called cooperative multitasking mean task must polite say finished someone else turn nice designing single process know never interrupted unexpectedly cooperative scheduling also mean greedy slow hung process bring whole system halt everyone waiting process hand control never preemptive multitasking mean scheduler involved scheduler say essentially process take turn turn n microsecond long finish work much time great force pause give someone else cpu get back line continue turn introduces overhead every time process pause little time wasted term raw speed cooperative multitasking better waste le time switching task preemptive multitasking make overall system performance predictable since one big buggy task ca nt delay smaller task much nt want one inefficientlywritten program one unexpectedly large task make whole system hang reason nearly operating system today use preemptive multitasking erlang advantage erlang vm known beam erlang elixir code run sometimes called operating system code like system o allows parallel execution us preemptive multitasking basically see beam book caveat contrast example nodejs singlethreaded us cooperative multitasking nodejs juggle io task efficiently single slow computation could bring work halt beam loses bit raw speed switching task much payoff performs consistently example suppose phoenix application people upload data processing respond processed data suppose parse large xml api response order respond phoenix fronted cowboy every incoming request get beam process request small occasionally get expensive request problem incoming request wo nt affected heavy process keep getting paused give one turn true whether heavy process waiting io performing long computation multiple core beam use get work done parallel core outweighs raw speed course web service heavy computation background respond asynchronously using beam option requirement wo nt kill site synchronously make decision based user experience uptime want know bryan hunter talk every nodejs developer need know elixir nice explanation concurrency parallelism beam scheduler starting update talk solid ground published since wrote article talk beam concurrency model basis predictable performance reliability nice quote runtime foundation ground ground solid move top lot confidence steady reasonable pace start building system confidently watch grow way beyond original plan imagination ask language syntax library framework first foremost ask runtime
234,Lobsters,erlang,Erlang development,Erlang Behaviors… and how to behave around them (2/2),https://medium.com/erlang-battleground/erlang-behaviors-d5bb30d5412b,erlang behave around,tip defining behavior disclaimer introduction heuristic definition usage together callback module type callback export spec callback spec callback callback callback type type type callback spec testing sumodb test helper optional callback huge fan callback module loaded using existing behavior otp,tip defining behaviorsdisclaimer introductionsame last time following tip heuristic rule exception situation much convenient bend break guideline better accommodate definition usage togetheras general rule behavior defined ie callback attribute written generic modulethere analogous limitation fact callback implemented one module callback defined one module well mixer library help never needed one anyway principle generic module one know callbacksalso remember callback used point dynamic call evaluated something like module thecallback param dynamic call time writing article impossible analyze tool like dialyzer xref elvis rule warn use dynamic call module define behaviorsif really need define behavior sure type provide similar interface afraid add function like one generic module module figure type module module callback area float export spec area float area figure module module module area figure see function middleman goal allow module evaluate figure area figure created callback module implement figure behavior alternative would force caller figure callback module evaluate dynamic call callback specsput lot effort proper callback spec easier deduction clearly know type need acceptprovide even important induction since specially case act documentation also allow dialyzer correctly typecheck callback modulesthe following callback provides documentation almost type specification dialyzer callback init term ok term stop term add documentation like callback init args term ok state term stop reason term genserver defines callback personally prefer bit type initarg term type callbackstate term type reason term callback init initarg ok callbackstate error reason way later need use type callback generally case precisely indicate fact type another term practice also added benefit callback module spec look like spec init genmod initarg ok genmod callbackstate error genmod reason way dialyzer check type exist ever change definition eg may want use map argument need change one location genmod need change every callback module testinggoing back said previous article general generic module work counterpart ie callback module generic module useful test generic module need create least one implementation behavior test black box mode clearly easier deducting since already test module refactoringit complex induction scenario might want generate fake callback module even one use test also provide default implementation behavior test one particularly useful writing library check sumodb instance library provides multiple behavior extend different layer architecture ie repository store backend etc also come implementation one based mnesia way developer may clearer reference supposed implement adapter information go beyond callback spec providenot sumodb also provides test helper developer use ensure compliance test coverage module without need copy paste existing test used mnesia optional callbackserlangotp introduced optional callback follow blog know huge fan tell used extreme cautionif mark callback optional need make sure generic module work well callback module export said callback mean default fake module one using test implement callback need use another fake callback module without function test generic module toojust case need remember use erlang find callback implemented callback module loaded using release application module automatically loaded startup great writing library sure user use release run erlang system using existing behaviorsfinally remember need start scratch every time module callback module behavior define another existing behavior take half way build new behavior top like otp
235,Lobsters,erlang,Erlang development,Erlang Behaviors… and how to behave around them,https://medium.com/erlang-battleground/erlang-behaviors-4348e89351ff,erlang behave around,using behavior disclaimer introduction heuristic encapsulation server rest api handler black box testing caveat optional callback dialyzer callback katana test opaque state mixer mixer kevin smith juan facorro inakaesi caveat,using behaviorsthis article focus using already existing behavior leave tip creating behavior next onedisclaimer introductionas usual kind list following one heuristic rule exception situation much convenient bend break guideline better accommodate encapsulationas said general using behavior building thing composed behavior callback implement genserver callback building server implement cowboyrest callback building rest api handler etc fact implement using generic module implementation decision usually best hide user providing api callback module instead relying others using generic one directlynotice outside module nobody need know implemented using genserver module want use relay kv kv kv eventually need start using genstatem instead genserver simply change internals module move forward black box testingfollowing line thought previous paragraph usage behavior seen implementation detail considering test test implementation functionality keeping mind followed previous rule already provided nice api write test apiin word even exported module write test evaluate directly contrary would much convenient write test start server use api let genserver invoke functiona basic common test suiteas see nowhere test directly testing callback test indirectly module interfacethe reason behind guideline one previous one assert anything module implemented focus behave free change implementation test let know affected functionality notcaveat general longer case thanks optional callback used quite difficult follow guideline wanted ensure test coverage code certain callback may still almost never evaluated hard trigger case need end writing white box testing coverage advocate tend put test one ensure coverage coveragesuite test dialyzersince introduction callback attribute dialyzer able verify properly implementing behavior want implement great tool use day project even add directly test suite using katana opaque statebehaviors particularly used process tend sort state context passed function state kept hidden rest world implementation detail strictly tied behavior choose implementrecords great ensure since bound module defines since achieve similar effect using well typed map case convenient define nonexported type state add proper spec exported functionsnotice added type spec function subtypes behavior defines exported used api function ie anybody try use type outside kv dialyzer properly warn u mixerthere one limitation imposed genericcallback module implementation callback written single module mean callback function shared several callback module workaround use mixer opensource library created kevin smith working chef later improved juan facorro working inakaesi let mix function moduleslet say want implement handling unexpected message way server write code baseserver mix function server et voilàcaveat example assuming baseserver ignores second parameter need use type defined kv following tip list might need relax rule bit sometimes share part state type among module map really handy need make sure type module mix function generic one use type subtypes one used one example spec baseserver case see kv subtype baseserver dialyzer certainly able figure even use parameterized type matter another blog post
236,Lobsters,erlang,Erlang development,When is an Erlang iolist an iovec?,http://www.cipht.net/2017/01/15/when-is-an-iolist-an-iovec.html,erlang iolist iovec,,beginning iolistveclen ertsemulatorbeamioc return successful nonzero value otherwise return value pointer vsize sysiovec size needed writev csize number byte binary common binary pvsize sysiovec size needed packing small binary pcsize number byte common binary packing totalsize total size iolist byte static int iolistveclen eterm obj int vsize uint csize uint pvsize uint pcsize erldrvsizet totalsize called ertsportoutput common binary get allocated based csize returned thought experiment want avoid allocating common binary would like make sure vsize minimized efficiently pack iovec without allocation copying note figure packed unpacked size basically unpacked vsize small enough wo nt pack since mean le work see worth noting copying thing common binary although cause allocation much faster forcing o work long iovec iolistveclen continues declareestack eterm objp uint vsize uint csize uint bsize uint inclist uint pvsize uint pcsize uint pinclist uint total uint due halfword emulator ertsemulatorbeamglobalh say declareestack implementation lightweiht stack sic basically lay little array term initially stack item migrated heap stack grows much reading ert allocator code easy way spend lot time pretty convoluted figuring exactly allocator end nonobvious one first encounter code goto ljumpstart avoid push estackisempty obj estackpop ljumpstart begin jumping loop note throughout code careful use goto avoid unnecessary churn stack islist obj literlist objp listval obj obj car objp obj con cell inspect head isbyte obj csize csize goto loverflowerror inclist inclist vsize pcsize pinclist pinclist pvsize byte specifically fixnum add size common binary required nt already section point common binary add size underlying iovec note behavior packed unpacked first rule probably going avoid interspersing binary string keep vsize lower else isbinary obj iolistveccount obj back loop still handling element list got binary instead invoke iolistveccount monster macro file let take look piece define iolistveccount obj uint size binarysize obj eterm real ertsdeclaredummy uint offset int bitoffs int bitsize ertsgetrealbin obj real offset bitoffs bitsize bitsize goto ltypeerror start getting bunch property binary erroring bitstring erlang bitstring binary number bit nt multiple note nt error binary nonoctet bit offset thingsubtag binaryval real refcbinarysubtag bitoffs bsize size bsize size goto loverflowerror inclist vsize bytealigned refcounted binary could put reference right iovec main answer blog post question iovlen smaller uint split binary multiple smaller element iolist vsize size maxsysioveciovlen commit code added note window max size iov element long ie order write larger binary file split binary smaller chunk write possible bet inspired fun bug size erlsmalliobinlimit pinclist pvsize else pcsize size pinclist pinclist pvsize code applies packed count erlsmalliobinlimit erlonheapbinlimit binary le byte need pack copy common binary instead referencing directly else csize size csize size goto loverflowerror inclist inclist vsize pcsize size pinclist pinclist pvsize otherwise heap binary always copy common binary back iolistveclen else islist obj estackpush cdr objp goto literlist head got list push stack deal later else isnil obj goto ltypeerror finally anything else nt empty list error obj cdr objp islist obj goto literlist tail else isbinary obj binary tail ok iolistveccount obj else isnil obj goto ltypeerror handle tail list interesting iolist nt need proper list list bin conclusion far would seem erlang iolist map closely iovec arbitrarily nested list refcounted binary must least byte long since stack processing list change allocation strategy around item deep practice probably nt want iolists deeply nested let look iolisttovec static int iolisttovec eterm obj iolist sysiovec iov io vector erldrvbinary binv binary reference vector erldrvbinary cbin binary store character erldrvsizet binlimit small binary limit comment pretty clear obj input iov output whether pack expressed binlimit look rest code see argument used function begin declaration declareestack eterm objp char buf cbin origbytes uint len cbin origsize uint csize int vlen char cptr buf note setup buf len cptr according cbin use become clear go continue jump body loop goto ljumpstart avoid push estackisempty obj estackpop ljumpstart see structure function mirror iolistveclen islist obj literlist objp listval obj obj car objp term con look car isbyte obj len goto loverflow buf unsignedval obj csize len byte store byte buffer passed cbin else isbinary obj estackpush cdr objp goto handlebinary binary push tail list working onto stack pick later jump handlebinary else islist obj estackpush cdr objp goto literlist head else isnil obj goto ltypeerror list save current position outer list stack start walking inner list obj cdr objp islist obj goto literlist tail else isbinary obj goto handlebinary else isnil obj goto ltypeerror cdr con handled unsurprising else isbinary obj eterm realbin uint offset eterm bptr erldrvsizet size int bitoffs int bitsize handlebinary size binarysize obj ertsgetrealbin obj realbin offset bitoffs bitsize assert bitsize binary handling case nt different iolistveccount die immediately bitstring bptr binaryval realbin bptr headerprocbin procbin pb procbin bptr bitoffs len size goto loverflow ertscopybits pb bytesoffset bitoffs byte buf size csize size buf size len size interesting bit offset handled even though extra bit nt permitted git history associated block helpful else binlimit size binlimit len size goto loverflow sysmemcpy buf pb bytesoffset size csize size buf size len size packing small binary one limit copy else csize iolisttovecsetvec iov binv cbin cptr csize vlen cptr buf csize pb flag ertsemasculatewritablebinary pb iolisttovecsetvec iov binv pb val pb bytesoffset size vlen otherwise make direct translation iovec entry need emit reference part common binary first note curiouslynamed ertsemasculatewritablebinary seems shrinkwrap binary reallocate trim unused space else erlheapbin hb erlheapbin bptr len size goto loverflow copybinarytobuffer buf byte hb data offset bitoffs size csize size buf size len size else isnil obj goto ltypeerror heap binary much le interesting append common binary csize iolisttovecsetvec iov binv cbin cptr csize vlen reference tail common binary anything left finally come end function destroyestack return vlen ltypeerror destroyestack return loverflow destroyestack return much see might well include looked every part nt complete without noting pair function called function like ertsportoutput wo nt get gut look file see iovec smallwritevec setup stack iolistveclen report vsize larger allocate space using ertsalcttmp allocator even csize zero binary get allocated anyway driverallocbinary return valid allocation seems like waste guess make subsequent logic simpler
237,Lobsters,erlang,Erlang development,"Cowboy 2.0: HTTP/2, Websocket compression, better interface and manual",https://ninenines.eu/articles/cowboy-2.0.0/,cowboy websocket compression better interface manual,much detailed manual migrating cowboy ticket github sponsor,cowboy released new stable version cowboy new release planned version cowboy highlight release support websocket compression much simpler cleaner interface weird error discard req object new lowlevel interface receives event every set request response replaces awkward hook much detailed manual complete list change found migration guide migrating cowboy two planned feature release feature temporarily removed added back new feature added allow user support grpc protocol full detail ticket feeling good release send money onetime monthly via github sponsor thanks advance usual feedback appreciated issue reported opening ticket thanks
238,Lobsters,erlang,Erlang development,Post-Basho: the NHS is directly investing in a number of improvements to the Riak database,https://www.youtube.com/watch?v=WFghXj5Bus8,postbasho nh directly investing number improvement riak database,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature riak planned enhancement nh riak webinar nh england youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature riak planned enhancement nh riak webinar nh england youtube
239,Lobsters,erlang,Erlang development,Thread Progress,https://github.com/erlang/otp/blob/master/erts/emulator/internal_doc/ThreadProgress.md,thread progress,thread progress problem knowing thread completed access data structure knowing modification memory consistently observed functionality used address problem thread progress event implementation thread progress functionality requirement implementation api implementation delay thread progress unmanaged thread overhead,thread progress problem knowing thread completed access data structure multiple thread access data structure often need know thread completed access example order know safe deallocate data structure one simple way accomplish reference count access data structure problem approach cache line reference counter located need communicated involved processor communication become extremely expensive scale poorly reference counter frequently accessed want use approach keeping track thread reference counting knowing modification memory consistently observed different hardware architecture different memory model architecture allows aggressive reordering memory access architecture reorder specific case common modern hardware however type reordering occur using lock protect memory access made multiple thread reordering visible locking primitive ensure memory access ordered using lock free algorithm one however take reordering made hardware account hardware memory barrier memory fence instruction used enforce order memory access different hardware architecture provide different memory barrier lock free algorithm need use memory barrier order ensure memory access reordered way algorithm break memory barrier also expensive instruction typically want minimize use instruction functionality used address problem thread progress functionality erlang vm used address problem name thread progress chosen since want use determine thread set thread made progress two specific event taken place set thread interested call managed thread managed thread thread get information thread frequently report progress thread system able frequently report progress thread allowed set managed thread called unmanaged thread example unmanaged thread thread async thread pool async thread blocked long time prevented frequently reporting progress currently scheduler thread couple thread managed thread thread progress event thread system may use thread progress functionality order determine following event occurred least managed thread thread returned code known state thread progress functionality independent code thread executed full memory barrier event course need occur ordered memory operation operation determining begin initiating thread progress operation thread initiated thread progress operation poll completion operation event must occur least thread progress operation initiated least operation completed managed thread ordered using communication via memory make possible draw conclusion memory state thread progress operation completed let call progress made initiation comletion thread progress assuming thread progress functionality efficient lot algorithm simplified made efficient using first approach come mind couple example follows able determine first event occurred easily know managed thread completed access data structure determined following way implementation functionality f using data structure reference always looked accessed reference always dropped leave code implementing f remove possibility look wait first event occurred managed thread managed thread reference data structure could example achieved using reference counting cache line containing reference counter would case ping ponged processor accessing every access able determine second event occurred quite easy complex modification memory need seen consistently thread without resort locking modification issuing full memory barrier wait second event occurred managed thread publish modification know managed thread reading memory get consistent view modification managed thread reading issue extra memory barrier implementation thread progress functionality requirement implementation order able determine managed thread reached state interested need communicate involved thread course want minimize communication also want thread able determine thread progress made relatively fast need balance comunication overhead time complete operation api present important function api ertsthrprgrval ertsthrprogresslater void initiation operation thread progress value returned used testing completion operation int ertsthrprogresshasreached ertsthrprgrval val return non zero value reached thread progress value passed argument non zero value returned operation completed thread call myval ertsthrprogresslater wait ertsthrprogresshasreached myval return non zero value know thread progress made waiting ertsthrprogresshasreached return non zero value typically want block waiting instead want continue working stuff run stuff work typically want block waiting reached thread progress value waiting order able provide functionality waking thread certain thread progress value reached void ertsthrprogresswakeup ertsschedulerdata esdp ertsthrprgrval val request wake calling thread woken thread progress reached val managed thread frequently need update thread progress calling following function int ertsthrprogressupdate ertsschedulerdata esdp update thread progress non zero value returned ertsthrprogressleaderupdate called without lock held int ertsthrprogressleaderupdate ertsschedulerdata esdp leader update thread progress unmanaged thread delay thread progress made ertsthrprgrdelayhandle ertsthrprogressunmanageddelay void delay thread progress void ertsthrprogressunmanagedcontinue ertsthrprgrdelayhandle handle let thread progress continue scheduler thread schedule operation executed scheduler thread progress made void ertsschedulethrprgrlaterop void funcp void void argp ertsthrprgrlaterop memp schedule call funcp call funcp argp executed thread progress made since call ertsschedulethrprgrlaterop made implementation order determine event happened use global counter incremented managed thread called ertsthrprogressupdate ertsthrprogressleaderupdate could naively implemented using thread confirmed counter would however cause explosion communication involved processor would need communicate update instead confirming global location thread confirms accepts increment global counter cache line confirmation cache line located sequence array confirmation cache line written one one thread one managed thread always leader responsibility responsibility may jump thread long activity system always one leader responsibility thread leader responsibility call ertsthrprogressleaderupdate check thread confirmed increment global counter increment global counter leader thread thread reading confirmation cache line way get communication pattern information going leader thread managed thread back thread leader thread since leader thread write global counter thread read since confirmation cache line written one specific thread read leader thread managed thread distributed different processor communication processor reflection communication pattern thread value returned ertsthrprogresslater equal thread latest confirmed value plus two global value may latest confirmed value latest confirmed value minus one order certain managed thread actually call ertsthrprogressupdate least reach value returned ertsthrprogresslater global counter plus one enough since thread may already confirmed current global value plus one time call ertsthrprogresslater however guaranteed confirmed global value plus two time described implementation le minimizes comunication needed increment global counter amount communication system due thread progress functionality however also depend frequency managed thread call ertsthrprogressupdate today scheduler thread call ertsthrprogressupdate le time erlang process scheduled one way reducing communication due thread progress functionality call ertsthrprogressupdate every second third time erlang process scheduled even le frequently however update thread progress le frequently operation depending thread progress functionality also take longer time delay thread progress unmanaged thread order implement delay thread progress unmanaged thread use two reference counter one current one waiting unmanaged thread want delay thread progress increment current get handle back reference counter incremented later want enable continuation thread progress us handle decrement reference counter previously incremented leader thread increment global thread progress counter verifies waiting counter zero zero leader nt allowed increment global counter need wait zero swap waiting current counter increasing global counter new waiting counter decrease eventually reach zero making possible increment global counter next time used one reference counter would potentially held zero ever different unmanaged thread unmanaged thread increment current counter prevent next increment global counter instead increment sufficient since global counter need incremented two time thread progress made also desirable prevent first increment since likelihood increase delay withdrawn increment global counter delayed operation cause little disruption possible however feature delaying thread progress unmanaged thread preferably used little possible since heavy use cause contention reference counter cache line functionality however useful code normally executes managed thread may infrequent circumstance executed thread overhead overhead caused thread progress functionality le fixed using amount scheduler regardless number us functionality already today quite lot functionality use plan use even rewriting old implementation ert internal functionality use thread progress functionality implies removing communication old implementation otherwise simply point rewriting old implementation use thread progress functionality since thread progress overhead le fixed rewrite cause reduction total communication system example main structure ets table originally managed using reference counting already long time ago replaced strategy since reference counter caused contention access table solution used schedule confirm deletion job scheduler order know safe deallocate table structure removed table confirm deletion job needed allocated allocate deallocate many block scheduler order deallocate one block course quite expensive operation needed removing table important get rid contention reference counter present every operation table thread progress functionality introduced could remove code implementing confirm deletion job schedule thread progress later operation deallocates structure besides simplifying code lot got increase number transaction per second handled mnesia tpcb benchmark executing quad core machine
240,Lobsters,erlang,Erlang development,Call Me… Maybe? – Erlang Battleground,https://medium.com/erlang-battleground/call-me-maybe-28671e6b92f4,call maybe erlang battleground,going documentation part supervision tree following condition apply set trap exit signal bold trapping exit server starting server terminating reason shutdown unstoppable exception warning note message evaluated server starting,going stated intro time documentation pretty clear happening genserver process part supervision tree ordered supervisor terminate function called reasonshutdown following condition apply genserverprocess set trap exit shutdown strategy defined child specification supervisor integer timeout value brutalkillnotice marked bold server supervision tree evaluated need trapping exitslet try added processflag trapexit true recompile startstop supervisor console maybesup start info report server starting ok maybesup stop okinfo report server terminating reason question need trap exit evaluated answer question bit related happened old friend unstoppable exception exit signal travel faster function evaluation supervisor dy mechanism us terminate child based good old exit signal dying supervisor us send exit signal kill brutalkill strategy childrenwhen process trapping exit signal genservers default soon receive one reason normal die ie way process evaluate function gone good way allow genserver evaluate trap exit signal let deal appropriatelya warning notebut careful process trapping exit signal converted message added process message queue mean following genserver logic message read message processed word server terminate instantaneously supervisor shutdown timeout defined server smaller take server process message one corresponds exit signal brutally killed therefore evaluatedwant see notice added long running function get server busy longer defaultshutdown supervisor using let see maybesup start ok info report server maybeserver sleep dbg maybeserver got cast maybesup stop isprocessalive worth implementing optional callback think let know comment
241,Lobsters,erlang,Erlang development,Multi-Paxos with riak_ensemble Part 2,http://marianoguerra.org/posts/multi-paxos-with-riak_ensemble-part-2/,multipaxos riakensemble part,configuring dev release add dependency configure relx section varsconfig sysconfig vmargs configure prod dev cluster release building prod release profile prod profile building dev cluster release joining cluster together multipaxos riakensemble part cadenaconsole module multipaxos riakensemble part cadenasup cadenaappsrc,post assumes erlang installed using erlang configuring dev release following step check link comment going step add dependency configure relx section add overlay variable file varsconfig add sysconfig add vmargs build release test everything setup correctly release run release interactively console builddefaultrelcadenabincadena console output edited path redacted clarity exec erlexec boot bootvar ertslibdir lib mode embedded config argsfile vmargs console root builddefaultrelcadena erlangotp source kernelpoll true info application lager started node cadena info application cadena started node cadena eshell abort g cadena quit cadena q ok non interactive start builddefaultrelcadenabincadena start output generated started check running pinging application builddefaultrelcadenabincadena ping get pong want attach console running system builddefaultrelcadenabincadena attach output attaching tmperlpipescadena exit cadena press ctrld dettach console without stopping system cadena quit stop system whenever want issuing stop command builddefaultrelcadenabincadena stop output ok note use ctrld exit write q dettach console also stop system let try non interactive start builddefaultrelcadenabincadena start output generated started check running pinging application builddefaultrelcadenabincadena ping get pong want attach console running system builddefaultrelcadenabincadena attach output attaching tmperlpipescadena exit cadena let quit q cadena q output ok let see alive builddefaultrelcadenabincadena ping node cadena responding ping careful quit attached console production system configure prod dev cluster release building prod release start adding new section rebarconfig called profile define profile override default release config specific value let start trying prod profile use create production release project prod release output verifying dependency compiling cadena running cuttlefish schema generator starting relx build process resolving otp application directory buildprodlib resolved including ert release successfully created notice new folder build directory l build output default prod result command run prod stored prod folder notice explore prodrelcadena folder folder called version may differ using different erlang version folder includeerts option overrided prod profile mean zip buildprodrelcadena folder upload server nt erlang installed still run release good way sure version running production use development build time build server careful deploying operating system different one used create release becase may problem binding like libc openssl running done usual path change buildprodrelcadenabincadena console buildprodrelcadenabincadena start buildprodrelcadenabincadena ping buildprodrelcadenabincadena attach buildprodrelcadenabincadena stop building dev cluster release build cluster need least node last profile need different node name use overlay var file override name achieved let build release release release output similar one prod release three different shell start node console check name node shell different shell console console get respectively case nt remember quit q joining cluster together built release code slight modification allow running cluster one computer node running nt mean cluster need use learned multipaxos riakensemble part code interactively create cadenaconsole module use make call outside trigger action node code similar one presented multipaxos riakensemble part join nodestr node name come list string need atom node listtoatom nodestr check node exists alive case netadm ping node return error pang error notreachable reply let join passing node reference pong riakensemblemanager join node node end create enable riakensemblemanager riakensemblemanager enable wait stabilizes waitstable clusterstatus case riakensemblemanager enabled false error notenabled true node list sort riakensemblemanager cluster io format node cluster pn node leadernode node riakensemblemanager getleaderpid root io format leader pn leadernode end also need add riakensemble supervisor supervisor tree cadenasup init get configuration sysconfig dataroot application getenv riakensemble dataroot data create unique path node avoid clash running one node computer nodedatadir filename join dataroot atomtolist node ensemble riakensemblesup riakensemblesup startlink nodedatadir permanent supervisor riakensemblesup ok oneforall ensemble building dev cluster need add crypto app cadenaappsrc since needed riakensemble create cluster let build dev cluster created makefile make simpler make devrel three different shell run one command make make make let make rpc call enable riakensemble cluster rpc cadenaconsole create see something like info root leading let join rpc cadenaconsole join see info join vsn info join success finally let join rpc cadenaconsole join output info join vsn info join success let check node view cluster let ask ensemble status rpc cadenaconsole ensemblestatus node cluster leader rpc cadenaconsole ensemblestatus node cluster leader rpc cadenaconsole ensemblestatus node cluster leader everything look right stop node q start see starting log info root leading call ensemblestatus node get output mean remember cluster topology even restarts
242,Lobsters,erlang,Erlang development,Investigating Erlang by reading its system calls,https://jvns.ca/blog/2016/05/13/erlang-seems-really-complicated/,investigating erlang reading system call,networking puzzle full strace output time put system call frequency gist kind operating system,helping debug performance problem networking puzzle erlang program yesterday learned erlang complicated learn maybe thing looking system call running never written erlang program really know anything erlang erlang seems complicated meant criticism much observation something really understand debugging program whether know programming language written often use strace see system call run experiment far erlang virtual machine run ton system call sure exactly experimental result write program helloc hello java helloerl hellopy include stdioh int main printf hello n class hello public static void main string args systemoutprintln hello module hello export helloworld io fwrite hello world n print hello number system call program made see full strace output generate instance strace f pythonstrace python hellopy wc l strace cstrace pythonstrace javastrace erlangstrace unsurprisingly c come least surprised erlang vm run time many system call java think java already pretty heavyweight maybe erlang start process core variety system call also interesting see put system call frequency gist look system call frequency see erlang running significantly different kind system call java python c language mostly open read lseek stat mmap mprotect fstat activity around reading bunch file allocating memory think normal behavior starting program top syscalls erlang process futex schedyield lot synchronization happening futex operating system thread erlang start keep scheduling cpu ok done go also lot mysterioustome ppoll system call erlang seems like programming language really significantly different primitive highly concurrent behavior consistent wikipedia article say erlang main strength support concurrency small powerful set primitive create process communicate among let look little carefully ppoll system call second story start openat atfdcwd ordonlyononblockodirectoryocloexec ppoll eventspollinpollrdnorm eventspollinpollrdnorm null timeout idea seems directory ppoll looking change really get one last thing erlang run bind start need listen tcp socket run hello world confused unable figure people twitter thought might something epmd epmd seems separate process know going operating system wanted write well know think interesting take operating systemslevel approach understanding program thought cool example interesting experience yesterday looking erlang problem victor david o x machine like dude debug anything o x got working laptop could make lot progress pretty good oslevel debugging tool spent lot time learning linux super comfortable nonlinux system know know dtrace amazing going learn one day soon promise
243,Lobsters,erlang,Erlang development,Erlang in Anger Ebook,https://www.erlang-in-anger.com/,erlang anger ebook,author fred hebert learn erlang great good,stuff go bad erlang anger book intends little guide erlang medic time war first foremost collection tip trick help understand failure come dictionary different code snippet practice helped developer debug production system built erlang download pdf author fred hebert author learn erlang great good free online also paid paper book designed teach erlang worked principal member technical staff heroku routing component helping design program maintain operate large scale distributed system cloud often written erlang
244,Lobsters,erlang,Erlang development,Get to know the Actor Model with JavaScript,https://monades.roperzh.com/get-to-know-the-actor-model/,get know actor model javascript,implementation erlang elixir akka internal state asynchronous message unique address behavior event loop event system messaging system performant roperzh email subscribe,actor model proposed carl hewitt conceptual model deal concurrent computation good amount implementation wild complete programming language library framework popular one erlangelixir akka every implementation particularity foundational concept remain post building javascript library implement actor model implementation mentioned robust purpose post explore foundation model think possible use case actor model actor foundation build structure application internal state invisible outer world interacts actor asynchronous message sound lot like objectoriented programming oop right actor model thought oop special treatment message delivered asynchronously executed synchronously receiver every actor identified unique address send message message processed matched current behavior actor nothing function defines action taken reaction message response message actor may create actor send message actor designate internal state handle next message base concept mind may good idea take peek library used import actor actormodel define behavior handle message const counter define initial state actor init return count define method invoked response message incrementby state number let count statecount number return count logtotal state consolelog statecount initialize actor counter behavior const address actorstart counter log initial state actorsend address logtotal count increment counter actorsend address incrementby number log current state actorsend address logtotal count previously mentioned message sent asynchronously arrive destination queued processed synchronously mechanism thought fifo first first queue turn javascript event loop work library take advantage making event loop chore messaging system post us nodejs event system api le verbose web apis refresher gist code show event work import eventemitter event const mailbox new eventemitter binding listener custom event mailboxon channelname message consolelog message firing custom event second argument sent callback function mailboxemit channelname hello eo wilson famously said one ant ant right well one actor actor come system carl hewitt first thing define start function function charge creating new actor returning address actor send message generate unique address library take advantage symbol function return unique value every time invoked first implementation start return address const actor start return symbol const address actorstart consolelog address symbol behind scene messaging system handled event loop library still need provide clear way send message specific actor address convenient method use actor address symbol primitive event name const mailbox new eventemitter const actor start const address symbol use address event name mailboxon address function return address actor equipped receive message system lack standard way send message send function come play function receives actor address message emits event using event api const actor send target message mailboxemit target message message come actor want designate internal state handle next upcoming message possible way take advantage closure define initial state start called update message come callback function const actor start const address symbol define initial state let state mailboxon address function message something based message update state assuming newstate defined somewhere function state newstate return address base system place last step provide ability define custom behavior handle message actor model behavior library behavior object expose method convenience sake behavior must follow certain rule set initial state behavior must implement function called init return initial state define state following message handled method invoked must return value used next state actor sends message another actor must provide tuple containing name method need executed optional data invoked every method behavior receives state param represents current state optional second parameter containing data term code translates const actor start behavior const address symbol set initial state behavior defines init function invoke otherwhise set state empty object let state typeof behaviorinit function behaviorinit desconstruct data provided caller mailboxon address function method message call required method behavior method return value use define next state state behavior method state message state return address first final version library look like import eventemitter event const mailbox new eventemitter const actor start behavior const address symbol let state typeof behaviorinit function behaviorinit mailboxon address function method message state behavior method state message state return address send target message mailboxemit target message export default actor provides basic functionality required play actor model suggest anybody build real application hopefully work good intro model work nothing perfect among many potential issue implementation like highlight actor system may contain potentially infinite amount actor therefore must lightweight possible knowing closure seem performant way keep state easy screw immutability javascript actor internal state modified externally user library extremely careful post always feel free reach questionscritiqueconcerns roperzh twitter email always open subscribe try post week interesting stuff programming nix web like notified new post go subscribe form
246,Lobsters,erlang,Erlang development,Introducing Talla: An Erlang implementation of Tor,https://media.ccc.de/v/SHA2017-304-introducing_talla_an_erlang_implementation_of_tor,introducing talla erlang implementation tor,,
247,Lobsters,erlang,Erlang development,Clojerl - Clojure implemented on the Erlang VM,https://github.com/jfacorro/clojerl/blob/master/README.md,clojerl clojure implemented erlang vm,clojerl building getting started documentation resource clojerlorg feature differs clojure online repl try clojerl docker repl local repl code example scriptsexamples web application example examplewebapp building app rationale goal personal goal qas clojerl heard lfe joxa nt language construct concurrency different clojure erlang rich hickey list reason chose use actor model clojure clojerl support every single clojure feature reuse existing clojure script library discussion clojerl slack channel clojerl jfacorro clojure erlang,clojerl clojure implemented erlang vm building building clojerl requires erlangotp git clone http githubcomclojerlclojerl cd clojerl make window git clone http githubcomclojerlclojerl cd clojerl clojerl compile getting started documentation resource information regarding clojerl clojerlorg find feature clojerl include differs clojure online repl try get sense visit try clojerl docker repl quickly try clojerl via docker make use docker image like docker pull clojerlclojerl docker run clojerlclojerl able see prompt clojure cljeuser local repl running make repl window first run clojerl compile bincljebat start repl show prompt clojure cljeuser repl possible start evaluating clojure expression cljeuser map inc range cljeuser doc map clojurecoremap f f coll f f f colls return lazy sequence consisting result applying f set first item coll followed applying f set second item coll one colls exhausted remaining item colls ignored function f accept numberofcolls argument return transducer collection provided nil cljeuser doc inc clojurecoreinc x return number one greater num nil cljeuser code example basic example scriptsexamples directory meant reference special form clojure beam used sometimes differ clojure jvm web application example basic example web project please check examplewebapp repository building app build tool clojerl plugin official build tool erlang community plugin provides helpful command build basic directory scaffolding new project compile run test start repl information use plugin please check documentation rationale erlang great language building safe reliable scalable system provides immutable persistent data structure box concurrency semantics unequalled language clojure lisp come goody lisp provide apart clojure also introduces powerful abstraction protocol multimethods seqs name clojure built simplify development concurrent program concurrency abstraction could adapted erlang fair say combining power erlang vm expressiveness clojure could provide interesting useful result make life many programmer simpler make world happier place goal interoperability smooth possible like clojure proper clojurescript provide clojure abstraction provide erlang abstraction toolset include default otp library clojerl personal goal learn erlang vm clojure language implementation project experiment hope others find useful regardless whether becomes fully functional implementation clojure learned lot along way qas clojerl clojerl experimental implementation clojure erlang vm goal leverage feature abstraction clojure love macro collection seq protocol multimethods metadata etc robustness erlang vm provides building distributed system heard lfe joxa yes lfe joxa created specific different goal mind lfe born provide lisp syntax erlang joxa mainly created platform creating dsl could take advantage erlang vm syntax inspired clojure creator nt interested implementing clojure feature nt language construct concurrency different clojure erlang yes one hand clojure provides tool handle mutable state sane way making clear distinction identity state reference type concurrency erlang vm implemented process message passing idea clojerl encourage erlangotp concurrency model support many clojure construct possible far make sense erlang vm rich hickey list reason chose use actor model clojure question see mean point make course good example state shared process communication overhead isolation also advantage lot circumstance also mention building distributed case aka process message passing complex always necessary decided optimise nondistributed case add distribution part system need rich hickey call erlang quite impressive interpretation writing exposing rationale behind decision tradeoff made designing clojure jvm disregarding actor model clojerl support every single clojure feature clojure feature implemented relying underlying mutability jvm object system erlang vm provides mutability construct support defining new type make hard nearly impossible port feature clojerl implementation reuse existing clojure script library yes need ported like clojurescript fact clojure core namespaces ported original clj file clojure jvm repository discussion join conversation clojerl mailing list clojerl slack channel also find news update clojerl question find jfacorro lurking clojure erlang mailing list feedback comment andor suggestion welcome
248,Lobsters,erlang,Erlang development,Videos from EFLBA2017,http://www.youtube.com/playlist?list=PLWbHc_FXPo2gZTX5oTYvIqTtKvS6WNNq8,video,,
249,Lobsters,erlang,Erlang development,"Spawned Shelter: best articles, videos and books for learning Erlang",http://spawnedshelter.com/,spawned shelter best article video book learning erlang,,page collection best article video book learning erlang internals virtual machine language run top like elixir lfe efene
250,Lobsters,erlang,Erlang development,Erlang: Migrating from Cowboy 1.0 to 2.0,https://github.com/ninenines/cowboy/blob/master/doc/src/guide/migrating_from_1.0.asciidoc,erlang migrating cowboy,permalink join github today sign appendix migrating cowboy compatibility feature added feature removed stream handler changed behavior new function changed function removed function change since header ignored rest handler corresponding reload reload,permalink dismiss join github today github home million developer working together host review code manage project build software together sign retrieve contributor time line sloc kb appendix migrating cowboy lot changed cowboy cowboyreq interface particular seen massive revamp hook gone functionality achieved via stream handler documentation seen great work particular manual module function dedicated manual page full detail example compatibility compatibility erlangotp dropped erlangotp required nontrivial make cowboy work older erlangotp version cowboy compatible cowlib version older compatible ranch however tested ranch version older cowboy tested arch linux ubuntu freebsd window osx tested every point release latest patch release also hipe recent release cowboy come erlangmk template feature added protocol supported cowboy longer us one process per connection us one process per connection plus one process per request default necessary might slight drop performance connection due change cowboy internals largely reworked order support opened way stream handler chain module called whenever something happens relating requestresponse cowboystreamh stream handler added provides cowboy default behavior cowboycompressh stream handler added compress response possible worth noting compress case cowboy ever many change internals cowboy many option added modified note websocket option given per handler rather entire listener websocket permessagedeflate compression supported via compress option static file handler correctly find file found ez archive constraint generalized used router also cowboyreq function interface also modified allow reverse operation formatting error feature removed spdy support removed use instead hook removed use stream handler instead undocumented waitingstream hack removed allowed disabling chunked transferencoding equivalent cowboy open ticket necessary sub protocol still exist interface largely changed longer documented time changed behavior handler behavior renamed cowboyhandler cowboyloop cowboyrest cowboywebsocket plain http loop rest websocket handler init terminate callback unified use callback latter optional terminate reason documented handler tuple returned switch different handler type changed take form module req state module req state opts opts map option configure handler timeout hibernate option must specified using map applicable behavior used accept halt shutdown tuples return value longer return value stop tuple consistent across cowboy middlewares longer return error tuple send response return stop tuple instead knowncontenttype rest handler callback removed found unnecessary websocket handler normal optional function reason exception websocket callback execute separate process callback therefore obvious timer monitor setup properly effectively initializing handler upgrade websocket handler send frame directly frame sent immediately handshake websocket handler callback longer receive req argument callback still receives used extract relevant information callback implemented may still receive req see next bullet point websocket handler new reqfilter option used customize much information discarded req object handshake note req object available past point websocket handler timeout default changed infinity second new function cowboyreq function added cowboyreq function added replacing le powerful function cowboyreq cowboyreq function cowboyreq cowboyreq allow matching query string cooky constraint function cowboyreq added complement cowboyreq function cowboyreq cowboyreq added used retrieve response header previously set function cowboyreq added allows setting many response header function cowboyreq used push resource protocol support default changed function cowboy function renamed cowboy cowboy function renamed cowboy function cowboyreq module modified please consult changelog individual function change mainly simplifying clarifying interface req longer returned necessary map used wherever possible function renamed position opts argument cowboyreq changed improve consistency last argument removed function function cowboyreq cowboyreq removed favor new function cowboyreq function cowboyreq cowboyreq removed req object public map therefore became unnecessary function cowboyreq removed sending file function cowboyreq take sendfile tuple remove many undocumented function cowboyreq including function cowboyreq cowboyreq change correct percentdecoding algorithm used path element routing longer decode character router properly handle path segment routing behavior changed uris containing character longer allowed uris expected percentdecoded client send multiple header name value header concatenated commaseparated list special importance case contenttype header previously first value used step rest handler etag comparison rest handler fixed request may fail succeeded past since header ignored rest handler corresponding ifmatch header exist former largely backward compatible header create issue new behavior follows current rfcs closely static file handler improved handle special character system accept perform action time signed another tab window reload refresh session signed another tab window reload refresh session
251,Lobsters,erlang,Erlang development,Yanni sings,http://blog.ikura.co/posts/yanni-sings.html,yanni sings,search ideal co web address,search ideal co web addressget gone
252,Lobsters,erlang,Erlang development,Boost message passing between Erlang nodes (2009),http://www.ostinelli.net/boost-message-passing-between-erlang-nodes/,boost message passing erlang node,copied pong process ping process within erlang node million two different erlang node thousand pid node message timeout size pong process ping process two different erlang node million time much without message queuing within erlang node million without k million update april adam bregenzer leopard osx queuing mechanism million messagesmin ubuntu linux without queuing mechanism million messagesmin ubuntu beta linux without queuing mechanism million messagesmin window xp queuing mechanism million messagesmin improve decrease update june queuing mechanism million messagesmin queuing mechanism million messagesmin improve ubuntu,message passing erlang node considerably slower within node normal due fact message sent node actually copied area sender receiver sent one node via tcpip getting interested server could achieve amazing performance single node performance got much lower server got distributed two erlang node therefore tried small benchmark test somehow measure difference message passing speed withinacross erlang node machine used benchmark apple macbook running leopard intel core duo ram memory benchmark simple ping requestpong response test process sends ping message process b reply pong message code pong process start pongstartpong register floodpong spawn fun pongloop end pongloop receive sender sendernode pong back sender sendernode pong pongloop shutdown io format pong shutdownn ignore pongloop io format pong timeout shutdownn end simple code basically start process register name floodpong see request format sender sendernode floodpong reply message format code ping process ie one start ping request following start pingstartping pongnode num register floodping spawn fun pingloop num num end send pongnode num send pongnode ok send pongnode num send spawned ping spawn fun floodpong pongnode floodping node pingrequest end send pongnode num pingloop num start timer nowdiff start io format received p p m pmin n num num pingloop num start count receive pong pingback pingloop num start received pingloop num start count io format ping timeout missing p pong shutdownn count end code two thing start register floodping process responsible await count incoming pong reply allows compute time needed pong reply get back node ping request first sent spawn ping request one process per ping request let give try first start two erlang node fire terminal enter roberto erl k true p name one robloc setcookie asd another terminal window roberto erl k true p name two robloc setcookie asd initializes two erlang node one robloc two robloc kernel polling enabled maximum number process per node set need ensure node see one robloc ping two robloc one robloc netadm ping two robloc pong one robloc node two robloc let perform message passing speed benchmark message sent received within erlang node first start pong process one robloc startpong true need start ping request issuing function per argument name recipient node ping request number request performed therefore set first parameter node second always try ping request one robloc startping node okreceived m see therefore within erlang node benchmark give result average million pingpong message per minute quite rush let try thing pong running two robloc ping request coming one robloc start pong process two robloc two robloc startpong issue ping request one robloc one robloc startping two robloc okreceived m see therefore two different erlang node benchmark give result average thousand pingpong message per minute around time loss performance compared benchmark run single erlang node expected still mean system heavily dependant message passing running single erlang node would considerably faster one running distributed node one thing erlang great point tried reducing overhead message passing using udp instead erlang native functionality success udp trouble known packet loss ordering double packet sending without getting interesting speed improvement got thought erlang message passing overhead demanding due tcpip actually queuing message sent process running node sending altogether would increase overall passing speed tcpip already provide mechanism performing queuing erlang application level could bring significant improvement infranodes message passing picture erlang node run genserver called qr performs queuing routing message sent one node instead sending message directly process node one robloc process b node two robloc process sends routing request qr running one robloc send qr running two robloc finally forward b fact sending qr queue message certain number node piled timeout period expired start defining genserver api route message function void description get routing requestroute topid tonode message case tonode node true send directly topid message false queue genserver cast server queue tonode topid message end see need pas pid destination process well name node process running together message need send case node remote cast message qr handle add incoming routing request queuehandlecast queue destnode topid message queue pid msg route topid message get node exists queue case list keysearch destnode queue false add node newqueue destnode msg queue value destnode creationtime msglist check queue long enough case length msglist queuelength true queue node maximum lenght send routing message qr destnode queueroute msgmsglist empty queue node newqueue list keydelete destnode queue false add message queue list replace node newqueue list keyreplace destnode queue destnode creationtime msgmsglist end end purge timeout purgedqueue purgequeueselective newqueue noreply purgedqueue function purgedqueue description loop queue purge node timeoutpurgequeueselective queue check timeout send remove element needed filterfun fun destnode creationtime msglist case timer nowdiff creationtime queuetimeout true timeout node send routing message io format send selective qr p queueroute p n destnode msglist qr destnode queueroute msglist delete node queue false false true end end return cleaned queue list filter filterfun queue mecanism quite simple message sent remote node arrives qr build list key tuples passed along genserver state variable format destnode creationtime msglist destnode ie destination node tuple key creationtime parameter allows know timeout message destnode passed msglist list tuples message sent destnode format handle key list check send queued message node certain timeout passed node computed using creationtime number message sent reached certain size see genserver cast also establishes overall timeout m fire message received qr thus need send remaining message timeout handled handleinfo call timeout cast message purge queuehandleinfo timeout queue purge timeout purgedqueue purgequeue queue return noreply purgedqueue function purgedqueue description loop queue purge nodespurgequeue queue sent remaining filterfun fun destnode creationtime msglist send routing message qr destnode queueroute msglist end list foreach filterfun queue return empty queue see message sent qr one node qr another node format msglist list individual message format qr node receives message handle handleinfo queueroute msglist state routefun fun route topid message local send node topid message end list foreach routefun msglist return noreply state ok basically let see improve message passing node need redifine pongloop send message directly process route request qr instead new code pong process start pongstartpong register floodpong spawn fun pongloop end pongloop receive sender sendernode pong back qr route sender sendernode pong line changed pongloop shutdown io format pong shutdownn ignore pongloop io format pong timeout shutdownn end go ping process start pingstartping pongnode num register floodping spawn fun pingloop num num end send pongnode num send pongnode ok send pongnode num send spawned ping line changed spawn fun qr route floodpong pongnode floodping node pingrequest end send pongnode num pingloop num start timer nowdiff start io format received p p m pmin n num num pingloop num start count receive pong pingback pingloop num start received pingloop num start count io format ping timeout missing p pong shutdownn count end set let try immediately perform test two different erlang node pong running two robloc ping request coming one robloc start qr pong process two robloc two robloc qr startlink ok two robloc startpong true start qr issue ping request one robloc one robloc qr startlink ok one robloc startping two robloc okreceived m see therefore two different erlang node benchmark give result average million pingpong message per minute time much without message queuing interesting safe side try benchmark message sent via qr process running erlang node ok two robloc startpong true two robloc startping node okreceived m see therefore within erlang node benchmark give result average million pingpong message per minute without queuing mechanism summarize without queuing mechanism erlang node million messagesmin different erlang node k messagesmin queuing mechanism erlang node million messagesmin different erlang node million messagesmin complete code run machine available whole queuing idea still experiment delighted hear feedback see whether getting result know improve concept code consideration would like share update april due comment adam bregenzer performed test linux box different result decided perform testing different o summary test please bear mind result definitely non exhaustive macbook running leopard osx intel core duo ram memory erlang node million messagesmin different erlang node without queuing mechanism k messagesmin queuing mechanism million messagesmin ubuntu linux system intel core duo adam test erlang node million messagesmin different erlang node without queuing mechanism million messagesmin queuing mechanism million messagesmin ubuntu beta linux system vm cpu ram memory erlang node million messagesmin different erlang node without queuing mechanism million messagesmin queuing mechanism messagesmin window xp intel core duo ram memory erlang node million messagesmin different erlang node without queuing mechanism million messagesmin queuing mechanism million messagesmin normal erlang result extremely different depending many factor one seems o nonexhaustive test qr mechanism improve message passing performance erlang node osx window environment decrease message passing performance erlang node ubuntu linux environment insight understand characteristic o switching result manner tcpip flow thread io though currently deploying similar qr mechanism application activated necessary based individual benchmarking test update june availability two hp proliant running ubuntu server bit therefore decided take shot also test bench different machine summary result test usual please bear mind result definitely non exhaustive erlang node million messagesmin machine two different erlang node running machine without queuing mechanism k million messagesmin queuing mechanism million messagesmin two different erlang node running different machine without queuing mechanism k million messagesmin queuing mechanism million messagesmin seems state qr mechanism improve message passing performance erlang node also ubuntu environment also updated original code destination node identifier extracted recipient pid thus necessary pas variable code found
253,Lobsters,erlang,Erlang development,"How Discord Scaled Elixir to 5,000,000 Concurrent Users",https://blog.discordapp.com/scaling-elixir-f9b8e1e7c29b,discord scaled elixir concurrent user,five million concurrent user million event per second erlang anger message fanout people started using discord large scale group roverwatch benchmarking blog post manifold http githubcomdiscordappmanifold fast access shared data consistent hashing library chris moo ets converted code pure elixir mochiglobal http githubcomdiscordappfastglobal limited concurrency cascading service outage circuit breaker semaphore http githubcomdiscordappsemaphore conclusion,beginning discord early adopter elixir erlang vm perfect candidate highly concurrent realtime system aiming build developed original prototype discord elixir became foundation infrastructure today elixir promise simple access power erlang vm much modern userfriendly language toolsetfast forward two year nearly five million concurrent user million event per second flowing system regret choice infrastructure lot research experimentation get elixir new ecosystem erlang ecosystem lack information using production although erlang anger awesome follows set lesson learned library created throughout journey making elixir work discordmessage fanoutwhile discord rich feature boil pubsub user connect websocket spin session process genserver communicates remote erlang node contain guild internal discord server process also genservers anything published guild fanned every session connected itwhen user come online connect guild guild publishes presence connected session guild lot logic behind scene simplified example fine approach originally built discord group le however fortunate enough good problem arise people started using discord large scale group eventually ended many discord server like roverwatch concurrent user peak hour began see process fail keep message queue certain point manually intervene turn feature generated message help cope load figure became fulltime jobwe began benchmarking hot path within guild process quickly stumbled onto obvious culprit sending message erlang process cheap expected reduction cost erlang unit work used process scheduling also quite high found wall clock time single call could range due erlang descheduling calling process meant peak hour publishing event large guild could take anywhere erlang process effectively single threaded way parallelize work shard would quite undertaking knew better waywe knew somehow distribute work sending message since spawning process erlang cheap first guess spawn another process handle publish however publish could scheduled different time discord client depend linearizability event solution also scale well guild service also responsible evergrowing amount workinspired blog post boosting performance message passing node manifold born manifold distributes work sending message remote node pid erlang process identifier guarantee sending process call equal number involved remote node manifold first grouping pid remote node sending manifoldpartitioner node partitioner consistently hash pid using group number core sends child worker finally worker send message actual process ensures partitioner get overloaded still provides linearizability guaranteed solution effectively dropin replacement awesome sideeffect manifold able distribute cpu cost fanning message also reduce network traffic node network reduction guild nodemanifold available github give spin http githubcomdiscordappmanifoldfast access shared datadiscord distributed system achieved consistent hashing using method requires u create ring data structure used lookup node particular entity want fast chose wonderful library chris moo via erlang c port process responsible interfacing c code worked great u discord scaled started notice issue burst user reconnecting erlang process responsible controlling ring would start get busy would fail keep request ring whole system would become overloaded solution first seemed obvious run multiple process ring data better utilize machine core answer request however noticed hot path could better let break cost hot patha user number guild average user erlang vm responsible session live session itwhen session connects lookup remote node guild interested inthe cost communicating another erlang process using requestreply session server crash restart would take second cost lookup ring even account erlang descheduling single process involved ring process work could remove cost completely first thing people elixir want speed data access introduce ets ets fast mutable dictionary implemented c tradeoff data copied move ring ets using c port control ring converted code pure elixir implemented process whose job ring constantly copy ets process could read directly ets noticeably improved performance ets read still spending second looking value ring ring data structure actually fairly large copying ets majority cost disappointed language could easily shared value safe read way erlang research found mochiglobal module exploit feature vm erlang see function always return constant data put data readonly shared heap process access without copying data mochiglobal take advantage creating erlang module one function runtime compiling since data never copied lookup cost decrease bringing total time thing free lunch though cost building module data structure large ring runtime take second good news rarely change ring penalty willing takewe decided port mochiglobal elixir add functionality avoid creating atom version called fastglobal available http githubcomdiscordappfastgloballimited concurrencyafter solving performance node lookup hot path noticed process responsible handling guildpid lookup guild node getting backed inherent back pressure slow node lookup previously protected process new problem nearly session process trying stampede ten process one guild node making path faster solve problem underlying issue call session process guild registry would timeout leave request queue guild registry would retry request backoff perpetually pile request get unrecoverable state session would block request timed receiving message service causing balloon message queue eventually oom whole erlang vm resulting cascading service outageswe needed make session process smarter ideally even try make call guild registry failure inevitable want use circuit breaker want burst timeouts result temporary state attempt made knew would solve language would solve elixir language could use atomic counter track outstanding request bail early number high effectively implementing semaphore erlang vm built around coordinating communication process knew want overload process responsible coordination research stumbled upon performs atomic conditional increment operation number inside ets key since needed high concurrency could also run ets writeconcurrency mode still read value since return result gave u fundamental piece create semaphore library extremely easy use performs really well high throughput library proved instrumental protecting elixir infrastructure similar situation aforementioned cascading outage occurred recently last week outage time presence service crashed due unrelated issue session service even budge presence service able rebuild within minute restarting live presence within presence servicecpu usage session service around time periodyou find semaphore library github http githubcomdiscordappsemaphoreconclusionchoosing use getting familiar erlang elixir proven great experience go back start would definitely choose path hope sharing experience tool prof useful elixir erlang developer hope continue sharing progress journey solving problem learning lesson along waywe hiring come join u type stuff tickle fancy
254,Lobsters,erlang,Erlang development,PropEr Testing,http://propertesting.com/,proper testing,get pro book view old free website,hi propertybased testing proper erlang elixir book propertybased testing pretty much friendliest intro property testing find book teach automatically generate test case test stateful program change design software principled reliable approach able better explore problem space validate assumption make coming program behavior expose unexpected weakness design proper even show reproduce bug found book writing efficient propertybased test time website essentially older draft copy book nt gone editing contains erlang elixir wellorganized also contain latest info proper targeted property stuff available decide buy copy real book meanwhile though want people easy access information still visit website book got published note keeping website date however get pro book view old free website
255,Lobsters,erlang,Erlang development,NOTP: a middle way,http://blog.ikura.co/posts/notp-a-middle-way.html,notp middle way,search ideal co web address,search ideal co web addressget gone
256,Lobsters,erlang,Erlang development,Suicidal Tendencies – Erlang Battleground,https://medium.com/erlang-battleground/suicidal-tendencies-f8f6bfb37461,suicidal tendency erlang battleground,intuitive scenario exit signal travel faster evaluation result boomerang situation spawnlink false linked expected unconditional killer normal situation suicidal tendency robert virding exception exit normal,provides well function theory send exit signal process without affecting current process stated function many corner case gotchasintuitive scenarioslet start expected scenario use exit pid reason reason normal kill either pid trapping exit linked calling processflag trapexit true self self pid spawnlink fun exit self bye timer sleep end flush shell got exit bye isprocessalive pid see since self aka console trapping exit receives exit signal spawned process process remains much pid spawn fun receive shell exit shell bye timer sleep end pid self exception exit isprocessalive pid see trick since exit signal travel faster evaluation result would able assign anything pid otherwise end thing happened shell got exit signal died process remained alivethe boomerang situationnow let show similar pid spawnlink fun receive shell exit shell bye timer sleep end pid self exception exit isprocessalive pid woah happened since pid linked shell trapping exit shell died reason pid died reason bye well expectedthe unconditional killeryou also use atom kill second argument according reason atom kill exit pid kill called untrappable exit signal sent pid unconditionally exit exit reason exception rule trapping exit exit reason kill exit pid kill called unconditionally terminates process regardless trapping exit processflag trapexit true self self spawn fun exit self kill end exception exit look consistent another way generate exit signal reason processflag trapexit true self self spawnlink fun exit kill end flush shell got exit kill aha exit pid kill sending exit signal reason kill actually something else sending untrappable exit signal reason actually irrelevant never access anywaythe normal situationso happens reason normal well try send exit signal self self pid spawnlink fun exit self normal timer sleep end processflag trapexit true spawnlink fun exit self normal timer sleep end flush shell got exit normal isprocessalive pid isprocessalive nothing different described doc send exit signal suicidal tendenciesfinally arrive core robert virding email mysterious reason decide send exit signal terminated let first try check exit signal trapping processflag trapexit true exit self bye flush shell got exit bye exit self normal flush shell got exit normal exit self kill exception exit trapping exit signal nothing ordinary happens unless reason kill receive corresponding message keep moving trapping exit self bye exception exit exit self normal exception exit
257,Lobsters,erlang,Erlang development,Erlang/OTP 20.0 has been released,http://erlang.org/pipermail/erlang-questions/2017-June/092646.html,erlangotp released,erlangquestions otp released kenneth redacted http http http http information erlangquestions mailing list,erlangquestions otp released kenneth lundin kenneth redacted wed jun cest erlangotp erlangotp new major release new feature quite characteristic improvement well incompatibility minor change compared second release candidate one listed ert release candidate function erlang changed encoding atom atomext changed atom actually containing unicode character encoded tag atom encoded atomext important news otp potential incompatibility ert non smp erlang vm deprecated built default remove deprecated erlang erlang schedulerwalltime also includes info dirty cpu scheduler new purge strategy introduced otp mandatory slightly incompatible process holding fun see erlang nif library reload supported anymore atom contain arbitrary unicode character mean capability distribution protocol must supported otp node accept connection another node library third party library us distribution protocol need updated deprecated module function removed ssh client option call start daemon fail highlight ert dirty scheduler enabled supported vm smp support support dirty bifs dirty gc erlang control minor major gc erlang literal longer copied sending message improved performance large ets table entry except orderedset erlang atomcount atomlimit reduced memory pressure converting subbinaries heapbinaries gc enifselect map external event message improvement timer internally vm resulting reduced memory consumption efficient administration timer compiler code generation complicated guard improved warning repeated identical map key b warn repeated key default warning exportall used disabled pattern matching map optimized new option deterministic omit path source option info beam file atom may contain arbitrary unicode character compile option include extra chunk beam file misc application significantly updated string module unicode support many new function crypto support openssl unnamed ets table optimized genfsm deprecated replaced genstatem new event manager handle subset o signal erlang optimized set addelement delelement union added rand genserver crash stacktrace client printed facilitate debugging added dict orddict gbtrees added gbtrees erltar support long path name new file format new map option change representation sequence map instead record tl client default call publickey verify hostname ssl dtls documented api experimental ssh improving security removing adding algorithm new math detail see http per built version window fetched http http line documentation browsed wwwerlangorgdoc thanks contributor next part html attachment scrubbed url http information erlangquestions mailing list
258,Lobsters,erlang,Erlang development,Stateful WebSockets with Elixir’s GenStage,https://medium.com/mint-digital/stateful-websockets-with-elixirs-genstage-a29eab420c0d,stateful websockets elixir genstage,stateful websockets elixir genstage utilise technology create incremental search solution incremental search genstage breaking problem algolia debounce throttle thinking different solution sent request last second need wait sent request last second next sent immediately immediately genstage enter genstage announcement enter websockets implementation query also queryrunner websocket front end wrap,stateful websockets elixir genstagecan utilise technology create incremental search solution visual designera colleague recently asked might go implementing incremental search third party api well documented problem variety way handle thought made good candidate try something little differenti walk way might typically solved going chose go solution using genstage websocketsbreaking problemperhaps first solution consider one fire request every keystroke search fieldto end user appear snappy giving nice autocomplete feeling precisely solution like algolia give box instant search solution tried searching debounce algolia doc see result returned upon clicking see string anywhere page search hardthere might however reason limit often send request server perhaps connecting api rate limit perhaps feel helpful send request every single keystroke perhaps server want send many request might look solution closer following setup rather submitting every single value input hold server use debounce throttle send request le frequently api provider happy thisfor many use case one solution perfectly acceptable potential downside sending request every keypress control often hit server server implement rate limit may become problem debounce send search user stopped typing given interval perhaps take away instant autocomplete feeling throttle send request every time given interval passed fine may case certain circumstance send request frequently others whenever request sent wait response ideally wait done bit take break handle result later server tell u thinking different solutionthe truth solution could work depending need case attempting implement incremental search party api endpoint rate limit need avoid running intoat time keen display result user type without worrying mistakenly running limit effectively rule debouncethe api connecting github graphql api give point play per hour request need make cost point mean long exceed average reqss given hour run limiti could look using throttle downside know happened previously sent request last second could send right still danger running limitimagine world implementation tell difference following state act appropriately know send request per second average sent request last second need wait know send request per second average however sent request last second next sent immediatelythe benefit approach v throttle twofold firstly waste call bank call unused use later secondly call banked make use immediately new query come throughwhile believe solvable javascript sort pattern fact one use case elixir genstage designed help solve going move mechanism sever worthwhile tradeoff least example genstage us wild present keen add one think interesting enter genstagethe official announcement likely explain genstage better able genstage new elixir behaviour exchanging event backpressure elixir process developer use genstage need worry data produced manipulated consumed act dispatching data providing backpressure completely abstracted away developersby using genstage create stage either acting producer emit event consumer ask producer event ready u mean setup separate stage following holding latest query input user asking latest query rate exceed given limit calling api endpoint queryi explain setup detail diagram show roughly data flow system query queryratelimiter queryrunner stage genstage setup new setup browser sends event elixir server genstage pipeline setup process event stage query producer module receives user input buffering emitting value eventqueryratelimiter producerconsumer per second module sends demand query query event ready queryratelimiter receive otherwise demand buffered next event dispatched come inqueryrunner consumer sends new demand whenever receives event meaning receives event queryratelimiter arrive sending external apithis handle limiting frequency query sent api intelligently previous strategy however mean query coming browser guarantee hit apiin addition want hit api need make jump browser elixir server api generally try avoid sort work done request case however user care response need send back somehowenter websocketsfortunately already made decision use elixir web framework phoenix also written phoenix make easy pie set websocketsby setting genstage pipeline client connects websocket process event time described send result back across connection whenever arrive implementationso got idea system architected dive implementation show code key module describe doingquerythe query module fairly small use calling startlink socket socket struct representing websocket connection query associated trigger specifies stage producer want keep event time buffer later whenever query come socket call pid previously started process incoming query trigger immediately attempt dispatch event subscribed consumer care incoming demand make use buffer return result setup good u number reason event dispatched outpace demand eg per second stored genstage internal buffer limited buffer ever buffer latest event want show stale result user incoming demand outpaces event eg send event second still ask demand time also buffered sent event last second safe send quick succession likely send one incoming keystroke quick successionultimately might good look handling buffer manually control looking think enough take without far see demand buffering ceiling would like limit canqueryratelimiterthis module bit involved producer start stage calling call initializes stage producerconsumer state represented empty map module subscribes producer eg query called take producer pid reference store producer state along value pending interval next call updated state new producer finally returning tuple specifies stage manually ask demand make use pending interval first ask producer pending event take care arrive simply emitting unchanged finally make use interval send message self interval elapsed message received simply call back loop begin anewqueryrunnerfinally consumer module simply sends demand queryratelimiter subscribe receiving event handling arrive event coming query value send external api code omitted something distraction right get result back push websocket also referenced eventwebsockethandling server side websocket easy thanks phoenix channel unusual part associating genstage socketupon join channel setup genstage pipeline storing socket producer state producer pid socket assigns receive search event channel send query along socket pid trigger event sent producerfront endfor front end used elm focus article complete novice find code tldr elm program load initializes model store current query result also join typeahead public channel create subscription listens herewe render input oninput send update function search message send value currently input across socketwhen result come back across channel subscription trigger result update message attempt decode received json updating model result turn trigger update viewwrap uponce plugged piece together working solution pretty pleased feel made good experiment however wanted try push farther order make production ready would need look closely area instancewe would currently handle rate limit needed shared across multiple client genstage process supervised phoenix drop websocket connection second inactivityhaving said think great way get know genstage better ultimately think issue ironed could good solution problem generally think nice way adding state websocket connection using async work sending result work back across socket later onyou find full source work love hear thought
259,Lobsters,erlang,Erlang development,Analyze This! – Erlang Battleground,https://medium.com/erlang-battleground/analyze-this-9d5f47d24d87,analyze erlang battleground,dialyzer v proplists situation proplists expand,dialyzer v proplists situationcheck see function look pretty similar difference lie expansion list tuples list second element atom mixture bothif compile module try use function actually expand good expanded expanded c expand bad expanded expanded c expand wat expanded expanded c run dialyzer call proplists expand expansion expanded b expanded listin b c break contract expansion listin listout expansion property property expansion term listin term listout term dialyzer correctly pointing spec proplists requires expansion list line using atom wrong dialyzer complaining line using atom well
261,Lobsters,erlang,Erlang development,My Erlang/OTP 20 Highlights,https://medium.com/erlang-battleground/my-erlang-otp-20-highlights-fbaec087ee51,erlangotp highlight,compare swap ets ets use ctslave ctslave article limit log backup ct keeplogs loïc write pid port shell pid port reference external fun erlang solution osx installer drop callback boilerplate optional,compare swap application stdlib related id add new function ets performs atomic compareandswap operation ets object using match specificationsthis one something many u waiting working around supernasty way long long time nice compareandswap ets something certainly use use ctslave application commontest ctslave module handle nodenames way nodenames passed sname mean ctslave start b workanother one fought long time stated article look bad ctslave friend workaround course super ugly basically involved using ctslave fix limit log backup application commontest added new option keeplogs setting value option integer n commontest remove ctrun directory current log directory except n newestbesides making loïc extra happy option prevent starting every test run rm rf log hating keeping track previous run write pid port application debugger stdlib erlang shell qlc stringtohandle debugger evaluator area edit variable window binding area parse pid port reference external fun long created running systemi still try use erlang solution osx installer provide rcs mean think mean ie erlang isprocessalive work erlang shell would single amazing feature release expecting particularly port thanks fred recon since first encounter erlang shell year drop callback application stdlib making codechange terminate handleinfo callback optional otp behavioursi honestly know highlight check full conversation started tweet
262,Lobsters,erlang,Erlang development,What is wrong with gen_event?,http://www.afronski.pl/2015/11/02/what-is-wrong-with-gen-event.html,wrong genevent,home wrong made garrett smith pattern language josé valim presentation come next elixir wolf rabbit carrot simulation problematic widely used process handler nick demonner talk hard supervise failure handling faulty event handler silently removed learn erlang great good state management alternative uwigergproc josé valim talk summary credit,home wrong genevent never used genevent think bad pattern first may look like controversial statement heard lot complaint people originally heard exact statement presentation made garrett smith pattern language someone asked behavior end recently heard similar thing josé valim presentation come next elixir confuses every time hear want investigate topic deeply dive reason explanation let recall purpose behavior genevent otp introduces two different term regarding behavior event manager event handler module responsibility event manager named object receive event event example error alarm information logged inside manager event handler installed responsibility handler process event event manager notified event processed installed handler easiest way imagine think manager sink incoming message handler different implementation writing message disk database terminal another example taken implementation francesco cesarini assignment called wolf rabbit carrot simulation main purpose task introduce concurrency internally simulation certain event happening broadcasted rest entity case simulationeventstream event manager module simulationeventstream export startlink ok pid genevent startlink local module genevent addhandler module simulationclihandler componentready module ok pid componentready name genevent notify module name ready notify name action state genevent notify module name action state notify name pid action state genevent notify module name pid action state attachhandler handler genevent addhandler module handler removehandler handler genevent deletehandler module handler easily add remove event handler event manager essentially maintains list module state pair module event handler state internal state event handler one handler implementation simulationclihandler related writing message console actual genevent callback module handler implementation abstraction module simulationclihandler behavior genevent export init args ok handleevent msg state indicator case msg planted born eaten died ii end io format w n indicator msg ok state codechange oldvsn state extra ok state handlecall request state ok empty state handleinfo info state ok state terminate args state ok important part term aforementioned complaint starting event manager spawned process event handler implemented callback module whole processing logic executed inside manager process problematic let reiterate spawning genevent manager installing handler handler exist process manager cause two biggest issue handler executed concurrently isolated process sense heard explicitly never used genevent think bad pattern whole argumentation summed aforementioned behavior used anywhere besides errorhandler alert mechanism otp cause problem supervision natural approach erlang combining manager handler together one process tricky use fault tolerant way handler bound together single process tricky manage state manager may tempting use eg process dictionary rather push handler obvious first sight let analyze root cause complaint separately widely used ert otp first objection related behavior widely used erlang core library platform partially true behavior used errorlogger alarmhandler errorhandler facility major reason drop behavior completely think guide responsibility use case behavior kind limited much narrower trying assign process handler one explicitly stated list manifest come failure handling supervision also another really significant drawback obvious think handler invoked synchronously sequentially one process order dispatch event manager use one two genevent function notify syncnotify first dispatch event quickly possible backpressure applied end situation event incoming really fast processing slower cause process queue grow eventually cause even crash check also manager presence easily throw message void hand synchronous dispatch wait event processed handler slow eventually become system bottleneck problem also nicely described nick demonner talk year elixirconf u conference check interested elixir genevent implementation also third function acknotify acknowledges incoming message something softer syncnotify still asynchronous come processing hard supervise approaching erlang newcomer really fascinated mantra everything process worst possible thing happen thought event handling platform language well oh crap moment thing really work came started observer looked handler process realized oh crap process behavior hide complexity underneath really good assumption regarding model dispatching separate handler manager reliable dispatch much harder achieve eg come fault tolerance simply counterintuitive come erlang philosophy especially newcomer failure handling another obvious thought realize handler manager coexist process happen fault installed event handler module may sound strange beginning faulty event handler silently removed produce error report printed terminal nothing moreover well known monitoring technique link monitor used event handler module process faulty event handler code crash manager use different facility exposed genevent called addsuphandler mean connection process want dispatch event handler supervised mean event handler deleted due fault manager sends message geneventexit handler reason caller mean need provide additional process often called guard possibly faulty handler dispatching event happen guardian process receives failure message via handleinfo act accordingly requirement keep mind underneath us link monitor event handler chapter learn erlang great good really good explanation may dangerous issue cause long story short using addsuphandler need cautious come event manager shutdown interesting elixir version behavior genevent solved problem exposing us monitor hood still solution another problem geneventexit handler reason message delivered manager process crash another edge case prepared either need monitor manager link trap exit handler state management one thing think emphasized enough state management always pas state handler really well described example code also come fault tolerance handler removed due failure operation restoring pas new state preserve state handler manager build facility exposing may cause strange hard debug side effect related state newly created handler alternative something use instead without using third party like uwigergproc afraid nothing like core interested elixir incoming genrouter behavior look really promising course still really far away core future uncertain whole concept described josé valim talk even example particular use case dynamicin broadcastout represent process based replacement genevent summary think wisely particularly useful behavior limited capability responsibility maybe reason used internally rarely mean also bend use case specific application similar one used inside otp mean errorlogger need concurrency support come processing logic safely use otherwise incur trouble credit
264,Lobsters,erlang,Erlang development,Speed up data access in Elixir,https://medium.com/learn-elixir/speed-up-data-access-in-elixir-842617030514,speed data access elixir,speed data access elixir accessing map two time slower accessing keyword list time slower time slower time slower tuples benchmark repository github warning,speed data access elixirworking data structure straightforward predictable day erlang time getting exactly expectelixir different beast allows way work map list keyword list turn performancewise radically different othersfirst nice graph access time depending structure size come explanation raw data benchmarking code end articleaccess time structure size elementsaccess time structure size elementsaccessing mapsthere way access map elixir using pattern matching fastest key value mapmap foo bar foo foovalue mapusing pattern matching case function clause head fast using mapfetch slower mapfetch slower match value also creates extra tuplemap foo bar ok foovalue mapfetch map foo using access module much slower map foo bar foovalue map foo obscure nonintuitive behavior elixir coming programming language immediately recognize notion keyindex access probably use itin elixir allow much example addressing updating element map show next article come huge cost two time slower pattern matchingaccessing keyword listserlang elixir turn use list name tuples pas around option introduction map erlang feasible way data structure dynamic propertieskeywordlist foo bar compact formkeywordlist foo bar list accessing element requires scan find necessary element access speed n expected really use keyword list couple element using custom function speedup lookup fastest know keyword list using limited value may want faster lookup function get value keyword listdef kwlistaccess kwlist key defaultnil case kwlist h v v h v v h v v h v v keywordget kwlist key default endend using keywordget slow time slower using custom functionkeywordlist foo bar foovalue keywordget keywordlist fooyou also supply default value keywordget list foo default case key found list using access module slowest story map access module great provide extra functionality time slower compared custom function time slower compared keywordgetkeywordlist foo bar foovalue keywordlist foo tuplesi cover tuple access v map list article tuples blazingly fast little bit le flexiblehow benchmarkclone repository github runmix bench benchaccessvsmapfetchvsmatchexswarning using modern computer o constantly change processor speed order save energy keep cool quiet great every day work terrible benchmark running benchmark manually set processor fixed speed example debian instruction show current settingsgrep sysdevicessystemcpucpu cpufreqscalinggovernornumber test name mean much element tested structure uncomment line element mapkwlistetcbaseline function call without processing done see much function call cost benchfellamatch test key value lookup mapmapfetch call mapfetch map kwgetunroll manually unrolled function lookup keyword list element big switch keywordgetkwget call keywordget keyword listaccesskw kwlist index callaccessmap map index callso see least time slower manual know flaw microbenchmarks also optimization real code based input significant speed ups access module nice slow case map matching function head fastest
265,Lobsters,erlang,Erlang development,Lasp: a little further down the Erlang rabbithole,https://notamonadtutorial.com/lasp-a-little-further-down-the-erlang-rabbithole-febba29c8d0c,lasp little erlang rabbithole,lasp little erlang rabbithole lasp christopher meiklejohn distributed eventually consistent computation unbalancedparen monad tutorial stay tuned lasp crdts problem crdt solve alternative exists apart crdts solve type issue downside using crdts lasp process registry create new process registry already got global gproc syn erlang think part created found developing lasp ported traditional programming language partisan use default distributed erlang programming language piece software keep eye erleans recommend reading u trying learn distributed system introduction reliable secure distributed programming,lasp little erlang rabbitholea year ago found lasp suite library aimed providing comprehensive programming system planetary scale elixir erlang application point come surprise learn monad tutorial interested distributed system erlang playing little bit lasp watched talk creator christopher meiklejohn watching talk distributed eventually consistent computation decided time interview christopherreach via twitter unbalancedparen comment interview request monad tutorial stay tuned discus vote lobster reddit hnwhat lasp originally lasp programming model designed deterministic distributed computing weak synchronization lasp programming model appears function write application look like functional program arbitrary distribution application guaranteed return correct result minimal coordination network anomaly network partition node failure lasp achieves building upon design philosophy conflictfree replicated data type crdts data structure designed achieve convergence without requiring locking synchronization primitivesduring evaluation phase lasp tasked trying scale prototype implementation written erlang node got far could allotted time node running amazon process trying achieve scale develop number library erlang provide supporting infrastructure new distribution algorithm optimized implementation data type deployment operation tooling etc say point lasp academic sense refers original programming model lasp industrial sense refers entire suite library deliver programming system programming model large scalewhat crdts problem crdt solve crdts conflictfree replicated data type data type designed use distributed system think regular sequential abstract data type predefined deterministic merge function two possible valuesone big challenge distributed computing related consistency network partition occurs system managing replicated data must make choice allow operation proceed remaining availableunderpartition prohibit operation proceed remaining consistentunderpartitionconsistentunderpartition system cp system provide strong consistency make application development easier whereas availableunderpartition system ap system allow developer exploit available concurrency system performance keep servicing request network partition inevitably occur availableunderpartition system ideal application geodistributed allow user read write locally geographically close replica incur synchronization penalty write operation case operation however one challenge using availableunderpartition system potential write conflict two writes happen object concurrently two replica network ultimately convergence different replica come agreement value win using database opaque value register set get value choice arbitrary either choice may valid system like cassandra resort solving using user provided timestamp pick value approach like deterministic problematic however arbitrarily picking value based time dropping write operation may fail capture developer intentcrdts say rather opaque register store actual data type database conflict resolution policy compatible semantics data type one example trivial crdt growonly set never remove element set always safe merge copy set independently modified using set union operation similar design exist set add remove element arbitrarily graph dictionary counter booleanswhat alternative exists apart crdts solve type issue operational transformation alternative approach predates crdts used build google doc apache wave operational transformation relies transforming edit operation based concurrent operation achieve desired effect transformation document modified exist significant number different algorithm make different set tradeoff algorithm better others general case extremely difficult implement correctly verify given number possible operation operation interleaving transformation must consideredare downside using crdts crdts expensive term implementation state synchronization lot effort gone reducing overhead state transmission operationsbased crdts variant sends operation instead state tradeoff requires stronger property message delivery network deltacrdts variant minimizes required state need transferred minimizing change representation one open challenge crdts system manage largeamount replica object concurrently operated actor management typically system data structure must carry metadata size n number actor ever modify object system system large amount mobile device high churn prohibitive term space recent approach try address problem rely either imposing structure way node share information one another allow node subsume change node allowing transient node temporarily borrow identity smaller number permanent node identifier temporary node carried around object metadata indefinitlywhat lasp process registry create new process registry already got global gproc syn erlang three year ago created riak pg process registry used distribution strategy riak corresponding paper presented erlang workshop year created process registry done extensive study writeup proc global designed properly fordistributed scenario partition occur availability paramountlasp pg natural extension us unstructured overlay full replication crdts instead partial replication across structured overlay network crdtswhile ericsson working scaling global facility growing distributed erlang support larger number node focusing supporting existing application developed ericsson distributed erlangb smaller scale node operating lan configuration think solution scaling global shard information across node requires availability dht using kademlia structured overlay network request servicedlasp therefore lasp pg focusing largescale widearea programming think node operating geoscale scenario partition common fact mobile client iot device might disable antenna preserve battery scenario assume node aware every node network route message node resilient partition ability keep operating lasp pg first step towards work presented erlang factory loquat second step towards goaldo think part created found developing lasp ported traditional programming language hopefully unclear component end useful mainly focused quickly prototyping thing performing evaluation erlang elixir determine approach scale easy program etci think get bit along research maybe year idea coming might useful developed enough make mainstreamwhat partisan use default distributed erlang partisan membership layer clustering group erlang node bypass distributed erlang completely run variety topology soon support connection multiplexing full support tlsssl partisan support cluster node running startopologies random unstructured overlay cluster fully connecteddistributed erlang bit rigid u assumes fully connected network extremely difficult scale large cluster node us single tcp connection process communicating one node another order build reliable system would scale large cluster nodessecurely needed membership layer state dissemination right partisan support semantics erlang provides actively working developer open source community extend partisan support normal erlang message passing across highlyavailable frameworkwe also started see company using erlang elixir pick partisan tool helping build reliable largescale application need efficient state dissemination nice implementation came research groupwhat programming language piece software keep eye right excited spacetime insight implementation microsoft orleans erlang called erleans think orleans take lot complexity actor management erlang elixir help developer get straight building distributed application without focus low level detail around message routing actor placement actor creation terminationwhat recommend reading u trying learn distributed system think everyone building distributed application nowadays web developer building richweb client javascript mobile developer building next hit application deal problem state synchronization offline operation maintaining consistencythat said academic side recommend introduction reliable secure distributed programming cahin guerraoui rodrigues book university teach course ta contributed content tothe course also taught via mooc edx well doinga guest lecture semester part lasp crdts
266,Lobsters,erlang,Erlang development,Erlang Performance Lab,http://www.erlang.pl/,erlang performance lab,dashboard,dashboard give high level overview current system throughput process activity like spawn exit memory footprint erlang runtime system setting good starting point system exploration live chart help observe trend recent history reason overall health system
267,Lobsters,erlang,Erlang development,"Director: Felxible, fast and powerful supervisor library for Erlang processes",https://github.com/Pouriya-Jahanbakhsh/director,director felxible fast powerful supervisor library erlang process,welcome director supervisor manager director director director supervisor newbie feature director director director director director director director director director director use director director director director director director director childspec id start director state director type terminatetimeout director director delete director director director director module append start option db table initarg delete director debug spawnopt timeout example director director director director director director director director director director director director director director build compile use dependency api documentation todo license author hex version,welcome director productionready supervisor manager erlangelixir process focus speed performance flexibility nt worry replacing director otpsupervisor director process responsive api function otpsupervisor module useful api function flexible otpsupervisor since director call callbackfunction dealing process crash changing code change strategy seeing advantage read readme file supervisor newbie according erlang manual supervisor process supervises process called child process child process either another supervisor worker process supervisor used build hierarchical process structure called supervision tree nice way structure faulttolerant application erlang tell supervisor start process every child process option called childspec feature useful api function director getpid directorref childid give pid child child alive director getpids directorref give pid alive child director terminateanddeletechild directorref childid terminates deletes child one request director becomesupervisor directorref pid childspec make director supervisor alive process director getrestartcount directorref childid give restart count child useful debug function listed director erlang behaviour every callbackmodule behaviour following callbackfunctions see use section detailed explanation initialization define child database type debug mode childspecs child want start initialize state called starting child process called crashing child process callbackfunction tell director deal process crash restart child restart time interval delete child child nothing terminate called director terminates child process called termination director use different database keeping child default director us erlang list three mode keeping child map ets mnesia table number director process use one ets table node sharing ets table number director process use one mnesia table cluster node sharing mnesia table sharing table director start restart terminate etc number child simultaneously using ets mnesia read child info directly table using api function directortableets directortablemnesia module instead getting director process example directortableets getpids tab directortablemnesia countchildren tab define database keeping child implementing directortable behaviour also test case ready testing module understandable debug output every operation feature listed info see guide example contributing see contributingmd file use since director erlang behaviour explaining workflow explain behaviour newbie erlang behaviour design pattern implemented modulelibrary provides functionality fashion similar inheritance objectoriented programming number function called callbackfunctions must defined behavior work module called callbackmodule want start director process specify callbackmodule director callbackfunctions defined exported runtime director process call callbackfunctions different state explain callbackfunctions starting linked director process call one api function director startlink module module initarg director startlink module module initarg opts director startoptions director startlink registername director registername module module initarg director startlink registername director registername module module initarg opts director startoptions starting standalone director process call one api function director start module module initarg director start module module initarg opts director startoptions director start registername director registername module module initarg director start registername director registername module module initarg opts director startoptions calling director process call module init initarg possible return value type initreturn ok ok undefined director defaultchildspec ok director state ok director state director childspec ok director state director childspec director defaultchildspec ok director state director childspec director startoptions ok director state director childspec director defaultchildspec director startoptions ignore stop reason childspec childspec erlang map containing mandatory optional key belongs one child process explain key id key unique child erlang term understand usage key later key mandatory start key mfa module function argument mandatory director call erlang apply mod func args using value key starting child possible value key mfa module func atom module func atom module module startlink state key optional defined default value atom undefined state data child process inside director process understand usage key later type child process worker another supervisor key optional default value atom worker possible value supervisor sup short supervisor worker w short worker short supervisor terminatetimeout one director process terminating call director director child terminates alive child child using erlang exit childpid reason possible value atom infinity positive integer value director call erlang exit childpid kill otherwise value x call erlang exit childpid shutdown wait x millisecond termination child terminate x call erlang exit childpid kill key optional key type defined worker default value otherwise infinity delete director process termination state deletes child database list ets mnesia etc director process using one ets mnesia etc table keeping child using shared table one director stop restart child another director access table every child key false childspec default true module key optional default value element start mfa possible value module dynamic name callback module determine future example genevent process append usage director defaultchildspec want number child similar childspec option define default childspec return value child append true childspec combine default childspec default childspec like normal childspec except id append key default default childspec terminatetimeout module type worker delete true state undefined start option define start option two place calling director director return value start option erlang proplist following item db another erlang proplist following item table default list one list ets mnesia defined new table x name module directortablex define value table x initarg using list keeping child value matter mnesia ets must table name new database callback module value defined atom undefined given callbackfunction directortablex defined argument value value given delete one true false defined true termination director deletes table default true debug standard otpsys debug option type dbgopts dbgopt type dbgopt trace true log n nonneginteger event systemevent funcstate formfunc formatfun statistic file datetime reduction nonneginteger messagesin nonneginteger messagesout nonneginteger logtofile file iodevice func dbgfun funcstate term default nothing info see otp sys module spawnopt list spawn option info see otp type proclib spawnoption use option return value timeout much time process need initialization use option return value example module directortest export forget export record state state record director record chstate state record director child init myinitarg id start startlink myinitarg state chstate terminatetimeout id start startlink myinitarg state chstate ok state db table ets initarg mytable want child similar childspecs use default childspec child id id append true list seq defchildspec start foo start ok state child defchildspec childspecs id start foo start want simpleoneforone strategy otpsupervisor child id id append true start foo start list seq defchildspec start foo start ok state child defchildspec childspecs id start foo start director start child process call yourcallbackmodule handlestart childid childstate directorstate metadata example director start call directortest handlestart chstate state restartcount pid callbackfunction yield type handlestartreturn ok newchildstate director childstate newdirectorstate director state director callbackreturnoptions stop director childstate reason director callbackreturnoptions example tell director nt call errorlogger starting child handlestart chstate state ok chstate state log false child process crash director receive child exit signal call yourcallbackmodule handleexit childid childstate reasonofchildtermination directorstate metadata example exit reason oops director call directortest handleexit chstate oops state restartcount callbackfunction yield type handleexitreturn director action director childstate director state director callbackreturnoptions type action restart restart posinteger delete wait stop stop reason example tell director restart child millisecond handleexit chstate state restart chstate state define delete action child removed child table define wait action director nothing call director restartchild directorproc childid restarting child define stop director terminate error reason child crash define restart restart int child restart director restart child call metadata argument restartcount key plus one example following code director restart child id foo time restarts millisecond time finally terminates reason maxrestart foo time handleexit foo chstate reason state restartcount rc rc restart chstate state handleexit foo chstate reason state restartcount restart chstate state handleexit foo chstate reason state stop maxrestart foo chstate state call director director director terminates child process call yourcallbackmodule handleterminate childid childstate reasonofchildtermination shutdownkillterm directorstate metadata also call terminate state terminating alive child example call director terminatechild directorproc call directortest handleexit chstate shutdown state restartcount callbackfunction yield type handleterminatereturn ok director childstate director state director callbackreturnoptions example following code tell director nt call errorlogger termination child id bar call child handleterminate bar childstate directorstate ok childstate directorstate log false handleterminate childstate directorstate ok childstate directorstate default log value true director terminating terminating alive child call yourcallbackmodule terminate reasonoftermination directorstate example director terminating reason normal call directortest terminate normal state callbackfunction yield type terminatereturn ok callbackreturnoptions newerror newreason callbackreturnoptions example following code tell director change crash reason oops normal call errorlogger terminating terminate oops state newerror normal log false anything ok opts newerror opts cause director callerrorlogger exit crash reason build compile director make verifying dependency compiling director use dependency put deps rebarconfig rebar put deps rebarconfig director git http githubcompouriyajahanbakhshdirectorgit tag mix put deps mixexs director erlangmk depdirector hex api documentation projectsdirector make doc verifying dependency fetching edown pkg edown compiling edown compiling director running edoc director projectsdirector l doc grep md directormd directortableetsmd directortablemnesiamd readmemd todo add test something like otpsupervisor simpleoneforone strategy add complete example add documentation writing new directortable behaviour based module license bsd author pouriyajahanbakhsh gmailcom hex version
268,Lobsters,erlang,Erlang development,Promises in Erlang,http://stratus3d.com/blog/2017/04/28/promises-in-erlang,promise erlang,university kent concurrent programming erlang elixir task conclusion reference,recently took university kent concurrent programming erlang course hoping would learn new thing erlang vm programming erlang year little disappointed course covered basic aspect otp cover anything new overall material course well presented turned great way refresh knowledge erlang concurrency primitive promise implementation briefly presented joe armstrong caught attention want talk code sample joe presented stood way thing normally done erlang promise common javascript asynchronous message passing erlang really need promise task want run asynchronously background spawn link another process work wait message exit signal receive block need result also thing like elixir task module handle hide message passing struck simple implement simple promise erlang promise pid request tag erlang makeref pid self tag request tag yield tag receive tag response response end using function easy run task another process call promise function function tag promise existingpid fun io format expensive task end receive result need result yield tag need process id existing worker function pas pid function promise function promise function call erlang function return unique reference use response message ensures get thing confused lot promise message sent process time function sends function provided worker process message along reference wait message back worker process function function block waiting message back promise tag provided code running worker process show hard spawn process receives function message execute function send response message back caller pid spawnworker spawn fun workerloop receive pid tag requestfun work result requestfun send response back pid tag result workerloop end needed worker process call function spawn process executes recursive function loop forever handling request message executing function received sending result back message work ideal javascript pas function promise object get promise back use existing process execute function passed promise function spawn new process u automatically easy modify promise function promise executorfun tag erlang makeref self self workerfun fun work result executorfun send message result back caller process self tag result end spawn workerfun return reference use yield function tag spawn new process inside function executes function pas sends result back calling process message using promise function even easier call promise function function tag promise fun io format expensive task end receive result need result yield tag much better still room improvement javascript catch function add promise chain handle exception happen promise previous handler erlang really need catch function pattern match result returned function directly calling process currently something go wrong function executed promise process crash need handle exception may occur execution function happen wrapping function call try catch block sending different message back calling process process based outcome promise executorfun tag erlang makeref self self workerfun fun work response try executorfun result everything go planned return ok tuple response ok result catch error reason otherwise return error tuple exception type reason error error reason end send message result back caller process self tag response end spawn workerfun return reference use yield function tag needed promise function take function execute like promise object javascript spawn process run function sends message back calling process function returned crashed done le line code using new function handle exception easy create promise immediately crash pattern match value returned case statement crash promise process tag promise fun exit crash end thing get result promise need case yield tag ok result io format success error error reason io format failed p due p error reason end one block code executed thing go expected another run exception occurs see need chain callback function onto promise block need get result current process wait promise message received equivalent javascript closest get javascript chaining catch callback promise like new promise function throw crash function consolelog success catch function reason consolelog failed reason different callback executed asynchronously whereas erlang code yield function synchronous wanted asynchronous callback executed erlang promise variation would simply call inside function pas promise something like thencallback fun io format success end tag promise fun dosomework everything need thencallback execute callback function end conclusion used spawn send receive construct promise function yield function le line code promise function handle executing executor function another process catching error may occur sending appropriate message back calling process yield function handle receiving response message could also enforce timeout promise took long possible without erlang concurrency primitive ever use promise erlang thing like genserver elixir task hopefully blog post shown inherit flexible erlang concurrency primitive reference
269,Lobsters,erlang,Erlang development,Turing’s residuum,http://blog.ikura.co/posts/turings-residuum.html,turing residuum,search ideal co web address,search ideal co web addressget gone
270,Lobsters,erlang,Erlang development,An adventure into learning a bit of erlang,http://dmathieu.com/articles/development/learning-erlang-sayagain/,adventure learning bit erlang,fair number erlang component published book learn erlang getting started hello world erlang tcp server building something useful githubdmathieusayagain saytcpsup listener parse data sent resp execute command next,common knowledge heroku fair number erlang component even published book joined year ago barely heard tried get better grasp platform work wanted learn erlang component work better understanding erlang took roughly year obviously full time started reading learn erlang point amazed language offered yet understand kind fell love tell wife functional programming pattern matching practice stopped caring almost two year last fall went back successfully time want share article getting started seems erlang documentation assumes either already working application simple console getting started building new app barely documented fact fairly simple use definitely come obvious thing manager rebar package available seems rebar even github organization end available package manager homebrew required manually compiling moving path ended storing compiled binary inside dotfiles repository hello world able install bootstrap new app thing went lot smoothly within week working minute hour week day able boot simple erlang tcp server tcp server linked much responds exactly content request sent work point love language time process supervisor mechanism attracted attention realizing able write equivalent unicorn line erlang opened lot possibility building something useful idea actually build something useful something something mime artist answer told started building keyvalue store make fun missing mime artist made mimick redis idea erlang tcp server understand redis client three command get set flushall built adding command would straightforward go entire code available githubdmathieusayagain best joke explained exception one french mean moi translated hence name sayagain process started app look like following apps nicer process graph one quite selfexplanatory app work say guy wrote app absolutely biased saytcpsup supervisor boot tcp listener pool default app idle always process waiting new connection new connection come assigned one listener minion start booting new listener process another request parse data sent expecting resp data parsed get tuple similar get hello execute command get andor mutate data return value redis expects command finally go back command parser time parse erlang tuples back readable redis line code including tcp server spent time benchmarking yet architecture allow handle thousand client parallel next awesome learning experience play erlang love get syntax factor preventing people trying first one get feeling reason started playing elixir time building small api might hear coming month get bored sure though learning erlang giving better inspiration daytoday work apps building go ruby word making better programmer
271,Lobsters,erlang,Erlang development,"Lists, Maps and Commas – Erlang Battleground",https://medium.com/erlang-battleground/lists-maps-and-commas-e5132d7d6e0c,list map comma erlang battleground,many map compile thread,many map quick question many map following list b c even compile people following erlangquestions mailing list might know already correct answer compile error well missing comma second rowbut compile written perfectly valid expression course match syntax used record pointed thread module sample record export bug foof comma missing function shell return list element rr sample sample bug foof undefined
272,Lobsters,erlang,Erlang development,"Aaargh!! - Macros, Parse Transforms and others @ Erlang Battleground",https://medium.com/erlang-battleground/aaargh-a7dc940f8d0f,aaargh macro parse transforms others erlang battleground,weird module module define ifdnef compile endif macro doc module define ifndef compile endif tell module define,weird modulethis basically module john sent mailing list changed name easier avoid apostrophe weird define pleasedont ifdnef pleasedont compile parsetransform undefinedparsetransform endifthe idea first define pleasedont macro line later comment needed rather remove define macro compile time macro defined run code parse transformation called undefinedparsetransform key point parse transformation module exist line compilebut macro defined parse transform used right erlc weirderlsrcweirderl undefined parse transform undefinedparsetransformand macro turn macro defined alex point mailing oneargument define see doc macro defined follows define const replacement define func varn replacement change define line weird define pleasedont true ifndef pleasedont compile parsetransform undefinedparsetransform compiles perfectly erlc weirderl l weirdbeamweirdbeamwhy tell right easy oneargument define compilerparser warned u check module weird define pleasedont try compile erlc badly formed define
274,Lobsters,erlang,Erlang development,The BEAM Book (Exhaustive book on Erlang/Elixir VM),https://github.com/happi/theBeamBook,beam book exhaustive book erlangelixir vm,beam book latest stable release online webpage bookasciidoc github io page contributing style guide comment asciidoc linking otperlang source code directory structure build tag chapter section figure process issue tracker building pdf locally source docker dcokerasciidoctor linux mac osx asciidoc asciidoctorpdf asciidoctordiagram ditaa graphviz rouge wget mac osx using brew etc license http githubcomhappithebeambook short personal history book,beam book attempt document internals erlang runtime system erlang virtual machine known beam read download book pdf latest stable release online webpage book written asciidoc read directly source github browser read book online open file bookasciidoc also read github io page contributing plan make book project collaboration effort get complete documentation erlang runtime system soon possible please feel free contribute since work far done contribute raising issue comment open issue create branch fix addition note book released creative common license see anything contribute also included license chapter book one four state placeholder basically title perhaps outline chapter done interested writing chapter part chapter grab corresponding issue start writing first draft text place editing needed feel free comment focusing missing content hard read passage order section within chapter diagram picture needed plain error final draft spelling error probably still need fixing done otp version x thing change later version erlang otp chapter need update chapter yet marked way style guide several way use asciidoc construct work better environment target priority asciidoc code project render nicely following target following order pdf target html target view directly github try come specific guide asciidoc construct use add discover work nt work comment asciidoc chapter begin comment status chapter one placeholder first draft final draft done erlang xx also link issue describing needed bring chapter next level comment code start linking otperlang source code refering source code erlangotp please add link tagged version master code github link http erltimeh directory structure build try keep root directory clean put chapter separate asciidoc file chapter directory use underscore separate word chapter name try use oneword file name chapter put code used chapter codechapternamechaptersrc add include code apcodelistingsasciidoc put image image directory tag chapter section figure following yet done consistently please feel free contribute fixing tag current version chapter tag start ch word tag separated underscore part tag start p section tag start sec figure tag start fig appendix tag start ap code listing tag appendix start listing process find something understand incorrect please raise issue issue tracker find spelling formatting error feel free fix make pull request larger rewrite check status chapter check issue see someone likely working chapter right someone else working chapter try contact person major rewrite otherwise either go ahead rewrite pull request start opening issue declaring intend building pdf locally source project contains makefile let build pdf source provided needed tool installed docker docker image asciidoctor available dcokerasciidoctor linux wip updated mac osx install asciidoc install asciidoctorpdf install asciidoctordiagram install ditaa install graphviz install rouge install wget make mac osx using brew etc brew install asciidoctor gem install asciidoctorpdf gem install asciidoctordiagram brew install ditaa brew install graphviz gem install rouge brew install wget make license erlang runtime system erik stenman licensed creative common attribution international license based work http githubcomhappithebeambook complete copy license found short personal history book erik stenman happi started writing book back first thinking self publishing book blog since english nt native language felt needed help good editor managed get deal oreilly started converting outline build process original plan long thorough book editor felt would get reader started cutting content tried write tutorial manual unfortunately progress slow presales even slower publisher cancelled book managed get new deal pragmatic started converting content build system rewriting book according pragmatic style new publisher cutting content even series editor also wanted fit book elixir series tried add elixir example really manage make elixir book also progress still slow led another cancellation book early three repository three different book building system three different outline book end le went back original longer book outline original asciidoc build system started new repository private github account started pulling content three different version april opened repository public share student nt think anyone else would notice planning release book real yet since repo currently contains bit piece different version book interest expected though fortunately also several willing contribute book collaborative effort document erlang runtime system ert released creative common license see watch space news see whole book take shape erik stenman aka happi
275,Lobsters,erlang,Erlang development,Unbalanced Parentheses – Erlang Battleground,https://medium.com/erlang-battleground/unbalanced-parentheses-6634140c6adb,unbalanced parenthesis erlang battleground,usual suspect module export spec module export spec,usual suspectsthis perfectly valid erlang module module mymod export spec whoami atom whoami mymodyou compile execute c mymod ok mymod mymod whoami also perfectly valid erlang module using macro module mymod export spec whoami atom whoami moduleas expected c mymod ok mymod mymod whoami
276,Lobsters,erlang,Erlang development,The elephant in the room,https://ninenines.eu/articles/the-elephant-in-the-room/,elephant room,convincing people use commit catch attention,ever tried telling someone use erlang boast smaller code size auto healing mechanism distribution seem really excited wonder never heard erlang show code look like excitement go away smile disappear face start becoming really serious lost know lost comment syntax perhaps already admitting defeat unlike anything ever used likely end using people already know syntax look like soon mention erlang topic syntax come like nothing else matter perhaps topic syntax nt come still going try erlang probably kind interaction erlang conference nt happen people already somewhat interested need feature erlang provides syntax worst minor inconvenience happens developer familiar syntax look nothing like erlang clear include language feature concept like object part syntax familiarity important factor drive adoption see example elixir world majority people come ruby already knew liked ruby survey tell u elixir developer using ruby primarily large part syntax deny course find reason yet nt see strong adoption erlang ruby developer elixir appeared side note ever wondered elixir community quote much friendlier ruby community despite much people continue let clear love erlang syntax simple explicit powerful especially dealing binary data quirk little ambiguity great except persuading people use year writing erlang seen people point syntax slows adoption problem would others time people coming erlang come solve real problem syntax fairly secondary even hate first know solve problem despite syntax nt build popular product language solving people problem though general end solving problem creating new problem build popular product convincing people use make stay product making commit using take mongodb example nt become popular working even practical nt performing primary function losing people data nt stop becoming popular smart people would knowingly use database losing data think minute mongodb course huge marketing machine focused helped organize many meetups world complete various swag item given free including small handbook mongodb people show nt go tell people look weakness product focused strength would convince people try would go meetups discus others commit try try meetups directly sell mongodb get people meetups though first step need catch attention believe mongodb using benchmark result ironic nt mongodb get fast benchmark result lose data get everyone buy product key point remember catch people attention show product strength make people take commitment commit something win everyone end ultimately using product course least become consideration mind resolve stronger ultimately try inevitably run issue erlang syntax weakness almost nobody look erlang syntax fall love first sight take time learn understand good need sell erlang people without showing erlang syntax show need hide part feel alien function call ok recursion much map ok record avoiding code always possible try sell especially developer however prepare accept alien syntax admitting syntax perfect show praising time example syntax little match concept perfectly make sense start learning might best introduction someone need ab test find one give best result give idea something terrible happens mentioning nt end world tell others happened soften reaction someone break favorite item cry calling stupid harder get mad compared event emotional reaction behavior largely dependent top mind take advantage make case best condition next time try make someone use erlang remember aim getting spoken commitment possible show syntax possible prepare accept flaw weirdness see
277,Lobsters,erlang,Erlang development,Alpaca – Functional programming inspired by ML for the Erlang VM,https://github.com/alpaca-lang/alpaca/,alpaca functional programming inspired ml erlang vm,alpaca tldr use installing alpaca available repository release page plugin documentation using alpaca project tour language basic building using alpaca editor support intentionsgoals ocaml elm eunit work already licensing contribution help freenode using eunit prerequisite writing alpaca tsloughter alpaca plugin compiler hacking builtin stuff language tour pattern matching map module erlang kind test process current ffi localization problem missing http lfe implementation issue parsing approach ast construction type inferencing checking http okmijorgftpmlgeneralizationhtml http githubcomtomprimozictypesystemsblobmasteralgorithmw single module typing ets recursion type,alpaca alpaca statically typed stricteagerly evaluated functional programming language erlang virtual machine beam present relies type inference provide way add type specification toplevel function value binding formerly known mlflavoured erlang mlfe tldr use make sure following installed installing alpaca release otp built travis ci available repository release page want one following unpack anywhere point environment variable alpacaroot base folder place beam subfolder following location usrlibalpaca usrlocallibalpaca optalpaca please see plugin documentation detail using alpaca project make new project new app yourappname rebarconfig file project root folder eg yourappnamerebarconfig add following plugins rebarprvalpaca git http githubcomalpacalangrebarprvalpacagit branch master providerhooks post compile alpaca compile check tour language basic put source file ending alp source folder run compile andor eunit building using alpaca rather using official build build test version alpaca please note alpaca need order build basic step clone andor modify alpaca suit need compile build compile make local untagged release use bash makereleasesh root folder alpaca export alpacaroot eg alpaca folder export alpacaroot pwd alpacaunversioned plugin find alpaca binary built editor support alpaca plugins available various editor intentionsgoals something look operates little bit like ml erlang vm static typing deliberately ignoring typing erlang code call alpaca parametric polymorphism infinitely recursive function distinct allowable type process looping receive recursive data type syntax somewhere ocaml elm ffi erlang code allow return value typed term simple test annotation something like eunit test live beside function test still rough incomplete set wish future might nice dialyzer check type coming back ffi suggest possible union type nt appropriate one scope work already type inferencer adts tuples map record product type union sum please note alpaca record compatible erlang record former currently compiled map compile typechecked source beam binary simple ffi erlang typesafe message flow process defined inside alpaca example module module simpleexample basic toplevel function let x x let somethingwithletbindings x function let adder b b variable immutable let adder x x polymorphic adt type message x x fetch pid x function spawned receive message int message increment state received integer queried state let willbeaprocess x receive willbeaprocess x fetch sender let sent send x sender willbeaprocess x let startaprocess init spawn willbeaprocess init licensing alpaca released term apache license version copyright jeremy pierre licensed apache license version license may use file except compliance license may obtain copy license http unless required applicable law agreed writing software distributed license distributed basis without warranty condition kind either express implied see license specific language governing permission limitation license contribution help please note project released contributor code conduct version participating project agree abide term see codeofconductmd detail join alpacalang freenode discus language direction improvement get help irc channel governed code conduct detailed repository pull request improvement bug report accompanying test welcome using still quite early alpaca evolution test give relatively clear picture going testfiles contains example source file used unit test call alpaca compile file list file name string list option alpaca compile text codeasastring option generally recommend using plugin supported option test option cause test module type checked exported function eunit pick warnexhaustiveness boolean set true default compiler print warning regarding missed pattern top level function error compiler eg type error almost comically hostile usability moment see test alpacatypererl prerequisite generally want following two thing installed writing alpaca thanks tsloughter alpaca plugin pretty easy get running make new project substituting whatever project name like alpacaexample new app alpacaexample cd alpacaexample rebarconfig file project root folder add following borrowed tsloughter doc plugins rebarprvalpaca git http githubcomalpacalangrebarprvalpacagit branch master providerhooks post compile alpaca compile file project source folder end extension alp compiled included output folder provided typecheck compile successfully course simple module open srcexamplealp add following module example export let add x x look like module named example function add two integer call function directly erlang shell compiling like note alpaca prepends alpaca module name erlang shell must explicitly add shell compiler output skipped alpacaexample add note calling alpaca erlang wo nt type checking written variety alpaca module project interaction type checked safe provided compile succeeds compiler hacking installed prerequisite given clone repository run test dialyzer eunit dialyzer command line frontend compiler unless use tsloughter plugin detailed previous section need boot erlang shell run alpaca build typecheck thing written alpaca example wanted compile type import test file testfiles folder shell file testfilesbasicadtalp testfilestypeimportalp alpaca compile file file result either error list tuples following form compiledmodule modulename filename beambinary file actually written compiler binary described tuples either loaded directly running vm see test alpacaerl written manually unless course using aforementioned plugin builtin stuff basic erlang data type supported booleans true false atom atom quoted atom float integer string string encoded binary character list like default erlang string c character list binary 안녕 text typeint signedfalse etc tuples tuple arity map basic support eg atomkey string value statically typed list generic parametric polymorphism record basic support look bit like ocaml elm record eg hello world produce record x int hello string field please see language tour detail pid also parametric like list generic including type something like type int pid int type cover integer process receive integer addition unit type expressed note tuple example typed tuple arity requires member type string atom string integer order top define adts eg type try success error ok success error error adts basic type union work eg type json int float string bool list json list string json type start lowercase type constructor uppercase integer float math use different symbol ocaml eg ok type error type error ok basic comparison function place type checked eg work guard function ok type error hello world ok type error see srcbuiltintypeshrl included function pattern matching pretty simple straightforward let length l match l h length first clause nt start since treated like logical pattern match guard clause essentially assert type eg evaluate tbool type match x b isbool b b match x f isinteger isfloat f sometuple type tuple integer float since string currently compiled erlang binary first clause ever match type mybinarystringunion binary string match hello world b isbinary b b isstring nullary type constructor encoded atom unary constructor tuples led atom eg type mylist x nil con x mylist x nil become nil compilation con nil become con nil exercise caution order pattern match clause accordingly map distinction made syntactically map literal map pattern v erlang eg match mymap akey someval someval course use variable match map could write simple getbykey function follows type myopt none let getbykey k match k v v none module erlang kind mlstyle module nt implemented present module alpaca module erlang toplevel entity including module name required function export arity erlang type import eg use moduletype type declaration adts function contain function variable via let binding function automatically curried limitation simple test definition example module try export separate multiple export comma type variable start single quote type maybesuccess error ok error error success ok apply function successful result preserve error let trymap e f match e error e success ok success f ok test test expressed extremely barebones manner right nt even proper assertion available compiler invoked option test following synthesize export function called let add x x test add let re add assertequal re let assertequal x match x true ok throw notequal x test throw exception fail would work replaced add x x get failing test use plugin mentioned eunit run test written bug currently first test run wo nt execute test run sure yet expression make test body type inferenced checked type error test always cause compilation error process example let f x receive sender let z x let sent send z sender f z let startf init spawn f init type checked including spawn message sends expression contains receive block becomes receiver associated type type inferred f following treceiver ttuple tint tpid tint tarrow tint trec mean f function type tarrow part also contains one receive call handle tuples integer pid receive integer f function type one take integer infinitely recursive send return unit notationside effect support moment hence let binding spawn moment start function defined module called within simplify crossmodule lookup stuff time intend support spawning function module fairly soon note following yield type error let x receive b x let b x receive f x b tfloat receiver tint receiver adding union type like type int float solve type error spawn function nowhere call graph pose receive block pid typed undefined mean message sends process type error current ffi ffi quite limited present operates follows beam amodule afunction different argument ok ok error error clearly room provide version skip pattern match succeeds dialyzer supply return type function match type scope union otherwise worth noting ffi assumes know check module function calling exist localization compiler error message may localized calling alpacaerrorformat translation available specified locale translation enus used localization performed using gettext po file stored privlang add new language say swedish svse create new file privlangalpacasvsepo use poedit may import message translated selecting catalog update pot file menu pick privlangalpacapot message may bit cryptic use enus aid understand pot file automatically updated whenever alpaca compiled update pofiles also picked compile phase problem missing incomplete list self little tricky type typesafe solution spawn process send pid still thinking better exception handling trycatch sort standard library biggest missing thing right thing like basic string manipulation function adapter genserver etc anything like behaviour thing would support trait type class ml module etc smell like supersets nt definite direction yet simpler ffi open issue discussion http annotation beam file output source line number etc hard based seen lfe code base support typing anything raw source file side effect like using ocaml printing function nonunit result implementation issue process learningwhiledoing number issue code including limited lot cruft around error handling refactored sort basic monadlike thing extremely evident alpacaastgenerl alpacatypererl frankly latter begging complete rewrite type unification error line number confusing sequence unification step sometimes unification error might occur function variable location match expression rather clause considering tracking history change course unification reference cell order provide typing trace user generalization type variable incompletely applied parsing approach parsingvalidating occurs several pass yecc initial rough syntax form basic module structure export toplevel function definition collected initial construction ast completed validating function definition binding inside stage us environment track whether function application referring known function variable output stage either module definition list error found stage also renames variable internally type checking awkward overlap environment built previous step may benefit interleaving point argument mixing might function defined type checking permit forward reference ast construction several pass internally source file module validate function definition report syntax error eg params neither unit variable binding socalled symbol yecc parser building list toplevel internalonly exported function module output global environment containing exported function module environment toplevel function per module list found error function defined module check every variable function reference valid function application arity checked function applied variable type inferencing checking present based sound eager type inferencer http okmijorgftpmlgeneralizationhtml influence http githubcomtomprimozictypesystemsblobmasteralgorithmw arrow type type schema instantiation concerned single module typing module example export let add x adder x let adder x x forward reference permitted currently lead wasted work typing typer encounter reference yet bound environment available module definition typer look ahead module definition determine type use type throw work away proceeding type may beneficial leverage something like ets near term recursion infinitely recursive function typed permitted necessary process loop receive bidirectional call module disallowed simplicity mean given module b call occur function b opposite direction think generally pretty reasonable bidirectional reference probably indicate failure separate concern additional benefit bounding complicated inferencing set mutually recursive function get case particularly concerned illustrated following modulefunction example let ax let cz let cz ax loop belive possible check necessitates either great deal state tracking complexity enormous amount wasted work likely nasty corner case yet unaware mechanism preventing simple relatively naive start entering module type inferencingchecking add module list module encountered pas call occurs function application cross module boundary check see referenced module already list entered module type checking fails error type currently rootbottom type going problem something like simple printlnprintf function simple use version would best take list ffi erlang code get around type checking argument passed checking result portion pattern match
278,Lobsters,erlang,Erlang development,Serving Erlang,http://blog.ikura.co/posts/serving-erlang.html,serving erlang,search ideal co web address,search ideal co web addressget gone
279,Lobsters,erlang,Erlang development,Avoiding race conditions in GenServer,https://bhelx.simst.im/articles/avoiding-race-conditions-in-genserver-state/,avoiding race condition genserver,hidden race condition checkthenact atomic operation client side server side bottleneck holistic approach exactor,suppose making multiplayer game choosing store state game struct game game start without player player individually choose join game determined must maximum number player maxplayers player represented list string player nickname defmodule game maxplayers defstruct player def addplayer game nick mapupdate game player nick end def maxplayers player p length p maxplayers false def maxplayers game true end try iex iex game game game player iex game gameaddplayer game ben game player ben iex game gameaddplayer game harry game player harry ben iex game gameaddplayer game ralph game player ralph harry ben iex gamemaxplayers game false iex game gameaddplayer game tom game player tom ralph harry ben iex gamemaxplayers game true seems working need way wrap process otp provides number way case going use genserver game get isolated process identified pid create genserver call gameserver defmodule gameserver use genserver def startlink genserverstartlink module game end def getstate pid genservercall pid getstate end def addplayer pid nick game getstate pid gamemaxplayers game error maxplayers else genservercall pid addplayer nick end end callback def handlecall getstate game reply game game end def handlecall addplayer nick game reply ok gameaddplayer game nick end end two call getstate return current game state addplayer return error reason player added ok otherwise try iex iex ok pid gameserverstartlink ok pid iex gameserveraddplayer pid ben ok iex gameserveraddplayer pid harry ok iex gameserveraddplayer pid ralph ok iex gameserveraddplayer pid tom ok iex gameserveraddplayer pid richard error maxplayers hidden race condition seems working repl deployed production may find every even player sneak code race condition prove adding temporary function gameserver add n player simultaneously defmodule gameserver def addplayerssimultaneously pid nick enumeach nick fn nick taskasync fn gameserveraddplayer pid nick end end end end function take list nick call addplayer simultaneously one process per nick try player attempting join iex ok pid gameserverstartlink ok pid iex nick ben harry ralph tom richard ben harry ralph tom richard iex gameserveraddplayerssimultaneously pid nick ok iex gameservergetstate pid game player richard tom ralph harry ben wait richard get erlang process model great way handle concurrent operation state done right quite hard mess state way need think little front mutating state order demonstrate happening add put gameserveraddplayer function defmodule gameserver def addplayer pid nick game getstate pid ioputs player game inspect gameplayers gamemaxplayers game error maxplayers else ioputs add player nick genservercall pid addplayer nick end end end run iex ok pid gameserverstartlink ok pid iex nick ben harry ralph tom richard ben harry ralph tom richard iex gameserveraddplayerssimultaneously pid nick player game player game player game player game player game ok add player ben add player harry add player ralph add player tom add player richard classic checkthenact race condition important remember way genservers work operate message mailbox one time order received getstate message come server process return current state every player see stale state new message come add player game state order fix need make addplayer atomic operation genserver make easy u process model ensures everything happens callback atomic need move logic addplayer callback defmodule gameserver removed maxplayers check def addplayer pid nick genservercall pid addplayer nick end checking inside callback def handlecall addplayer nick game gamemaxplayers game reply error maxplayers game else reply ok gameaddplayer game nick end end end trying iex ok pid gameserverstartlink ok pid iex nick ben harry ralph tom richard ben harry ralph tom richard iex gameserveraddplayerssimultaneously pid nick ok iex gameservergetstate pid game player ralph tom harry ben state consistent like expect richard tried join would see maxplayers error nice thing semantics genserver think code term client server public api function top module happen calling process client side handle callback happen server process server side maintain mental model becomes obvious side code belongs bottleneck may tempted throw everything server side safety need consider performance implication writing callback asking minimal operation need determine next state important remember callback happen one time easily become bottleneck careful performing long operation particularly network operation callback get away somewhere else holistic approach although work example genservers state suggest problem deeper root cause design flaw game datastructure designing new datastructure good idea guard ever getting invalid state logic keeping structure consistent belongs module encourage programmer use interface manipulate structure return descriptive error something wrong case might change interface game module instead something like defmodule game maxplayers defstruct player def addplayer game nick maxplayers game error maxplayers else ok mapupdate game player nick end end defp maxplayers player p length p maxplayers false defp maxplayers game true end leave genservers pretty bare believe good thing consider something like exactor make even smaller
280,Lobsters,erlang,Erlang development,A tour of Elixir performance & monitoring tools,https://hackernoon.com/a-tour-of-elixir-performance-monitoring-tools-aac2df726e8c#.b2v3ch2m1,tour elixir performance monitoring tool,tour elixir performance monitoring tool nasa mission control room metric collection exometer exometer recording metric storing metric reporting metric michael schäfermeyer elixometer elixometer beam resource usage observer observer wombat wombat recon recon application monitoring appsignal app monitoring agent scout learn new relic communitydeveloped agent new relixir newrelic roman smirnov take tracing profiling recon trace recon trace tap tap erlyberly elyberly getting started guide elyberly redbug redbug redbug tutorial dbg dbg dbg exception monitoring honeybadger experience elixir,tour elixir performance monitoring toolsworking bookletai cofounded scout server monitoring acq scoutapm acq nasa mission control roomupdated appsignal exited beta scout released beta agentyou diving elixir getting close releasing first production elixir app profile monitor production tour available elixir ecosystem today note many tool erlangbased access via elixirmetric collectiongeneric metric collection sensor array app counter user signups collecting average call time critical http call etc service assist collecting aggregating metric send metric another service ex graphite influxdb datadog etc visualization alertingexometerulf wiger magnus feuer exometer defacto erlang instrumentation package several part exometer recording metric tell exometer update value exometer run function interval choosing record valuesstoring metric raw metric stored via etf beam vmreporting metric metric aggregated forwarded onto external system like graphite amnq statsdthe following story michael schäfermeyer provides great overview exometer elixometerpinterest elixometer light elixir wrapper around exometer make definingupdating metric easier plus nice timed annotation easily time function execution time timing function metric name timed function key prefixdevtimerstimedfunction timed key timedfunction def functionthatistimed othermoduleslowmethodendbeam resource usagethere several tool monitoring resource usage beam vm run elixr erlang apps beam feel like operating system versus typical vm monitoring tool sophistication matchobserverthe default goto observer likely already installed computer try launching observer via iex observer also connect remote systemwombata fullfeatured operation maintenance framework wombat commercial software available via erlang solutionsreconrecon one module erlang recon application module provides access highlevel resource usage information beam vmfor example iex reconinfo self meta registeredname memoryused memory messagequeuelen heapsize totalheapsize garbagecollection maxheapsize errorlogger true kill true size minbinvheapsize minheapsize application monitoringapplication performance monitoring apm service instrument elixir function call provide breakdown performance via transaction trace apm tool orientated around monitoring web request v general performance monitoringappsignalappsignal officiallysupported app monitoring agent elixirscoutat day job released app monitoring agent elixir learn morenew relicnew relic officially supported agent couple communitydeveloped agent available new relixirnewrelic author newrelic module roman smirnov mentioned response newrelixir trigger performance memory cpu issue triggered newrelicerlang module address issuesmy take app monitoring magical form monitoring get lot little work however making magic happen involve hook application cause crash reason lean towards service official support team dedicated keeping monitoring agent updatedtracing profilingsometimes need walk application execution framebyframe debug issue several tool provide erlang elixir appsrecon tracepart previously mentioned recon application recon trace erlang module allows safe tracing function production environmenttaptap thin elixir wrapper around recon trace providing easy elixir interface recon trace iex require tapniliex tapcall stringstrip max stringstrip test e pid stringstrip test pid e erlyberlyelyberly provides gui interface debugging profiling erlang elixir apps addition tracing elyberly collection information process memory usage elyberly meant trace production system overload protectionthe folk plataformatec great getting started guide elyberlyredbugredbug productionsafe debuggingtracing utility erlang roberto aloi great redbug tutorial blogdbgdbg erlang module tracing also thin elixir wrapper around dbg monitoringmany existing exception monitoring service already support elixir elixir erlang unique take exception important see service exception logic match needssome option take prefer service use language monitor production firsthand experience monitoring pain honeybadger experience elixir production appssubscribe get daily roundup top tech story
282,Lobsters,erlang,Erlang development,Building A Slack Bot in Elixir Part 2,http://bendyworks.com/blog/building-a-slackbot-in-elixir-part-2,building slack bot elixir part,building slack bot elixir part first part receiving slack message incoming outgoing bot user setting hook custom integration ngrok localtunnel receiving webhook predicting weather darksky api dependency httpoison poison keeping secret making request responding slack putting together spawn next step exvcr area forecast discussion floki,building slack bot elixir part first part tutorial covered basic defining running testing web server elixir using plug cowboy part tutorial build groundwork create slack bot fetch sends weather forecast receiving slack message tutorial using slack incoming outgoing webhook apis handle message traffic note slack also provides feature rich bot user api using simpler solution focus implementing elixir side le particular slack api setting hook begin need register new incoming outgoing webhook slack custom integration page notice outgoing webhook requires target url address slack send request unsurprisingly must publicly accessible could set application server control paas provider heroku much easier iterate make change app use localhost tunnel ngrok localtunnel development use ngrok set tunnel port app run running ngrok http ngrok provide url set outgoing webhook target also recommend defining trigger word forecast weatherbot wb otherwise easy accidentally get bot stuck loop triggering response receiving webhook verify slack integration set properly let define webhook route return ok simple response message add post route routerex following definition post webhook sendresp conn text ok end everything set correctly get response ok enter trigger word slack predicting weather fetch weather prediction using darksky api free tier allowing request per day following along go ahead sign account make note secret key given dependency need new dependency interact dark sky api httpoison making http request poison parsing json response see elixir follows ruby footstep regarding odd thematically appropriate library name refer readmes project previous post series instruction adding library elixir app keeping secret planning saving project via github another publicly accessible vcs solution want make sure nt commit dark sky api key incoming slack webhook set easy way accomplish without complicating application configuration create configsecretexs file config directory add gitignore instruct application load adding importconfig configsecretexs main configexs file example configsecretexs look like use mixconfig config weatherbot incomingslackwebhook webhook url config weatherbot darkskykey darksky key making request organize function interacting dark sky api let create new module libweatherbotweatherfetcherex following definition defmodule weatherbotweatherfetcher darkskyurl http apiforecastioforecast applicationgetenv weatherbot darkskykey def getforecast httpoisonget darkskyurl body poisonparserparse end def hourlyforecast getforecast mapget hourly mapget summary end def dailyforecast getforecast mapget daily mapget summary end def dailyandhourlyforecasts hourly hourlyforecast daily dailyforecast end end test new module opening iex prompt iex mix calling weatherbotweatherfetcherdailyandhourlyforecasts let break component part new function first fetching dark sky key via call applicationgetenv weatherbot darkskykey second line also unless really interested receiving weather forecast bendyworks hq want change latlong number end url fetch forecast data making call via httpoisonget api endpoint passing response body poisonparserparse case unfamiliar convention elixir generally mean function unsafe throw exception circumstance take parsed response represented map extract daily hourly summary combined via heredoc sigil build response responding slack create another new module libweatherbotslacksenderex sending forecast slack defmodule weatherbotslacksender def posttoslack encodedmsg httpoisonpost applicationgetenv weatherbot incomingslackwebhook encodedmsg end def sendmsg msg poisonencode username forecastbot iconemoji cloud text msg posttoslack end end module nearly reverse one wrote receive outgoing webhooks encodes json payload poisonencode post incomingslackwebhook url defined configsecretexs weatherbotweatherfetcher module test new functionality opening new iex prompt calling recompile existing one running weatherbotweatherfetcherdailyandhourlyforecasts weatherbotslacksendersendmsg putting together route router receive outgoing webhooks module fetch weather forecast dark sky api another module send forecast back slack wire together need make slight modification behavior webhook route although slack longer requires timely response outgoing webhook request still leverage elixir excellent concurrency facility friendlier responsive api consumer post webhook spawn fn weatherbotweatherfetcherdailyandhourlyforecasts weatherbotslacksendersendmsg end sendresp conn text ok end spawn new elixir process manage fetching forecast sending slack allow current process immediately respond original webhook request weather forecasting slack bot ready go run application mix run nohalt case forgotten able get forecast entering outgoing webhook trigger word slack next step fully functional weather forecasting slack bot lot could build simple app interested extending built far idea using exvcr write robust network independent unit test taking zip code address argument geocoding latlong using different iconemoji param depending weather condition delivering area forecast discussion requires web page scraping parsing coming ruby familiar nokogiri floki good elixir equivalent implementing complex behavior able ask rain today need jacket
283,Lobsters,erlang,Erlang development,Concurrent Programming in Erlang Course,https://www.futurelearn.com/courses/concurrent-programming-erlang/1,concurrent programming erlang course,,minute second simon thompson real world concurrent natural think different activity going independently interacting passing information similar way great way writing program think writing program collection separate process communicate passing message model ericsson programming team chose use wanted build ideal programming language programming telecom system erlang used program sort webscale application need fault tolerant robust reliable example used program whatsapp messenger process billion message day minute second erlang concurrency impact moment provides clean model program interact world multiple request coming example handled multiple process inside erlang virtual machine erlang also map well onto modern hardware see process executed concurrently multicore chip also erlang model scale work distributed way across network process expect got programming experience coming course teach basic concurrency scalability robustness also expect write simple erlang function put module run minute second installed erlang able write program put idea practise well joe armstrong one inventor erlang francesco cesarini founder erlang solution big consultancy company area helping u present session also taking part wideranging discussion erlang concurrent programming general end three week appreciation message passing concurrency erlang also build robust scalable system erlang otp also experience writing erlang concurrent program
284,Lobsters,erlang,Erlang development,Hot routes with cowboy (Erlang),http://blog.ikura.co/posts/hot-routes-with-cowboy.html,hot route cowboy erlang,search ideal co web address,search ideal co web addressget gone
285,Lobsters,erlang,Erlang development,Introducing PureScript Erlang backend,http://nwolverson.uk/devlog/2016/08/01/introducing-purescript-erlang.html,introducing purescript erlang backend,compiler fork available purerl overview type output purescriptfunctions ffi pattern matching list tuples friend purescripterllists purescripterltuples core library step atom code,sure decided create erlang backend purescript compiler platform somewhat interesting know particular use case know head sure one consider implementation long time uploaded anything kept quiet time anyway bag compiler fork available along port various library purerl organisation overview new compiler executable pserlc introduced compiles purescript erlang source take approach javascript backend attempting produce reasonable readable output place leaf little desired others translation come pretty neatly ffi provided via erlang source file function compilation pscide psci etc yet supported type purescript type erlang type int integer number float boolean boolean string string array array record atom tagged union tuple tag element erlang data type immutable work nicely target functional language number unbounded mapped primitive numeric type string currently represented erlang string simply list character simply integer simple straightforward per haskell string probably bad idea reason elixir us binary representation string maybe array entirely obvious array special status purescript compiler notation construction instance provided various core library make easy interoperate javascript array performance characteristic often poor erlang builtin immutable functional array implemented tree give good lookup performance log n reasonable immutable update performance case however api somewhat lean compared list case simple implementation many typeclass instance currently provided via roundtripping list clearly ideal unfortunate native list easily used syntax pattern matching record come nicely erlang map giving simple representation construction update tagged union represented tuples eg nothing simply nothing output purescript module correspond erlang module name mangling datalist come datalist ffi module separate datalist foreign reexported via main module required top level identifier purescript module translated function erlang module support nonfunction value every definition translated nullary function returning translated value example x int x id forall id x x translates x id fun x x end erlang function higher arity appear generated code purescriptfunctions used deal tupled function ffi support autocurrying import erlang syntax unfortunate precedence function call application curried function f b f b instead must f b combined imperfection code generation compiler output currently contains staggering number parenthesis pattern matching pattern matching purescript translated pattern matching erlang output example consider maybe maybe forall b b b maybe b maybe b nothing b maybe f f output whitespace adjusted maybe fun v fun fun fun b nothing b f f end v end end end function call used rather case expression due scope course uncurried function would much simpler maybe b nothing b maybe f f thing work nicely come nested pattern nothing u guard expression hand mixed bag simplest guard become guard erlang output isjust forall maybe boolean isjust case true true false isjust fun v fun true true false end v end however erlang guard expression restricted contain arbitrary expression like function call fact trivial guard boolean variable one translated directly complex expression must first evaluate guard expression start pattern match due fact guard expression generally make use binding pattern match end pattern match expression output islarge maybe int boolean islarge case n n true false islarge fun v begin fun n dataord greaterthan dataord ordint n false end v fun n true false end v end end expression n evaluated initially used guard match able inline typeclass dictionary expression n would suitable inclusion guard directly list tuples friend datalist used representation reasonable coincide erlang list native erlang list provided via purescripterllists may efficient could useful interfacing erlang library con operator provided data constructor used pattern matching must go via uncons datatuple used tuple tuple correspond tuple tuple native erlang tuples provided purescripterltuples allows higherarity tuples may useful ffi downside lack pattern matching case conversion datatuplenested provided permit pattern matching core library many core library ported erlang ffi experience discovering many transitive dependency innocentlooking package may many package include ffi definition sometimes apparent reason library work either ported ffi part purerl org ffifree package must used correct dependency prelude via bower resolution purerl purescriptprelude purescriptintegers purescriptmath purescriptassert purescripteff purescriptpartial purescriptconsole purescriptfoldabletraversable purescriptunfoldable purescriptfunctions work many purescriptmaybe purescripteither purescripttuples purescriptbifunctors step continuing work despite distraction atomcode plugins work life large part fleshing library port occasional compiler bug surfacing driving trying write interesting app chasing relevant dependency expect see eventually
286,Lobsters,erlang,Erlang development,Erlang & Elixir Factory Lite at Buenos Aires,https://medium.com/@elbrujohalcon/erlang-factory-lite-at-buenos-aires-bfa28b62b527,erlang elixir factory lite buenos aire,bleacher report eventfabric sponsor prospectus register register,simon coauthor one popular book erlang erlang programming written book erlang haskell dependent type talking power functional programming increase programming productivity using idea paradigmben elixir programmer lead developer bleacher report leading transition ruby rail elixir phoenix giving talk using bleacher report story show fulfillment promise elixir phoenixmariano born córdoba still keep accent p working company eventfabric talking distributed system necessarythe founder erlang solution coauthor book mentioned couple others francesco giving workshop reactive system micro service architecturesi also take chance give talk course p talking adts heuristic would help better erlangerbut room several speaker one idea talk submit love hear say talk spanish english mine spanish course sponsorswe sponsor already linked erlang solution inaka event fabric bleacher report looking company interested sponsoring awesome event check prospectus feel free reach u timeregister come join u amazing conference register get super early bird price
287,Lobsters,erlang,Erlang development,Don't let it crash,https://ninenines.eu/articles/dont-let-it-crash/,nt let crash,influence presuasion printed tshirt,specific mindset writing erlang program focus normal execution program nt handle error may occur sometimes call normal execution happy path general pattern behind writing happy path letting vm catch error writing log future consumption supervisor restart process failed clean state name call let crash drive many design decision really great way program result fantastic compared programming language yet let crash barely convinced anyone use erlang would may already know cowboy capable handling least million websocket connection single server large part thanks capability vm still million good much better server cowboy websocket server also http server handle many related feature like long polling parsing request header guess large cowboy codebase without looking source make sure clear answer mind go check good back result correct overestimated size cowboy cowboy fact five thousand line code probably thought least ten thousand eighty percent reader overestimated size cowboy mentioned handle million websocket connection numerous study show effect mentioning large number already prepared mind think direction repeating number made focus even question asked number ended larger reality effect applied negotiation example generally want start giving offer let party initiate want give really large number first also prepare customer mentioning even larger number previous discussion number either experiment showed looking image cloud customer pillow store buying pillow comfortable expensive nt see image power association covered much larger detail book influence presuasion highly recommend reading applying learn daily life definitely professional psychologist take post grain salt selling erlang whether selling customer trying convince developer friend start using often talk erlang let sleep night auto healing always get fantastic uptime talk let crash describe mean might well say erlang crash lot take door would effect nt even stop program crashing know else crash car plane train often disastrous consequence really message want convey even printed tshirt keep calm let crash kind tshirt probably nt wear airport good reason people realized wearing smug yet sell erlang better way would focus positive course also make sure positive phrased way prevents bad association formed people mind instead let crash say erlang auto healing mechanism healing good thing accurately describes happens system need go detail probably want avoid recover crash instead say recover exception exception pretty neutral word explain mean talk exception occur reason unrelated erlang like hardware failure network instability trick always use positive word phrase describe erlang use external factor explain erlang deal failure never mention failure internal erlang system unless asked specifically case say auto healing applies exception let crash philosophy great learning erlang writing faulttolerant system going convince anyone use unless already looking like post tell twitter might make
288,Lobsters,erlang,Erlang development,llaisdy/beam_languages,https://github.com/llaisdy/beam_languages,llaisdybeamlanguages,language language beam content overview language lispinfluenced staticallytyped others erlang lisp clojerl joxa kapok lfe concurrent schemer staticallytyped language alpaca cuneiform elchemy eml fez gleam hamler haskerl et al http wwwdcsglaacukpartainhaskerlhtml http wikihaskellorgyhcerlangproofofconcept idriserlang purerl http etc efene elixir ephp bragful http http http erlog erlyjs http ajaxiancomarchiveserlyjsjavascriptonerlang http ffe forthflavoured erlang interfix luerl otpcl reia xerl http language implementing language beam implementing language beam efene beam community beam made eric merritt erlang distributed system expert give view beam language type system new technology create language implement language top erlang virtual machine beam implementing language beam implementing language beam erlang lfe joxa elixir established emerging language erlang ecosystem beam beam book http githubcomhappithebeambook beam toolbox http efeneorgtoolboxhtml erlang type http homepagesinfedacukwadlertopicserlanghtml practical subtyping system erlang great type hope om erlang system fomega erlang type proposal gradualizer gradual type system erlang,language language beam content overview document intended list language implemented run beam erlang virtual machine b document article presentation hows why writing language run beam moment want better name call language beam language although heard erlang vms would like document comprehensive least representative missed beam language noteworthy discussion beam language documentation implementing language targetting beam please let know usual channel issue fork pr tweet email etc thank language first erlang lispinfluenced language staticallytyped language others including erlang language erlang lisp clojerl clojerl clojure erlang vm joxa difference joxa lfe joxa full featured lisp erlang vm kapok lfe concurrent schemer staticallytyped language alpaca cuneiform elchemy elm syntax frontend elixir ie convert elmstyle input language elixir source code eml eml erlang flavored ml fez fez fsharp core erlang compiler experiment gleam gleam statically typed language erlang vm hamler haskellstyle functional programming language running erlang vm haskerl et al haskerl index http wwwdcsglaacukpartainhaskerlhtml yhcerlangproof concept http wikihaskellorgyhcerlangproofofconcept idriserlang idris package therefore requiring haskell idris compiles idris source code erlang source code purerl erlang backend purescript introducing purescript erlang http etc efene elixir ephp erlang interpreter php presumably used bragful resilient scalable php announcement ensuing discussion erlangquestions http improvement erlang euc http blog post presentation chinese http erlog backtracking erlang part control erlyjs original repo google code longer exists several fork eg couple blog post second original developer erlyjs erlyjs javascript erlang http ajaxiancomarchiveserlyjsjavascriptonerlang erlyjs translating javascript erlang http ffe forthflavoured erlang interfix luerl otpcl open telecom platform command language scripting language designed integrate extend application written beambased language reia xerl five web article starting xerl empty module http language implementing language beam video implementing language beam video efene beam community slide video beam made slide link github repo eric merritt erlang distributed system expert give view beam language type system new technology articleinterview link podcast video create language implement language top erlang virtual machine beam slide implementing language beam slide video implementing language beam video erlang lfe joxa elixir established emerging language erlang ecosystem slide beam beam book description erlang runtime system ert virtual machine beam http githubcomhappithebeambook beam toolbox list tool library useful beam language like efene erlang lfe elixir project http efeneorgtoolboxhtml erlang type first two paper linked philip wadler erlang page http homepagesinfedacukwadlertopicserlanghtml practical subtyping system erlang paper great type hope slide om erlang system fomega erlang type proposal gradualizer gradual type system erlang gradual typing system static code analysis tool erlang type system based gradual typing functional language siek taha see docgtlchs
289,Lobsters,erlang,Erlang development,What I Learned Writing a Game Server in Erlang,https://www.youtube.com/watch?v=Hf96bhU7R80,learned writing game server erlang,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature learned writing game server erlang w qp youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature learned writing game server erlang w qp youtube
290,Lobsters,erlang,Erlang development,Simple slug generator,http://blog.ikura.co/posts/simple-slug-generator.html,simple slug generator,search ideal co web address,search ideal co web addressget gone
291,Lobsters,erlang,Erlang development,Running out of Ammo – Erlang Battleground,https://medium.com/erlang-battleground/running-out-of-ammo-769bb28baac2,running ammo erlang battleground,yeah bang question register dead process question prevent happening whereis whereis whereis case end try catch end,yeah could stopped thereas might guessed asked sending message registered process fails badarg process registered process registered name alive word bang failing mean process alive check process registered name using bang question register dead process question check something first process dead also registered name tried pid self exception error error occurred evaluating arithmetic expression operator called register pid exception error bad argument function called register first tried use erlang process already dead tried register process kill register self exception error error occurred evaluating arithmetic expression operator called message exception error bad argument operator called failed fail process dead registered time sending message brings u back second prevent badarg happening find process registered name use actually using bang quick accurate answer due concurrent nature erlang moment check process moment send message process might died new process might registered namenevertheless way check process registered name node find process bonus whereis register self whereis exception error error occurred evaluating arithmetic expression operator called whereis return undefined know process registered name node stated write code like following whereis undefined donothing messageendyou buying ticket race condition land right since whereis bang process called might terminated example little bit contrived easily improved actually using result whereis sadly unheard case safer way achieve result something messagecatch badarg donothingend
292,Lobsters,erlang,Erlang development,"Background processing using Elixir, GenServer and the Erlang queue module",https://hackernoon.com/background-processing-using-elixir-genserver-and-the-erlang-queue-class-8d476d4942c2,background processing using elixir genserver erlang queue module,background processing using elixir genserver erlang queue module story replaced redisexq pure elixir erlang queue class omgneering magnetissimo working kinda working working magnetissimo step one towards ultimate goal distillery magnetissimo,background processing using elixir genserver erlang queue modulei writing ruby code year like may reach familiar tool like redis sidekiq process background job data like show sometimes pure elixir enough get job donethis story replaced redisexq pure elixir erlang queue classa huge thank omgneering video genserver trouble understanding genserver tremendous helpi built magnetissimo learning exercise really understand elixir see take ship production ready code version github right work lacking important area set initial goalsgoals crawl multiple index site torrent magnet link working run without ceremony pointless configuration needed kinda high performance leveraging elixir genserver erlang beam vm working unit tested correctness working easy people run project even developer question wanted zerofrictionthe le step running magnetissimo higher adoption rate would bei found solution erlang queue class elixir genserverthis step one towards ultimate goalthe first thing make crawler create worker ofthose crawler supervised supervisorchildren start ecto repository supervisor magnetissimorepo start endpoint application start supervisor magnetissimoendpoint worker magnetissimocrawlerthepiratebay worker magnetissimocrawlereztv worker magnetissimocrawlerlimetorrents worker magnetissimocrawlerleetx worker magnetissimocrawlerdemonoid crawler actually genserver implementation example thepiratebay version crawlerdefmodule magnetissimocrawlerthepiratebay use genserver alias magnetissimotorrent alias magnetissimocrawlerhelper def startlink queue initialqueue genserverstartlink module queue end def init queue schedulework ok queue end defp schedulework processsendafter self work second end callback def handleinfo work queue case queueout queue value item queue queue process item queue ioputs queue empty restarting queue queue initialqueue end schedulework noreply queue end def process pagelink url queue ioputs downloading page url htmlbody helperdownload url htmlbody nil torrent torrentlinks htmlbody queue enumreduce torrent queue fn torrent queue queuein torrentlink torrent queue end end queue end def process torrentlink url queue ioputs downloading torrent url htmlbody helperdownload url htmlbody nil torrentstruct torrentinformation htmlbody torrentsavetorrent torrentstruct end queue end parser function def initialqueue url j pagelink http thepiratebayorgbrowse j end queuefromlist url end def torrentlinks htmlbody htmlbody flokifind detname flokiattribute href enummap fn url http thepiratebayorg url end end def torrentinformation htmlbody name htmlbody flokifind title flokitext stringtrim htmlentitiesdecode magnet htmlbody flokifind download flokiattribute href enumfilter fn url stringstartswith url magnet end enumat size htmlbody flokifind detailsframe detail dd enumat flokitext stringsplit enumat stringreplace seeder htmlbody flokifind detailsframe detail dd enumat flokitext integerparse leechers htmlbody flokifind detailsframe detail dd enumat flokitext integerparse name name magnet magnet size size websitesource thepiratebay seeder seeder leechers leechers endendinitialqueue function creates erlang queue object initial url sprawl link pagination page individual torrent linkseach element queue tuple two part torrentlink someurl pagelink someurl using function pattern matching process method easily either parse pagination link parse individual torrent pagethe schedulework function schedule next item processedthe end result cohesive code le indirection much easier add new crawler project also easier know exactly running le chance bug predictable growth behavior one downside approach volatility app shuts lose queue process comfortable particular projectone potential upgrade change handleinfo async handlecallmy next step going using distillery build single deployable executable end user run magnetissimo start service localhostsubscribe get daily roundup top tech story
294,Lobsters,erlang,Erlang development,A CutEr Tool,https://www.youtube.com/watch?v=XVOV0KQAf-8,cuter tool,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature erlang factory sf kostis sagonas cuter tool youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature erlang factory sf kostis sagonas cuter tool youtube
295,Lobsters,erlang,Erlang development,Beyond the Limits of an ETS – Erlang Battleground,https://medium.com/erlang-battleground/beyond-the-limits-of-an-ets-cdd79fa8300c,beyond limit ets erlang battleground,lesson ets question happens covering base wat namedtable public wat adding strange key ets first wat endoftable making thing even complex impact instead,lesson etsthe lesson delivering day ets table eventually get point explain use ets ets iterate key tablefor know ets first key key table tab orderedset table first key erlang term order returned table type first key according internal order table returned table empty endoftable ets next key following key table tab table type orderedset next key erlang term order returned table type next key according internal order table returned next key exists endoftable returnedthe questionas couple classical otp function example student spotted edge case easily precisely shown slide could even get console show two function used dummy example one happens endoftable one key table actually take surprise made kind observation time find function return special result case endoftable indicate abnormal status case fact next key wonder result special even seen special result never checked happened particular scenariomy response student course let see going boring recursive function showing use ets ets turned nice live coding session eventually morphed blog postso happens covering basesfirst need check basic spawn fun ets new wat namedtable public receive ok end end ets first wat endoftable ets next wat endoftable exception error bad argument function ets called ets next wat endoftable ets next wat exception error bad argument function ets called ets next wat ets insert wat ets first wat ets next wat endoftable ets next wat endoftable exception error bad argument function ets called ets next wat endoftable first spawn process hold public table called wat avoid exception console killing table ets table linked process created check everything work expected ask first key empty table get endoftable ask next key inexistent key get exceptionif ask next key last key table get endoftable adding strange keyso far good let try crazy key endoftable ets insert wat endoftable ets first wat ets next wat endoftable ets next wat suddenly table empty least according doc right well fair endoftable actually key table happens ask next key course get next one get endoftable since fact last key tablemaking thing even complexthen endoftable first key actually related internal order table stated doc let add key occupies lower position endoftable ets insert wat ets first wat ets next wat ets next wat endoftable ets next wat see way sure endoftable first last element table might convenient eg want create ring impactwell played bit let see actually happen add element ets table endoftable might would like show way use ets ets traverse ets table check handy module let iterator end find value endoftable instead keyfor rely value determine reached end table next key ets fails badarg error simplest scenario work spawn fun ets new wat namedtable public receive ok end end iterator catching wat iterator matching wat ets insert wat b c iterator matching wat b c iterator catching wat b c add endoftable none work ets insert wat endoftable iterator matching wat iterator catching wat endoftable b c endoftable b c endoftable b want break system somehow find turning user input atom using atom key ets table later traversing using ets ets know break
296,Lobsters,erlang,Erlang development,Reducing the maximum latency [on BEAM],http://theerlangelist.com/article/reducing_maximum_latency,reducing maximum latency beam,low latency large working set ghc garbage collector pick two three golang realtime gc theory practice challenge accepted measuring asdf functional implementation queue article one refc binary ets based implementation final thought processspawn inprocess c nifs outprocess anything port,recently came across two great article pusher blog low latency large working set ghc garbage collector pick two three golang realtime gc theory practice article tell story pusher engineer reimplemented message bus first take done haskell performance test noticed high latency percentile range bared code able prove spike caused ghc stoptheworld garbage collector coupled large working set number inmemory object team experimented go got much better result owing go concurrent garbage collector highly recommend article pusher test great benching example focused solving real challenge evaluating technology based whether suitable job kind evaluation prefer instead comparing technology shallow synthetic benchmark passing token ring benching web server return ok find much useful make simple implementation critical functionality see behaves desired load provide answer question solve x efficiently using approach took first evaluated erlang hour test simulation real system time expected load convinced technology capable needed challenge accepted reading pusher article made wonder well would elixir implementation perform underlying erlang vm beam built low predictable latency mind coupled property faulttolerance massive concurrency scalability support distributed system seems like compelling choice job let define challenge based original article implement fifo buffer handle two operation push pull buffer bound maximum size buffer full push operation overwrite oldest item queue goal reduce maximum latency push pull operation large buffer max item important keep final goal mind care smoothing latency spike buffer operation care le language give better worstcase gc pause root issue pusher challenge caused long gc pause mean solve moving another language demonstrate relying trick elixirerlang bypass gc completely bring max latency microsecond area measuring measure performance decided run buffer separate genserver powered process see implementation measurement taken using erlang tracing capability separate process started set trace buffer process receives startfinish time push pull operation well buffer garbage collection collect time asked produce final stats find implementation tracing cause slowdown whole bench seems take longer tracing used say much affect reported time care much able get good result tracing turned implementation suffice tracing turned familiar erlang word process refers erlang process lightweight concurrent program run o process share nothing erlang process o level still one o process inside multiple erlang process running separately process nothing common share memory communicate sending message particular process separate heap garbage collected separately process therefore whatever data allocated tracer process code put gc pressure buffer data actually pushing buffer considered buffer gc thus affect latency buffer operation approach demonstrates great benefit erlang running different thing separate process prevent gc pressure one process affect others system aware lightweight concurrency platform provides guarantee test first start brief stretch warmup create buffer maximum capacity item number used pusher bench push item pull push item end warmup buffer maximum capacity bench start issuing request cycle push followed pull buffer therefore mostly operates overflow mode total push performed full buffer push nearly full buffer item pushed byte erlang binares item different others meaning test create different item bench code resides full project available benched using erlang elixir installed asdf version manager test performed imac ghz intel core functional implementation first try consider idiomatic approach elixir erlang purely functional implementation based queue module according doc module implement doubleended fifo queue efficient manner operation amortized running time api module provides thing needed use pushpull item direct support setting maximum size fairly simple implement top queue module find implementation originally read pusher article pretty certain implementation lead larger latency spike stoptheworld gc erlang still stoptheprocess gc erlang process start fairly small heap kb need allocate process gced heap possibly expanded detail gc recommend article one test mean buffer process pretty soon expand large heap need accommodate item pushing item create garbage gc lot work consequently expect significant gc pause lead latency spike let verify mix bufferbench bufferqueue pushpull time average μs μs μs μs μs μs longest μs gc time average μs μs μs μs μs μs longest μs buffer process memory kb total memory used mb lot data highlight number find interesting start average latency buffer operation average get bad reputation day still find useful metric observed average latency microsecond tell implementation cope roughly operationssec without lagging even buffer completely full tolerate latency variation expect request higher rate queue implementation suit need looking latency distribution see max latency millisecond might unacceptable may fine depending particular use case would wrong broadly extrapolate queue powered buffer always suck proclaim work well case interpret number know specification requirement particular problem hand look closer latency distribution pushpull operation see latency grows rapidly four five nine transition two digit microsecond two digit millisecond area operation mean experience latency spike le whether acceptable depends constraint particular problem printed gc stats related buffer process see gc took place buffer process high percentile latency twodigit millisecond range unsurprisingly seems strong correlation gc time latency spike start nine percentile range finally notice buffer process heap size mb might expect around mb since buffer hold item byte however bench item called refc binary mean stored separate heap buffer process heap hold reference binary data course buffer process still live reference heap together garbage removed message cause latency spike looking worstcase gc time comparing language erlang fare well might wrongly conclude suitable job ets based implementation however work around gc limitation ets table ets table come couple shape article keep simple saying serve inprocess inmemory keyvalue store come semantics ets table bring anything new table pun intended could implement functionality using plain erlang process data structure however ets table couple interesting property make perform well case first ets table data stored separate memory space outside process heap hence use ets table store item buffer process need hold lot live reference anymore reduce gc time moreover data ets table released immediately removal mean completely remove gc large set implementation ets based buffer based pusher go implementation basically using ets table simulate mutable array storing kv pair index value table maintaining two index one determines going push next item another pull operation originally start value zero push store pushindex value pair table increase push index one push index reach maximum buffer size set zero likewise pulling data read value associated pullindex key increment pull index buffer full push operation overwrite oldest value increment index thus making sure next pull operation read proper location full implementation available let see performs mix bufferbench bufferets pushpull time average μs μs μs μs μs μs longest μs gc time average μs μs μs μs μs μs longest μs buffer process memory kb total memory used mb average time microsecond radically better queue powered implementation however latency spike much smaller longest observed latency microsecond five nine range already twodigits microsecond area fact push took longer microsecond shabby full disclosure result best one got couple run machine max latency sometimes go slightly number change significantly particular always μs looking gc stats see large increase number gc buffer process queue implementation buffer process triggered gc implementation observe gc reason keep mind buffer process still manages data heap includes index next pushpull operation well temporary reference item pushedpulled since lot request arrive buffer process going generate lot garbage however given buffer item stored separate heap ets table buffer never maintain large live set corresponds pusher conclusion gc spike problem related amount generated garbage rather amount live working set implementation reduced set keeping buffer process heap pretty small consequently although trigger lot gc pretty short longest observed gc buffer process took microsecond final thought given erlang stoptheprocess gc property might sometimes experience large pause process however option disposal help u trim large spike main trick control pause keep process heap small large active heap coupled frequent incoming request going put pressure gc latency going increase particular example using ets helped reduce heap size buffer process although number gc increased dramatically gc pause pretty short keeping overall latency stable erlang certainly fastest platform around allows keep latency predictable build system finetune reach desired performance expect le surprise production worth mentioning two technique might help reduce gc spike one approach split process manages big heap multiple process smaller working set lead fragmented gc possibly remove spike case capitalize fact process memory immediately released process terminates need perform oneoff job allocates lot temporary memory consider using processspawn allows explicitly preallocate larger heap starting process might completely prevent gc happening process calculation spit result finally terminate process memory get immediately reclaimed without ever gced finally make critical part system efficient erlang always resort inprocess c nifs outprocess anything port keeping elixirerlang main platform controller plane system many option table give lot confidence able handle challenge encounter matter tricky might
298,Lobsters,erlang,Erlang development,Erlangers! USE LABELS! (aka “Stop Writing Punched-in-the-Face Code Blocks”),http://zxq9.com/archives/1337,erlangers use label aka stop writing punchedintheface code block,shittyinlineerl shittylistcomperl lessshittylistcomperl labeledlambdaerl isolatedfunctionserl assignment assertion list comprehension shittyinlineerl shittylistcomperl lessshittylistcomperl labeledlambdaerl isolatedfunctionserl io shittyinlineerl labeledlambdaerl labelexamplecomparisontxt manpage isolatedfunctionserl isolatedfunctionss,write lambda directly inline argument list various list function list comprehension ever even though fun argument return assignmentassertion call long force scrunch lambda definition inlinemultiline ball wild shit wtf ahhhh first realize incredibly impolite people future self whenever big difference human reading shittyinlineerl dowhatever key someparameter list foreach fun k case externallookup k ok v dosideeffectything v someparameter error r reportsomefailure r end end key shittylistcomperl dowhatever key someparameter fun k case externallookup k ok v dosideeffectything v someparameter error r reportsomefailure r end end key key key ok lessshittylistcomperl dowhatever key someparameter execiffound fun k case externallookup k ok v dosideeffectything v someparameter error r reportsomefailure r end end execiffound key key key ok labeledlambdaerl dowhatever key someparameter execiffound fun key case externallookup key ok value dosideeffectything value someparameter error reason reportsomefailure reason end end list foreach execiffound key isolatedfunctionserl spec dowhatever key someparameter ok key somekindofkey someparameter term dowhatever key someparameter execiffound fun key maybedostuff key someparameter end list foreach execiffound key maybedostuff key param case externallookup key ok value dosideeffectything value param error reason reportsomefailure reason end version force eye le jumping around version let naturally understand component code independently universal code like translate erlc go difficult read course every version pretty darn basic common need listy operation require closure inscope state make work right really need lambda instead able look suave fun type thing agree taken version easy comprehend reading hundred sort thing understand wtf going project also remembering bunch shit code laying around side effect trying recall detail standard phone thing change really care way toy case like actual code care forever ever absolutely yes fifth version definite preference fourth fine also even third maybe tend disagree semantic confusion using list comprehension effect loop list value side effect without returning value partly semantically ambiguous also whenever possible like every expression code either assignment assertion every line normally word use list case list comp especially disagree using listcomp main utility using list comprehension normally achieve closure local state calling another closure semantic fail twice lolspeed know let see created five module based example shittyinlineerl shittylistcomperl lessshittylistcomperl labeledlambdaerl isolatedfunctionserl call helper basically nothing important actual side effect called call io interested generated assembler cost introducing label help human v leaving thing messy way imagine might faster runtime turn like using assignment document code zero cost label function example assembler shittyinlineerl sidebyside labeledlambdaerl oooh look exact stuff screenshot text file content shown labelexamplecomparisontxt see annoyingtoread inline lambdaness buy absolutely nothing helping compiler helping runtime hurting future self anyone want work code later note generate precompiler output erlc p erlc e assembler output erlc manpage play around bit beam evm amazing platform wide open exploration use label execution perform basically except last one isolatedfunctionserl assembler one isolatedfunctionss outperforms others though relatively insignificant degree course insignificant degree part program critical part whatever program even difference may really huge win case worth refactor test speed different representation version runtime happen using thought mere style take backseat never case vast majority code read report past indicate performance bottleneck tend reside le code line count recall name happen find reference let know update little parenthetical blurb hard reference point breaking every lambda separate named function always worth sometimes inplace lambda really idiomatic easier understand simply see everything right function body want see multiline lambda squashed argument list make thing hard read give exact result compiled labeling lambda meaningful variable name another line code referring invoked later
299,Lobsters,erlang,Erlang development,How Do I Test?,https://medium.com/erlang-battleground/how-do-i-test-a9658a83c392,test,simple function ok pattern matching dynamic binding ghost function simple module whole system project restful apis binary apis internal apis marcelo gornstein peace mind meta testing zach github elvis gadget meta testing inakaesi katanatest meta testing,enough intro let talk actually test erlang codesimple functionsas erlang trainer always faced task assigning problem student test recently acquired knowledge check solution actually meet goal right well maybe usually besides exercise statement usually written pdf document build simple function called use function test code write showing mefor example let say exercise asks function temp convert fahrenheit degree celsius case would give student something like way try compile module evaluate temp test erlang console return oki taking advantage key part erlang language pattern matching matching result calling function want define proper pattern knowing matching error break test descriptive enough error messagedynamic binding temp module compiles even exist erlang dynamic binding fully qualified function check function actually exists runtime exist used ghost function produce runtime error thus breaking test expectedsimple modulestaking step forward consider exercise requires student provide full module let simple key value store exercise list expected module interface function like scenario simple test function may limited almost using catch multiple time inside list way student detect multiple test error one per test case evaluate db test whole systemswell nice basic function simple module happens build big system case tend apply similar approach system build communicate external world restful api specification system work defined term api since use test specify system work write test hit restful api verify proper behavior see example see using sptstestutils apicall internally us http client hit endpoint server supposed provide patternmatching responsesas see project code came restful apis binary apis even internal apisafter writing test suite sometimes writing individual test case write code needed test pas tdd fashion recommended beforeonce whole system built run test suite coverage report coverage write missing test raise given unavoidable boilerplate otp sometimes requires generally end stuff like one well marcelo gornstein told great truth coverage consistently see lower coverage number implementing new feature never sure looking number line covered introduced already uncovered beforealways maintaining coverage give peace mindmeta testingfinally following logic zach article also like use tool erlang otp community provide ensure code quality particular project github reviewed elvis andor gadget ensures every single pr checked erlang compiler dialyzer elvis xrefbut another thing learned hernán include thing directly test call meta testing inakaesi created supersimple tool katanatest allows add meta testing erlang project line code katanatest get dialyzer xref elvis directly test suite check every single change make code cool
300,Lobsters,erlang,Erlang development,Thinking in Erlang (2007),https://web.archive.org/web/20070212210331/http://chuffyrodents.org/erlang.pdf,thinking erlang,,obj length filter flatedecode stream h j j endobj obj type page content r resource r mediabox parent r endobj obj font r r procset pdf text endobj obj length filter flatedecode stream ߢ z yytt qxn n endstream endobj obj type page content r resource r mediabox parent r endobj obj font r r procset pdf text endobj obj length filter flatedecode stream j n υ ѧ aƻ endobj obj type page content r resource r mediabox parent r endobj obj font r r procset pdf text endobj obj length filter flatedecode stream ko dr endobj obj type page content r resource r mediabox parent r endobj obj font r r r procset pdf text endobj obj length filter flatedecode stream fk bu zq q w rrv j h u jˬ h af e endobj obj type page content r resource r mediabox parent r endobj obj font r r r r r r procset pdf text endobj obj length filter flatedecode stream v g fw g endobj obj type page content r resource r mediabox parent r endobj obj font r r r procset pdf text endobj obj length filter flatedecode stream x ģg h p
301,Lobsters,erlang,Erlang development,Erlang and Multicores,https://www.youtube.com/watch?v=bo5WL5IQAd0,erlang multicores,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature program multicores joe armstrong youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature program multicores joe armstrong youtube
302,Lobsters,erlang,Erlang development,Last resort testing,http://blog.ikura.co/posts/last-resort-testing.html,last resort testing,search ideal co web address,search ideal co web addressget gone
303,Lobsters,erlang,Erlang development,Reverse-Engineering a Proprietary Game Server with Erlang,http://www.erlang-factory.com/conference/ErlangUserConference2012/speakers/LoicHoguin,reverseengineering proprietary game server erlang,,hoguin erlang cowboy nine nine founder nine nine founder nine nine open source erlang company main author cowboy bullet sheriff farwest project spawnfest cofounder organizertwitter lhoguin hoguin giving following talk reverseengineering proprietary game server erlang online gaming suffers big issue owner game decides shut gone good sometimes released open source time reverse engineering needed bring fallen server back lifethe best tool analyze reverse engineer protocol game client erlang closely associated good debuggerthis talk explain big advantage erlang language reverse engineering protocol analyzing client file live demo showcasing tool technique givenat end talk good idea start reverseengineering favorite online game talk objective learn use erlang analyze reimplement proprietary protocol file format efficientlytarget audience network developer video game enthusiast tutorial building chat cowboy part tutorial introduces cowboy web server writing simple chat applicationthe cowboy web server allows write efficient web application however thin layer managing http part applicationafter brief presentation cowboy start writing simple echo application using get post using websocketswe start talking general architecture application build session server make client communicate otherrequirements tutorial basic knowledge http work laptop erlang rebar installed higher along websocket enabled browsertutorial objective learn use cowboy build realworld httpwebsocket applicationstarget audience web network developer tutorial building chat cowboy part tutorial introduces cowboy web server writing simple chat applicationthe cowboy web server allows write efficient web application however thin layer managing http part applicationafter brief presentation cowboy start writing simple echo application using get post using websocketswe start talking general architecture application build session server make client communicate otherrequirements tutorial basic knowledge http work laptop erlang rebar installed higher along websocket enabled browsertutorial objective learn use cowboy build realworld httpwebsocket applicationstarget audience web network developer
304,Lobsters,erlang,Erlang development,How Supervisors Work,https://jbodah.github.io/blog/2016/11/18/supervisors-work/,supervisor work,elixir source erlang source genserver work childspec trap exit record source conventionally call startlink worker module errorlogger reading handleinfo genserverstop supervisor terminate callback,erlang elixir supervisor process manage child process restart crash post going take look detail supervisor implemented rough idea worked understand specific felt like learning stuff figured share dive would helpful understand use genserver supervisor module used elixir equivalent fine delegate erlang module really change behaviorally let start example elixir straight doc defmodule myappsupervisor use supervisor def startlink supervisorstartlink module end def init child worker stack hello imported supervisorspec supervise child strategy oneforone end end example startlink spawning supervisor init callback used supervisor behaviour let dig supervisor quick recap behaviour use supervisor call expand compile time whatever behaviour using macro let look using supervisor module elixir source tangent elixir source laid conventionally recommend take little time get comfortable navigating using macro time writing defmacro using quote location keep behaviour supervisor import supervisorspec end end behaviour check make sure implement necessary callback supervisor import statement pulling extra method myappsupervisor supervisorspec worker supervise method defined gist use supervisor statement mixing function making sure implement right callback way start supervisor calling myappsupervisorstartlink let dig obviously delegate supervisorstartlink passing reference via module checking source supervisorstartlink def startlink module arg option islist option case keywordget option name nil supervisorstartlink module arg atom isatom atom supervisorstartlink local atom module arg global term tuple supervisorstartlink tuple module arg via viamodule term tuple isatom viamodule supervisorstartlink tuple module arg raise argumenterror expected name option one nil atom global term via module term got inspect end end main thing see elixir module delegating erlang supervisor module wait run screaming follow erlang source trust grepping startlink find export statement exposing outside module spec telling type function expects actual implementation startlink mod args genserver startlink supervisor self mod args see already something familiar starting genserver dig genserver work main takeaway supervisor built ontop genserver genserver expects u implement bunch callback one concerned right init note even though myappsupervisor implement init callback called next look back startlink erlang supervisor module see pass self reference meaning supervisorinit function looking next source init supname mod args processflag trapexit true case mod init args ok supflags startspec case initstate supname supflags mod args ok state issimple state initdynamic state startspec ok state initchildren state startspec error stop supervisordata error end ignore ignore error stop badreturn mod init error end thing first calling mod init args calling myappsupervisorinit let look real quickly def init child worker stack hello imported supervisorspec supervise child strategy oneforone end remember worker supervise helper coming supervisorspec without digging plumbing cut chase focus erlang side thing worker output childspec supervise output tuple looking like ok strategy maxretries maxseconds childspecs back supervisorinit next importantly call processflag trap exit important central supervisor know restart process tl dr process terminates sends exit signal linked process calling processflag trap signal instead send exit frompid reason message process instead see later supervisor process use frompid value know process died restart okay left supervisorinit started trapping exit signal next initialize state child go initstate let go initchildren since dealing simpleoneforone supervisor initchildren state startspec supname state statename case checkstartspec startspec ok child case startchildren child supname ok nchildren ok state state child nchildren error nchildren reason terminatechildren nchildren supname stop shutdown reason end error stop startspec error end oh boy symbol another quick tangent state statename accessing variable state state record plucking name field record moreorless structs stored ordered tuples like state josh kind like enum type language record way decouple position field meaning source state record defined top file record state name strategy strategy undefined child childrec dynamic dict dict pid list set set pid undefined intensity nonneginteger undefined period posinteger undefined restarts dynamicrestarts nonneginteger module args see state record name field supname state statename treating state tuple state record plucking whatever field corresponds name saving supname glancing checkstartspec validation well casting spec received myappsupervisorinit record source real meat supervisorinitchildren startchildren though startchildren child supname startchildren child supname startchildren childchs nchildren supname case dostartchild supname child ok undefined child childrestarttype temporary startchildren chs nchildren supname ok pid startchildren chs child child pid pid nchildren supname ok pid extra startchildren chs child child pid pid nchildren supname error reason reporterror starterror reason child supname error list reverse chs child nchildren failedtostartchild child childname reason end startchildren nchildren supname ok nchildren little recursion plucking child calling dostartchild dostartchild supname child child mfargs f args child case catch apply f args ok pid ispid pid nchild child child pid pid reportprogress nchild supname ok pid ok pid extra ispid pid nchild child child pid pid reportprogress nchild supname ok pid extra ignore ok undefined error error error end apply erlang dynamic function invocation method similar send ruby applycall javascript wind dynamically calling callback defined supervisorspecworker conventionally call startlink worker module finally call reportprogress us erlang unfortunately named errorlogger publish info event new process started supervisor first breathe okay let continue zooming way supervisor start trap exit start child still gotten real beef supervisor restart child really close remember processflag trap exit signal turn exit frompid reason tuples also remember supervisor built top genserver well genserver handle noncallcast message using handleinfo reading handleinfo supervisor handle exit child handleinfo exit pid reason state case restartchild pid reason state ok noreply shutdown stop shutdown end see handle exit message contains pid child process exited reason feed restartchild victory already seen dostartchild work restartchild fairly similar leave curious look interested supervisor implement shutdown strategy take peek genserverstop delegate supervisor terminate callback let sum elixir implement conventional framework writing supervisor framework interface erlang supervisor module built top genserver elixir pass configs supervisor module us start child process manages child process trapping exit signal child convert signal message implement handleinfo callback handle exit message restart correct worker finally worth reiterating publishes report errorlogger erlang event manager anyways learned ton dig hope found post useful way think could clearer please let know thanks reading
305,Lobsters,erlang,Erlang development,Distributed Jamming with Sonic Pi and Erlang,https://www.youtube.com/watch?v=4SUdnOUKGmo,distributed jamming sonic pi erlang,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature sam aaron joe armstrong keynote distributed jamming sonic pi erlang youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature sam aaron joe armstrong keynote distributed jamming sonic pi erlang youtube
306,Lobsters,erlang,Erlang development,Handling Overload,http://ferd.ca/handling-overload.html,handling overload,handling overload background info little law backpressure loadshedding naive fast system unavoidable backpressure handle erlang naive backpressure erlang pullbased control flow decent metric begin erlang erlstreams goldrush bounded queue erlang pobox sbroker pqueue lrw jch chash canallock counterprotected process erlang canallock network play ball related reading applying system erlang capacity probe erlang job conclusion,handling overload longish entry posted multiple discussion nature bounded mailbox erlang general consensus bad mailbox unbound via language therefore bound memory limitation computer control lost longer true since otp added maxheapsize flag set per process force early death memory usage high including mailbox text going dig common overload pattern encountered erlang regular workarounds available today system note however overall criticism flowcontrol remain true concurrent platform specifically preemptive one go cooperative one like akka nodejs tend implicit mechanism due heavy workload blocking cpu earlier may still encounter issue depending workload background info gon na try go fairly generic manner establish concept little law longterm average number customer stable system l equal longterm average effective arrival rate λ multiplied average time customer spends system w expressed algebraically l λw essentially say really matter capacity system going long task take go many handled concurrently system anything mean sooner later find situation overload increasing capacity speeding processing time way help thing average load subside backpressure mechanism resist given input usually blocking loadshedding mechanism drop task floor instead handling naive fast system naive fast system one task done asynchronously feedback get request entered system trust thing fine rest processing know thing worked looking change overall system streaming log otherwise feedbackfree possible input output bit made synchronous observer could poll system change desired modification noticed even internal flow information would still synchronous transforms process level concurrency system may look like generally would mean get quite linear scaling going incoming request allocated resource need capacity fairly easy predict little law rating system maximal capacity simple harder scenario one tend happen real world process charge transform b parallelized bottleneck flow task depend success average sojourn time request system shoot sojourn time shoot continuous influx request system increase load request making thing worse one system run memory fails people complain need bounded queue erlang process charge transform b could configured max queue size would drop block fix problem unavoidable backpressure default people tend think control flow blocking first tends far case intuitively think late better never therefore forcing request waiting line make sense shedding load ignoring dropping backpressure actually default way thing programming language since function method call inherently synchronous case move forward return computation ended contention overall systematic symptom thing become slow course remains true erlang long call given request happen within single process regulating factor request much concurrency design limitation system server able handle concurrent request stop accepting much load plan get easy upper limit server whether web server socket server whatever kind tend impose limit even though done like idea scale linearly happy idea known lowlevel concurrency place sake stability indeed way nicer get stability le drastic mean case perfectly parallelisable system fairly trivial handle still benchmark hit breaking point put hard limit concurrency make whole server pool scale horizontally adding server case interesting handle systemwide fairly rare still going valuable subcomponents system part optimization concurrent connection pool come mind handle erlang pooling library offer simple way many offer fancier control would otherwise available note omitting pool adapted specific task dedicated network client database connection handling probably generic pool shown naive backpressure case erlang asynchronous default soon introduce multiprocess communication given complex diagram earlier process going risk getting overflowing mailbox process node send many message way easy way fix backpressure making call process synchronous mean whenever process send message process wo nt able send another one process responded one every one stuck waiting goahead signal send instantly limit amount concurrent work possible prevents overflow slowing system fatal flaw reasoning however often system design account implicit limitation instead seeing workflow term pipeline see term step accept request given protocol http tcp udp etc parse request authentication authorisation send request worker process ask worker process resource required processing process turn call subsystem backpressure loadshedding mechanism format response send response publish log metric approach make sense ultimately problem face entirely desirable decoupling also tends decouple processing flow source process accepting external request either done concern clarity implementation usage library design tend want selfcontained problem becomes simple limitation worker data processing interacting data store disconnected concurrency limitation request accepting parsing disconnect result disjointed backpressure mechanism like even though may backpressure server process worker constant flow new incoming server process enough kill overall system system limitation amount concurrent connection still required prevent worker overflowing add worker limitting resource implicitly become difficult example easy conceive idea request cost may take millisecond handle may take millisecond last could take millisecond creates imbalance either overly pessimistic really throttle need prevent worse case scenario task take example take unsafe permissive approach latter usually chosen reality mostly concurrent language relies synchronous backpressure solve problem specifically preemptive scheduling worker easily saturate cpu prevent server process accepting whether willingly inadvertently erlang pullbased control flow interesting workaround done many stack language elixir genstage come mind similar pattern exist many place work done represented set pull consume operation rather set push operation message diagram still look instead server process knowing worker worker know pool server process allowed consume data however problem may encounter approach see synchronous workload namely disjoint limitation number accepting process consuming one may result overload overflow note flowbased processing still interesting advantage property mostly restricted set producer exists create lot data control good example thing fully control may parsing file disk data dump introducing line memory process done well streaming fashion reading another stream kafka stream also make sense notice case essentially trivial pull initial source without interfering semantics resource controlled one mostly pushbased tcp socket example system harder make stable start considering wider scale incoming data come remote endpoint fill syn queue syn queue used handle pending request create connection linux kernel handed tcp backlog tcp backlog hold connection user program call accept socket hand program buffer tuned properly user aware existence tend handle overload either denying request dropping floor pair buffer turn tcp backlog deny request keep existing one memory create fun case request seen sent accepted long period time sender never actually seen consuming program sender give timeout kernel may close connection drop backlog without notice server process userland often cause ghost request known sent accepted sender never logged server unless someone looking tcpdump specific system metric moment syn queue may freely discard incoming syn packet default configured block new connection attempt rely client tcp stack assuming lost packet retrying second minimal tcp delay linux retransmit full second going particularly nefarious metric usually gathered server software userland meanwhile slowness detected caller usually outside system everyone scratching head trying figure people complaining assuming decent metric begin stack using udp may instead suffer lossiness assume using udp ready deal would mistake build system without considering queue part control flow anything heavy load nt considered sooner later debug whereas application server look extremely healthy overall system slow lossy way nobody easily debug overall visibility lost clear solution one aside hoping system fast enough adding layer indirection erlang erlang mechanism pullbased workflow community adopted largely everyone plenty library erlstreams approach similar many language use stream processing actor pullbased workflow goldrush different functional compositionalfeeling approach bounded queue simple way handle problem get visibility bring data inside system soon possible chuck bounded queue previous bit tcp stack fact implementing important distinction bounded queue synchronous communication bounded queue give failfast mechanism deal overload synchronous communication silently block giving task may make hard purge system resource easily grow unlimited usage producer strictly limited waiting blocking process contact instead bounded queue let know buffer full decision made dropping request returning nope sorry busy back client backpressure operation enqueue synchronous expected fail earlier much faster queue full system bound queue may look like noted communication transform queue either synchronous push pull mechanism without major impact semantics quickly becomes critical however queue implemented case serverside stack like erlang may interesting use process queue suffer problem worker work done queue process quickly limited work task even strictly optimize process may sooner later hit limitation running core box may okay queue worker peg core limitation let rest work go elsewhere practical amount resource obtainable process diminishes rapidly move server even core though rapidly may hit harder limit producer fast enough flatout beat work done queue worker fact becomes bit clearer case erlang use distribution socket used distributed erlang talk another given node using limited buffer implicit limitation bounded queue existing shifting around system rapidly become confusing fight pattern two solution generally offered first one queue dispatch form hashing allow spread load across core process although may get fight hotspot whatnot time otherwise usually recommended instead use something like ets table gatekeeper ets table contain single counter given queue process wanting insert message queue make atomic write call ets updatecounter function upperbound max queue size queue consumer decrease counter max hit server process producer flat refuse enqueue task end much stabler pattern cheaper operation copy message worker queue process transfer message mailbox onto process heap possibly shed return message back denying processing garbage collection erlang queueing library offered erlang directly part people use mailbox queue advanced tool discussed later still pobox specific focus batching loadshedding sbroker support simple mode make work like bounded queue previously mentioned pool library often also include queue interesting approach would use library like pqueue consume message fast possible priority queue memory hashing used split work evenly erlang arbitrarily hash erlang term pid dispatch many worker lrw lowest random weight hashing stable interface jch jump consistent hashing chash riak consistent hashing library counter locking solution tend use ets maintain lock value canallock resourceadjustable dynamic lock dynamic resource pooling library mentioned contain mechanism counterprotected process interesting bit bounded queue usage mailbox process erlang queue previous section stop required go back long given server process access counter mutex sending message fact probably one would naively implement queue previous section reason interesting think counter protecting mailbox instead queue let u think agumenting process instead adding architectural component would value putting one every step way technically would little value simply first worker synchronous work latter one synchronous aspect execution mean single counter therefore single point contention sufficient protect entire pipeline otherwise reate dequeue related hold operation worker become asnchronous criticism hold queue communication b asynchronous counter protecting mostly useless help total system stability prevents mailbox overflow b counter would slower since b depends c b implicitly protects c counter b possibly useful thing get hairier track messaging process pipeline graph multiple process mostly disorganised independent structure ensuring good system balance tricky introduce kind possibility asymmetric delay part system clogged one data cross stream subcomponents part pipeline super healthy bit crawling pain transpires tought exercise thing need protect point asynchrony prevent direct feedback via message pattern everincreasing sender effectively cancel result direct feedback via message ton queuing point make hard reason system interesting food thought erlang use ets maintain lock value canallock resourceadjustable dynamic lock dynamic resource pooling library mentioned contain mechanism network play ball fact problem specifically happens large networked application people go thing slow constellation networked service routed multiple physical device difference networked service thing big nodeglobal shared mutex atomic counter everyone hook synchronize thing everything made much harder done observer short network brings u back early design decision stuck message passing nothing fancier could done well lot actually make gross oversimplification network rely mechanism keep working band signaling messaging communicate health ie icmp message estimation quality service via observation inband message adjusting scheduling sending message according quick note observation inband message going oh thing starting take lot slower usual bet something iffy going better slow bit intimately require respect endtoend principle hopbyhop tends exercise frustration specifically end lot challenge similar see process within single node able insert probe beginning end pipeline tends let take snapshot system health simpler way synchronous communication channel therefore sender receives feedback entire pipeline receives response back receive sender backpressure mechanism lot serverside software though overall consensus trust client least instead kind middleman component take client request forward rest cluster trustable manner related reading applying system would bit difficult port expertise embedded world network application layer stuff make effective use mostly impractical problem space huge interesting borrowing network least one many thing idea probing quality service adjusting behaviour accordingly tricky aspect probing performance choosing given task system equal take longer take shorter except rare circumstance probing beginning end request total duration practical metric general mechanism often require rely queue used probe put either end queue probe calculate sojourn time given task within queue unlike duration single request tracking time queue give instant overall wait time within system based capacity extract number task queue system configured way adaptively handle queue filling increasing sojourn time longer sojourn overloaded system constrained aim low overall latency newer request nt care long wait ie phone call system support often deal turning queue stack automatically help provide upper timeout request waited given period time considered stale dropped loadshedding prevent enqueuing request sojourn time high backpressure randomly drop request within queue increasing aggressiveness sojourn time increase loadshedding randomly drop request enqueuing increasing aggressiveness sojourn time increase backpressure implement codel algorithm work well multiple queue system thing note include idea loadshedding tends require either workload sent possible ignore lose otherwise requires clientside cooperation eventually retry failing operation idea assume eventually system enough capacity job case true although may rarer overall thing worth mentioning randomly dropping request much complex approach could initially believed even though possible implement naive functional version algorithm like red mred ared rred blue pie le include small important variation random rate calculated modified account metric codel bit special case essentially requires configuration used backpressure loadshedding mechanism depending whether wait acceptance task specific implementation used able notify specific task dropped queue system tend fairly interesting lot task ability insert random asynchronous point pipeline accidentally undo work erlang following library implement various mechanism capacity probe get issue start interesting simply ask question force reaction shut system key metric high example work dropped memory get high cpu usage important detect send buffer network get filled database pool capacity exhausted course doable metric general shared across application cpu memory scheduler usage specific current apps pool usage specific api failure rate etc get play specialty multiple component specifically circuit breaker workregulation framework allow sampling former case simpler understand circuit breaker basically gatekeeper operation track given metric failure rate timeout delay similar metric failure rate judged high detected circuit breaker instantly prevents specific operation taking place return error instead thought component work efficiently counter work different metric maximal value naive circuitbreaker usage may example say given call web service fails time second assume prevent attempt second could also say take get result back consider remote service busy consider call failure circuitbreakers important component building stable system interesting often allow mode manually trip breaker long desire incoming call seen forced fail reason interesting use property build probe agent control certain breaker looking breaker entering system know worth scheduling given task denying putting probe place critical area system key metric cut trip circuit breaker see fit let u create surprisingly simple efficient mechanism allowed part system become asynchronous bypass common mechanism long consequence overload deep somehow captured one circuit breaker case everincreasing mailbox example memory could easily play role one caveat using circuit breaker though tend allornothing mechanism use therefore create flappy system react somewhat violently probe melting fuse simple way try work around use queue dampener put probe check queue kind barrier last could queue size include counter approach queue get drained blown fuse individual effect becomes like regulator full stop perfect match cause failure pretty major remote service entirely systematic approach resolve one seen job framework rather manually installing bunch circuit breaker queue overall system see limit input augmented sampling various metric cpu memory framework use sample taken various probe around system use weighing mechanism choose rate job queue may consumed consuming queue modulated metric may allowed fill point request directly denied add framework typically employed edge system throughout able take account various internal metric characteristic system get general configurable policy one spot protects rest system allowing clearer implementation rest may actually encourage asynchronous behaviour interesting approach mutually exclusive circuit breaker usually extremely cheap run check combining another approach great way preserve overall system balance major failure happen upstream component service case guaranteed failure operation would likely much expensive account within queue management framework erlang commonly seen circuit breaker library one tool full blown job management ulf wiger job framework conclusion lot possible solution kind task workload hoped show text rich zoo overload problem potential solution applied solve ranging far beyond simple queue boundary mailbox reasoning looking system becomes interesting figure approach best small system relatively infrequent loadspikes may fine queue pullbased mechanism allsynchronous system may fine simple counterbased protection tricky case complex system may hand require involved approach especially analyzing overall workflow complex solution range active queue management gathering kind metric probe enriching scheduling regulating mechanism system also combined together produce performant solution without requiring titanesque effort thanks jesper louis andersen evan vigilmcclanahan reviewing text
307,Lobsters,erlang,Erlang development,Brujo à la carte – Erlang Battleground,https://medium.com/erlang-battleground/brujo-%C3%A0-la-carte-13ea4f872419,brujo à la carte erlang battleground,format,formatnow tricky part moment sure talking see thing impromptu meeting really give much time actually prepare talkon hand given fair number talk last year written quite lot year run little voting beginning meetup let audience pick talk want give onei prepared option already maybe add another one week ready colombian folk
308,Lobsters,erlang,Erlang development,Writing an Erlang Template Compiler (2009),http://www.evanmiller.org/write-a-template-compiler-for-erlang.html,writing erlang template compiler,write template compiler erlang evan miller ord camp know target erlang core erlang intermediate code beam compiler step language erlydtl compiler piece scanner erlydtlscannererl compiler piece parser yecc erlydtlparseryrl compiler piece compiler erlydtlbeamcompilererl source source concluding remark reference erlangotp core erlang man page man page erlydtl roberto saccon evanmillerorg twitter r wizard data le time communicate discovery visually back evan home page subscribe r twitter youtube,write template compiler erlang evan miller february adapted talk gave ord camp erlang advanced distributed software platform one great network multicore computing believe almost ready prime time web programming least one big issue holding erlang platform back erlang language poor fit many problem web programmer face example erlang hard refactor builtin syntax hash map string manipulation hard going talk one way circumvent problem implement another language run erlang platform ambitious might implement fullfeatured programming language going talk writing compiler simple template language know target erlang platform virtual machine erlang code get compiled binary code byte code called beam take intermediate form along way compiler writer first need choose target platform one erlang highest level programmer write core erlang lower level readable programmer intermediate code even lower level readable beam byte code target need learn internals know much internals going target erlang language compiler turn template file erlang code call standard erlang compiler actually cheating end day still producing compiled module one know cheated compiler step language first need choose language compile help get hold language specification one implementing django template language really spec official implementation python consult whenever sure something rest tutorial take example roberto erlydtl project compiler piece scanner first step towards implementing language write scanner scanner read file decides token token string bracket identifier language keyword sort thing scanner return flat list token information line token erlang use program called leex help write scanner write scanner plain erlang know leex writing scanner going oldfashioned way important stuff scanner module erlydtlscannererl first boring stuff module erlydtlscanner export going take list represents source code compiling scan template scan template intext see call whose argument list character remaining scanned list token scanned far current position row column current state state atom pas around tell u whether scanning process eg whether waiting string get closed like state finitestate machine theory computation course actually scanner finitestate machine function clause define transition rule one rule scan scanned row column intext scan openvar row column scanned row incode mean state intext see push onto list token increment column position two character put u state incode wait see scan rest pretty cool accomplish four thing two line erlang erlang pretty good language scanning scanning rule dealing code comment scan scanned row column intext scan scanned row column incomment scan scanned row column incomment closer scan scanned row column incomment closer scan scanned row column incomment scan scanned row column intext scanning rule dealing noncode part template file scan n scanned row column intext scan appendtextchar scanned row column n row intext scan h scanned row column intext scan appendtextchar scanned row column h row column intext increment row column position note use appendtextchar current character appended previous token define function jump hoop u appendtextchar scanned row column char case length scanned text row column char token scanned case element token text text element token char element token text element token char scanned end end following rule deal character special meaning django template language scan scanned row column closer scan comma row column scanned row column incode closer scan scanned row column closer scan pipe row column scanned row column incode closer scan scanned row column closer scan equal row column scanned row column incode closer scan scanned row column closer scan colon row column scanned row column incode closer scan scanned row column closer scan dot row column scanned row column incode closer bit verbose whatever give main idea rule finally reach end input need reverse list token mark language keywords run across scan scanned intext ok list reverse list map fun identifier po string revstring list reverse string keywords else endif many others type case list member revstring keywords true listtoatom revstring keyword identifier end type po revstring type po string type po list reverse string end scanned done scanner return ok token time send token parser compiler piece parser parser take list token arranges tree structure called parse tree probably something like first c class take make tree parent child idea help form parser generator called yecc yecc like yacc erlang tell neighboring token related one another yecc rest yecc file look like three part list nonterminals list terminal list rule nonterminals thing expand list terminal nonterminals terminal expanded using rule expand nonterminals terminal subset django template language yecc file erlydtlparseryrl enough deal statement nonterminals element literal value variable ifblock ifbraced ifexpression elsebraced endifbraced terminal closetag endifkeyword ifkeyword elsekeyword dot opentag notkeyword text rootsymbol element rule format thing expanded component expansion erlang expression recombining component list tree highest level put thing list element empty element element text element element ifblock well interesting say ifblock ifblock ifbraced element elsebraced element endifbraced ifelse ifblock ifbraced element endifbraced using tuples build tree nonterminal expand ifbraced opentag ifkeyword ifexpression closetag ifexpression notkeyword ifexpression ifexpression value finally terminal rule value little complicated go see part colon strictly optional case nothing get added parse tree elsebraced opentag elsekeyword closetag endifbraced opentag endifkeyword closetag need compile yecc file erlang code yecc built erlc run erlc src srcmyfileyrl spit erl file total yecc file erlydtl weighs line roughly length scanner line code compiler done well kind compiler piece compiler parse tree want turn erlang code actually turn abstract syntax tree ast help erlang module called erlsyntax call special function compile ast byte code building ast instead erlang ascii code make code feel cleaner easier debug although time seem verbose erlsyntax method corresponding every syntactic structure erlang want build atom call erlsyntax want build function call call erlsyntax check erlsyntax man page detail compiler code found erlydtlbeamcompilererl ugliest part compiler making ast compiled skeleton need ast module definition export statement render function compiled template erlydtl done function called erlydtlbeamcompiler source probably make head hurt read time key part call erlsyntax revert convert ast representation called form send straight compile prettiest part erlydtl compiler also subtle function called source look node parse tree convert appropriate erlang ast node recursively thing child descend parse tree need pas along context specifically variable currently scope might pick scope descend parse tree shed come back take look snippet bodyast take top level parse tree decides parent node bit deal statement bodyast djangoparsetree context list map fun variable content ifelseast variable bodyast content context emptyast context variable content ifelseast variable emptyast bodyast content context context ifelse variable ifcontents elsecontents ifelseast variable bodyast ifcontents context bodyast elsecontents context context end djangoparsetree code like cool breeze may well maybe code like one simple pleasure life basic structure recursive descent compiler function process node pass child node back bodyast statement call function ifelseast build ast testing whether variable evaluates true running appropriate code block else block pass empty ast code run variable false ifelseast ifelseast variable ifcontentsast elsecontentsast context first resolve variable right scope ast varname resolveifvariableast variable context write statement erlsyntax caseexpr erlsyntax application erlsyntax atom erlydtlruntime erlsyntax atom isfalse ast erlsyntax clause erlsyntax atom true none elsecontentsast erlsyntax clause erlsyntax underscore none ifcontentsast well basic idea erlydtl compiler compiler piece weighs around line cheat little bit runtime code compiled module depend told fullfeatured template compiler line code something code afternoon huge undertaking either concluding remark erlang almost certainly server platform future need creative idea make web programming pleasant implementing template language start new language model controller well say rail possible due great metaprogramming feature rail equivalent erlang possible due ease writing compiler erlang platform reference erlangotp platform future core erlang intermediate language template compiler probably target yecc man page erlang parser generator erlsyntax man page package building abstract syntax tree erlydtl django template language erlang written roberto saccon reading evanmillerorg random collection math tech musing liked might also enjoy get new article published via twitter r want look statistical pattern mysql postgresql sqlite database desktop statistic software wizard help analyze data le time communicate discovery visually without spending day struggling pointless command syntax check back evan home page subscribe r twitter youtube
309,Lobsters,erlang,Erlang development,The Hidden XML Simplifier – Erlang Battleground,https://medium.com/erlang-battleground/the-hidden-xml-simplifier-a5f66e10c928,hidden xml simplifier erlang battleground,introduction function http worldcomfamily http worldcomfamily http worldcomfamily http worldcomfamily verbose xmerlscan xmlelement rest xmlelement xmlelement http worldcomfamily node http worldcomfamily http worldcomfamily node http worldcomfamily http worldcomfamily node lot,introductionso example let say parse following xml json xml parser come bundled otp xmerl since already decide use parse file little bit googling determine need xmerlscan file familyxml xmlelement family family xmlnamespace http worldcomfamily xmlattribute xmlns http worldcomfamily false xmltext n text xmlelement parent parent xmlnamespace http worldcomfamily xmltext n text xmlelement person person xmlnamespace xmltext family xmlelement person person xmltext undeclared xmltext n text xmlelement child child xmlnamespace http worldcomfamily xmltext family xmlelement person person xmltext xmlelement person xmltext undeclared xmltext n text undeclared oh verbose first doc state clearly result xmerlscan tuple xmlelement rest xmlelement xmlelement let try adding record definition rr code libdir xmerl includexmerlhrl xmerlevent xmerlfunstates xmerlscanner xmlattribute xmlcomment xmlcontext xmldecl xmldocument xmlelement xmlnamespace xmlnode xmlnsnode xmlobj xmlpi xmltext element xmerlscan file familyxml element xmlelement name family expandedname family nsinfo namespace xmlnamespace default http worldcomfamily node parent po attribute xmlattribute name xmlns expandedname nsinfo namespace parent po language value http worldcomfamily normalized false content xmltext parent po language value n type text xmlelement name parent expandedname parent nsinfo namespace xmlnamespace default http worldcomfamily node parent po attribute content xmltext parent po language value n type text xmlelement name person expandedname person nsinfo namespace xmlnamespace default http worldcomfamily parent po xmltext parent po language value n type text xmlelement name person expandedname person nsinfo namespace xmltext parent parent po language language xmlbase elementdef undeclared xmltext parent po language value n type text xmlelement name child expandedname child nsinfo namespace xmlnamespace default http worldcomfamily node parent po attribute content xmltext parent po language value n type text xmlelement name person expandedname person nsinfo namespace xmltext parent child po language xmlelement name person expandedname person xmltext parent language xmlbase elementdef undeclared xmltext parent po language value n type text language xmlbase elementdef undeclared clearer still lot information hear erlang master supposed inspect record visually use function provided xmerl module walk extra info provided record precisely thatnevertheless often find wanting simpler representation xml basic data need possible tuple format
310,Lobsters,erlang,Erlang development,MLFE: ML landing in the Erlang world,https://medium.com/@unbalancedparen/d-day-invasion-with-mlfe-ml-landing-in-the-erlang-world-ef2267ae3215,mlfe ml landing erlang world,mlfe ml landing erlang world monad tutorial pornhub war ad blocker continued jeremy pierre mlfe lobster reddit programming hn mlfe create ml language top erlang vmbeam main problem find coding erlang coding ml like language implement type inference algorithm ocaml type checker work type programming language algorithmw generate core erlang code erlang code type check message one biggest issue erlang case necessary write code lot nested case elixir added special form deal issue rust added new operator provides syntax sugar help deal issue rabbitmq team created erlando using erlang parse transform erlang like macro add syntax extension erlang syntax monad important one solve somehow issue seen mlfetypeerl mlfe also issue plan adding construct syntactic sugar deal type issue difficult thing implementing mlfe recommendation u implemented language yet great lfe graal truffle plai jeeves gradual typing first class module language recommend keeping eye purerl,mlfe ml landing erlang worldtime passed since last interview monad tutorial openbsd released version year continues release without agile openssl vulnerability keep breeding pornhub war ad blocker continued macbook pro pro anymore new javascript package manager released facebook last least brexit trump reality shape new world ordergoing back endogamic tech world interviewed jeremy pierre mlfe ml flavoured erlang learning haskell playing elm became quite fan adts hindleymilner type system really exited mlfe think way counterbalance love lisp language let add little bit ml coffee one project list implement ml like language top erlang vmbeam instead recreating wheel hope see standing upon shoulder mlfe invasion began question please let know via lobster reddit programming hn au mlfewhat mlfe ml flavoured erlang statically typed strict eagerly evaluated language erlang vm patterned little bit part ocaml elm incredibly early language development already thing like sum type product type eg tuples record row polymorphism pretty basic foreign function interface erlang proper honestly language probably need renaming almost entirely impossible call erlang code directly outside ffi create ml language top erlang vmbeam appreciate lot practicality erlang ecosystem least operational aspect vm wanted something faster feedback type issue dialyzer currently provides along brevity expressiveness come feature like ocaml elm adts one earliest driver constantly wishing scala case class every time wrote erlang day job involves main problem find coding erlang coding ml like language often work directly ml dialect perfectly honest although keep trying find reason use maybe subconscious reason behind starting mlfe mentioned however often work scala le pervasive approach pattern matching second class nature thing like actor jvm often sore point said would really great something like scala future scalaz task erlang vm language well maybe build something mlfe scratch itch little early say thinkhow implement type inference algorithm give credit apologize implementing badly oleg kiselyov incredibly helpful article ocaml type checker work relied heavily type programming language bit algorithmw earliest work typerit started basic translation erlang oleg kiselyov eagerstrict inferencer example grew since algorithm relies unification hence mutation mlfe inferencer need reference cell currently implemented erlang process like move something like ets probably wait trying rewrite clean typer mlfe generate core erlang code erlang code mlfe ast translated core erlang ast using cerl module compiled beam module therehow type check message mlfe receive block type receiver receiver polymorphic two parameter kind message received result type contained expression two parameter determined unifying type pattern type result portion receive clause egreceive zero x isinteger x notzeroall pattern clearly integer result portion atom type internally mlfe would treceiver tint tatom aside course use union type want complex messagesunifying receiver enclosing expression make expression receiver assigning variable let expression whole thing becomes receiver eglet mymsg receive zero x isinteger x notzero mymsg inalist whynot let expression treceiver tint tlist tatom wrapped function whole function receiver foo let mymsg receive zero x isinteger x notzero mymsg inalist whynot type treceiver tint tarrow tunit tlist tatom function unit list atom internally receives integer messagesnow spawn process spawn us receiver first parameter constrain resulting pid specific type spawn function receiver integer resulting tpid tint message sent must able unify tint try send float string get type error compile timeif spawn function receiver get tpid undefined since undefined unify type type error send particular process message allone biggest issue erlang case necessary write code lot nested case elixir added special form deal issue rust added new operator provides syntax sugar help deal issue rabbitmq team created erlando using erlang parse transform erlang like macro add syntax extension erlang syntax monad important one solve somehow issue seen mlfetypeerl mlfe also issuedo plan adding construct syntactic sugar deal type issue certainly common issue within mlfe typer currently plan add specific error handling sugar since worry might push people away otp supervision hierarchy said think unreasonable simple error type handling alternative library trycatch exist yet mlfe could look like something simple following module simpletryexport result error ok result error error try run f wrapping success ok failure error tryf f try ok f catch err error err success apply function f maintain failed result trymap f match ok result let runner f result tryf runner error e ti call ideal need anonymous function make usable begin think demonstrate relatively easy solve problem way without needing firstclass constructsto clear think rust approach make great deal sense since far aware result type core language reluctance mlfe almost entirely due convention capability place otp see beneficial rightwhat difficult thing implementing mlfe wrapping head around type inference unification definitely challenging thing far still working understand lot detail barely ready dig something like implementation ml module system especially come functors need parametric module order type binding lot otp probably something pretty simple restrictive start lot studying learning even reasonably confident still type system decidable recommendation u implemented language yet pick problem feature find interesting dive start simple definitional interpreter play thing first want learn existing platform ast reynolds paper great write interpreter wanted target particular runtime core erlang ast generally pretty easy get started lfe great learn like jvm graal truffle look really interesting tooi yet taken time dig sicp plai heard dr krishnamurthi working new one want point understand really good deep divesthere many great idea check explore recent work like dr jean yang jeeves security policy enforcement gradual typing especially effect eg drs banados schwerter garcia tanter new approach first class module dr andreas rossberg much barely dug dr barbara liskov decade work mountain great idea many people barely scratching surface really exciting enthusiastically recommend anyone interest programming language pick paper read idea research start following lead start reading group language recommend keeping eye rust pony look like really interesting stuff curious purerl erlang backend purescript go seems lot cool stuff happening scheme side thing keep worrying missing
311,Lobsters,erlang,Erlang development,RabbitMQ macros that add do syntax and monads plus the Scheme form of cuts to Erlang [2011],https://www.rabbitmq.com/blog/2011/05/17/can-you-hear-the-drums-erlando/,rabbitmq macro add syntax monad plus scheme form cut erlang,introduction erlando parse transformer cut scheme form cut haskell use cut motivation definition always tuples list record case testcuterl inevitable monad tutorial mechanic comma lot different type monad bind monad transformer parameterized module erlang beyond monad cut erlando erlang monad programming language r,u rabbitmq hq spend time working number functional language addition erlang haskell scheme lisp ocaml others whilst lot like erlang vmemulator inevitably feature miss language case spent couple year working haskell returning rabbitmq fold sort feature missing laziness type class additional infix operator ability specify precedence function fewer parenthesis partial application consistent standard library donotation fair list take get around implementing erlang two starter introduction erlando set syntax extension erlang currently consists two syntax extension take form parse transformer cut add support cut erlang inspired scheme form cut cut thought lightweight form abstraction similarity partial application currying add support dosyntax monad erlang heavily inspired haskell monad library nearmechanical translation haskell ghc library use use parse transformer must add necessary compile attribute erlang source file example module test compile parsetransform cut compile parsetransform compiling testerl must ensure erlc locate cutbeam andor dobeam passing suitable path erlc pa pz argument example erlc wall debuginfo include pa ebin ebin srccuterl erlc wall debuginfo include pa ebin ebin srcdoerl erlc wall debuginfo include pa testebin pa ebin testebin testsrctesterl note using qlc may find need careful order parse transforms found compile parsetransform cut must occur includelib stdlibincludeqlchrl cut motivation cut motivated frequency simple abstraction lambdacalculus sense used erlang relatively noisy nature declaring fun example quite common see code like withresource resource fun case lookupresource resource ok r fun r error err err end myfun b c withresource fun resource myresourcemodification resource b c end ie fun simply created order perform variable capture surrounding scope leave hole argument provided using cut function myfun rewritten myfun b c withresource myresourcemodification b c definition normally variable occur pattern ie match occurs assignment case function head example bar foo bar cut us expression indicate abstraction occur abstraction cut always performed shallowest enclosing expression example listtobinary math pow create expression listtobinary fun x math pow x end fun x listtobinary math pow x end fine use multiple cut expression argument created abstraction match order var found expression example x z sum x z sum ok x z sum error notsum test ok perfectly legal take cut cut abstraction created cut normal fun expression thus recut necessary test ok note simple fun constructed cut argument evaluated prior cut function example io format test f io format test line f io format test line print test line test line cut creates fun x io format test line x end thus clear x must evaluated first fun invoked course one would crazy enough sideeffects function argument expression never cause issue cut limited function call used expression make sense tuples f f list dblcons list list test f dblcons f note nest list list tail erlang still treated one expression example b c e exactly right erlang parser onwards b c e ie sublists tail position form subexpressions thus f g h f g h however clear difference tail list defined following following defining another list element f synonym g f b g b record record vector x z test getz vectorz getz vector z setx vector x v vector x setx vector case f case n isinteger n n n n n end f ok f ok see testcuterl example including use cut list comprehension binary construction note cut allowed result cut useful interacting evaluation scope example f begin end allowed argument f would evaluated invocation body would effect already fully evaluated point parse transformer permit haskellstyle donotation erlang make using monad monad transformer possible easy without donotation monad tend look like lot line noise inevitable monad tutorial mechanic comma follows brief mechanical introduction monad differs lot haskell monad tutorial tend view monad mean achieving sequencing operation haskell challenging haskell lazy language erlang lazy language powerful abstraction possible using monad still worthwhile whilst mechanical tutorial possible see advanced abstraction possible let say three line code foo b bar dog ok three simple statement evaluated consecutively monad give control happens statement erlang programmatic comma wanted implement programmatic comma would might start something like foo comma b bar dog comma ok quite powerful enough unless throw sort exception ca nt actually stop subsequent expression evaluated time probably like function able act variable currently scope possible either extend function take result preceding expression choose whether subsequent expression evaluated comma foo fun comma bar dog fun b ok end thus function take result previous expression control whether passed next expression defined function monadic function pretty difficult read program function especially erlang annoyingly nt allow u define new infix function special syntax necessary haskell donotation borrowed abused erlang list comprehension haskell also lovely typeclasses sort faked specifically monad parse transformer write erlang monad foo b bar dog ok readable straightforward transformed monad foo fun monad bar dog fun b ok end intention latter form readable form however clear function monad complete control happens fun right hand side ever get invoked value lot different type monad relatively nice syntax using monad also code monad foo b bar dog ok possible value monad answer first question almost anything later question module name implement monad behaviour covered one three monadic operator others lift value monad see example shortly take term describing error encountered informs whichever monad currently use sort error occurred note within donotation function call function named return fail automatically rewritten invoke return fail within current monad people familiar haskell monad may expecting see fourth operator interestingly turn ca nt implement strict language unless monad type built top function strict language argument function evaluated function invoked argument reduced function prior invocation argument function strict language fully reduced prior invoked problematic operator meant control whether subsequent expression evaluated solution would make basic monad type function would mean argument would become function function result however required b behaves identically fun b end whenever come monad b rewrite fun b end rather b effect operator exist simplest monad possible identitymonad module identitym behaviour monad export x fun fun x return x x fail x throw error x make programmatic comma behave like erlang comma normally bind operator inspect value passed always invokes subsequent expression fun could inspect value passed sequencing combinators one possibility result maybemonad module maybem behaviour monad export x fun fun x nothing fun nothing return x x fail x nothing thus result preceding expression nothing subsequent expression evaluated mean write neat looking code immediately stop failure encountered ifsafedivzero x fun maybem result case true fail divide zero false return x end return fun result equal fun invoked result ifsafedivzero function call nothing equal result ifsafedivzero function call fun x see within doblock mention nothing abstracted away maybemonad result possible change monad use without rewrite code one common place use monad like maybemonad otherwise lot nested case statement order detect error example writefile path data mode binary write mode binary write case makebinary data bin isbinary bin case file open path ok hdl case file write hdl bin ok case file sync hdl ok file close hdl error e file close hdl e end error e file close hdl e end error e e end error e e end makebinary bin isbinary bin bin makebinary list try iolisttobinary list catch error reason error reason end transformed much shorter writefile path data mode binary write mode binary write errorm bin makebinary data ok hdl file open path ok result return errorm ok file write hdl bin file sync hdl file close hdl result note nested doblock nonmonadic code ensure file opened always call file even error occurs subsequent operation achieved wrapping nested doblock call even inner doblock error error lifted nonerror value outer doblock thus execution continues subsequent file call using errormonad remarkably similar maybemonad match typical erlang practice indicating error error reason tuple module errorm behaviour monad export error err error fun error result fun fun result return x ok x fail x error x monad transformer monad nested doblocks inside doblocks parameterized defining monad transformation another inner monad state transform commonly used monad transformer especially relevant erlang erlang singleassignment language common end lot code incrementally number variable init dimension plantseeds seedcount didflood pouronwater watervolume applysunlight time pouronwater watervolume crop harvest doubly annoying look awful also renumber many variable reference whenever line added removed would nt nice could abstract state could monad encapsulate state provide collect function wish run implementation monadtransformers like state us hidden feature erlang distribution called parameterized module described parameterized module erlang statetransform applied monad apply identitymonad get looking key extra functionality state transformer provides u ability get set plain modify state within inner monad use cut parse transformer write statet statet new identitym sm statet modify smr statet modifyandreturn statet exec statet statet put init dimension sm plantseeds seedcount didflood smr pouronwater watervolume sm applysunlight time smr pouronwater watervolume crop smr harvest undefined start creating statetransform identitymonad syntax instantiating parameterized module statet variable referencing module instance case monad set two shorthand running function either modify state modify state return result whilst bit bookkeeping achieve goal state variable renumber whenever make change use cut leave hole function state fed obey protocol function return result state form result state tuple statetransform rest beyond monad standard monad function available monad module also implemented monadplus work monad obvious sense zero plus currently maybemonad listmonad omegamonad associated function guard msum mfilter available monadplus module many case fairly mechanical translation haskell erlang possible many case converting monad combinators straightforward however lack type class erlang limiting tag cut erlando erlang monad entry posted tuesday may pm matthew sackman filed programming language follow response entry r feed comment ping currently closed
312,Lobsters,erlang,Erlang development,The Josephus Problem in Erlang - Stratus3D,http://stratus3d.com/blog/2016/10/29/josephus-problem-in-erlang,josephus problem erlang,recursion pattern matching binary pattern matching quite question conclusion recursive function erlang process reference,saw video josephus problem yesterday immediately thought might fun problem solve erlang first video got interested recursion pattern matching thought would interesting problem solve erlang recursion pattern matching decided use list integer represent soldier circle recursive function loop around list remove every second integer one remains pattern matching make easy pick every second integer first attempt solving problem recursion pattern matching module josephus export survivorincircle num killtoleft list seq num killtoleft survivor one person remaining survivor survivor killtoleft survivor start another loop around circle killtoleft list reverse survivor killtoleft killer survivor killer last person loop start another loop around circle killtoleft killerlists reverse survivor killtoleft killer killedrest survivor killer survives killtoleft rest killersurvivors josephus survivorincircle josephus survivorincircle josephus survivorincircle josephus survivorincircle josephus survivorincircle josephus survivorincircle solution requires function clause would nice required clause ideally one clause one number remains list another clause two number list actually erlang two clause using operator concatenate surviving number onto end list remaining number never empty module josephus export survivorincircle num killtoleft list seq num killtoleft survivor one person remaining survivor survivor killtoleft killer killedrest killer survives killtoleft rest killer usually try avoid using operator erlang creates entirely new list time used elegant first solution le efficient small list matter largest list created contained integer solution fast enough binary pattern matching also thought binary method solving problem interesting need move first bit binary representation number end binary also something done easily erlang pattern matching since requires moving around couple bit far fastest way solve problem little tinkering little help erlang irc channel got working survivor num restbinary integertobinary num binarytointeger restbinary actually moving bit around moving byte call return binary representing sequence one zero eg ideally like move bit instead byte easy erlang took figure get work asked quite question finally got working note using erlang function using binary encodeunsigned convert number binary notation representation required bit moving trick work convert number binary notation remove leading zerobits move first bit end convert back integer see specify number bit used construct resulting integer count number bit original binary get number bitsolution num restbits removeleadingzerobits binary encodeunsigned num size bitsize rest survivor size restbits survivor removeleadingzerobits restbitstring removeleadingzerobits rest removeleadingzerobits bin bin conclusion writing looked online solution josephus problem erlang found several different solution used recursive function like others used erlang process erlang pattern matching recursion make ideal tool solving sort problem fun problem solve erlang spend time thinking going translate problem erlang jumped started coding binary solution far efficient expressive relatively succinct reference
313,Lobsters,erlang,Erlang development,MLFE v0.2.4 Released,http://noisycode.com/blog/2016/11/09/mlfe-v0-dot-2-4-released,mlfe released,mlfe version daniel abrahamsson type alias daniel daniel record presentation neel krishnaswami elm curious first time typed mlfetypererl contributing discussing freenode username,mlfe version available includes significant change fix type alias use union type type constructor thanks daniel abrahamsson work early support record row polymorphism fix map typed type alias daniel fix following type correctly module circle export type radius float type circle circle radius new r circle r area c let pi match c circle r pi r r issue typer looking radius member tried type circle type variable used nested type handled correctly either big thanks daniel work record basic record row polymorphism supported mlfe compatible erlang record module recordswithx export makexy x xx yy makexyz x z xx yy zz getx rec match rec xx x matter type record pas record returned tuple always remember full set field return type eg pas return type wo nt forget z full type returned function pas exact record int x int int z int getxandtherecord rec match rec xx x rec worth noting module course construct polymorphic record could call makexy foo bar makexy two would distinct type x foo bar x string string x int float understanding row polymorphism far driven presentation neel krishnaswami well skimming paper elm history currently missing adding field record updatingreplacing accessing individual record field currently planning adding removal record field seems like could get problematic andor confusing quickly although pose particular technical challenge far tell add field record like following work take x return x hello string getxandaddhello rec match rec xx x rec hello world accessing individual member look pretty simple eg type int string let tuple getxandaddhello match tuple x rec recx rechello curious mlfe typer use row variable capture extra field record passed around row variable constructed added record first time typed function mlfetypererl probably also interest record currently compiled map simply make implementation right far easier tuples need way distinguish record map pattern match code generation add key struct key either map record distinguish two compiled pattern match course leverage well contributing discussing always contribution welcome subject licence code conduct specified project repository please join irc channel mlfe freenode help general discussion governed code conduct project irc twitter username
314,Lobsters,erlang,Erlang development,Erudite Erlang,https://dhavaldalal.wordpress.com/2016/10/27/erudite-erlang/,erudite erlang,erlang deep dive erlang ecosystem robert virding functional conference john hughes functional programming matter sequential erlang language pattern matching function module node exception concurrent erlang creating process supervisor erlang ecosystem using erlang erlang good good realtime like,october opportunity learn erlang preconference workshop deep dive erlang ecosystem robert virding one cocreators language functional conference bengaluru many thing surprised especially philosophy behind letting thing fail custom datatypes facilitate upgrading thing system running share nothing massively scalable baked language till vm erlang functional language though start one evolved applies actor model erlang well got introduced language solve realworld problem simplicity thing got approached john hughes paper functional programming matter highlight structuring software using complicated scope rule separate compilation unit help clerical detail modularisation however two great feature functional language higherorder function hofs lazy evaluation separating generation selection contribute significantly modularity additionally view erlang brings modularity function process take modularity runtime function become firstclass process anything special function simply using spawn call function run separate process thus partitioning application based load becomes dynamic axis modularity pervade physical structure organising code really big thing jot thing managed scribe workshop robert started sequential erlang followed concurrent erlang sequential erlang language equivalence null erlang character datatype proper string datatype list character shell present prettyprinted string syntactic sugar example h e l l print hello atom concept borrowed prolog value constant literal example foo atom point foo unique one system name foo example module name function name atom c sample print tuple sample ok also atom atom stored atom table size million convert atomtolist foo use atom thing dynamically careful use converting listtoatom give create new datatypes erlang common convention create datatype create tuple first element type name example person joe armstrong constructor act creating data structure writing data want create type use first element tuple type discriminator atom example define square side square define circle radius c circle define triangle length side triangle erlang functional data immutable way erlang vm many thing implemented vm level fundamental variable rebound variable beginning special called care variable global variable erlang share data global data mutation data allowed variable unbound exception error match right hand side value forget value work shell function f ok variable unbound pattern matching pattern match operator second big thing confused assignment pattern matching general structure pattern expression expression contain unbound variable list list element list con operator example headrest head rest ht exception error match right hand side value erlang probably language binary pattern matching pattern matching bitstrings make easy grab part binary packet validation function always prefix module name import entire module module function way called declaring function example circumference r math pi r write variable uppercase example r case use lowercase becomes atom treated variable also product x x product x z x z different function multiple dispatch based pattern matched example area square side side side area circle radius radius radius area triangle b c math sqrt sa sb sc said two difficult thing computer science naming distributed computing erlang lambda handle naming distributed computing builtin support module construct allows related function grouped together module name file name store demo demoerl module demo first directive export exportable function double x time x private function time x x exported function called outside module case double exported function name followed arity case function double arity unexported function private visibility upgrade system running one key principle behind reloading module one reason erlang userdefined type come way hotloading module node erlang node composed many erlang process erlang process o level process however erlang system o process example start erlang system shell prompt say erl sname foo erl sname bar erlang system spawn million erlang process thing shared erlang system across erlang process one atom table per erlang system see code send message across erlang process two erlang process also communicate sending message pid etc marshalunmarshall data across process need marshallingunmarshalling across erlang process exception erlang big error defensive programming erlang system designed handle error whenever exception occurs instead handling exception erlang let process crash start new one hope take care died restarted fundamentally different way thinking handling exception start handling exception client code get polluted lot exception handling erlang scared crashing erlang process exception occurs erlang process killed whole erlang system closest metaphor think erlang process like cell body one dy create new one given time check process running erlang system process concurrent erlang creating process everything erlang process fact io also process one design srp compliant process group related process supervisor create process use spawn return process id syntax pid spawn mod func args example spawn sample add pid spawn sample add process message passing way process communicate sending asynchronous receive selective suspend matched message pattern removed executed whereas unmatched message left queue tool called wombat monitor erlang system queue one define threshold process dy message queue everything else associated also dy process multiple receive end block module many function function run process way tell physical inspection except reading code knowing function run different process spawn create process node within local node use pid instead use registered name alias pid return success error value tuple success ok result error error reason timeout error timeout forget remove message queue timeout occurs general process skeleton initialize loop terminate managing state carry state along produce new state operation carry along tracing one use observer start look graphical interface tracing detail supervisor group related process supervisor supervisor tree created toplevel supervisor kill supervisor kill child kill child keep restarting genserver implementation generic server implementation callback plugin erlang ecosystem test tool eunit commontest erlang build tool run eunit test language many language available code elixir lfe mnesia distributed database using erlang take time get new featuresthings language typically take release stabilize normally release per year backward compatible looking say elephant cope erlang make dance erlang good good strength concurrency fault tolerence scaling nicely used soft realtime system however efficient numerical calculation sharing thing use erlang concurrent glue part system different part system different requirement use java program talk databasenumerical calculation use erlang system frontend world talk java behind scene well erlang start exploring post meant inspiration journal like like loading related
316,Lobsters,erlang,Erlang development,The Extinction of the Dodos (OTP style) – Erlang Battleground,https://medium.com/erlang-battleground/the-extinction-of-the-dodos-otp-style-f421f9de4275,extinction dodo otp style erlang battleground,going restart intensity maximum restart intensity restart strategy abnormally permanent abnormal sasl rescue sasl killed reachedmaxrestartintensity killed reachedmaxrestartintensity reachedmaxrestartintensity shutdown shutdown,going repeat usual message one time still think useful read paragraph without previously tried understand issue go try right tried let see found thing marc intensitylet talk little bit supervision configuration first particular would like show paragraph erlang doc prevent supervisor getting infinite loop child process termination restarts maximum restart intensity defined using two integer value specified key intensity period supflags map assuming value maxr intensity maxt period maxr restarts occur within maxt second supervisor terminates child process intensity default period default check animalssup module see used intensity period mean restarts happen single second supervisor die dodo killed clearly demand restarts single secondso dodo supervisor died problem solved right cockroach also killed also required restarts second supervisor restarted one dodo restart strategywe determined supervisor cockroach dodo died one restarted process charge restarting worldsup let check spot difference supervisor defined childspecs part supervisor definition returned difference restart field dodo transient cockroach permanentbut mean let check erlang doc restart defines terminated child process must restarted permanent child process always restarted temporary child process never restarted even supervisor restart strategy restforone oneforall sibling death cause temporary process terminated transient child process restarted terminates abnormally another exit reason normal shutdown shutdown term ok since cockroach permanent supervisor always restarted make sensenow dodo well supervisor terminated reach max restart strategy look lot like abnormal termination nevertheless restarted sasl rescue remember told added sasl dependency app well sasl print progress report also display crash report process terminated intentionally removed console snippet let see say know looking world start progress report application world startedat nonode world adddodos world killdodos supervisor report supervisor local dodo context childterminated reason killed similar childterminated message true true true true true true supervisor report supervisor local dodo context shutdown reason reachedmaxrestartintensity offender pid id animal mfargs animal startlink dodo restarttype permanent childtype worker process killed reason killed one killed reason reachedmaxrestartintensity report dodo supervisor killed considering doc shown seems like reason termination supervisor normal shutdown shutdown reason sasl show report terminated normallylet look log cockroach see find world addcockroaches world killcockroaches true true true true true true supervisor report supervisor local cockroach context childterminated reason killed childterminated message supervisor report supervisor local cockroach context shutdown reason reachedmaxrestartintensity offender pid id animal mfargs animal startlink cockroach restarttype permanent childtype supervisor supervisor report supervisor local worldsup context childterminated reason shutdown offender pid id cockroachessup mfargs animalssup startlink cockroach restarttype permanent childtype supervisor case since cockroach supervisor permanent mean restarted regardless reason terminated report sasl report let u see reason cockroach supervisor termination fact shutdownthat may seem unexpected first glance considering one goal supervision tree able escalate issue higher level app tree better deal problem lower level would expected worldsup restart dodo supervisor dodo determined unable deal many child restarts killed itselfthe otp team probably good reason implementation know know reason let know comment remember use transient supervisor want parent supervisor restart case maxrestartintensity
317,Lobsters,erlang,Erlang development,ML-flavoured Erlang v0.2.0 Released,http://noisycode.com/blog/2016/08/01/mlfe-v0-dot-2-0-released,mlflavoured erlang released,mlflavoured erlang eunit tristan sloughter plugin tour language language tour document next contributing discussing freenode username,mlflavoured erlang ready use version includes couple major missing piece first release including support map constructing literal map pattern matching binary support binary string release also includes early support writing unit test inside module concerned running via eunit help tristan sloughter plugin using plugin able run test defined mlfe file eunit example module new tour language module mymodule one function take single argument publicly accessible export double function defines add function inside comment cstyle double x let add b b add x x test doubling sometestchecker double basic adt type constructor type evenorodd even int odd int function integer adt evenorodd x let rem x match rem even x odd x full changelog available new language tour document available explains use language little detail anyone new next version main goal probable project rename type annotationsascriptions record like basic row polymorphism believe fit record ocaml elm need reading research likelihood record get syntax similar ocaml compiled erlang map start nicetohaves include quoted atom pipe operator notationside effect contributing discussing contribution welcome subject licence code conduct specified project repository please join irc channel mlfe freenode help general discussion governed code conduct project irc twitter username
318,Lobsters,erlang,Erlang development,History of Actors (eighty-twenty news),https://eighty-twenty.org/2016/10/18/actors-hopl,history actor eightytwenty news,history programming language introduction actor context approach concurrent programming actor model terminology rest talk classic actor model erlang actor faulttolerant system e actor secure cooperation conclusion annotated bibliography early work actor carl hewitt peter bishop richard steiger universal modular actor formalism artificial intelligence proc international joint conference artificial intelligence http erightsorghistoryactorshtml irene greif phd dissertation mit eec c hewitt control structure pattern passing message c hewitt h baker continuous functionals mit ai memo russell atkinson carl hewitt actor system proc acm sigactsigplan symp princ program lang pp phd dissertation mit actor concurrent objectoriented programming gul bookdissertation g agha objectoriented programming commun acm vol pp g agha mason f smith c l talcott foundation actor computation j funct program vol pp erlang actor requirement faulttolerance highavailability j armstrong reliable distributed system presence software error royal institute technology stockholm e actor requirement secure interaction miller e tribble j shapiro among stranger proc int symp trustworthy global computing pp taxonomy actor j de koster van cutsem w de meuter year actor taxonomy actor model key property software language lab vrije universiteit brussel,yesterday presented history actor christos history programming language class writtenout talk note prepared beforehand annotated bibliography end introduction today going talk actor model first put model context show three different style actor language including two aim realistic programming system going draw paper survey joeri de koster tom van cutsem wolfgang de meuter taxonomy common terminology splash agere overview gul agha contributed hugely study actor comm acm operational semantics actor gul agha ian mason scott smith carolyn talcott brief mention content original paper carl hewitt peter bishop richard steiger ijcai joe dissertation erlang paper language e mark miller dean tribble jonathan shapiro tgc put annotated bibliography end file actor context approach concurrent programming one way classifying approach along spectrum private v shared state shared memory thread locking limited private state almost shared tuple space research syndicate shared private isolated actor almost private isolated enough shared routing pure functional fit chart lack shared mutable state entirely actor model actor model asynchronous message passing entity actor guaranteed delivery addressing message actor identity thing called turn shared mutable state strong encapsulation global mutable state interleaving process one message time serializes state access liveness blocking model actor performs one turn taking waiting message interpreting deciding state update actor collection action take response perhaps sending message creating new actor turn sequential atomic block computation happens response incoming message actor model buy modular reasoning state overall system modular reasoning local state change within actor state private access serialized consider interleavings message data race though get global nonprogress circumstance logical inconsistency otherwise flexible powerful capabilitybased security failure isolation fault tolerance worth remarking actorlike concept sprung several time independently hewitt many others invented developed actor two occasion actor seem independently reinvented far know one work capabilitybased operating system keykos involved design much like actor feeding research led ultimately language e work highly faulttolerant design telephone switch also culminated language erlang language clearly actor language case apparently people involved unaware actor model time terminology two kind thing actor model message data sent across medium communication actor stateful entity affect sending message back forth message completely immutable data passed copy may contain reference actor actor private state analogous instance variable interface message respond together private state interface make behaviour key term actor literature addition actor mailbox inbox message queue address denotes mailbox within framework quite bit variety model appears concrete programming language de koster et al classify actor language classic actor model create send become active object oo thread per object copying passive data object process raw erlang receive spawn send communicating eventloops passive data e nearfar ref eventual ref batching see instance actor model around u ip network one example host actor datagrams message web seen another url denotes actor http request message seen certain light even unix process actorlike single threaded use fds shm used structuring principle system architecture even language like c c hope enforcing invariant model rest talk rest talk going cover classic actor model using presentation guide compare e communicating eventloop actor language erlang process actor language classic actor model original actor paper hewitt bishop steiger international joint conference artificial intelligence incredibly far position paper lay broad colourful research vision packed amazing idea heart actor proposed universal programming language formalism ideally suited building artificial intelligence goal really ai actor programming language mean end make claim actor bring great benefit huge range area foundation semantics logic knowledgebased programming intention software contract study expressiveness programming language teaching computation extensible modular programming privacy protection synchronization construct resource management structured programming computer architecture amazingly computer architecture area see going actor definitely useful others result much modest midtolate hewitt student irene greif henry baker clinger developed lot basic theory actor model inspired originally simula irene greif developed first operational semantics dissertation work clinger developed denotational semantics actor late beyond gul agha made huge contribution actor theory dissertation published book actor influential separated actor model ai root started treating general programming model particular comm acm paper describes foundation concurrent objectoriented programming formulation based around three core operation classic actor model create construct new actor template parameter send delivers message asynchronously named actor become within actor replaces behaviour state interface classic actor model uniform actor model everything actor compare uniform object model everything object strict uniformity fallen favour people often worked twolayer language might functional core language objectoriented core language imperative core language actor model part added base language going give simplified somewhat informal semantics based work mason smith talcott going drop lot detail relevant really simplified e î xe e e x e e l atom bool primitive operation create e send e e become e l label pid use like symbol imagine convenience syntax stand î let x stand î match e p e p e stand matching implemented predicate etc forbid program containing literal process id v î xe v v l r r e v r r e v r create r send r e send v r become r configuration pair set actor multiset message l v v l e l c normal lambdacalculuslike reduction apply like beta r î xe v l r e vx l plus new interesting one actor specific v l l v v v l r create v l r l l v l l fresh r send l v l r l l l v r become v l r nil l v l l fresh whole program e started e arbitrary label example mutable cell cell î content î message match message get k become cell content send k content put v become cell v notice get get message first performs become order quickly return ready state handle message remainder code run alongside ready actor action become directly affect state actor anymore even though look like multiple concurrent execution actor sharing access state still serialized needed isolated turn principle let c create cell send c get create î v send c put v let c send c get create î v send c put v cell send get create î v send put v cell send get cell î v send put v cell î v send put v get cell get î v send put v become cell send î v send put v send cell î v send put v cell î v send put v cell send put cell put cell put become cell nil cell could consider adding garbage collection rule like v l discard final value end activation level continuation explicit encode pattern sequential control flow forkjoin example start two longrunning computation parallel collect answer either order multiplying sending result actor could write let k create î become î send k send k send k practically speaking original actor language plasma language agha us example paper rosette special syntax ordinary rpc programmer manipulate continuation cover classic actor model create send become explicit use actor address lot lot temporary actor interactor rpc continuation move erlang remember right beginning told actor model asynchronous message passing isolated turn principle isolated turn principle requires liveness allowed block indefinitely responding message let create î c send c c send compare letrec beh î c become beh send c c let create beh send degenerate case different way first becomes inert quickly actor never returned idleready state second spin uselessly forever error could make would fail send expected reply continuation one thing semantics rule interaction actor become way waiting continuation perform become time different actor way stick letter isolated turn principle forbidding kind thing go wrong destroy progress even require behaviour function total still get global nontermination saying actor model much oversimplified even level simple formal model let alone come realistic programming system practice programmer often need call actor making state update classic actor model done done complicated encoding erlang actor faulttolerant system erlang example de koster et al call processbased actor language origin telephony used build telephone switch fabled uptime research process led erlang concentrated highavailability faulttolerant software reasoning led actorlike system nutshell program bug part program crash corrupt part hence strong isolation sharednothing messagepassing part program crash another part take slack one way another need crash signalling detect failure take action egg one basket one machine fails hardware level need nearby neighbour smoothly continue running redundancy need distribution make sharednothing message passing extra attractive unifying mechanism erlang twolevel system functional language core equipped imperative action asynchronous message send spawning new process like system difference lack become instead construct called receive erlang actor called process ultra lightweight thread run sequentially beginning end little functional program run explicit temporary continuation actor created time us receive simply block matching message appears initialization step program typically enter message loop example mutable cell mainloop content receive get k k content mainloop content put v mainloop v end client program might cell spawn fun mainloop end cell get self receive v end instead using become program performs tail call return receive statement last thing receive statement like erlang process use enter substates mainloop service receive req k service subreq self receive subreply answer k reply answer mainloop service end end process blocked inner receive process message matching pattern inner receive tail call back mainloop start waiting req message meantime nonmatched message queue waiting received later called difficult reason quite violate letter isolated turn principle come close become used similar way goal underlying namely changing set message one responds temporarily ignoring others important way people think actor system lot research done different way selectively enabling message handler see paper pointer toward research one unique feature erlang brings table crash signalling jargon process ask system make sure send message monitored process exit way perform rpc monitoring server process sending request reply message arrives unmonitor server process continue exit message arrives service crashed take corrective action general idea able monitor status process one seed research language syndicate classic actor model createsendbecome primitive erlang spawnsendreceive actor process rather eventhandler function programmer still manipulates reference actorsprocesses directly far fewer explicit temporary actor created compared ordinary continuation functional fragment take duty e actor secure cooperation last language want show e example de koster et al call communicating eventloop language e look feel much like traditional objectoriented language programmer either variation seen far def makecell var content def getter get return content def setter set newcontents content newcontents return getter setter mutable cell e interestingly different yield two value one specifically setting cell one getting e focus security securability encourages programmer hand object minimum possible authority needed get job done safely pas around reference getter without risking unauthorized update cell e us term describe concept closest traditional actor vat mailbox like actor also call stack heap local object see e programmer manipulate reference vat directly instead pas around reference object heap interesting actor model message addressed particular actor seemingly handing reference something finer grained individual object within actor vat first sign e us basic createsendbecomestyle model core expose model directly programmer layer special especific protocol top let programmer use feature upper layer protocol two kind reference available near ref definitely point object local vat far ref may point object different vat perhaps another machine go two kind ref two kind method call immediate call eventual call receivermethod arg receiver method arg error use immediate call ref object different vat block current turn answer computed ok use eventual call ref though cause message queued target vat might promise immediately returned caller promise start unresolved later target vat computed sent reply promise become resolved nifty trick even unresolved promise useful pipeline example def x def b def c would block perform multiple network round trip traditional simple rpc system e protocol layered top raw message sending discus promise creation resolution use protocol allows system send message like send x name resulting promise send b name resulting promise known send c crucial protocol language discourse actor allows expression concept including notion send happen future time currentlyunknown recipient protocol e vat runtimes work together make sure message get need go efficiently even face multiple layer forwarding turn e vat involves taking one message message queue dispatching local object denotes immediate call push stack frame stack usual objectoriented programming language eventual call push message onto message queue execution continues stack empty point turn concludes next turn start one interesting problem using promise represent crossvat interaction control flow say def c earlier myvar else myvar b time need make decision way go promise may yet resolved e handle making error depend immediately value promise control flow instead programmer us expression install handler event resolution promise myvar else myvar b test call b update myvar delayed resolved value look like violates isolated turn principle seems like kind interleaving going cover promise resolution done incoming message queued usual turn come round clause run like classic actor erlang managing multiplestage stateful interaction response incoming message generally difficult question finding balance isolated turn principle commitment availability encoding necessary state transition without risking inconsistency deadlock turning failure signalling vat unit concurrency also unit partial failure uncaught exception within vat destroys whole vat invalidates remote reference object within erlang process directly notified failure process whole e finegrained e programmer convenient value represents outcome transaction promise vat fails network problem arises promise depending vat network link put special state become broken promise interacting broken promise cause contained exception signalled way broken promise propagate failure along causal chain look cover e seems model using createsendbecome manage communicate whole vat operation exposed programmer programmer instead manipulates twopart denote vat along object local vat local object created frequently like regular objectoriented language vat created much le frequently stack take duty performed actor model temporary actor conclusion presented three different type actor language classic actor model roughly formulated agha et al process actor model represented erlang communicating eventloop model represented e three model take different approach reconciling need structured local data within actor addition coarsegrained structure relating actor classic model make everything actor local data largely deemphasised erlang offer traditional functional programming model handling local data e offer smooth integration imperative local oo model asynchronous promisebased remote oo model annotated bibliography early work actor carl hewitt peter bishop richard steiger universal modular actor formalism artificial intelligence proc international joint conference artificial intelligence paper position paper understand motivation intention research actor lay broad colourful research vision touch huge range area computer architecture programming language design teaching computer science approach artificial intelligence paper present uniform actor model compare contrast uniform object model offered oo language original application model given plannerlike ai language paper claim benefit using actor model huge range area foundation semantics logic knowledgebased programming intention contract study expressiveness teaching computation extensible modular programming privacy protection synchronization construct resource management structured programming computer architecture paper sketch idea contract called ensuring invariant actor protocol conformance maintained seems connection modern work session type author write intention contract actor outside world everything super meta actor intention intention actor intention intention paper present beginning reflective metamodel actor every actor scheduler may monitor firstclass environment paper draw explicit connection capability security sense mark miller http erightsorghistoryactorshtml say actor work included statement actor semantics basis confinement year norm hardy key logic remark key logic guy unaware actor locality law time working great slogan scattered throughout flow data flow state considered paper eventually turn nutsandbolts description predecessor language plasma fully described hewitt come formal reasoning actor system author define partial order precedes capture notion causal connection later paper make excursion epistemic modal reasoning aside paper discus continuation reynolds concept continuation firmly part discourse rediscovered different context van initial description idea see j c reynolds discovery continuation lisp symb comput vol pp section see alan kay whose flex small talk machine influenced work alan emphasized crucial importance using intentional definition data structure passing message paper explores consequence generalizing message mechanism small talk port mechanism krutar balzer mitchell previous call statement universal communication mechanism irene greif phd dissertation mit eec specification language actor per baker discus c hewitt control structure pattern passing message ai focus actor ai sense recursive decomposition expert viewed society decomposed way primitive actor system investigating nature communication mechanism convention discourse concretely examines actor message passing used understand control structure pattern passing way decompose actor part actor defined behavior physical representation discus plasma system modeled give fairly detailed description language appendix develops present schemely factorial implementation recursive iterative tailrecursive accumulatorpassing style discussion iterative factorial implementation hewitt remark n closed loop actor loop beginning line thinking led work everything actor actor treated awfully structural way tree example section generator nonterminal nonterminal terminal terminal b terminal c thing written keyword notation look like structure reflection actor structure subject patternmatching unsure duality thought principal time see remark regarding appendix c hewitt h baker continuous functionals mit ai memo communicating process restriction history computation physically inspired physical intuition discus history computation term partial order event rather sequence actor model formalization idea simulasmalltalkclulike active data processing message independent particular programming language instance simula smalltalk class clu cluster nonconcurrent actor model broader including concurrent messagepassing behaviour law essentially lexical scope law history finitude activation chain total ordering message inbound actor etc including four different ordering relation miller referring erightsorg page mentioned close capability law governing confinement step toward denotational semantics actor russell atkinson carl hewitt actor system proc acm sigactsigplan symp princ program lang pp introduces concept improvement monitor mechanism brinchhansen build work phd dissertation mit actor concurrent objectoriented programming gul bookdissertation g agha objectoriented programming commun acm vol pp work recast early actor work term concurrent objectoriented programming defines actor interactive independent component computing system communicate asynchronous message give basic actor primitive create send become example given actor language rosette paper give overview summary many important facet research actor done time including brief discussion nondeterminism fairness pattern coordination beyond simple requestreply transaction visualization monitoring debugging resource management case extremely high level potential concurrency reflection customerpassing style supported actor concurrent generalization continuationpassing style supported sequential language scheme case sequential system object must completed processing communication process another communication contrast concurrent system possible process next communication soon replacement behavior object known note sequentialseeming portion language defined term asynchronous message passing construction explicit continuation actor g agha mason f smith c l talcott foundation actor computation j funct program vol pp long paper carefully fully develops operational semantics concrete actor language based lambdacalculus discus various equivalence law excellent starting point looking build modern approach operational semantics actor erlang actor requirement faulttolerance highavailability j armstrong reliable distributed system presence software error royal institute technology stockholm good overview erlang language design intent underlying philosophy includes evaluation language design e actor requirement secure interaction miller e tribble j shapiro among stranger proc int symp trustworthy global computing pp summarised paper seminar class distributed system author present e language designed help programmer manage coordination concurrent activity setting distributed mutuallysuspicious object design feature e allow programmer take control concern relevant distributed system without immediately losing benefit ordinary oo e canonical example event approach actor language per taxonomy survey paper listed combine messagepassing isolation interesting way ordinary objectoriented programming giving twolevel language structure oo flavour paper great job explaining difficulty arise writing concurrent program traditional model thereby motivating actor model general feature e particular way making job easier taxonomy actor j de koster van cutsem w de meuter year actor taxonomy actor model key property software language lab vrije universiteit brussel recent survey paper offer taxonomy classifying actorstyle language broadest actor language placed one four group classic actor model create send become active object oo thread per object copying passive data object process raw erlang receive spawn send communicating eventloops e near far reference eventual reference batching different kind also appear many variation order integrate asynchronous message reception otherwisesequential programming
319,Lobsters,erlang,Erlang development,Donald Knuth Was The First Erlang Programmer,http://videlalvaro.github.io/2016/10/knuth-first-erlang-programmer.html,donald knuth first erlang programmer,donald knuth first erlang programmer joe robert,donald knuth first erlang programmer combing art computer programming taocp donald knuth found something interesting right beginning book stating basis presentation algorithm proposes different notation expressing algorithm seems used section forgotten rest book notation talking knuth present greatest common divisor algorithm look similar erlang syntax us semicolon separate function clause function body executed selected pattern matching argument last function clause end period guard form execute otherwise let translate erlang module algorithme export f n f n f n n f n r f n rem n f n r r f n f n r f n r f n p f n p p write variable name uppercase since required erlang delimited tuples using instead expected erlang finally wrote guard using keyword also instead assigning function body equal sign used arrow interesting curiosity prof erlang syntax sort platonic language ideal predates programming language time joe robert confess got inspiration
320,Lobsters,erlang,Erlang development,BeamBA just Happened – Erlang Elixir Efene LFE Meetup @ Buenos Aires,https://medium.com/erlang-battleground/beamba-just-happened-807771987a2a,beamba happened erlang elixir efene lfe meetup buenos aire,watch meetup erlangba,watch event streamed live thanks youtube missed video spanish course want thing please join u meetup erlangba
321,Lobsters,erlang,Erlang development,The simplest Erlang TCP server ever,http://dmathieu.com/articles/development/erlang-tcp-server/,simplest erlang tcp server ever,erlang library learn erlang architecture code supervisor simplified one one worker worker omg,number month wanting learn erlang week ago started pet project lot erlang resource around though strangely enough would appear starting server listening connection trivial actually looking around found interesting library article best one probably case erlang learn erlang found issue solution though gennbserver allow overriding genserver state preventing keeping state connection erlang central article us priminet public api learn erlang probably best source fully understand everything give quick dirty server writing architecture getting started erlang might still struggling bit worker supervisor awesome though article going setup supervisor listen port need accept connection setup number worker able accept one single connection used programming ruby going rebuild puma line code yes huge shortcut worker start new one right starting handle request kill end code supervisor module hellotcpsup behaviour supervisor export export startlink supervisor startlink local module module init ok listensocket gentcp listen active start pool empty listener must another blocking process spawnlink fun ok simpleoneforone hellotcpserver hellotcpserver startlink listensocket temporary worker hellotcpserver startsocket supervisor startchild module start listener many multiple connection started without serialization best circumstance process would keep count active time insure nothing bad happens time process get killed much emptylisteners startsocket list seq ok supervisor listens port store socket got exchange configures simplified one one worker worker module hellotcpserver behaviour genserver export export record state socket startlink socket genserver startlink module socket init socket start accepting request must cast worker process block genserver cast self accept ok state socketsocket handlecast accept state state socketlistensocket ok acceptsocket gentcp accept listensocket boot new listener replace one hellotcpsup startsocket send acceptsocket hello noreply state state socketacceptsocket handlecast state noreply state handleinfo tcp socket quit state gentcp close socket stop normal state handleinfo tcp socket msg state send socket msg noreply state handleinfo tcpclosed socket state stop normal state handleinfo tcperror socket state stop normal state handleinfo e state io fwrite unexpected pn e noreply state handlecall e state noreply state terminate reason tab ok codechange oldversion tab extra ok tab send message back client send socket str args ok gentcp send socket iolib format str n args ok inet setopts socket active ok worker start new genserver inside tell tcp server ready accept connection worker blocked receives connection receive async message send server example send one accept actual accepting connection would block supervisor receive every message send client send back unless send quit case close connection omg simple tcp listener start supervisor app inside helloapperl erlang start starttype startargs hellosup startlink
322,Lobsters,erlang,Erlang development,Ghost Functions in Erlang,https://medium.com/erlang-battleground/the-laziest-erlang-git-user-ever-ff69d86cf3c1,ghost function erlang,story history fred erlanghistory tutorial,story historyin early day erlang fred gave u erlanghistory erlang shell history ephemeral lost soon closed nodemany u ton erlang snippet sticky note text file document copied pasted every time needed crafty one stored thing userdefault constantly available know talking maybe good time read tutorial still leaving erlang shell pain tried avoid costson hand u work git right good round testingcodingcompilingetc one would like commit push change upstream repository git run terminal whenever wanted use either keep terminal one erlang shell another running git command close erlang shell run git command reopen oh struggle well io format sn o cmd git status o executes command shell target o result evaluation iolist output given said command using io could print erlang shell nicelybut lot boilerplate something git status
323,Lobsters,erlang,Erlang development,Erlang tips: remote module loading,https://newoldstuff.wordpress.com/2009/05/26/erlang-tips-remote-module-loading/,erlang tip remote module loading,like erlang r leave response trackback,context remote module pushing needed initial setup node physical node one one erlang instance started erlang instance must started cookie order able successfully communicate step create test module module test export testfun io format hello sn world start erlang instance erl name setcookie testcookie erlang kernelpoll false eshell abort g start erlang instance erl name setcookie testcookie erlang kernelpoll false eshell abort g compileloadremote load test module c test ok test mod bin code getobjectcode test test homealintestbeam rpc call erlang loadmodule mod bin module test spawn test testfun hello world edit testerl instead io format hello sn world set io format hello sn go back opened erlang shell f ok c test ok test mod bin code getobjectcode test test homealintestbeam rpc call code purge mod false rpc call erlang loadmodule mod bin module test spawn test testfun hello note touched anything else starting erl name setcookie testcookie done like like loading related entry posted may pm filed erlang follow response entry r feed leave response trackback site
324,Lobsters,erlang,Erlang development,Erlang and millions of concurrent gamers (2011),http://www.erlang-factory.com/upload/presentations/395/ErlangandFirst-PersonShooters.pdf,erlang million concurrent gamers,,obj endobj obj endobj obj font procset pdftextimagebimagecimagei mediabox content rgroup tabssstructparents endobj obj stream ܕ wl x endstream endobj obj stream jfif ii
325,Lobsters,erlang,Erlang development,Erlang Dirty Scheduler Overhead,https://medium.com/@jlouis666/erlang-dirty-scheduler-overhead-6e1219dcc7,erlang dirty scheduler overhead,low level detail overhead measurement strategy schedtime returntime measurement dualize dirty nif handling,low level detailsso really happens detail first compile erlang vm support pas option enabledirtyschedulersto configure script next code change bit standard nif like one obtaining random data enacl library x function signature erlnifterm enifrandombytes erlnifenv int erlnifterm build table nif write following tie knot erlang world static erlniffunc niffuncs randombytesb enifrandombytes randombytes enifrandombytes erlnifdirtyjobcpubound erlnifinit enaclnif niffuncs enifcryptoload null null null tell erlang system function randombytesb regular nif function randombytes bound dirty scheduler cpu bound jobsthe way erlang work nif module replace function module nif function calling erlang read niffuncs array patch function calling function module invoke beam operation callnif first instruction opcode contains function pointer real cfunctionwhen opcode invoked environment set passed c code inspect environment incomnig parameter carry work done simply return erlang term back interpreter turn regard return value function questionwhen loading dirty nif however nif directly patched rather wrapper function scheduledirtyionif scheduledirtycpunif patched nif wrapped yet another helper executedirtynif calling nif really calling say scheduledirtycpunifthe scheduling function alters process flag currently executing function becomes dirty cpubound function bump reduction process reduction force reevaluation process queueing scheduler see dirtyflag evacuates process run queue dirty schedulersonce dirty scheduler executedirtynif wrapper get called wrapper executes real nif clear flag arranges dirtyniffinalizer run function simply return nif result via standard trap scheduler requeues move nif back onto one main scheduler continue execution return valuethe execution wrapper also handle exception nif executes another finalizer raise exception back main scheduler thread also function may decide yield scheduler running order give others chance run like exception case execution wrapper handle thisoverhead measurement strategynow whole dirty nif evacuation back forth free operation longrunning nif could take something like millisecond probably negligible overhead nif return instruction overhead moving thing around would dominate also nif return quickly reason even consider dirty schedulerthe question however large overhead luckily new illumos machine sitting around answer question dtracethe description suggests way grab overhead going back forth use dtrace dynamically add trace probe running erlang system measure actual overhead going back forth scheduler writing dtrace script pid target beamsmp scheduledirtycpunif return timestamp pid target beamsmp executedirtynif entry schedtime lquantize timestamp whenever return scheduledirtycpunif record timestamp whenever start execute dirty nif executedirtynif linearly quantize time took likewise return path measured recording time take dirty nif execution return dirty nif finalizer run happen back normal scheduler core pid target beamsmp executedirtynif return r timestamp pid target beamsmp dirtyniffinalizer entryr returntime lquantize timestamp r r running dtrace script dynamically reach inside erlang vm patch prologueepilogue targeted function hit execute body snippet order measure runtime overheadmeasurementmeasurements done intel r core tm cpu gigabyte ram running sunos dev ie omnios first naive run run many scheduler operation backtoback one time standard configured erlang special provisioning option result following output scheduling overhead nanos value distribution count suggests overhead moving scheduler ballpark nanosecond around return graph look like return overhead nanos value distribution count take around get back main schedulerthe hypothesis reason cost nearly move around highly likely move one cpu core another happening result lot contention cache tlbs locking turn thing get expensive wake core intercommunicate lot worse since need single core moved around cpu core time blow cache destroys tlb make u generally sadto test hypothesis exploit running raw steel machine set erlang flag option runtime erlflagsk true sbt db sbwt verylong swt verylow mulmbcs mumbcgs musmbcs shellthe important flag sbt bind scheduler core sbwtswt setting wakeup threshold option make system allocate megabyte block really help system support superpageshugepages vm layer also tends pack data localitythis huge effect run whereas overhead setting option overhead ballpark scheduling overhead nanos value distribution count overhead nanos value distribution count important caveat far loading system run concurrency level let measurement interfere others easily use threadlocalvariables since measuring work get moved thread use somewhat simplified scheduling operation high several atomics couple mutex lock dram hit cost synchronization rarely entirely free yet another example highly optimized loop eternity given good ilp modern cpu core easily insns number much higher use simd style vector operation suggests pipeline feed system synchronization routine quite differentdualize dirty nif handlingthe erlang documentation suggests using dirty scheduler whenever nif lengthy work measurement suggests another solution overhead executing dirty nif low enough execution hidden noisefor instance running enacl cryptobox operation requires first compute curve shared key take much time compute overhead running dirty scheduler impossible measure hence easier always execute dirty operationfor operation say secret key computation nacllibsodium encrypting byte entry fast movement onto dirty scheduler dominates enacl detects simply run operation directly nondirty scheduler order make many small operation fasteri currently revising overhead threshold enacl subsystem based measurement targeting far smaller threshold suggests stop worring d overhead le say handling byte data take stop worrying run dirty scheduler example run one operation secretboxes size byte abovementioned ivy bridge based enaclnif value distribution count obtain used scott l fritchie etal work erlang dtrace provider directly hook onto nifentry nifreturn erlang measure long took execute suggests current overhead roughly fine think provided know configure erlang system
327,Lobsters,erlang,Erlang development,The most basic Erlang service: worker pattern,http://zxq9.com/archives/1311,basic erlang service worker pattern,,talk identifying erlang design pattern functional design pattern reason sort talk rarely get far generally speaking design pattern phrase mean thing time language provides primitive represent easy way write library function behind hide abstract implementation oop entire paradigm built around special syntax writing dispatching closure tends lack lot primitive want represent today litany design pattern note discussion basic erlang implementation pattern basic also point place new erlangers get hung like context specific call obvious already familiar concurrency level erlang already wizard article probably erlang design pattern almost none emerged main reason would design pattern erlang mostly become either functional abstraction otp otp refers framework shipped erlang far need pattern needed go general case please note often possible write framework implement pattern though difficult make framework completely generic one thing ole outlaw techno psychobitch u quite u common need discover create basic arrangement service process supervisor worker spawn worker according ongoing global state node configuration figuring almost like rite passage erlangers often even experienced erlangers never distilled pattern even many project eventually evolve something structured similarly case describe involves two thing service want create represented named process manages act sole interface higherlevel code system want call lowlevel code get thing done service know manage configurable state relevant service whole remembered shouldâ forced pas argument every time call work done example let say artificial world written erlang let say game world let say mob management abstracted behind single mob manager service interface want spawn bunch monster mob according rule care game system know detail right task spawning mob need spawn bunch monster mob controller process course need supervised know detail able tell system create mob bestiary really basic config data passed every time call new monster spawned maybe want back even want specify type monster perhaps game system know correct spawnlive percentage different type mob maybe also know best way deal positioning create playable density deal position conflict zone conflict leveling phasing influence thing like said already care wait really talking talking sane default really sane default rule default case erlang generally mean sane option comfortably curried away lowestarity call whatever service function whence come sane default service state course scenario mind sort thing tend work three logical component service interface state keeper let call manager typically shortened man spawning supervisor typically shortened sup spawned thingies shortened typically look erlang like three module imaginarybuttypical case gamemobmanerl gamemobsuperl gamemoberl gamemobman module represents erlang version singleton least something similar nature registered process definite point contact request create mob calling gamemobman defined spawnmob spawnmob sanedefault spawnmob option genserver cast module begetmob option internally detail typical handlecast begetmob option state newstate begetmob option state noreply newstate course since never putting bunch logic sideeffecty stuff directly handle function clause work actually occurs course since talking common pattern point always good linguistic parallel like spawn beget common thing see someverbn becomes message verbname data becomes call implementation dosomeverb data state spawnmob option genserver cast module spawnmob option handlecast spawnmob option state newstate dospawnmob option state noreply newstate dospawnmob option state stuff stuff actually work function important thing note kind registered module registered name call genserver using module address self remember interface function executed context caller process defined module also someverbn someverb data dosomeverbn name sort redundant yes indeed totally unambiguous inherently easy grep n importantly give u break chain function call necessary implement abstraction like managed messaging supervision underlies otp magic like genserver begrudge name convention learn convention write le annoyingly mysterious code future self thank spawning worker inside dospawnmobn going call another registered process gamemobsup call gamemobsup directly two reason defining spawnmobn within supervisor still requires acquisition world configuration current game state supervisor hold kind state want data retrieval task evaluation logic defined call supervisor public function called context caller supervisor anyway forget calling manger first give manager chance wrap call supervisor state pas message along quite natural gamemobsup supervisor mob service otp already dictate role limited supervisor particular case dynamic worker simpleoneforone supervisor gamemobsup look inside something close module gamemobsup behavior supervisor interface spawnmob conf supervisor startchild module conf startup startlink supervisor startlink local module module init restartstrategy simpleoneforone mob gamemob gamemob startlink temporary brutalkill worker gamemob child mob ok restartstrategy child really necessary define thing variable really necessary break tuple assigned mob vertically line align everything pretty like course pretty darn common therefore easy catch piece eye first glance module readability uber reducing line count nobody even aware even relevant compiled code see going almost nothing interesting part note little config data going supervisor exception supervision set work mob crash come back life better leave dead signal whatever keep account decide gamemobman example would probably monitoring setting permanent worker easily hilariously result phenomenon called highly available mini boss crash death cleanup routine mistake mob process retire exit status normal cause keep coming back life right initial configuration ie full health full weapon full mana etc stand supervises supervisor generally speaking component like mob monster would part larger concept world object whatever world object service concept would sit mob mob would one component world entity general sum craptastic diagram yes game involve wildlife blonde nurse diagram show solid line spawnlink dashed line indicate direction request thing like spawnlink diagram show anything else monitor message etc imagine point post wait see made bigger diagram cut bunch stuff yep made even huger much crappier inaccurate diagram sure first wanted fit imaginary game system got carried away diagrammed lot supervision tree though meh screw push rough imagining might look like pushed way back supersup result digression look exactly like use imagination supervision yep right called supervision tree instead supervision list place dependency part thing crash bring system consider entire game fail chat still work user still logged etc nearly big deal restart one part itemreg well fails probably squash entire item system got gun bullet whatever game item critical data really critical data become critical gamers much willing accept server interruption losing item bad item data stored hopefully able express tiny little bit one way supervision coupled worker context ongoing configured service life within larger erlang system requires onthefly spawning supervised worker smarties around point glossed thing spawning million item process might best know point post right approach entirely context dependent anyway constructive criticism always welcome
328,Lobsters,erlang,Erlang development,Rethinking the Language Runtime for Scale by Christopher Meiklejohn,https://www.youtube.com/watch?v=SXT_fVJOkD0,rethinking language runtime scale christopher meiklejohn,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature rethinking language runtime scale christopher meiklejohn youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature rethinking language runtime scale christopher meiklejohn youtube
330,Lobsters,erlang,Erlang development,Erlang on OS X (beta),https://www.erlang-solutions.com/blog/erlang-installer-a-better-way-to-use-erlang-on-osx.html,erlang o x beta,erlang installer better way use erlang osx motivation change installation usage downloading release setting perk download link direct link webpage conclusion package erlangsolutionscom thought might also interested go back blog,erlang installer better way use erlang osx karol urbanski back joined erlang solution work providing something convenient erlang developer selfcompiled bundle otp apps happy say time managed significantly improve ease deploying erlang variety system especially variant linux recently decided make obtaining erlangotp painless possible o x end recruited wonderful people inaka network help u create better slicker version erlang solution o x installer motivation change previous iteration installer support autoupdating new version come useful feature people like stay cutting edge lot serious developer like stick older version know supported software using moreover looking around company noticed people forgo downloading installer offer indispensable feature ability quickly switch different version many devs important able switch old erlang version order test patch legacy system quickly popping back people keep different version erlang machine decided change esl installer allow kind feature incorporating change make app feel modern installation installation new esl installer easy downloading drag dropping application folder app show tray preference accessed o x system preference usage clicked tray icon expands menu allows download release start shell one release already downloaded force check new release update quickly access preference downloading release release tab installer allows install uninstall various version erlang release providing newest version numbered release since find list missing version would like let u know try provide setting general tab installer allows setup preference including default terminal release like use automatic check update automatically starting installer system boot ensure stay date new thing world erlang perk new installer app look similar o x apps know love instead ugly annoying popup getting much le obstructive notification download link try new installer go direct link webpage conclusion hoping release new comprehensive esl installer convince developer previously found lacking feature try see improves erlang coding experience suggestion feature like see improvement think make give u note package erlangsolutionscom thought might also interested go back blog
331,Lobsters,erlang,Erlang development,BeamBA is Coming!,https://medium.com/@elbrujohalcon/beamba-is-coming-2ee05f9fc83,beamba coming,talk,meetup logo thanks andrés geracethe talksthis time speaker person remotely mariano guerrathis talk describe way programming language created top erlang vm vm work thing simplifies thing complicates shown going step step creating language compiles beam bytecode provides basic functionality needed build calculator variable
332,Lobsters,erlang,Erlang development,CouchDB 2.0 released,https://blog.couchdb.org/2016/09/20/2-0/,couchdb released,official apache press release api compatible cluster dynamo paper note couchdb architecture easy query mango query new admin interface fauxton new couchdb dashboard performance pouchdb feature replication feature compaction new logo couchdb branding guide detail blog post series download http couchdbapacheorg download acknowledgement like,apache couchdb development community proud announce immediate availability version see also official apache press release couchdb api compatible series application continue work cluster couchdb prime new feature native support clustering based dynamo paper work done cloudant ibm bigcouch project fully merged apache couchdb project short clustering mean take set computer virtual machine data center make behave like single unified couchdb instance three benefit fault tolerance data stored one computer couchdb cluster obviates need custom setup failover couchdb instance performance data split part life node cluster mean node fraction work like computing view index single node instance would capacity setup multiple computer storing data data split among node possible store amount data couchdb exceed capacity single computer many many time setting couchdb genuine big data solution full control parameter cluster suit every project need note couchdb also configured single node cluster none benefit relevant see couchdb architecture blog post information clustering technology easy query second major feature declarative query language mango mango easier use faster operation existing javascriptbased view course javascript view continue work see mango query blog post information mango new admin interface couchdb come completely rewritten administration interface nickname fauxton built reactjs sport modern look advanced feature codebase easy contribute see fauxton new couchdb dashboard info performance replicator compactor undergone significant performance improvement speed replication couchdb instance well pouchdb couchbase lite instance compaction run time even continuously ioqueueing system ensuring live request slowed compaction running addition compaction process shorter us le cpu ram produce smaller database file freshly compacted database significantly faster read see feature replication feature compaction info new logo couchdb come brand new logo designed constantin angheloui website doc material updated see couchdb branding guide detail detail detail please refer blog post series download apache couchdb downloads available official website http couchdbapacheorg download acknowledgement community would like thank contributor part making release smallest bug report patch major contribution code design marketing done without like like loading related
333,Lobsters,erlang,Erlang development,Trust,http://blog.ikura.co/posts/trust.html,trust,search ideal co web address,search ideal co web addressget gone
336,Lobsters,erlang,Erlang development,Consistent Hashing,http://blog.carlosgaldino.com/consistent-hashing.html,consistent hashing,consistent hashing introduction consistent hashing virtual node consistent hashing library erlang consistent hashing library erlang repository github reference consistent hashing random tree distributed caching protocol relieving hot spot world wide web dynamo amazon highly available keyvalue store http http consistenthashingpoolandconsistenthashinggroup chord scalable peertopeer lookup service internet application http enwikipediaorgwikiconsistenthashing note,consistent hashing sep introduction traditional hash table map key array index using following process hash hashfunc key index hash arraysize arraysize change key need remapped index calculated modular operation technique used partition data application number database calculating hash key data modulo number database could situation like following new database added cluster one existing db removed fails key would need remapped like hash table example dealing lot data imagine remapping key would take quite time attractive consistent hashing consistent hashing come alternative first let consider output range function f connect end end ring using function f map node point ring interval two node ring form partition use function f key end projection key ring notion define server responsible key first node clockwise direction key projection case mar would stored server process applied key note f venus mapped point last node maximum value function f since end connected problem walking clockwise find responsible node case adding new node ring mean key need remapped fraction key need move different node fraction key also remapped node leaf ring essence consistent hashing idea presented paper karger et al node mapped ring forming partition used find node responsible key mapping key ring finding first node clockwise direction key position example system use consistent hashing amazon dynamo riak akka chord consistent hashing easier avoid hotspot using function f mix well even key similar end projected different distant point ring causing stored different node another benefit smoothness moving key node join leave ring immediate neighbor node impacted node remain unaffected system using consistent hashing apply technique reduce even impact change ring structure node data store like initial example post system could replicate data next n node original node responsible data give advantage leaf ring immediate neighbor already data stored preventing increase network traffic node case departs technique help avoiding hotspot even since request data handled next n neighbor ring usually system using consistent hashing construct ring output range hash function like example range go different output range etc using function map node ring effect placing node random position partition likely different size mean node responsible different amount data may attractive characteristic since range well defined ring could split partition equal size node could claim ownership number partition guaranteeing node handle le amount data another important technique usage virtual node see next virtual node ring shown onetoone mapping physical node node ring approach present challenge randomly placing node ring might lead nonuniform distribution data node problem becomes evident node leaf ring requires data handled node need moved entirely single node avoid overloading single node another one leaf ring distribute key evenly system create different mapping physical node node ring instead onetoone mapping system creates virtual node creating mton mapping physical node virtual node ring virtual node physical node becomes responsible multiple partition ring node leaf ring load handled node evenly dispersed across remaining node ring similarly node join ring receives roughly equivalent amount data node ring virtual node scheme also help system comprised heterogeneous node term resource cpu core ram disk space etc heterogeneous cluster number virtual node physical node chosen considering characteristic physical node concha consistent hashing library erlang concha consistent hashing library erlang built ring represents output range function used mapping node key ring provides lookup node based given key creating ring virtual node adding removing node etc information example usage visit repository github reference karger e lehman leighton r panigrahy levine lewin consistent hashing random tree distributed caching protocol relieving hot spot world wide web new york new york usa acm pp g decandia hastorun jampani g kakulapati lakshman pilchin sivasubramanian p vosshall w vogels dynamo amazon highly available keyvalue store pp riak vnodes http akka routing http consistenthashingpoolandconsistenthashinggroup stoica r morris karger f kaashoek h balakrishnan chord scalable peertopeer lookup service internet application acm sigcomm pp consistent hashing wikipedia http enwikipediaorgwikiconsistenthashing note
338,Lobsters,erlang,Erlang development,OTP releases by hand,http://blog.ikura.co/posts/otp-releases-by-hand.html,otp release hand,search ideal co web address,search ideal co web addressget gone
339,Lobsters,erlang,Erlang development,BEAM VM Wisdoms,http://beam-wisdoms.clau.se/en/latest/,beam vm wisdom,welcome adventurer http githubcomkvakvsbeamwisdoms latest section explain like five,welcome adventurer collection easy read article well indepth knowledge vm internals memory layout opcodes etc project work progress come back soon github repository page http githubcomkvakvsbeamwisdoms latest binary match opcodes added instruction list trycatch opcodes added instruction list section explain like five
340,Lobsters,erlang,Erlang development,"Interview to Boyd Multerer, founder of Xbox Live, about Elixir",https://soundcloud.com/elixirfountain/elixir-fountain-boyd-multerer-2016-08-24,interview boyd multerer founder xbox live elixir,,network connection unstable browser outdated
341,Lobsters,erlang,Erlang development,Rebar3 3.3.0 released,https://github.com/erlang/rebar3/releases/tag/3.3.0,released,reload reload,new feature fix change lock file format biggest thing note compatible format going back tag version older display warning lose newly added information package hash lock file generated older version accepted one new information related package hash added allow safer usage case package found multiple index mirror actually different hash expected existing project perform action time signed another tab window reload refresh session signed another tab window reload refresh session
342,Lobsters,erlang,Erlang development,Erlang beauty (2015),http://blog.ikura.co/posts/erlang-beauty.html,erlang beauty,search ideal co web address,search ideal co web addressget gone
343,Lobsters,erlang,Erlang development,Hotfix howto,http://blog.ikura.co/posts/hotfix-howto.html,hotfix howto,search ideal co web address,search ideal co web addressget gone
344,Lobsters,erlang,Erlang development,Erlang Easter-Eggs,https://medium.com/@elbrujohalcon/erlang-easter-eggs-5d14023c267c,erlang eastereggs,objectivec devs allowed previous article excellent way nonemptymaybeimproperlist nonemptymaybeimproperlist nonemptyimproperlist nonemptymaybeimproperlist memgenerator,objectivec devs allowed hereif remember one previous article many type list erlang article listed proper one ie one represent valid list erlang allows use improper list well developer found excellent way prevent devs according note page following builtin list type also exist expected rarely used hence long name nonemptymaybeimproperlist nonemptymaybeimproperlist nonemptyimproperlist nonemptymaybeimproperlist true story man time use long type name right thanks memgenerator p
346,Lobsters,erlang,Erlang development,Prod-to-dev with Mnesia,http://blog.ikura.co/posts/prod-to-dev-with-mnesia.html,prodtodev mnesia,search ideal co web address,search ideal co web addressget gone
347,Lobsters,erlang,Erlang development,"Erlang, Elixir, Efene & LFE Buenos Aires Meetup - Sept. 28th @ Inaka's offices",http://www.meetup.com/es/ErlangBA/events/232750618/,erlang elixir efene lfe buenos aire meetup sept inaka office,http proyectociaacomardevwikidokuphp iddesarrollo educiaa educiaanxp,meeting cancelled queridos beamers tenemos fecha para el primer meetup del año será el de setiembre la h en la oficinas de inakaeste año vamos intentar hacer el meetup lo más políglota posible incluyendo erlang elixir efene lfe todo otro lenguaje que corra sobre la beampresentaciones como se hacen la beam mariano guerra una charla que describe como se crea un lenguaje de programacion sobre la maquina virtual de erlang como funciona la maquina virtual que cosas hace facil que cosas dificil todo esto creando paso paso un lenguaje que compila beam bytecode con funcionalidad basica de calculadora con erlang en educiaa sin sistema operativo carlos pantelides presentación convocatoria participar del proyecto de implementar portar erlang la plataforma educiaanxp http proyectociaacomardevwikidokuphp iddesarrollo educiaa educiaanxp comparando erlang con elixir federico carrone el objetivo de la charla e compartir la alegrias dificultades sorpresas que topé al usar elixir como lenguaje principal para programar backend de videojuegos luego de utilizar erlang como principal lenguaje de programación además compararemos la diferencias de cultura dentro de la comunidad haremos un pequeño repaso de algunas herramientas que brinda elixir que se encuentran disponibles en erlang en resumen la idea e comparar los do lenguajes comunidadeslos esperamos todos
348,Lobsters,erlang,Erlang development,The Erlang shell: Your secret weapon [2013],https://medium.com/@jlouis666/the-erlang-shell-ab8d8bec3972,erlang shell secret weapon,concurrency distribution failure erlang shell,strength persistent model come apparent late development cycle software usually go several phasesanalysis design impl test deploy maintenanceit important stress development software dynamic activity repeatedly change software production layering complexityfeatures top system also dynamically fix bug software productionthe recent year development tends socalled agile many small dynamic iteration software construction process running time social tooling place try achieve scrum kanban technical tooling place reach goal git mercurial maintenance part expensive maintaining running software periodic cost associated world everything service pay operator pay hardware resource developer onwhen program try remove error early employ static type system extensive testing use static analysis perhaps even use probalistic model checker like quickcheck exhaustive model checker like spin prove software coq know inherently eradicating bug early software life cycle mean le work maintenance phasebut interestingly raise bar error done hard work error remain subtle kind error caught initial guardian system static type system capture class fault slow algorithm excessive memory consumption instance proper benchmark suite envision failure case frontthe class fault tend interesting class survive static type check mere fact could capture static analysis compile phase make error much subtle also often mean much harder trigger production system fault furthermore survives test suite becomes even interesting viral strain certain basic dna mutated could get past two barrier correctness test becomes latent bug softwareaside tend absolutely love static type system enjoy lot program go standard ml ocaml haskell richer description come static type systemthere great power able say v τ rather former representation richer structure richer structure help documentation make possible pick better inmemory representation make program go faster force coherent programming modelyet also recognize error caught static type system interesting kind simple run program find instantlyend asideconcurrency distribution failureswhen system fault due concurrency distribution debugger work problem stop world go inspect foreign system inspect answer time time many modern system large part direct control anymore life era computing internet defines interface program component erlang system two node enough problematic even could snapshot one node node carry onthe true concurrency error often incorporate race condition must trigger attaching debugger alters execution schedule making race condition disappear process way debug system analysing postmortem trace went inspecting system online runningto make matter worse lot race occur data size increased production system batch say small write conflict data store due inappropriate transactional serialization isolation test system user conflict never show disregard onetime fluke never happen production system increase capacity problem start occur statistical birthday paradox come rear ugly head hitting conflict often point occurs multiple time dayin conclusion capturing kind bug front deceptively hardthe erlang shellthe erlang shell necessary tool producing correct software usefulness mostly targeted maintenance phase also useful initial phase development running erlang system connected running qlglicko provides repl work software note repl running production system run command system qlglicko qlgdb playerstorefresh ok qlglicko hook running process case qlgdb connection pooling towards postgres database allows go probe system running check correct operation exported functionality probed shelli often keep module around named zerl compile inject running system qlglicko c zerl ok z qlglicko dynamically compiles load z module running system make function module available system introspection manipulation debugging hardtofind bug system need functionalityand yes want erlang node contains compiler application compile module
349,Lobsters,erlang,Erlang development,Ranking 4 Million Quake Live duels in 1.5 seconds [2015],https://medium.com/@jlouis666/ranking-4-million-quake-live-duels-in-1-5-seconds-fc84750aad1f,ranking million quake live duel second,ranking million quake live duel second erlang go opponent int int next step reference http githubcomjlouisfuse http githubcomjlouissafetyvalve http http godocorggithubcomjlouisnmoptim http godocorggithubcomjlouisrank http mediumcom http mediumcom,ranking million quake live duel secondsthe last couple day toying little hobby project minethe project rank player player quake live duel reported gathering duel since february project written hybrid code storage retrieval presentation written erlang ranking code written goat moment gathered exactly match deem eligible ranking sometimes quake live report match one player time match lasted couple second remove ranking think good enough around player database right average number played match varies lot player player played one duel clock duel week lot given duel often take minute everything stored database choice postgresql recently upgraded meant could change internal representation erlang conversion jsonb storage type directly postgres price storage erlang serialization format took gigabyte disk space jsonb take gigabyte advantage ease query directly json representation database take query exampleselect idfrom corerawmatchwhere content ranked int look inside content json column grab row ranked toplevel key integer representation equal simplifies lot processing use update statement preanalyze large swath duel without lowlevel work erlangerlangthe choice using erlang processing proved worth number restarts due fatal failure around reason faulttolerance erlang small mistake affect code whole often mistake end end quakelivecom site handle fusecircuitbreaker installed request code clamp operation site experience problem either unreachable trip timer request slow process mean end back quake live site experience troublein order limit concurrent access quakelive site installed safetyvalve application defines request queue policy fast request queue emptied mean run erlang system internal concurrency level around outstanding process try fetch quakelive queue control policy set limit many outstanding concurrent request allow frequency start new requestsin short erlang right tool choice longrunning daemon service must go even database foreign system rely one example power quakelive upgrade service take change line code order handle fuse simply blow system rechecks connectivity every minutesanother important design decision make database operation idempotent since postgresql give u atomic operation simply make sure job idempotent retried later system always trying catch current state system always behind real time small factor go handle situation catching virtue idempotence save u quakelive remove match week played nonpaying bet keep internally least day act grave problemgoerlang shine due fault tolerance robustness nice functional language write succinct code go somewhat opposite imperative explicit data layout statically typed simple type system however go compiled native code provides good parallelism nice unique feature interface channelbasedmessagepassing thing think go shine syntax clike imperative language first language year actually innovate simplify language writing go necessary important another brilliant decision get rid semicolon use simple layout rule still keeping mostly lalr grammar provide excellent go fmt tool reindent code predefined defaultpackages go way handling library imported code something language picking trick import statement string like external tool understands parse string automatically fetch source code library compile coalesces concept package dependency language remove lot external boilerplate managementtoolchain quick recompilation software help lot developing remove overhead compilation coming language fast compiler like ocaml erlang nice wait compiler one design decision transitive dependency recompiled depends b depends c compiling b everything related c pulled resulting object file turn compiling look b avoid c help compilation time lotinterfaces go package interface structuring tool allows break large system smaller part increase modularity code base since altering one module code le likely yield alteration module decoupling far important construction handling large code base erlang write independent application ocaml create module functor go write separate package eventually use interface abstraction provided different parameterization java generic ocaml functor really experienced limitation approach yetin earlier post mine looked ranking different approach different language ended choosing go ocaml erlang erlang strong number crunching floating point domain ocamls current lack parallelism excluded recently updated go package better simpler use everthe main interface package following type opponent interface r rd sigma sj func rank r rd sigma opponent opponent tau nr nrd nsigma rank player call rank player parameter r rd sigma set opponent given slice configuration parameter system called tau opponent interface implement making opponent interface avoid problem caller take code mangle fit scheme rather wrap data structure provide opponent interface turn rank gamesthe code also optimize configuration parameter tau initial rd use system running neldermead optimization routine api isfunc optimize f func start cf func int int optimize function f subject start value start constraint cf note speed concern overhead f function computation make everything work adapted simple parallel variant ranking computation speed full ranking week match take le second full optimization completed second core gigabyte ram lenovo technical code next stepsthe next phase project employ order provide nice graphical output data initially tested output r nice plotting package ggplot version wickham order make easier everyone use system decided build frontend us plot result work currently ongoing done way present datareferences http githubcomjlouisfuse http githubcomjlouissafetyvalve http http godocorggithubcomjlouisnmoptim http godocorggithubcomjlouisrank http mediumcom http mediumcom
350,Lobsters,erlang,Erlang development,Erlang RPC: The Road we didn't go down,http://armstrongonsoftware.blogspot.com/2008/05/road-we-didnt-go-down.html,erlang rpc road nt go,,following interesting discussion erlang mailing list steve vinoski friend telling u wrong rpcthe discussion started may general topic conversation announcement facebook deployed chat server written erlangfuture post asked steve elaborate thissteve posted long brilliant summary problem rpc erlang mailing list read brain shouted thank steve steve wrote bad enough performance aspect also completely different local operation take microsecond performed rpc suddenly take millisecondshow thing erlang world erlang program composed set parallel process process create process send receive message easy lightweight operationprocesses linked together purpose error handling linked b fails b sent error signal fails vice versa link mechanism completely orthogonal message sendreceive mechanismwhen programming distributed system various form rpc often extremely useful programming abstraction exact form rpc varies problem problem varies architecturefreezing exact form rpc rigid framework disregarding error case recipe disasterwith send receive link erlang programmer easily roll rpc custom error handlingthere standard rpc stub generator erlang would wise generatorin lot application simplest possible form rpc suffices define follows rcp pid request pid self request receive pid response response endnothing complicated code sends message wait replythere many variation theme simplest rpc wait forever reply never come client hang fix adding timeout rcp pid request time pid self request receive pid response ok response time error timeout endsuppose wish exception raised client remote machine dy middle rpc define rcp pid request link pid pid self request receive response response endthe addition link ensure client terminates anything go wrong rpcsuppose want parallelize two rpcs rpc request self request receive receive end end nt worry work order reply irrelevant point trying make number small example level granularity rpc error characteristic precise control programmerif turn rpc abstraction exactly want easily code solution raw process messagesso example going message sequence diagram erlang code trivial programming exercise standard rpc also make following crazy assumption reply go back client interaction form tell x send result z impossible express standard rpc framework like soap simple erlang rpc tell x todo replyto z x z assumes convention used earlier always sending twotuples message id process expecting reply first element tuple using self earlier example forced reply come back originator let suppose want add versioning protocol easy rpc pid request vsn pid self vsn vsn request receive endthe point show thing like versioning error handling parallelisation etc easily added expose interface messaging function call allow user custom build form interaction remote codeof course certain common pattern interaction complement emerge thesis baked otp librarieswhat otp otp set battle tested way thing like rpc fairly common case otp method cover error case cover common case often step outside otp framework design specialised error recovery strategy easy since otp message driven framework strip away stub function send receive message replace custom routinesotp rebranded otp rail really framework building fault tolerant systemsdoes method building software without excessive reliance upon one particular flavour rpc work say answer yes yes vengeancethis way built realtime server software ericsson decade used plex eripascal erlang c rosert year common factor nonreliance rpc specify protocol terminate number different technologiesthese protocol way complex specified using rpcs exposing protocol failure mode make system highly reliablei always thought thing rpcs run troublesteve went found problem went different roadwhat really interesting steve world world starting collide lot learn
351,Lobsters,erlang,Erlang development,Why scaling and parallelism remain hard even with new tools and languages,https://www.erlang-solutions.com/blog/the-continuing-headaches-of-distributed-programming.html,scaling parallelism remain hard even new tool language,continuing headache distributed programming scaling parallelism remain hard even new tool language pthreads programming language facilitate distributed degree designing scalability erlangotp useful overview policy decision distributed system riak core scalable distributed erlang unrelated process gproc device discovery scheduling system used internally google wrote bonjour way turn francesco cesarini cap go back blog,continuing headache distributed programming guest author andy oram senior editor oreilly medium scaling parallelism remain hard even new tool language despite groundbreaking advance language utility purport simplify parallel distributed computing designing system support modern commerce highpriority application remains one difficult task computing dealt system wrote test documentation unix pthreads implementation manufacturing firm instance edited pthreads programming book gotten familiar seeing difficulty learned look every distributed system hear recently started wonder limited progress field assigned cluster book language erlang haskell scala ocaml messaging zeromq devopsscheduling tool mesos zookeeper expect language tool designer deal difficulty distributed computing surprise user developer operation well complexity completely hidden tool think identified reason efficient robust distributed computing requires careful tuning architectural parameter parameter must exposed programmer operation people least following issue intrude decision many node want function application frontend application backend database load balancing etc memory cpu capacity node geographic distribution node share data center partition replicate data number replica needed distribution node many system site alive simultaneously handle availability load many node constitute quorum replicating state electing leader consistency model eventual causal strong etc want data replication recovery policy case failure unresponsive system data maintenance policy whether cache intermediate result calculation recalculate necessary demand operation pile fast lot configuration required matter easy toolmaker try render article discus design system language facilitate distributed degree erlang go several language tout solution people writing multiple cooperating node support distributing computing certainly refined language particularly messagepassing model seems almost universal good old thread multiprocessing relegated performancecritical application single system application spanning node benefit data sharing thread process single system exploit even blessing sharing data single node run headache cache consistency notorious vulnerability hardtodebug error definitely convenient use single programming model cover communication among local remote process messaging win asynchronous communication allows mechanism used local remote process transparently write code run single node little change distribute code cluster node asynchronous messaging even used network time protocol ntp synchronize clock different computer engage shared memory activity writing file shared disk view external world roughly agreement process still deal backedup queue child process fail child process simply never return result process failure programming error networking partitioning programmer work protocol back pressure policy enforced supervisor node existence zookeeper implementing distributed consensus guaranteeing agreement across application process demonstrates complicated distributed computing remains would unreasonable expect programming language deal issue fact erlang developer realized time ago something top erlang required deal distributed computing developed otp library discussed book designing scalability erlangotp library provides basic call starting restarting process recognizing propagating error message similar supervisor responsibility distinction appropriate language semantics appropriate library depends architectural consideration mentioned policy decision following appropriate build language whether give process failed need result recover corrupt state restart long wait deciding node vanished many node run faulttolerance scalability whether set single monitor subprocesses separate monitor user interaction backend database sort decision relegated erlang otp library otp built functionality deal issue launching process joining handling failure set generic template programmer concentrate business logic particular application useful overview policy decision distributed system introduces even treatment length cover everything certain level missioncritical application deployment even otp insufficient order avoid need human staff person hang around monitor thousand node want automated way send user request pool server sophisticated way duplicate data way safe even multiple node fail requirement call need network cooperating separate process riak core scalable distributed erlang discussed book extra tool fill gap tool expose detailed configuration detail mentioned earlier article programmer make tough architecturespecific environmentspecific choice allow application scale stay highly available unrelated process tool discussed far article diversity take one easy way assume process common ancestor least started single operator zeromq erlangotp rely tree structure supervisor going back single root unrelated erlang process microservices find central registry called gproc bluetooth wireless technology allow device discovery local network part technology internet thing zookeeper also flexible using coordination voting algorithm tradition paxos coordinate independent peer scheduling system used internally google allows multiple scheduler start job shared computing resource potentially different policy determining job varying length run paper explain system user pas information expected time requirement latency job submit shared resource mean conflict occur scheduler must use transaction deal job require many resource finish system try support totally peertopeer environment different process different goal already recognized nearly intractable wrote unknown process distributed environment everybody communicating local area network broadcast network allow system discover choose leader bonjour cifs let start printer system automatically communicate outside lan coordination unrelated process requires outofband communication tweet url video want view also specialized server use dns lookup related method register offer unknown service client seeking summary various cloud solution scheduler take important burden job monitoring fair division resource autoscaling tasksharing algorithm publishsubscribe configuration issue mentioned beginning article still require intervention programmer operation person way turn watching distributed computing space since fundamental problem go away solved throwing cpu faster network distributed computing force computer reflect complexity life many interacting factor various period time go meditate forest half hour understand problem distributed system thing convey text friend stalwart author francesco cesarini reminds computing made many advance past decade one mentioned largescale abandonment shared member favor messagepassing shared resource given though every production system rest shared data store relational database data store present partitioning highavailability challenge computer field significantly advanced understanding tradeoff consistency availability illustrated discussion around cap data system designed different tradeoff network failure understood handled like software exception cesarini say framework try automate activity end failing hide complexity limit tradeoff make cater subset system often detailed cesarini say framework try automate activity end failing hide complexity limit tradeoff make cater subset system often detailed go ahead pick tool may well picking another one two year rest comfortably knowledge whatever challenge struggling whatever solution find reusing idea thought probably implemented year ago go back blog
352,Lobsters,erlang,Erlang development,Escript Essentials,http://stratus3d.com/blog/2016/07/02/escript-essentials,escript essential,geoff cant excellent talk different execution mode interpreted mode compiled mode native mode enumlator argument lot specify encoding erlang code escript connect running erlang release ping node short name make rpc call remote node load config running application load module running application remsh node lock package multiple file escript building escript hand automation file specifying application name escript name application include escript finally emulator argument erlangmk plugin conclusion getopt juan jose comellas essential resource,v working lot escripts recently discovered quite feature wish know earlier written several escripts last couple year recently read documentation escript lot powerful feature tucked away escript would never know dug deeper documentation also learned lot geoff cant excellent talk escript erlang factory post try cover feature wish would known day one example post using erlang note example escripts post meant complete escripts rather simple example showcase certain thing script work handle possible return value function call handle error ideally escripts like catch error print helpful error message user informing mistake different execution mode interpreted mode default mode escript run interpreted mode code executed much like erl repl unlike repl escript actually erlang module even though define module file erlang code file treated inside module include header file define use macro anything else would regular erlang module even use module escripts compiled mode compiled mode erlang code compiled bytecode execution improve performance set mode attribute shebang comment line escript mode compile native mode native mode compiles escript native code even faster execution mode native course want make sure actually improves performance simple escript overhead compilation may make escript slower concerned performance benchmark escript mode go one run fastest use timer tc time execution resource intensive code escript also use unix time utility record total run time escript enumlator argument argument passed escript second line third line emacs directive line present start example escript us function mymainmodule module escript flag run interpreted mode usrbinenv escript coding escript main mymainmodule flag find useful escript main module use main function defined module running escript syntax check escript load module containing function debugger set breakpoint invokes c run escript compiled mode regardless mode attribute run escript interpreted mode regardless mode attribute n run escript native mode regardless mode attribute emulator flag override setting escript additional flag many flag erl accepts also used well lot find useful escripts setcookie set erlang cookie sname set short name escript node also cause netkernel start noinput ensures erlang runtime system never try read input noshell start erlang runtime system shell path pa pz tinker escript erlang path erlang look find module recommend relying later show better way setting escripts path also specify encoding erlang code escript second line using slightly different syntax line contain emacs directive coding connect running erlang release escripts regular erlang node connect node netkernel running many thing netkernel running inside escript example ping node easily ping node netkernel running usrbinenv escript define nodename pinger main node cookie ok netkernel start nodename shortnames erlang setcookie node listtoatom cookie case netadm ping listtoatom node ping io format pn node ping halt else io format pn node else halt end note instead calling erlang could used setcookie flag second line escript setcookie cookie use escript run pinger nodename hostname cookie note script us short name able ping node short name make rpc call remote node rpc module make easy call function remote node allows escript get statistic performance information running node check job status kick utility need run change configuration example use rpc get statistic number reduction performed node usrbinenv escript define nodename reductionstats main node cookie nodename listtoatom node ok netkernel start nodename shortnames erlang setcookie node listtoatom cookie total sincelastcall rpc call nodename erlang statistic reduction io format number reduction node pn nodename total use script invoke node name want check along cookie us reductionstats node host cookie number reduction node node host load config running application often want verify release running correct configuration load configuration release use escript loading config running node trivial rpc module usrbinenv escript define nodename configprinter main target app cookie targetname listtoatom target appname listtoatom app ok netkernel start nodename shortnames erlang setcookie node listtoatom cookie config rpc call targetname application getallenv appname io format config node pn appname targetname config invoke escript node want get config cookie configprinter node host cookie config yourapp node node host param value load module running application also pull erlang path running application set erlang path escript making erlang module release available escript usrbinenv escript define nodename path main target cookie targetname listtoatom target ok netkernel start nodename shortnames erlang setcookie node listtoatom cookie path rpc call targetname code getpath print io format path node pn targetname path add path escript code addpathsz path use module path directly escript usage escript path node host cookie path yourapp node node host remsh node starting remsh using erl pain sometimes start remote shell inside escript userdrv usrbinenv escript noshell noinput define nodename remsh main node cookie netkernel start nodename shortnames erlang setcookie node listtoatom cookie target listtoatom node trap exit remote shell crash exit gracefully processflag trapexit true start remote shell shell userdrv start ttysl c e target shell start link remote shell receive exit message true erlang link shell io format grabbed remote shell pn target return get exit message receive exit shell ok end usage escript time remote erlang shell started remsh node host cookie erlangotp source hipe kernelpoll false grabbed remote shell server eshell abort g node host issue command normally would enter ctrl c exit lock node name repurposed lock ensure one instance escript running per machine always starting erlang node name define nodename escriptlock main case netkernel start nodename longnames error errorexit user state sync already progress ok end continue second escript name started one already running name second fail since name already taken first escript stop name become available allowing escript invoked second time package multiple file escript writing nontrivial escript usually best organize code multiple module keep project organized escripts contain beam bytecode zip archive file needed escript make possible package entire erlang application single portable escript building escript hand let say erlang project directory structure look like src module want include escript module export function priv resource indexhtml packaging multiple module escript done several step compile erlang code one module must export function escript call command line argument something along line mkdir ebin erlc v werror debuginfo warnexportvars warnshadowvars warnobsoleteguard ebin build zip archive nonbeam file zip archivezip priv create escript beam file archive couple thing erlang escript module need build escript convience put code build escript another escript usrbinenv escript define escript archivedemo define shebang usrbinenv escript define comment define emuargs pa sasl errlogtype error escript main main beam f read f f filelib wildcard ebin file archivezip read archivezip beam ok escript create escript archive file memory shebang shebang comment comment emuargs emuargs ok file changemode escript ok read file ok b file readfile filename absname file b automation rebar erlangmk tool built make building multimodule escripts even easier flexible custom build script like one need create rebarconfig file specifying application name escript name application include escript finally emulator argument escriptmainapp escriptname escriptdemo escriptinclapps escriptemuargs escript main note emulator argument option must specify module containing function escript module name containing differs application name build escript run escriptize find completed escript build directory erlangmk erlangmk need add escriptmk plugin project include makefile also need specify option escript project escriptexample escriptname escriptdemo escriptemuargs escript main include erlangmk include escriptmk use escript target build escript make escript conclusion almost anything done erlang release also done escript little work since escripts regular erlang node call module much directly escript blog post really scratched surface possible escript may possible everything need inside escript important remember escripts meant replacement erlang release need long running application use erlang release escript real strength ability provide better interface interacting erlang system especially helpful engineer experienced erlang maintaining erlang system hopefully blog post show feature escript use build better escripts oh writing larger escripts getopt juan jose comellas essential live without resource
353,Lobsters,erlang,Erlang development,There are Guards and Guards,https://medium.com/@elbrujohalcon/there-are-guards-and-guards-71e67d4975d7,guard guard,boolean operator guard roberto ostinelli factorial,diego torres la furia boolean operator guardsnot use example roberto ostinelli used mailing list let something noone else u let define factorial fact fun f f x x f end fun fact fact far good know next step right wise dev come tell u function hang negative number improve f fact fun f f x x x f end fun fact fact exception error function clause matching erleval insideaninterpretedfun awesome fair factorial make sense integer add guard right f fact fun f f x isinteger x x x f end fun fact exception error function clause matching erleval insideaninterpretedfun look good shinny except fact exception error function clause matching erleval insideaninterpretedfun googled guard wat disappointed
354,Lobsters,erlang,Erlang development,The Exceptional Server,https://medium.com/@elbrujohalcon/the-exceptional-server-abe9016ebe75,exceptional server,whats going doc code throw r ok r backwards compatibility example catch mod handlecall msg state technique please,whats going one time recommend check erlangotp doc probably code try figure happens reading furthernow let together first let check doc say closest thing could find callback function fails return bad value genserver process terminatesthat seems case consider emptytray exception situation although hold replylike exception actually say anything throwing exceptionswe dig otp code see going part genserver code evaluating handlecall callback tryhandlecall mod msg state try ok mod handlecall msg state catch throw r ok r error r stacktrace erlang getstacktrace exit r stacktrace r stacktrace exit r stacktrace erlang getstacktrace exit r r stacktrace endi highlighted important section basically state module implement behaviour throw exception within handlecall function exception treated regular reply happens callbackbut well reason lot backwards compatibility see try somewhat recent addition erlang language time genserver written erlangers managed exception using catch see manual page bif throw used nonlocal return function must evaluated within catch return value catch throw hello helloif evaluated within catch nocatch runtime error occursgenserver code oct looked like case catch mod handlecall msg state reply reply nstate reply reply loop parent name nstate mod infinity reply reply nstate reply reply loop parent name nstate mod noreply nstate loop parent name nstate mod infinity noreply nstate loop parent name nstate mod stop reason reply nstate exit r catch terminate reason name msg mod nstate reply reply exit r handlecommonreply parent name msg mod state end combined technique seen allows write really clever code send user message state isvalid user orelse throw reply error invaliduser state throw reply error invalidmessage state iswellformed message deliverycode newstate sendmessage user message state reply ok deliverycode newstate please home kid
356,Lobsters,erlang,Erlang development,The Shoemaker’s Son - an Erlang story about Dialyzer,https://medium.com/@elbrujohalcon/the-shoemakers-son-ef473e8a2be,shoemaker son erlang story dialyzer,running dialyzer katanatest dialyzer formatwarning warning atom rawwarning string,adam sandler cobbler running dialyzerdialyzer shell tool run console course en erlang application run within erlang vms katanatest meta test suite needed run dialyzer code might expecteda simplified version needed shown module contains main function end calling dialyzer different option main difference analysistype used build plt dialyzer need analyze code used actually check successful type module functionsdialyzer return list warning erlang form later run dialyzer get proper message string formatso far good let see happens try analyze module tried meta c dia debuginfo ok dia dia plt creating plt diaplt done dia run diabeam checking whether plt diaplt uptodate yes proceeding analysis done call dialyzer formatwarning warning atom break contract rawwarning string oh man breaking contract
357,Lobsters,erlang,Erlang development,Lisp Flavoured Erlang,http://lfe.io/,lisp flavoured erlang,script standalone library bread butter otp application otp release sophisticated machinery,script addition heavyduty power lfe get free virtue erlang vm also create small easytowrite oneoff main script lfescripts even escripts either single file additional module help organise larger script standalone library building library use lfe application even erlang beam language application bread butter lfe hacker erlangbeam ecosystem fully accessible lfe application also freedom lfe otp application take advantage otp lfe mere second creating faulttolerant application builtin process monitoring supervision tree genservers behaviour never go otp release lfe prototype ready bigtime run sophisticated machinery otp release fact nt wait start prototype release zero pain benefit
359,Lobsters,erlang,Erlang development,Where Erlang BLOOMs [2012],http://ferd.ca/rtb-where-erlang-blooms.html,erlang bloom,rtb erlang bloom real time bidding erlang bloom type advertising cookie matching gateway got scale graphite statsd statsderl vmstats made load balancer error l aog ger lager scaling operation bidder bertconf pedal metal queue suck stack nice nothing better dispcount dispcount optimization,rtb erlang bloom still way back bay area erlang factory fact finished post coming back entirely san francisco starting see bunch twitter post regarding people posting slide online although good idea tend view slide pure visual support animation nt show well static pdf thought quick transcript main idea work talk real time bidding erlang bloom brought bloom digital platform type advertising advertiser want buy advertisement large user group hope get decent result participate real time bidding rtb rtb advertiser bid individual advertisement space obtain targeted audience usually built backbone large exchange bidder require high performance short response time high volume precisely context internet traditional way thing called display advertising general practice website owner contacting advertiser adgency push advertisement said website done broadly deal dealer send bunch ad always change site precise case deal specific advertiser one example latter microsoft window vista came paid people cdn per week website change background something provista realtime bidding rtb kind evolution top display advertising bunch loosely defined protocol employed nearly many exchange allow instead dealing single distributor limited inventory ad anybody try buying advertisement soft realtime exchange look like let say car dealer got website user perspective whenever visit page see little snippet html javascript contact server optionally display advertiser place tracking cookie site able thing like calculate various conversion rate make sure show thing browser often come rtb thing begin way request ad make exchange exchange sends something called bid request bunch bidder bidder represent one advertiser exchange aggregate request many exchange forward bidder bid request often contain information kind site user visiting general information geographical location age etc available case bidder case bloom called adgear trader try decide help data whether want advertise person given bidder bid sending snippet html javascript depending exchange winning bidder snippet displayed page exchange update cooky time pushed page point bidder set cooky thinkering also generally practice cookie matching help share anonymized data different actor making general decision process better case done c directly apache module case type campaign made especially interesting rtb say still car dealer website book deal given bidder also advertise online given user visited site bidder thus got cookied tagged deal user visit another car dealer website expecially local area chance put advertisement site thus bid money auction hope winning win finally display ad update cooky ideally bring browser back shop gateway product working related realtime bidding erlang bloom adgear trader sits bunch bidder bunch exchange gateway running far server core ram although instance gateway usually take le running linux gentoo think mean gnulinux make use cassandra redis term database gateway instance get thousand bid request second usually depending period day request forwarded many bidder received back reply get sent gateway act bit like small exchange aggregator latency pretty important given usually get around millisecond handle request although value tends grow recent development includes delay parsing bid request search database serializing bid request sending client waiting response parsing said response picking best bid client encoding exchange format pushing back ideally want without skipping beat also handle thing like serving javascript tag tell u bid need little downtime possible ideally none knowing bid let u increment allocated budget campaign way make sure spending trillion dollar got scale well course scaling nice first thing measure measure measure tool trade graphite statsd nodejs frontend graphite statsderl client statsd bunch manual call statsderl vmstats push erlang vm detail statsd obtain series graph customize make look bit like reveals first problem left hand side graph large green peak red bump caused ibrowse http client library first one used running nice loadbalancing feature support asynchronous mode problem time time loadbalancer would lockup forgetting release resource would cause green peak happen request would stop forwarded bidder red peak consequence u basically restarting ibrowse every minute thing short time fix ibrowse suboptimal temporary solution taken eventually time fix picked lhttpc library choice also supported asynchronous request made load balancer deployed saw happened righthand side graph peaceful functionality loadbalancer wrote one based idea one loadbalancer per domain say one per bidder load balancer keep list n socket always active request coming send message ask socket thing returning make sense reason first want keep socket always open setting new connection mighty expensive take millisecond get one going could processing time bid request keeping socket open nobrainer next idea one loadbalancer per domain necessary simple reason one bidder twice slower one unfair one hog socket available moreover imperative able divide request many process let say made bad decision one loadbalancer whole node three bidder bid request might send request socket average bid request per second rapidly brings u message per second single process way vm sustain long period time instead choose divide request three loadbalancers possible peak message per second single process still lot even much far nicer multiplicative result get single loadbalancer many bidder error l aog ger point time winter started following graph showing alarm flowing email box middle night plenty people seen chain error start happening sudden errorlogger queue growing hand vm dy going memory oom actually worse logging crash fast ca nt know error vm recover problem picked one two option turned logging used alternative logging library picked latter chose use andrew thompson lager quickly result visible solved problem right away although log large cycling fast often missing original source issue vm could stand ground tolerate kind crash turned problem one exchange would often send u misshaped packet erroneous contentlength value crashed outdated version cowboy using upgrading allowed u deal correctly since vm managed become fairly stable scaling operation one thing writing bidder running locally gateway node nt much say fairly basic one thing though force u think configuration whole lot one common problem rtb configuration want static possible order optimize able change fast possible order correct error someone saying want spend million instead thousand solution picked one central point origin config data pink node center controller take two role one web service external bidder want information bid one application push flat bert file gateway node bert file loaded bertconf transformed local ets table bertconf look file change regular interval detects anything new reloads new file make new table swap existing one using trickery insure never request failing hint work bit like module versioning vm purge option somewhat safe depends central node push update read long local bert file reload memory even crash also stupidly easy override file single node manually replace central service need another nice aspect read configuration pretty much every bid request ever great able avoid going outside vm fetch value need stay local speed maybe year much configuration wo nt able hold memory meantime bertconf appears good option pedal metal config flexible fast basic bidder place http library stable exchange integrated needed open gate system hit u cassandra suffered problem cassanderl pooling system nt especially robust cassandra lot request would sometimes really long insert comment java gc problem brown line timeouts show request per second could reach timing pretty bad explanation possible queue suck pool system based queue usually message queue different request execute thing usually work fine able process data fast faster enters queue however problem happens element join queue faster leave happens request queue bound le le time processed initial millisecond fact point time request going stale throw away start cycle actually happens production u given always getting thousand request queue second might connection open database constant overload going see bump time sometimes serve one request lot time left serve many crumb initial allowed time left spent idling good reason stack nice let imagine instead using queue using stack mailbox even situation overload always going pick newest element top stack stack model work fairly well case burst overload catch later done fresh query hit batch stale one try quickly discard go saying wo nt bid exchange awesome right nt remember gateway situation constant overload mean likely never hit stale item first place would need use kind bucketbased approach garbage collector specialized enough throw away old request nt good enough nothing better nothing better mean nothing stack rather stack upper limit one element idea whenever handling one element wo nt accepting anything else nt care serving item wait mean going le time always overload pretty much guarantee element take place one finished right away much stuff coming reason queue build say request ca nt make sorry guy guess wo nt bid one important idea nt actually serve request nt fit right away answer back sorry gon na bid exchange wait fact get much throughput way try halfassed job answering query nearly time left equivalent preemptive time get better throughput yes also guaranteeing also maximize time request making bidder useful dispcount dispcount library built bloom harness idea prefer answer nobid response responding time even losing time request given new one take place instantly actually work without using message passing way bypass mailbox queue oh integrated cassanderl dispcount push idea bit trying avoid central point communication play single point failure want avoid everyone wanting chunk data start n resource watcher work idea know say request done nt wait external information know resource watcher contact know practice using hash unique data pid timestamp us lookup table diagram watcher teal purple pink orange black request get hashed value orange us ets increment value atomically value returned incrementation know access resource anything else nt case nt value returned going image request got hashed purple color counter update returned value request gained right table containing pid resource requested pid single message thing explain first distribution request nondeterministic entirely possible system load thousand resource available get busy message request however heavy load case time statistic pretty much guarantee u going get full usage resource whenever resource get checked back counter reset new request obtain secondly feel explain use two ets table use counter like reason actually simple ets table switching read write mode relatively slow laptop benched operation per second table mixing read writes staying read xor write mode could nt hit limit first memory scheduler working hard process would problem splitting table two one read mode one write mode avoid switching using ets actually read write data single write operation tricking vm giving bang buck would also recommend use dispcount anyone allowed thing like avoiding process request actually nt frequent situation overload repository explains condition assumption made designing dispcount detail result show impact dispcount production right somewhat painful first deployment interesting see timeouts green bump getting squashed deployment replaced fact see minimal amount request need discarded brown line making initially nonintuitive call dropping request fact ended serving lot due mainly fact never accumulate request thus end busting timer losing race dropping request fact let u serve lot graph show run queue period time request building mailbox erlang vm working hard try go including garbage collection using dispcount removed issue pretty much instantly optimization one thing spent lot time trying reduce work done encoding decoding bid request response json protobuffs even http request making gateway dangerously close cpubound application one thing tried changing encoding outgoing json nif library like ejson using iolists data show little variation theory promising first benchmark instead revealed little gain made maybe best thing though benchmark sequential encoding random copy json structure tight loop started measuring thing using little hundred fifty concurrent process suddenly change much noticeable iolists would two three time faster ejson suspecting nifs might tend behave differently parallel concurrent setup sequential benchmark always representative reality especially reality nt purely sequential fact started could seen witch hunt nonessential nifs system caused u problem crashing vm cowboystyle hotcode loading actually need relups slower request shortlived point safer hotreload without protection locking everything currently skip reloading away would nt sadden u note system constraint different might embrace nifs different requirement yield different optimal solution finally want keep decentralizing single point failure single point communication annoying thing limit much push gateway thank reading talk question
360,Lobsters,erlang,Erlang development,Erlang shell: REPL? A bit more (and less) than that [2013],http://ferd.ca/repl-a-bit-more-and-less-than-that.html,erlang shell repl bit le,repl bit le history nt repl totally possible get better io protocol nt made better,repl bit le erlang shell funny thing think lot people used language short quickly got annoyed lack support feature often considered basic history history search supported since lack full support emacs shortcut fact nt use readline emulates wrapping erlang shell rlwrap often recommended user advanced repls one provided factor dr racket likely disappointed visual support available erlang able declare inline module bit annoying module accepted file shell post want explain erlang shell work feature somewhat difficult easy add also showcase really neat feature shell provide nt repl first thing know erlang shell readevalprint loop least original lisp definition loop print eval read starter erlang thing main loop process main loop easily traceable central process lead march language designed support feature called group group leader get detail later allow multiple shell bit output redirected kind place node current standard inputoutput inherited parent process child process unless change erlang vm start start kernel application stdlib application magic innards vm allows two module depend exist boot kernel app start bunch supervisor process control every service vm run distribution example one supervisor named usersup one process charge detecting argument passed vm relative shell figure vm master slave shell input output disabled kind shell want load default one old one people use kind switch useful shell regular erlang process mean node might distributed one redirect output master node many shell one virtual machine erlang instance started need forward output master node either redirect output standard inputoutput oldshell mode input disabled redirect port program middleman process named user said paragraph earlier group group leader allow redirecting output clever thing happen group leader process given name setting default group leader user get entire vm dynamically send input take output wherever need without process ever needing care want change io take place change user process everything get redirected usersup thus follows decision tree first option trivial second one somewhat simple implemented infamous user module infamous every newcomer try module named end killing lot stuff current default erlang shell third solution far complex one picked deal send io stuff still nt seen actually get shell running closest thing erlang would repl would old shell accessible using erl oldshell one go straight user module given simplest one also decent starting point understand thing work user module basically handle read print part repl accumulates character display prompt collect line shove eval part fetch back display drawing show shellerl charge evaluation take string tokenizes get ready evaluation spawn temporary process evaluation purpose reason process running shell evaluator also charge tricky state may want stick around across call fail example record definition loaded file record compiler trick held memory inject evaluating term evaluation history shell hold list previous abstract call abstract result recalled later variable binding expression evaluated result forwarded usererl check terminal geometry whatever make sure fine shove result standard output work somewhat alright could possibly push far enough work like pretty good shell problem process based module like usererl leaf little reimplement large part ever want reuse kind code thing straight standard io want allow connecting shell directly ssh totally possible given c program gui wherever else need deal thing rather low level move stream text around hope best erlang guy decided go different way use level abstraction decided write new shell instead starting usererl supervisor start process named userdrv based userdrverl module new structure look like structure usererl functionality split shared component tty play role former stdio stuff adapted whatever o running compiletime text type shell enters vm forwarded userdrv decides text happens c g userdrv drop shell management mode understand mode need know many concurrent shell running regrouped list grouperl process managed userdrv list determines shell currently active one shell management allow various operation shell see pressing g user switch command h c nn connect job nn interrupt job k nn kill job j list job shell start local shell r node shell start remote shell q quit erlang h message j shell start init shell start c shell individually killed interrupted good infinite loop wait deadlock connecting given shell instance get back regular editing mode text type regular text userdrv look currently active grouperl process current shell one send data message passing grouperl process exactly prime task buffer data line ready evaluated handle line stack move updown arrow search line history line completed going backandforth edlinerl handle cursor movement character deletion escaping heavy tagteam deal history highlevel line editing management second task act group leader shellerl started line seen valid shellerl instance attached current grouperl process ready line sent evaluated result passed back grouperl process move userdrv user driver perspective many shell data forwarded receiving output userdrv check current grouperl instance data formatted forwarded tty nt muted however special case data sent directly user one free pas never filtered allowing regular io reach user even switching active shell instance generally give sane filtering group process set shell process group leader group leader inherited process started directly within active shell instance output limited one still able access output application started outside terminal still send data user seems good enough people never know filtering take place need know work get better particularly interesting feature ability start remote shell made possible part due group feature work want tell group start shell rpc mechanism language giving something bit like scheme regular message passing enough get thing working evaluation take place remote context editing done locally different slave node slave node output redirected master remote shell kind output come particular rpc shell child redirected another interesting thing erlang guy implement messagepassing protocol grouperl userdrverl latter translates tty part stack protocol look kind similar regular io protocol added support lineediting message moving cursor blinking visual bell erasing line sound bit overkill shell nice aspect code reused erlang application example ssh daemon linked us group custom evaluator terminal setup look like substituting userdrv ssh daemon take place tty input output part grouperl edlinerl keep line editing working anybody could implement shell even web browser felt like thing need translate line editing protocol implement client side also need think security trying sandbox erlang node nontrivial attempt made using something called safe shell substituting shellerl process another implementation something doable given direct dependency grouperl whatever evaluator outside messagepassing protocol speak nt made better good question easy hypothesis people actually know shell work developer likely expect regular repl end finding distributed task management system called dozen way unexpected confusing first get feature like better emacs shortcut support likely easy add edlinerl adding vi mode support would probably need new line editor entirely support shortcut may need implemented driver tty example saving shell history need take account group actually run many one node trying access file hope post allowed interested reader get general idea thing work erlang shell interesting piece code powerful could even though underwhelming level fun trying add feature erlang shell getting people discus could nice
361,Lobsters,erlang,Erlang development,"Learn to Forget, when you learn Erlang",https://www.erlang-solutions.com/blog/learn-to-forget.html,learn forget learn erlang,learn forget inaka erlang trainer erlang developer nutshell sequential erlang concurrent erlang sse write whole system learn point learning book inadequate fashion condensed knowledge emerged famous book behaviour opensource library condensed knowledge workerpool sumorest many others let put library hexpm hexpm furthermore go back blog,learn forget brujo benavides many rolespositions inside erlang solution inaka cto one erlang solution tech lead also erlang trainer sometimes truly erlang developer want share experience learning erlang couple year ago incidentally something also seen time different perspective erlang trainer nutshell thing keep seeing someone learning erlang happened people learning language like haskell instance keep learning thing forget later probably never going use anymore need know want understand concept intrinsically tied philosophy language one thing render many building block forgettable usually seen attached language name itslef erlangotp let show sequential erlang let leave otp aside second start learning erlang usually start sequential erlang right erlang book course tutorial start way erlang functional language one first thing everyone learns write recursive function start database actually list fetch key undefined fetch key key value value fetch key db fetch key db somebody introduces anonymous function course highorder function suddenly use recursion anymore cool kid use list instead fetch key db case list dropwhile fun k k key end db undefined value value end course eventually realize someone else must issue often exactly case function use fetch key db proplists getvalue key db concurrent erlang ok writing sequential erlang easier expected lot thing already written good thing make people choose erlang first place chosen erlang develop system probably concurrency problem rather problem best solved using concurrent language least intuitive first situation described sequential erlang could apply concurrent erlang well start database new dbvalues spawn module init dbvalues init dbvalues loop dbvalues loop db receive fetch key reply proplists getvalue key db end loop db fetch key db db fetch self key receive reply result result end see implement example learn spawn process using erlang variant send receive message database process receives message message receives using internal state build response sends back caller message yeah tiny bit internal logic proplists getvalue key db unique rest pretty generic even caller side everything boil sending message waiting response might guessed lot people faced issue condensed experience helped create thing otp learn work otp behaviour longer need spawn process send message explicitly new dbvalues genserver start module dbvalues init dbvalues ok dbvalues handlecall fetch key db reply proplists getvalue key db db fetch key db genserver call db fetch key terminate ok see suddenly using spawn anymore genserver take care furthermore genserver also take care ton thing even thought yet like server running running node timeouts code upgrade etc point job erlang developer longer spawning process sending message starting server fsms inside supervision tree end building application building whole new kind app building generic enough instance web server rest api web socket even sse support surely app already need write piece code specific system longer think process even server supervisor whatnot hidden behind internal logic erlang application use day certainly write whole system multiple endpoint database connection interactive documentation even sse support without even thinking otp learn point unavoidable question pop end use point learning question every math student ever forever asked logarithm right answer unsurprisingly shape way think building system erlang writing functional code spawning process interchanging message building erlang system thinking term scalability faulttolerance reliability many thing francesco cesarini steve vinoski explain detail book understanding mechanism behind otp process lead creation help gain crucial insight architect system true write web server erlang limited functional programming knowledge almost total lack awareness otp knowingcaring internals building really know capable importantly know system capable also fact even totally use otp knowing linked process behave save countless hour frantical debugging googling stackoverflowing find started genserverin inadequate fashion condensed knowledge important notice something fully realize started teaching erlangotp course otp created orimposed emerged point someone established right way building system erlang contrary otp created multiple already existing system built way working ericsson smart people realized thing writing code time time making mistake fixing saw decided condense knowledge code well course big library set application actually eventually called otp thought process lead gang four write famous book described many common pattern observed several project provided name example making otp common programming pattern identified ended encoded behaviour using actually profiting condensed knowledge year programming building system similar one hand opensource library process described stop otp maybe add many new thing otp anymore thanks thriving opensource community behind erlang still keep collecting condensed knowledge apps library framework allow others well forget certain thing keep constantly library like workerpool sumorest many others result thought process behind otp time people let put library central place share knowledge hexpm learned forget couple internal component find writing piece code encourage create opensource library share hexpm others stop reinventing particular wheel using experience others also turn simple wooden wheel allstar highperformance one keep u rolling faster faster everyday furthermore erlang developer long time described come experience learner teacher well experience colleague friend based pretty certain developer learn erlang love hear learning pattern spice thing brand new language beam town elixir really interested discovering learning process like especially people come erlang background currently trying gather info speaking alchemist know learnt elixir recently please share insight comment plan eventually write post elixir learning experience see difference stay tuned go back blog
362,Lobsters,erlang,Erlang development,Why I dislikes IFs in Erlang,https://medium.com/@elbrujohalcon/if-i-fell-in-love-with-you-f35cf6b80d15,dislike ifs erlang,daniel radcliffe zoe kazan like like statement john degoes wonderful article positively printing going multiclause expression built guard body want true branch andalso andalso one andalso andalso andalso andalso orelse andalso andalso andalso orelse andalso begin end andalso andalso orelse andalso begin andalso end trick learned week ago andalso andalso orelse andalso begin end else source,daniel radcliffe zoe kazan like ifsfirst let get something straight like statement like general language could expose reason thankfully john degoes wrote wonderful article day ago check technique solve issue may controversial may apply happily haskell agree reason exhibit destroying ifsnow one greatest thing erlang joking p never need explain conceptual dislike ifs others let check syntax usually enough convince use let show printinggranted example might best one let go show almost issue ifs idea simple want print number want display sign prefix positive deep understanding ifs work erlang especially come functional programming background would tempted write function like pp fun x x io format io format pn x endbut simple test show even work positive number fails negative pp pp exception error true branch found evaluating expressionwhat going one thing functional language everything expression therefore need evaluate value expression x end must value every possible value x want erlang evaluate function function written provide way evaluate expression negative value x call function negative value get ifclause exception word unless really sure one going call function negative value need provide true branch ifa true branch work like else language although since erlang multiclause expression built guard body keyword provide guard always true achieve desired effect even example doc let upgrade pp fun x x io format true io format pn x endlet test new pp pp sure enough worked want true branch often adding true branch every something developer wrote elseless first place want facing dilemma developer learn achieve result functional way pp fun x x andalso io format io format pn x end fun yes using shortcircuit boolean operator andalso achieve elseless effect check pp pp amazing right even circumvent restriction imposed erlang ifs clause guard expression use expression want boolean operator write code like inside function user andalso registerlogin user date need one condition isregistered user andalso passwordmatches user password andalso registerlogin user date condition little bit complicated isregistered user andalso passwordmatches user password andalso hasactivesession user orelse isadmin user andalso registerlogin user date need one thing condition match isregistered user andalso passwordmatches user password andalso hasactivesession user orelse isadmin user andalso begin registerlogin user date opensession user endwhat nested statement isregistered user andalso passwordmatches user password andalso hasactivesession user orelse isadmin user andalso begin registerlogin user date isadmin user andalso openadminsession user use trick learned week ago right isregistered user andalso passwordmatches user password andalso hasactivesession user orelse isadmin user andalso begin registerlogin user date openadminsession user isadmin user endif extremely ugly code convince use method know else
363,Lobsters,erlang,Erlang development,The Mouse Trap: A Final LZ4 Act - Hacking Erlang,http://blog.securitymouse.com/2014/07/a-final-lz4-act-hacking-erlang.html,mouse trap final act hacking erlang,killing money writing twice writeonce language erlang oh slay mehherlang clone repository github version github file github polymorphism bitch looking nif erlnifc file erlbinaryh file magic happens globalh,killing money getting lot email dm pm etc congratulating perseverance pr mess bug thanks support let realistic really killing money amount engineering effort take prove something vulnerable exploit often unnecessary addon bug report talking potentially thousand dollar consulting hour lost due effort nt required first place bug reported fixed required say hey patch think information security industry failing client general internet community waste time asking people prove code bug report sufficiently elaborate perhaps time better spent patching moving chose prove code first nt like lose going lie lot selfish need prove right also job released bug first place right thing information security consultant job try make internet safer spending thousand dollar lost consulting time hoping saved company hundred thousand dollar remediation forensics engineering time chasing adversary critical bug could end costing lot money said enough bug fun made point writing twice writeonce language attacking erlang language fun time erlang virtual machine allows object written variable erlang language written instantiation want write variable darn bad vm forbits check simple example nt familiar erlang run aptget install erlang machine test environment always debian erlangotp source hipe kernelpoll false eshell abort g variable hello hello variable hello variable lol exception error match right hand side value lol example see erlang command line erl allows u set variable similar python command line difference writes variable require deletion said variable erlang pattern matching system right side expression must always equal left side unless left side yet defined amazing pattern matching functionality part elegance functional language erlang haskell etc personally big fan erlang write lot code recently wrote fuzzer reason see could fun nt fun attacking erlang nature language depicted easy mangle object memory ca nt alter fact oh slay mehherlang beauty elegant bug like memory corruption flaw come order use optimized library best call erlang language native implemented function must constructed basically erlang equivalent ruby python binding connect erlang language existing shared library mean calling erlang module within erlang actually talking c library binding interface give u opportunity attack decompression function way would system even better simple functionality variable define decompressed data set data decompressed essentially corrupting object memory instantiated note maintainer nif smart quick updated package chance get kudos szktty want play vulnerable release code please clone repository github check version start let take look nif binding work follow along static erlnifterm nifuncompress erlnifenv env int argc const erlnifterm argv erlnifterm retterm erlnifbinary srcbin resbin long ressize enifinspectbinary env argv srcbin enifgetlong env argv ressize return enifallocbinary sizet ressize resbin char srcbindata char resbindata resbinsize retterm env atomok enifmakebinary env resbin enifreleasebinary resbin return retterm else enifreleasebinary resbin return env atomerror atomuncompressfailed code see native implemented function handle call uncompress first argument data decompressed second argument size buffer data decompressed decompression buffer essentially variable even though variable yet assigned remember variable set erlang object created memory done mangling object must altered way new instantiation used object originally created therefore focus corrupting object initially decompressed example see resbin object erlnifbinary created object containing destination buffer data size destination buffer mentioned moment ago passed second argument uncompress let ignore moment author nif ignores allocator return value focus content enifallocbinary int enifallocbinary sizet size erlnifbinary bin binary refbin refbin ertsbindrvallocfnf size bugbug alloc type refbin null return nif must take action refbin flag binflagdrv bugbug flag ertsrefcinit refbin refc refbin origsize sword size bin size size bin data unsigned char refbin origbytes bin binterm thenonvalue bin refbin refbin return seen github enifallocbinary creates binary object memory contains actual allocated memory buffer origbytes erlnifbinary simply container binary object allowing semblance inheritance c similar pyobject variant python really need understand layout binary memory since decompression payload actually resides typedef struct binary ertsinternalbinaryfields sword origsize char origbytes continued binary see allocated object defined almost exactly like object python dynamic behavior structure last value array implying object allocated memory excess byte allocated referenced origbytes making binary dynamic object methodology used python many project require semblance class inheritance polymorphism c language since know decompression buffer point origbytes know use memory corruption bug overwrite previous field binary object little effort let take look field define ertsinternalbinaryfields uword flag ertsrefct refc ertsbinarystructalignment file github binary structure definition see macro including structure variable origsize three object memory origbytes flag integer reference counter refc padding structure system four variable architecture meaning point memory corruption byte prior start decompression buffer overwrite might saying would bother crappy exploit scenario like ruby corrupting header going home fair question friend remember erlang nt crappy programming language like ruby real thing erlang besides building metasploit module used real world application course get functionality exploit erlang functional language polymorphism bitch great thing binary object destructed point like self respecting garbage collected virtual machine would mean something point inspect binary object let see work looking nif char srcbindata char resbindata resbinsize retterm env atomok enifmakebinary env resbin enifreleasebinary resbin return retterm else enifreleasebinary resbin return env atomerror atomuncompressfailed remember code decompression return error call immediately made enifreleasebinary seems familiar almost exactly python binding react failure huh go figure enifreleasebinary called whether return error case failure called immediately look promising let check void enifreleasebinary erlnifbinary bin bin refbin null binary refbin bin refbin assert bin binterm thenonvalue ertsrefcdectest refbin refc ertsbinfree refbin back erlnifc file see corrupted binary within erlnifbinary immediately tested passed ertsbinfree two important thing note reference count binary decremented tested zero ertsbinfree simply passed entire binary structure first point important immediately tell u refc must overwritten order make call ertsbinfree second point important point ertsbinfree nt know anything erlnifbinary mean generic memory destruct function also mean due polymorphic behavior virtual machine must presume dynamically allocated data interpreted somehow ertsglbinline void ertsbinfree binary bp bp flag binflagmagic ertsmagicbindestructor bp bp bp flag binflagdrv ertsfree ertsalctdrvbinary void bp else ertsfree ertsalctbinary void bp bingo got lift erlbinaryh file see ertsbinfree indeed attempt interpret type binary passed flag variable set binflagmagic destructor function resides binary called awesome binary nt defined magic object overwrite flag variable good go magic happens left evaluate structure look like interpreted magic oh magic indeed let go back globalh inspect proper structure typedef struct ertsinternalbinaryfields sword origsize void destructor binary char magicbindata ertsmagicbinary oh well nt perfect offset would normally correctly decompressed data binary structure variable origbytes contains function pointer destructor ertsmagicbinary well nt convenient mean payload essentially contain binflagmagic value followed reference count followed padding followed original size value followed function pointer payload win let try simple erlang program call uncompress data payload file module donb export doit file io format doit n case file readfile file ok b x attack b ok x error r error file formaterror r end attack b r uncompress b io format uncompress returned wn r compile file donberl erlang using c donb simply test payload described adjustment python payload previous blog post offset donb debian usrlocalbinerl noshell run donb doit init stop doit segmentation fault core dumped donb debian gdb q core reading symbol done new lwp new lwp new lwp new lwp new lwp new lwp new lwp new lwp new lwp new lwp new lwp warning ca nt read pathname load map inputoutput error thread debugging using libthreaddb enabled using host libthreaddb library core generated root usrlocalliberlang prognam program terminated signal segmentation fault gdb elegance polymorphism c allows u turn binary magic end remote code execution one single integer overflow attacking language nt even let write variable multiple time win corruption nt beautiful thing think best bailey founder ceo lab mouse security infosecmouse http wwwsecuritymousecom binbash erlang exploit work otp vers donb securitymousecom work version prior testing misuse append printf file init rm f file touch file large x xff x perl e print x file appendsize lt append done initialize file init simple literal run mask append copy fifteen byte embed null ref second mask must embedded well note second mask start first append goal need byte large append xdd binary structure overwrite need byte need mask append append obtype append binflagmagic append refcount append origsize append padding append destructor append magic bin data append append append append append append append append append append append append finish bad reference append xffxff
364,Lobsters,erlang,Erlang development,Evolution of an Erlang Programming Style,http://prog21.dadgum.com/220.html,evolution erlang programming style,evolution erlang style came erlang first permalink previously,evolution erlang stylei first learned erlang still goto language personal project tool popular criticism semicolon comma dynamic typing irrelevant technique feature use changed year look erlang programming style evolvedi came erlang five year lowlevel coding video game concerned language interpreted overhead functional programming one reason went erlang easy correspondence source code beam virtual machine even subset erlang result optimal code function make tail call call function written c parameter stay fixed register even function look like lot parameter pushing popping turn destructive register update one first thing wrote back curious retrospect writing sort functional assembly language stopped thinking beam performance real problem turned much better expected decision cemented several round hardware upgradesthe tailrecursive list building pattern accumulator list reverse end worked well primitive style common functional idiom tend use straightforward recursive call right hand side list constructor whole build backward reverse idea feel clunkyfor small project tried composing program higherlevel function map filter foldl zip much possible ended code harder follow writing loop straight erlang awkward syntax including remembering parameter order enough case foldl nt exactly right accumulating list counting something time raw erlang function easierlist comprehension though use time syntax make difference order parameter remember even clearly inefficient thing like list sum x x list simpler foldli use fun lambda often pas function like map simplify code reducing number parameter need passed around also handy returning structured type sort simple object hide unneccessary detailsearly also concerned cost communicating external program obvious method use port essentially bidirectional pipe benchmark window good instead used linkedin driver harder get right could easy crash emulator nt even think port everything rewrote action game o x graphic user input external program main game logic erlang erlang code spawn game driver communicate via binary protocol even performance issuepermalink july
366,Lobsters,erlang,Erlang development,Introducing MLFE (ML-Flavoured Erlang),http://noisycode.com/blog/2016/06/27/introducing-mlfe,introducing mlfe mlflavoured erlang,mlflavoured erlang leex yecc homebrew edoc mlfe repository next ets contributing discussing username,mlflavoured erlang statically typed language basic parametric polymorphism generic erlang vm hacking away spare time since roughly beginning making repository public version apache license think hit point entirely useless currently every type inferred type annotation error message leave much desired work simple example module module examplemodule function add integer try call float get type error x x basic adt noargument type constructor type evenodd even odd convert integer basic adt evenorodd x match x even odd written erlang using leex yecc parsing cerl module build core erlang ast compilation erlang compile module build doc cerl directly seem generally hosted anywhere curious want explore find source cerl erlang distribution compiler lib osx erlang compiler source installed homebrew machine life following folder used edoc generate api doc keep around locally reference mlfe repository basic getting started help readme user experience rough around edge put mildly familiar already erlang note distinct temporary absence binary map well started working two reason wanted something like various form ml adts available erlang vm along static typing like concision help wanted learn type system implemented much adt requirement satisfied atom tuples erlang proper always end feeling bit cumbersome dialyzer great feel like work pretty hard properly constrain contract really want none stop reaching erlang good fit friction point wanted try smooth critical happening following resource next version mostly lowhanging fruit binary map quoted atom test formmacro notationside effect like write basic plugin well simplify working erlang since much functionality going depend mixing time longer term type inferencer need substantially reworked possibly even rewritten specific goal logging typing decision tied reference cell binding point function variable name proper garbage collection reference cell probably abandoning process using something like ets always generalizing type variable incomplete shortlist thing like see record structural pattern matching want able match subset field type annotation anonymous function pattern matching function definition eg f x x destructure tuple without explicit match emacs mode manually indent thing something like go fmt intention integrate comment ast partially enable contributing discussing contribution welcome subject licence code conduct specified project repository lurk erlounge freenode twitter username
367,Lobsters,erlang,Erlang development,Erlang/OTP 19.0 has been released,http://www.erlang.org/news/105,erlangotp released,http githubcom http http wwwerlangorgdoc,genstatem new state machine behavior mnesiaext plugin external storage solution mnesia crypto us evp interface openssl resulting generally better performance support hw acceleration ssh performance improvement us new genstatem behavior ssl enhanced error log message dialyzer support map much extended type specification syntax type analysis ert erlang openport spawn time faster tracing extensive improvement scalability speed match specification sendreceive support lttng dirty scheduler improved per process configurable handling messagequeue fast loading multiple module maxheapsize process flag ertskernel experimental support unix domain socket example genudp open ifaddr local tmpsocket much find release note detailed info http find source code githubcom official erlang repository git tag http also read documentation online see release note mentioned release note updated doc new functionality http wwwerlangorgdoc also want thank contributed new feature bugfixes suggestion bug report erlangotp team ericsson
368,Lobsters,erlang,Erlang development,Tail Call Optimization in Elixir & Erlang – not as efficient and important as you probably think,https://pragtob.wordpress.com/2016/06/16/tail-call-optimization-in-elixir-erlang-not-as-efficient-and-important-as-you-probably-think/,tail call optimization elixir erlang efficient important probably think,bodyrecursive function faster memory efficient especially optimized tailrecursive counter part dave thomas programming elixir writing map implementation easiest readable care accumulator reversing list benchee little verbose equivalent script bencheecsv tailrecursive version slower result million item list josé valim chimed argument order adding following apparently common misconception myth tailrecursive function much faster recursive function list fred hebert remark body recursion may simpler also faster save memory time blog post topic explode clojure koan seems impossible memory consumption tailrecursive version take almost gigabyte memory bodyrecursive version take bit gigabyte gist bodyrecursive function time clojure kaon exercise take megabyte tailrecursive version almost gigabyte bodyrecursive version become faster standard library version bodyrecursive function case bodyrecursive function faster efficient tailrecursive function robert virding creator erlang rightfully highlight assume always proof erlang performance myth section measure puella notifying bodyrecursive function significantly slower tco version seems erlang mapbody version significantly slower elixir mapbody fastfaster thread full post course worth read rightful nitpick paweł pointing version comment benchmarked different variant multiple time new benchmarking script gist sasa juric showing get bytecode elixir function significantly faster bodyrecursive version even stdlib version like,automatic tail call optimization tco great feature elixir erlang everyone tell super fast super cool definitely always aim make every recursive function tailrecursive told bodyrecursive function faster memory efficient especially optimized tailrecursive counter part seems unlikely every beginner book mention tco tell efficient definitely use plus maybe tried bodyrecusion language x call stack blew horrendously slow thought tailrecursive function always better bodyrecursive one day accident wrote none tailrecursive function tco apply someone told eagerly replaced tailrecursive counterpart stopped second benchmarked result surprising say least deep dive topic let take refresher tail call optimization dave thomas programming elixir great book end calling many language add new frame stack large number message might run memory happen elixir implement tailcall optimization last thing function call need make call instead runtime simply jump back start function recursive call argument replace original parameter well let get writing map implementation let write implementation map function one bodyrecursive one tailrecursive add another tailrecursive implementation using reverse one reverse list end one reverse list course functionally equivalent others element order wrote function care ordering might update also added version argument order different see result defmodule mymap def maptco list function enumreverse maptco list function end defp maptco acc head tail function maptco function head acc tail function end defp maptco acc function acc end def maptcoargorder list function enumreverse domaptcoargorder list function end defp domaptcoargorder function acc acc end defp domaptcoargorder head tail function acc domaptcoargorder tail function function head acc end def maptcoconcat acc list function def maptcoconcat acc head tail function maptcoconcat acc function head tail function end def maptcoconcat acc function acc end def mapbody func def mapbody head tail func func head mapbody tail func end def maptconoreverse list function maptco list function end end mapbody function originally wrote tailrecursive last operation method list append operation call mapbody comparing implementation also argue easiest readable care accumulator reversing list code let u benchmark function benchee benchmark run elixir erlang linux mint let map large list add one element list also throw standard library implementation map comparison baseline list enumtolist mapfun fn end bencheerun map tailrecursive fn mymapmaptcoconcat list mapfun end map tco reverse fn mymapmaptco list mapfun end stdlib map fn enummap list mapfun end map simple without tco fn mymapmapbody list mapfun end map tco new arg order fn mymapmaptcoargorder list mapfun end map tco reverse fn mymapmaptconoreverse list mapfun end time warmup tobi happy githubelixirplayground mix run benchtcoblogpostdetailedexs benchmarking map tailrecursive benchmarking map tco benchmarking stdlib benchmarking map tco new arg benchmarking map simple without benchmarking map tco name ip average deviation median map simple without tco stdlib map map tco new arg order map tco reverse map tco reverse map tailrecursive comparison map simple without tco stdlib map slower map tco new arg order slower map tco reverse slower map tco reverse slower map tailrecursive slower benchmarking actually done little verbose equivalent script generates csv ouput console output run using benchee slightly verbose interface feature make possible nicer interface planned visual also graph showcasing result visualized using bencheecsv graphing iteration per second higher better see bodyrecursive function seems fast version standard library reported value faster well within margin error plus median two standard deviation higher standard library version hint possibility worse average may outlier resulting fex garbage collection tailrecursive version slow appending frequently bad idea need go end linked list every time around n main point main point tailrecursive version slower even tailrecursive version reverse list slower bodyrecursive implementation seems like good point interject mention brought comment see significantly larger list tailrecursive implementation get faster check result million item list highly irritating surprising tailrecursive function slightly different argument order significantly faster original implementation almost one consistently faster across number run see implementation thankfully josé valim chimed argument order adding following order argument likely matter generate branching code order argument specially matter performing binary matching order function clause matter although sure measurable empty clause come first last maybe better tailrecursive version please tell result rather staggering repeatable consistent happened apparently common misconception tailrecursive function always faster seems common misconception common enough made list erlang performance myth myth tailrecursive function much faster recursive function note section currently reworked name might changelink might lead directly nearish future quote bodyrecursive list function tailrecursive function call list end use amount memory list list list comprehension many recursive function use amount space tailrecursive equivalent faster depends solarissparc bodyrecursive function seems slightly faster even list lot element architecture tailrecursion faster topic also recently came erlangquestions mailing list talking rework aforementioned erlang performance myth site really worth read fred hebert remark emphasis added case function build new list accumulator whose size equivalent number iteration hence stack nearly data structure say list body recursion may simpler also faster save memory time also blog post topic explode question experience clojure koan expected bodyrecursive function blow call stack given large enough input manage matter tried seems impossible beam vm erlang elixir run differs implementation vms body recursion limited ram erlang recursion limit tail call optimised recursive call tail call limited available ram memory consumption memory consumption let create list one hundred million element map measuring memory consumption done tailrecursive version take almost gigabyte memory bodyrecursive version take bit gigabyte detail found gist well likely large list tail recursive version need create new reversed version accumulator return correct result bodyrecursive function time let recap bodyrecursive version map faster consumes le memory easier read maintain every time well example course let take look dumb function deciding whether number even implemented homage clojure kaon exercise showed call stack blow clojure without recur defmodule number def iseven true def iseven n iseven n end def iseventco n acc true def iseventco acc acc def iseventco n acc iseventco n acc end end number bencheerun iseven fn numberiseven number end iseventco fn numberiseventco number end tobi happy githubelixirplayground mix run benchisevenexs benchmarking iseven benchmarking iseventco name ip average deviation median iseven iseventco comparison iseven iseventco slower tailrecursive version still slower memory running function one hundred million input take megabyte tailrecursive version mind whole elixir process almost gigabyte bodyrecursive version also huge input tailrecursive version took second bodyrecursive function took second larger input faster stark contrast likely time around huge list carried around accumulated boolean number effect bodyrecursive function need save call stack ram much damaging effect need call one hundred million time rerunning map implementation significantly larger list tailrecursive version also become faster standard library version bodyrecursive function see tailrecursive function still faster efficient many use case believe year taught tail call optimization lead fastest recursive function post say tco bad slow say highlight case bodyrecursive function faster efficient tailrecursive function also still unsure tailrecursive function reverse list still slower bodyrecursive version might carry accumulator around maybe also take step back education teaching careful overemphasize tail call optimization tailrecursive function bodyrecursive function viable even superior alternative presented course case writing tailrecursive function absolutely vital robert virding creator erlang rightfully highlight main case tco critical process toploops function never return unless process dy build stack never release get right alternative applies toploop actually composed set mutually calling function alternative sorry pushing critical teach u end take assumption stemming programming environment granted also assume always proof let finish closing word erlang performance myth section choice mostly matter taste really need utmost speed must measure longer sure tailrecursive list function always fastest previously bug iseventco missing caught test calling wrong function thanks puella notifying see next editupdate pointed lobster running erlang session bodyrecursive function significantly slower tco version running believe equivalent code elixir erlang seems erlang mapbody version significantly slower elixir time look need run erlang benchmarking tool confirm though small try mentioned first addendum run shell great idea using little erlang knowledge made something compiled benchmark mapbody fastfaster thread benchmarking fickle wrong done right would still look forward run proper erlang benchmarking tool use benchee erlang time right added comment robert virding regarding process top loop critical tco thanks reading honoured surprised one creator erlang read full post course worth read following rightful nitpick write tail call optimized function rather tailrecursive tail call optimization feature compiler directly attribute function included another version benchmark swap argument order list stay first argument accumulator last argument surprisingly yet version constantly faster tailrecursive implementation still slower body recursive want thank paweł pointing version comment reversed argument order distinguishing factor could make version assignment new accumulator benchmarked different variant multiple time consistently faster although could never reproduce fastest memory consumption example seemed consume le original tailrecursive function bit faster also since reran either way ran freshly released elixir erlang also increased runtime benchmark well warmup get consistent result overall wrote new benchmarking script result shown graph console output added little tco intro might helpful case interested bytecode look like done area expertise yet gist sasa juric showing get bytecode elixir function added josé comment argument order thanks reading commenting added cpu o information pointed comment performance characteristic might differ larger list taking time many element tailrecursive version significantly faster bodyrecursive version even stdlib version updated reflect newer benchee api old api list tuples work anymore like like loading related
369,Lobsters,erlang,Erlang development,Robert Virding - Implementing Languages in Erlang,https://www.youtube.com/watch?v=du6qWa8lWZA,robert virding implementing language erlang,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature robert virding implementing language erlang youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature robert virding implementing language erlang youtube
370,Lobsters,erlang,Erlang development,In Defense of Erlang : Through the Magic of Offense,https://drive.google.com/file/d/0Bz8Lmg2kodQiRXYwWVpGNXQtdG5hNG5GaDFFNF9UNXp4UXo4/view,defense erlang magic offense,,
372,Lobsters,erlang,Erlang development,Real World Elixir Deployment,http://www.slideshare.net/petegamache/real-world-elixir-deployment,real world elixir deployment,user agreement privacy policy privacy policy user agreement,slideshare us cooky improve functionality performance provide relevant advertising continue browsing site agree use cooky website see user agreement privacy policy slideshare us cooky improve functionality performance provide relevant advertising continue browsing site agree use cooky website see privacy policy user agreement detail
373,Lobsters,erlang,Erlang development,Towards Hard Real–Time Erlang,http://www.erlang.se/workshop/2007/proceedings/05nicosi.pdf,towards hard erlang,,obj goto endobj obj motivation endobj obj goto endobj obj scheduling erlang endobj obj goto endobj obj harte proposal rt erlang endobj obj goto endobj obj test endobj obj goto endobj obj open issue endobj obj goto r fit endobj obj length filter flatedecode stream uβ zz vkd h k lu txoˋ n kź endstream endobj obj type page content r resource r mediabox trans r parent r annots r r r r r r r r r r r r r r r r r r r r r r r r r endobj obj type xobject subtype form bbox formtype matrix resource r length filter flatedecode stream endstream endobj obj shading sh shadingtype colorspace devicergb domain coords function functiontype domain function functiontype domain n functiontype domain n functiontype domain n functiontype domain n bound encode extend false false procset pdf endobj obj type xobject subtype form bbox formtype matrix resource r length filter flatedecode stream endstream endobj obj shading sh shadingtype colorspace devicergb domain coords function functiontype domain n extend true false procset pdf endobj obj type xobject subtype form bbox formtype matrix resource r length filter flatedecode stream endstream endobj obj shading sh shadingtype colorspace devicergb domain coords function functiontype domain function functiontype domain n functiontype domain n bound encode extend true false procset pdf endobj obj type xobject subtype form bbox formtype matrix resource r length filter flatedecode stream endstream endobj obj shading sh shadingtype colorspace devicergb domain coords function functiontype domain function functiontype domain n functiontype domain n bound encode extend false false procset pdf endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link endobj obj type annot border hnc rect subtype link endobj obj type annot border hnc rect subtype link endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link goto endobj obj type annot border hnc rect subtype link goto endobj obj r xyz null endobj obj r xyz null endobj obj r xyz null endobj obj font r xobject r r r r procset pdf text endobj obj length filter flatedecode stream x
374,Lobsters,erlang,Erlang development,How Erlang does scheduling (2013),http://jlouisramblings.blogspot.com/2013/01/how-erlang-does-scheduling.html,erlang scheduling,,
375,Lobsters,erlang,Erlang development,Elixir RAM and the Template of Doom,http://www.evanmiller.org/elixir-ram-and-the-template-of-doom.html,elixir ram template doom,elixir ram template doom evan miller gather script tracing limit le costly phoenix request request template doom parting wisdom phoenix chicago bos dtrace note evanmillerorg twitter r wizard data le time communicate discovery visually back evan home page subscribe r twitter youtube,elixir ram template doom evan miller april attempt convince two line code elixir interesting programming language ever used ready worry code involve quicksort metaprogramming anything like go ok file fileopen tmpsomethingtxt write raw filewrite file rereplace hello goodbye amp code nothing special open file writes short string replacing ampersand hardcoded string html entity amp probably sharp enough write equivalent code favorite language couple minute le code entirely equivalent elixir code least perspective run tracing program like strace dtruss nonelixir code probably see something like write hello usual syscall expect trace elixir program instead see something like writev give strange hexadecimal number point good old write good enough mr fancy pant elixir answer immediately obvious code sample go long way towards explaining unique performance characteristic well anomaly might encounter ever try benchmarking erlang elixirâ html template read tale technical subtlety engineering culminates inmemory rendering template doom gigabyte monster bottom sea end post promise look web server way anyway enough gabbing dive gather get handle thing first revisit stringreplacement code rereplace hello goodbye amp paste code elixir shell see something slightly unexpected hello amp goodbye instead flat string erlang oops say erlang meant elixir creates nested list containing four leaf element add string expect hello amp goodbye first glance may seem like pointless complication see computer think situation look man page writev see mean writes data multiple memory location single system call wrote little dtrace script unpack writev call saw earlier peek elixir code actually system call log script writev return writev data byte hello writev return writev data byte writev return writev data byte amp writev return writev data byte goodbye original hexademical number writev call introduction memory address vector vector contains memory address four memory address represented big hexadecimal number next string address see log elixir writing element nested list separately hello amp goodbye notice anything peculiar memory location one perhaps look like others hello amp goodbye good hexadecimal lay character stated memory address simply rearranging expanding data log boldfacing start address clarity p h e l l g b e see yet nested list string fragment list make new string start make sense three pointer original string plus outoforder pointer replacement string word set modification old string also see extra tiny optimization performed regex engine notice final string us ampersand original string rather replacement string data structure called io list designed leverage writev thus minimize data copy writing disk network language wipe original string copy whole thing missing whole class nocopy latecopy performance optimization course pointer panacea sometimes data copying cheaper pointer juggling use dtrace explore erlang vm implementation see system draw various line attempt balance engineering consideration tracing limit try tracing two line code filewrite file enummap fn foobar end filewrite file enummap fn foobar end attempt write io list file first one foobar repeated time second foobar repeated time might think task result syscalls reality first line code call writev vector element second one flattens io list single blob memory call write concatenated data much language try string slightly longer shorter foobar see trigger simply number element list rather total size resulting string hit element list erlang switch concatenating data contiguous chunk memory poke around vm code see triggered constant smallwritevec dtrace log vector reveals something else writev something might surprise take look writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar notice anything memory address well strain eye mean point different address copy foobar lying around memory interestingly case move foobar literal outside closure elixir code trace code instead foobar foobar filewrite file enummap fn foobar end see end result get rather different trace writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar time memory address work hood small string elixir instantiated wherever literal appears code foobar inside closure new string created whenever closure executed foobar outside closure execution closure result new reference string coming say javascript point might seem obvious remember string elixir immutable necessarily expect new instantiation execution code fact rule change string defined byte larger second magic number erlonheapbinlimit vm code big literal appear compiled module allocated shared heap refcounted see memory address trace regardless literal appears code worth noting string literal elixir shell always use smallstring rule complicated might thinking great care foobar got le costly show benchmark going blow mind make question everything thought knew web server performance well everything except great stuff learned article far ready going back something like scene raider lost ark one face melt head explodes simply unsee two elixir template wired excellent phoenix web framework template first iters blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah end template second iters blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah end template produce identical output lot blahblahblahblah difference second template insert string length zero middle iteration going believe one template greater throughput get excited caching computed template fragment better close look benchmark output benchmark first template without empty string running test http thread connection thread stats avg stdev max stdev latency reqsec request read socket error connect read write timeout requestssec transfersec benchmark second template empty string running test http thread connection thread stats avg stdev max stdev latency reqsec request read socket error connect read write timeout requestssec transfersec ruhroh inserting empty string template increase performance could learned anything far syscalls matter strace dtrace friend use look template perspective first template produce lot output like writev return writev data byte nblahblahblahblah second template produce output like writev return writev data byte ok first template delivered client tiny byte chunk empty string included second template along http response header flattened one big kilobyte string instead verrrrrrrry interesting tell least little curious going discrepancy traced another compiletime constant erlang vm one known erlsmalliobinlimit determines maximum string size consolidated one big string hardcoded four time value erlonheapbinlimit byte exact string smaller equal limit consolidated larger string preserved writev vector notice template example deliberately contrived byte chunk blahblahblahblah exceed limit get entry writev vector split chunk half true nefarious purpose mysterious empty string resulting chunk limit get consolidated happens computer consolidation greater throughput particular template come cost higher ram usage brings template doom enough information render template doom recently recovered sunken spanish galleon doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom end template produce file word doom repeated billion time totaling gb size template consists entirely chunk larger byte chunk compiled refer memory address know server storing million boxed pointer order magnitude gb machine vm topped gb ram usage serving single copy template doom best part make template doom crash server inserting empty string template dare try rather secondbest part best part understand crash email implemented template doom assembly using five molecule ram remember silly benchmark underpowered macbook point exercise empty string template string million time order save help give tool understand going hood system engineering situation call small memory footprint tinychunk writev strategy may better others great cpu caching slabofram may fine exercise starting point exploration parting wisdom memory architecture fit neatly onto problem dynamic template rendering rendering speed killing productivity making customer swim black pool pageload depression take look phoenix chicago bos framework work writev io list well kqueueepoll slash cpu ram usage compared nonerlang system many case obviate need serverside erlang vm clever produce oddity highly informal testing look like erlsmalliobinlimit particular cranked bit perhaps byte guardian vm might consider making tunable compiletime parameter using erlang elixir might want poke around favorite template implementation see using writev hood tracer make quick work task strace linux dtruss o x good start absolutely nothing beat dtrace power see writev trace log might opportunity improving memory architecture keep eye memory location trace output little string reuse go long way finally enjoyed using elixir code example found library could make better use io list particularly regex string module well html entityescaping without io list elixir eagercopying memory like everybody else missing one feature make erlang vm technically interesting note reading evanmillerorg random collection math tech musing liked might also enjoy get new article published via twitter r want look statistical pattern mysql postgresql sqlite database desktop statistic software wizard help analyze data le time communicate discovery visually without spending day struggling pointless command syntax check back evan home page subscribe r twitter youtube
376,Lobsters,erlang,Erlang development,"Lashup - high availability control plane foundation, crdt store",https://github.com/dcos/lashup,lashup high availability control plane foundation crdt store,lashup summary minuteman distributed load balancer publicly evaluated overlay builder hyparview routing failure detection distributed database riakdt background deltacrdt paper failure detector network partition happen often usecases detecting failure publishing vip powering novel load balancing algorithm joinidlequeue security usage membership keyvalue store test suite subscription api multicast,lashup summary lashup building block distributed control plane act failure detector distributed fullyreplicated crdt store multicast system nt meant used rather conjunction component several component described currently use minuteman distributed load balancer publicly evaluated capability fault tolerance minuteman overlay builder core lashup overlay builder strongly connected sparse graph tcp connection used communication primary reason scalability every node check health every node maintain connection every node would quickly see scalability problem code file prefixed lashuphyparview implementation heavily based hyparview change randomized timer used instead round throttling mechanism employed found take longer overlay become stable join throttled overlay member stored disk health occasionally checked routing failure detection atop overlay routing failure detection layer node lashup network distributes adjacency every node system stored memory found node typical size database mb fanout set based static tunables overlay layer whenever change given node adjacency table gossip throughout network node also check health one another healthcheck algorithm adaptive algorithm set initial expected round trip time second proceed ping every one adjacency every second historical round trip time cached use logarithmic scale determine long future round trip take node fails respond immediately disconnect propagate information gossip protocol point node also connected node proceed check health result typical subsecond failure detection overlay unstable ping interval naturally elevated therefore inhibit rejection node overlay adjacency table run depthfirst search build minimum spanning tree minimum spanning tree becomes mechanism build senderrooted multicast message distributed database lastly interestingly lashup distributed database lashup act crdt store built top basho riakdt every key replicated every node rather performing readmodify writes crdt store offer operation specifically operate counter map set flag register also compose data structure build complex model given lashup nt meant work high key count due naiveté antientropy algorithm preferential build map data also persisted disk via mnesia mnesia chosen due reliability testing production well fact requires dependency outside erlang background lashup underlying infrastructure project minuteman enables minuteman determine list available backends fulfill connection request context project peacekeeper lashup could disseminate list available ip port endpoint system strong availability performance property highavailability property also known event fabric lashup run every agent cluster information needed derived mesos agent taskinfo taskstatus record therefore initial goal lashup advertise uptodate task record agent addition must replicate state node running lashup modeled keyvalue system every agent namespace write agent read estimate size information used taskinfo record likely kilobyte taskstatus size likely byte efficiency taken order advertise mutation work deltacrdt paper since information used make routing decision must disseminated timely manner lashup provide strong guarantee timely convergence partial failure typical operating condition although strong requirement lashup also provide mechanism determine whether replica agent entirely failed avoid sending request likely different mechanism used state dissemination versus liveness checking failure detector prior gossip protocol lashup need provide failure detector minuteman purpose failure detector allow faster dissemination data whether cache broker something else reason agent advertise state independently health allows u handle stale data better retire advertised vip agent quickly period epidemicgossip system would take disseminate said data need failure detector quick converge le second disseminating member failure cluster failure detector detect asymmetric network partition example assume master agent want able detect case communicate communicate ideally also want failure detector enable instigating health check based minuteman connection want mark member set failed communicate network partition happen often many caused misconfiguration usecases detecting failure first obvious usecase lashup detect agent failure system sending traffic node via load balancing mechanism react node failure faster mesos mechanism detect failure using technique like gossip indirect healthchecks alternatively dcos take advantage mesos slow period detecting fault publishing vip second usecase lashup publish vip minuteman vip derived reading local agent statejson extracting vip result map set map simply merged across agent merge operation set simple merge powering novel load balancing algorithm reliable failure detector mechanism disseminate data extended although could trivially implement local least connection global random balancing algorithm algorithm quite often ideal mechanism interactive web service one algorithm serf purpose better microsoft joinidlequeue effectively requires mechanism expose queue depth router algorithm performancebased routing require small amount metadata exposed short update period security security implemented project peacekeeper peacekeeper intercept first packet every connection complexity determining destination order determine destination task list must queried find task matching networkinfo record allocated port information difficult cache high churn overly aggressive caching potentially lead security compromise distributed filtering system also requirement distribute filtering rule node timely fashion otherwise user left without connectivity user may much connectivity usage integrating lashup project easy must set configuration mnesia dir kv store persist data lashup workdir persist lamport clock used gossip algorithm must also configure contact node via lashup contactnodes node used bootstrap overlay least one must new node join membership get global membership snapshot calling lashupgm gm interested finding change global membership subscribe lashupgmevents genevent interested finding reachability information call lashupgmroute gettree origin get dfs tree origin return map key destination node name value either distance given origin infinity node unreachable keyvalue store keyvalue store expose traditional api subscription api request operation keyvalue store simply executing lashupkv requestop key op op riakdt operation example found test suite subscription api subscription api allows subscribe keyvalue change match specific pattern use standard ets match spec purpose match spec must return true example ets fun nodemetadata true end match spec must member tuple key pattern simply call lashupkv subscribe ets fun nodemetadata true end dump existing key matching given pattern send future key matching pattern addition lashup deduplicates update sends new update multicast simplest way use multicast api call lashupgmevents subscribe topic update topic streamed caller send update topic via lashupgmmc multicast topic data topic aforementioned topic data whatever like
377,Lobsters,erlang,Erlang development,"A comparison between Misultin, Mochiweb, Cowboy, NodeJS and Tornadoweb (2011)",http://www.ostinelli.net/a-comparison-between-misultin-mochiweb-cowboy-nodejs-and-tornadoweb/,comparison misultin mochiweb cowboy nodejs tornadoweb,nginx patched version httperf misultin mochiweb cowboy nodejs tornadoweb test result tornadoweb nodejs mochiweb cowboy misultin update may,already know author misultin erlang http lightweight server library interested http server spend quite time trying always interested comparing different perspective today wanted try benchmark various http server library chosen library one currently interest misultin obviously since wrote mochiweb since solid library widely used production afaik used still used empower facebook chat amongst thing cowboy newly born lib whose programmer active erlang community nodejs since bringing javascript backend opened new whole world possibility code reusable frontend ease access various programmer finally tornadoweb since python still remains one favourite language tornadoweb excelling load benchmark production empowering friendfeed two main idea behind benchmark first want hello world kind test static server nginx wonderfully perform task benchmark needed address dynamic server second wanted socket get periodically closed since load socket scarcely correspond real life situation latter reason decided use patched version httperf widely known used benchmark tool hp basically try send desired number request server report many actually got replied many error experienced process together variety piece information great thing httperf set parameter called set amount call per session ie socket connection socket get closed client command issued test httperf server uri valuebenchmarks rate value rate set incrementally since number requestssec rate numcalls test conducted desired number responsessec incrementing total number request numconns rate therefore fixed value along every test iteration test basically asks server check get variable set variable set reply xml stating error variable set echo inside xml therefore tested header parsing querystring parsing string concatenation socket implementation server virtualized uptodate ubuntu lts cpu ram etcsysctlconf file tuned parameter maximum tcp receive windownetcorermemmax maximum tcp send windownetcorewmemmax give kernel memory tcp need many open socket etcsecuritylimitsconf file tuned ulimit n set hard soft limit code different server misultin module misultinbench export start port misultin startlink port port loop fun req handlehttp req end stop misultin stop handlehttp req get value parameter args req parseqs value misultinutility getkeyvalue value args case value undefined req ok contenttype textxml value specified req ok contenttype textxml value end mochiweb module mochibench export start port mochiwebhttp start port port loop fun req handlehttp req end stop mochiwebhttp stop handlehttp req get value parameter args req parseqs value misultinutility getkeyvalue value args case value undefined req respond contenttype textxml value specified req respond contenttype textxml value end note using misultinutility function inside code since proplists much slower cowboy module cowboybench export start port application start cowboy dispatch host list path handler opts cowboybenchhandler name nbacceptors transport transopts protocol protoopts cowboy startlistener http cowboytcptransport port port cowboyhttpprotocol dispatch dispatch stop application stop cowboy module cowboybenchhandler behaviour cowboyhttphandler export init tcp http req opts ok req undefinedstate handle req state ok case cowboyhttpreq qsval value req undefined cowboyhttpreq reply contenttype textxml value specified req value cowboyhttpreq reply contenttype textxml value req end ok state terminate req state ok nodejs var http require http url require url httpcreateserver function request response responsewritehead contenttype textxml var urlobj urlparse requesturl true var value urlobjquery value value responseend value specified else responseend value listen tornadoweb import tornadoioloopimport tornadoweb class mainhandler tornadowebrequesthandler def get self value selfgetargument value selfsetheader contenttype textxml value selfwrite value specified else selfwrite value application tornadowebapplication r mainhandler name main applicationlisten tornadoioloopioloopinstance start took code run misultin erlang mochiweb erlang cowboy master erlang nodejs tornadoweb python library run standard setting erlang launched kernel polling enabled smp disabled single cpu used library test result raw printout httperf result got downloaded note graph logarithmic scale according see tornadoweb top around responsesseconds nodejs mochiweb cowboy misultin misultin cowboy experience little error server seem funnel load please note error timeout error second without reply total response response time speak say surprised result point like feedback code methodology alternate test performed input welcome available update post correct eventual error made ongoing discussion whomever want contribute however please refrain flame war welcomed published post exactly surprised result got opinion update may due success benchmark want stress important point read including mine benchmark often misleading interpreted higher graph best libofthemomentnamehere everything absolutely wrongest way look stress point enough fast n feature desire webserver library definitely want consider stability feature ease maintenance low standard deviation code usability community development speed many factor whenever choosing best suited library application thing generic benchmark one related specific situation fast application computational time load connection small data transfer therefore please use grain salt jump generic conclusion regarding cited library clearly stated beginning post find interesting valuable still open criticized described methodology thing might missed
378,Lobsters,erlang,Erlang development,hansihe/Rustler -- Safe Rust bridge for creating Erlang NIF functions,https://github.com/hansihe/Rustler,hansiherustler safe rust bridge creating erlang nif function,rustler documentation getting started example feature getting started rustler elixir library rustler elixir library look like supported nifversion community freenode elixirlang slack license,rustler documentation getting started example rustler library writing erlang nifs safe rust code mean way crash beam erlang vm library provides facility generating boilerplate interacting beam handle encoding decoding erlang term catch rust panic unwind c library provides functionality erlang elixir however elixir favored feature safety code write rust nif never able crash beam interop decoding encoding rust value erlang term easy function call type composition making rust struct encodable decodable erlang elixir done single attribute resource object enables safely pas reference rust struct erlang code struct automatically dropped longer referenced getting started easiest way getting started rustler elixir library add rustler elixir library dependency project run mix rustlernew generate new nif project follow instruction already using serde consider using serderustler easily encode decode data type elixir term note previously used rustler need run mix archiveuninstall rustlerinstallerez remove generating nif look like code minimal nif add two number return result rustler nif fn add b b rustler init elixirmath add supported nifversion rustler us erlang systeminfo nifversion detect supported nif version erlangotp system nif compiled possible restrict nif version older version nif compiled older version erlang example target nif version erlangotp defined using environment variable mix compile community find u rustler freenode elixirlang slack license licensed either option contribution unless explicitly state otherwise contribution intentionally submitted inclusion work defined license shall dual licensed without additional term condition
379,Lobsters,erlang,Erlang development,Erlang 19.0 Garbage Collector,https://www.erlang-solutions.com/blog/erlang-19-0-garbage-collector.html,erlang garbage collector,erlang garbage collector learn erlang solution erlang elixir solution sign mailing list first know future blog post tracing garbage collector overview meet creating data immediate term boxed term collector scanning rootset see move marker term catch deallocate generational garbage collection erlang garbagecollect spawnopt fun fullsweepafter n young heap sizing heap grows variation fibonacci sequence grows increment literal binary heap reference counted mso list swept move marker decremented potentially freed encounter heap binary old heap virtual binary heap trigger message large allocate enough space copy insert message queue message allocating strategy bibliography c j cheney nonrecursive list compacting algorithm commun acm nov learn erlang solution erlang elixir solution sign mailing list first know future blog post go back blog,erlang garbage collector lukas larsson learn erlang solution erlang elixir solution sign mailing list first know future blog post disclaimer blog post describes state erlang garbage collector erlangotp thing change clearly marked section erlangotp master branch moving target thing may changed time released erlang manages dynamic memory tracing garbage collector precisely per process generational semispace copying collector using cheney copy collection algorithm together global large object space overview erlang process stack heap allocated memory block grow towards stack heap meet garbage collector triggered memory reclaimed enough memory reclaimed heap grow creating data term created heap evaluating expression two major type term immediate term require heap space small integer atom pid port id etc con boxed term tuple big num binary etc require heap space immediate term need heap space embedded containing structure let look example return tuple newly created data data foo con literal text hello world tag con literal example first create new con cell integer tuple text tuple size three wrapping value atom tag created returned heap tuples require word size element well header con cell always require two word adding thing together get seven word tuples word con cell string hello world list con cell thus requires word atom tag integer require additional heap memory since immediate adding term together heap space required example word compiling code beam assembly erlc show exactly happening putlist put atom tag put put literal text hello world return looking assembler code see three thing heap requirement function turn six word seen instruction allocation combined single instruction bulk data text hello world literal literal sometimes referred constant allocated function since part module allocated load time enough space available heap satisfy testheap instruction request memory garbage collection initiated may happen immediately testheap instruction delayed later time depending state process garbage collection delayed memory needed allocated heap fragment heap fragment extra memory block part young heap allocated contigious area term normally recide see young heap detail collector erlang copying semispace garbage collector mean garbage collection term copied one distinct area called space new clean area called space collector start scanning rootset stack register etc follows pointer rootset heap copy term word word space header word copied move marker destructively placed pointing term space term point already moved term see move marker copy referring pointer instead example following erlang code foo arg test arg wrapper one copy exists heap garbage collection first time encountered copied term referenced rootset copied collector scan space copy term term reference scanning collector step term space term still referencing space copied space term contain nonterm data payload heap binary instance encountered collector value simply skipped every term object reach copied space stored top scan stop line scan stop moved end last object scan stop marker catch scan start marker garbage collection done point deallocate entire space therefore reclaim entire young heap generational garbage collection addition collection algorithm described erlang garbage collector also provides generational garbage collection additional heap called old heap used long lived data stored original heap called young heap sometimes allocation heap mind look erlang garbage collection copy stage anything copied young space instead copied old space highwatermark highwatermark placed previous garbage collection ended introduced new area called old heap normal garbage collection pas term located highwatermark copied old space instead young next garbage collection pointer old heap ignored scanned way garbage collector scan longlived term generational garbage collection aim increase performance expense memory achieved young smaller heap considered garbage collection generational hypothesis predicts term tend die young immutable language erlang young term die even faster language usage pattern data new heap die soon allocated good limit amount data copied old heap also garbage collection algorithm used proportional amount live data heap one critical issue note term young heap reference term old heap term old heap may refer term young heap due nature copy algorithm anything referenced old heap term included reference tree rootset follower hence copied data would lost fire brimstone would rise cover earth fortunately come naturally erlang term immutable thus pointer modified old heap point young heap reclaim data old heap young old heap included collection copied common space space young old heap deallocated procedure start beginning type garbage collection called full sweep triggered size area highwatermark larger size free area old heap also triggered manual call erlang garbagecollect running young garbage collection limit set spawnopt fun fullsweepafter n n number young garbage collection forcing garbage collection young old heap young heap young heap allocation heap consists stack heap described overview however also includes heap fragment attached heap heap fragment considered highwatermark part young generation heap fragment contain term either fit heap created another process attached heap instance bif binarytoterm created term fit current heap without garbage collection create heapfragment term schedule garbage collection later also message sent process payload may placed heapfragment fragment added young heap message matched receive clause procedure differs worked prior erlangotp contiguous memory block young heap stack resided considered part young heap heap fragment message immediately copied young heap could inspected erlang program behaviour introduced superior many way significantly reduces number necessary copy operation root set garbage collection sizing heap mentioned overview size heap grows accommodate data heap grow two stage first variation fibonacci sequence used starting word mega word heap grows increment two occasion young heap grows total size heap message heap fragment exceeds current heap size fullsweep total amount live object greater two occasion young heap shrunk young collection total amount live object le heap young heap big fullsweep total amount live object le heap old heap always one step ahead heap growth stage young heap literal garbage collecting heap young old literal left place copied figure term copied garbage collection following pseudo code used isliteral ptr onoldheap ptr fullsweep literal non fullsweep copy else copy ptr isliteral check work differently different architecture operating system bit system allow mapping unreserved virtual memory area operating system except window area size gb default mapped literal placed within area done determine something literal two quick pointer check system relies fact memory page touched yet take actual space even gb virtual memory mapped memory actually needed literal allocated ram size literal area configurable miscs ertsalloc option bit system enough virtual memory space allocate gb literal instead small kb sized literal region created demand card mark bitarray entire bit memory space used determine term literal since total memory space bit card mark bitarray word large bit system bitarray would tera word large technique viable bit system lookup array little expensive pointer check done bit system extremely bit window ertsalloc unreserved virtual memory mapping special tag within erlang term object used determine something literal cheap however tag available bit machine possible great deal nice optimization tag future like instance compact list implementation used operating system needed behaviour different worked prior erlangotp literal check done checking pointer pointed young old heap block considered literal lead considerable overhead strange memory usage scenario removed binary heap binary heap work large object space binary term greater byte called heap binary binary heap reference counted pointer offheap binary stored process heap keep track decrement reference counter heap binary linked list mso mark sweep object list containing fun external well heap binary woven heap garbage collection done mso list swept offheap binary move marker written header word reference decremented potentially freed item mso list ordered time added process heap minor garbage collection mso sweeper sweep encounter heap binary old heap virtual binary heap process virtual binary heap associated size current heap binary process reference virtual binary heap also limit grows shrink depending heap binary used process growth shrink mechanism used binary heap term heap first fibonacci like series growth virtual binary heap exists order trigger garbage collection earlier potentially large amount heap binary data could reclaimed approach catch problem binary memory released soon enough catch lot message message become part process heap different time depends process configured configure behaviour process using processflag messagequeuedata offheap onheap mixed set default process start using option xmqd different configuration use let start going happens one erlang process sends message another sending process need couple thing calculate large message sent allocate enough space fit entire message copy message payload allocate message container meta data insert message container receiver process message queue process flag messagequeuedata receiver process control message allocating strategy sender process step also message data treaded garbage collector procedure different worked prior configuration option behaviour always similar onheap option part message queue configured quite new master may exactly way released instance discussion removing mixed option completely message allocating strategy set mixed onheap sending process first attempt allocate space message directly young heap block receiving process always possible requires taking main lock receiving process main lock also held process executing possibility lock conflict thus likely intensely collaborating system sending process acquire main lock heap fragment instead created message message payload copied onto offheap option sender process always creates heap fragment message sent process difference mixed onheap difference happens receiving process side start looking message garbage collecting using onheap message internal message queue considered part rootset garbage collection using mixed message heap fragment part rootset thus copied garbage collector bunch different tradeoff come play trying figure strategy want use using offheap may seem like nice way get scalable system get little contention main lock however allocating heap fragment expensive allocating heap receiving process unlikely contention occur efficient try allocate message directly receiving process heap using onheap force message part young heap increase amount data garbage collector move garbage collection triggered processing large amount message copied young heap turn lead message quickly promoted old heap thus increase size may good bad depending exactly process large old heap mean young heap also larger turn mean le garbage collection triggered processing message queue temporarly increase throughput process cost memory usage however message consumed process enters state lot le message received may long time next fullsweep garbage collection happens message old heap happens onheap potentially faster mode us memory longer time mode legacy mode almost message queue handled erlangotp using mixed mode compromise two potentially efficient onheap may increase contention main lock receiving process compared offheap option may dropped release erlangotp clear brings benefit outside synthetic benchmark one strategy best depends lot process interacts process always profile application see behaves different option also note mode work may change release erlangotp bibliography c j cheney nonrecursive list compacting algorithm commun acm nov ungar generation scavenging nondisruptive high performance storage reclamation algorithm sigsoft softw eng note apr learn erlang solution erlang elixir solution sign mailing list first know future blog post go back blog
380,Lobsters,erlang,Erlang development,Why Erlang Matters,https://sameroom.io/blog/why-erlang-matters/,erlang matter,peter hizalev sameroom smp computer power wall superscalar theoretical concept research commercial application interconnect numa system travel embarrassing parallelism used armbased server significant overhead scale erlang elixir comment hacker news,peter hizalev peter cofounder sameroom chief technical officer repost paper still remember vividly first encounter smp computer around dualsocket pentium pro monster blew mind growing r evolution always curious innerworkings computer hardware first board simple enough could understand every signal line pentium pro machine two processor two set cache ram shared possible keep cache ram sync would someone actually write software incredible beast fastforward two thing happened internet power wall internet ignited renaissance distributed computing often cite operation scale unprecedented preinternet information system actually true handful company really undid traditional information system quickly capacity requirement grow а product hit hockey stick made old system terribly uneconomical seemingly overnight scaleup approach expensive proprietary system replaced scalingout generic consumerlevel kit power wall killed great hope keep scaling singlethreaded performance forever superscalar improvement still cpu designer finally took smp revolution street mid witnessed emergence multisocket pc server multiple core cpu became commonplace way laptop smartphones seemingly independent development idea connecting multiple computer network shared memory year making core theoretical concept behind distributed computing developed continued research commercial application emerging quicklyevolving ethernet made local computer network ubiquitous clientserver architecture became buzzword day distributed system two process talking network sending message message process process b copied memory process travel network wire memory process b seems smp computer problem copying data memory process running different cpu since share memory block thread wrong smp system process b read memory block written process still actual copying going process cpu cache interconnect process b cpu cache cache coherence underthehood copying mechanism try pretend copying happening memory really shared copying get pretty involved running numa system message process b travel multiple hop like network packet would switched data center cpu core place interconnect le look like shared memory like separate networked coherence scale awesome system built different flavor process talking network pretending share memory hardware thread used communication frequent amount shared data substantial networked process used scaling requirement le predictable fault tolerance required application exhibit embarrassing parallelism nicely package computation saturate given smp computer scale speed adding computer unfortunately application rare interactive application represented graph interdependent process waiting io complete make really hard nicely saturate today entrylevel smp computer enter another renaissance virtualization economical efficiency mind would love colocate multiple part application physical computer caveat application may different even conflicting dependency within operating system virtualization offer full isolation running many instance operating system single physical computer mention renaissance utility virtualization well known today mainframe used virtualization extensively decade simply became way powerful run anyone single application made sense economically start virtualizing mainframe still exist largely disrupted minicomputer minicomputer disrupted pc server argue pc server becoming powerful run distributed system economically much like advent pc server era economy scale personal computer made superior previous generation computer today smartphones armbased server tomorrow time speed local networking approaching speed cpu interconnect complexity cpu interconnect approaching switched packet network end new type computer bring datacentersonachip highdensity computing whichever way look abstraction today deal type computer process tcpip network thread shared memory seem like two different way dealing one concurrent workflow arguably antiquated new computer tcpip designed unreliable global network carry significant overhead fast local interconnects shared memory scale large number cpu core really want send message workflow workflow b enter erlang erlang designed group engineer ericsson specifically trying address shortcoming existing language respect handling highlyconcurrent telephony application extreme reliability requirement concurrency meant handling million small process would occasionally communicate reliability meant guarding hardware failure importantly bug program erlang designer made great tradeoff outset immutability single assignment uncommon conventional programming language enforced vm top immutability erlang vm defines lightweight process send receive message enables level isolation much nicer garbage garbage collected independently eliminating need stoptheworld model erlang promotes least amount error handling favor quickly crashing process address error recovery erlang defines concept supervision hierarchy watchdog process whose responsibility restart failed worker process another key builtin construct ability send receive message process vms running connected computer yet another ability hotload code without stopping vm running process would argue erlang execution model well suited run directly future datacenteronachip computer without operating system virtualization immutability remove need cache coherence although signaling inside vm may need one sort specialized hardware erlang vm already map one process scheduler one hardware thread process loadbalanced evenly saturate available cpu core maintain cache locality message precisely memory block shuttled cache switched interconnect supervision tree span hardware topology handle hardware failure software bug great fault tolerance would likely take evolved erlang run computer future may well erlang vm host top enforcing important semantics elixir good candidate may new software altogether erlang matter today demonstrates semantics elegantly packaged one language execution model virtual machine comment hacker news
381,Lobsters,erlang,Erlang development,Making reliable distributed systems in the presence of software errors,http://erlang.org/download/armstrong_thesis_2003.pdf,making reliable distributed system presence software error,,obj length filter flatedecode stream b e sa n endobj obj type page content r resource r mediabox parent r endobj obj type xobject subtype form formtype matrix bbox resource procset pdf extgstate r r length r filter flatedecode stream 玚 f n qk zfd ob u l k x
382,Lobsters,erlang,Erlang development,Lisp Flavoured Erlang 1.0 Released,https://twitter.com/rvirding/status/710259707819249664,lisp flavoured erlang released,,detected javascript disabled browser would like proceed legacy twitter yes
383,Lobsters,erlang,Erlang development,Cloud Haskell: Erlang-style concurrent and distributed programming in Haskell,https://haskell-distributed.github.io/,cloud haskell erlangstyle concurrent distributed programming haskell,get started learn generic network transport api static closure api distributed programming open telecom platform tcp inmemory window azure wiki example hackage recent activity,get started learn build concurrent distributed program cloud haskell learn cloud haskell erlangstyle concurrent distributed programming haskell cloud haskell platform consists generic network transport api library sending static closure remote node rich api distributed programming set platform library modelled erlang open telecom platform generic network transport backends developed tcp inmemory messaging several implementation available including transport window azure wiki provides link number resource learning conceptual underpinnings cloud haskell example documentation available site head hackage current preceding version library recent activity
386,Lobsters,erlang,Erlang development,Erlang Factroy SF 2016 - Keynote - John Hughes - Why Functional Programming Matters,https://www.youtube.com/watch?v=Z35Tt87pIpg,erlang factroy sf keynote john hughes functional programming matter,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature erlang factory sf keynote john hughes functional programming matter youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature erlang factory sf keynote john hughes functional programming matter youtube
387,Lobsters,erlang,Erlang development,When (not!) to use macros in Erlang,https://medium.com/@erszcz/when-not-to-use-macros-in-erlang-1d3f10d377f,use macro erlang,use macro erlang macro erlang simple text level substitution pas macro around function macro accessed module outside defined unless use header file macro shared header file make use even simple namespacing mechanism macro call traced macro introduce scope extra parenthesis needed preserve evaluation order expression macro parameter function call might called predefined macro whose value simply accessible program way get proper line number macro call site reuse existing assertion rely defining macro maintain correct line reporting macro asserting equality proplists composite predicate use guard written macro record syntax allow access record field stored variable name code generation templating single definition attribute escalus,use macro erlangthroughout year writing erlang noticed number us macro source code definitely agree opinion expressed differentlybefore elaborating why nots short recap might new erlang macro look like used bad example explained laterdefine pi define debug format args io format b format file line args area r debug radius pn r pi r rso macro erlang simple text level substitution think c lisp looking comparison language completely expanded preprocessor compiler unaware existence necessary clarify point erlang support lisplike macro operate language abstract syntax tree parse transformation well core transformation operate core erlang used later compiler pipeline completely different topica macro introduced define module attribute requires name pi name along parameter name debug format args conventionally macro name tend cap hard ubiquitous rule use macro prefixing name question mark pi exist predefined macro pretty selfexplanatory name like module line argument macro body expanded text preprocessor oblivious meaning careful operator precedence passing expression macro usual trick place argument parenthesis end erroneous code like define lousy arg arg test lousy error expands would write define quiteuseless arg arg test quiteuseless fortunately trivial case compiler warn u invalid pattern matching warning clause ever match result might luckyok use answer might seem slightly controversial almost never least seldom possiblewhy macro language primitive error prone given choice using higher level usually expressive language macro embedded almost always pick latter apart bit philosophical answer also pragmatic reason first class object pas macro around functionsmacros accessed module outside defined unless use header file cumbersome calling exported function general reusing requires u work lot admit still moreconnected erlang pretty limited namespacing support one flat namespace module name using save u headache name clash macro shared header file make use even simple namespacing mechanismmacros expanded plain code therefore macro call traced using machinery provided erlang vm erlang erlang dbg macro introduce scope ie erlang macro nonhygienic possible mistakenly shadow reuse variable code written outside macro expansion site though thanks singleassignment much problem erlang c worked around begin end block immediately invoked function expression technique make code complex make u look bad eye alberteverything made simple possible simpler albert einsteinas already mentioned extra parenthesis needed preserve evaluation order expression expected macro parameter might also expressionsif macro parameter function call might called macro parameter used multiple time macro body happens function sends message sum choose writing macro something writing function always choose writing function however situation actually express something plain erlang macro rescue previously mentioned predefined macro whose value simply accessible program way example line module filethe line file though arguably le macro indispensable writing assertion error message however sufficient write assertion function reported error line would always function body write assertion macro get proper line number macro call sitesmoreover even reuse existing assertion try add functionality also rely defining macro maintain correct line reporting macro asserting equality proplists assertequal come eunit define proplistseq expected actual fun expected actual assertequal list sort expected list sort actual end expected actual due fact erlang guard expression general call function apart bifs composite predicate use guard written macrosthe record syntax allow access record field stored variable name case composite record structure might convenient use short helper macro access instead multiplelevel deep expression define getinnerdata data key data toplevelrecordnestedfield innerrecordkey thanks go paweł chrząszcz pointing particular use casemacros might useful code generation aka limited form templatingone time might use macro sidestep limitation language order single definition type spec attribute necessary use macro example come escalus xmpp testing library define connectionstep escalusconnection client escalususers userspec feature stepstate type step fun connectionstep spec connectionstepstartstream conn prop feature distill problem write code like spectype syntax flexible enough type myf fun spec myf f instead rely text substitution define myf type myf fun myf spec myff going back example beginning note define pi define debug format args io format b format file line args definition debug format args expressed without using macro though would cleaner remember tracing rewrite define debug format args debug file line format args debug file line format args io format b format file line args pi hand fall category listed macro necessary seems erlang standard library author also followed chain thought constant available default math nullary function use macro really use plain function every case
388,Lobsters,erlang,Erlang development,"Interview with Robert Virding, creator of Lisp Flavored Erlang, an alien technology masterpiece",https://medium.com/this-is-not-a-monad-tutorial/interview-with-robert-virding-creator-lisp-flavored-erlang-an-alien-technology-masterpiece-c37003945c,interview robert virding creator lisp flavored erlang alien technology masterpiece,create lfe lfe philosophy talk called language design said point create new standard library lfe common lisp macro function added lfe clojure macro function also available separate library lfe follows traditional lisp like common lisp scheme modern lisp like clojure lfe flavor lfe object system pretty similar month ago sent email titled new macro handling compiled macro macro system work lfe changing think elixir incorporated idea lfe seen multimethods protocol mentioned time lfe community think clojure multimethods protocol think adding something like transducer lfe would good idea seen discussion dialyzer lfe mailing list dialyzer branch lfe repository well lfe support dialyzer think steel bank common lisp type system typed racket clojure coretyped shen type roadmap lfe,create lfe discovered learnt lisp long started working erlang always loved also like erlang language problem syntax build system goal make lisp real lisp build system erlang way hence lfewhat lfe philosophy lfe proper lisp based feature limitation erlang vm coexists seamlessly vanilla erlang otp run standard erlang vmin talk called language design said people complain erlang library thing complain rightly elang library inconsistent naming convention inconsistent argument ordering inconsistent everything inconsistent correct right people complain point create new standard library lfe would like deep problem trying basically really change library module used otp without effect propagating going viral otp adding new library yes modifying old module really elixir got around special module alias map onto module name elixirxxx end module naming convention preferred keep namescommon lisp macro function added lfe clojure macro function also available separate library lfe follows traditional lisp like common lisp scheme modern lisp like clojure lfe feel cl scheme especially cl like scheme clojure definitely interesting felt way concurrency really map well onto erlang style building system feel different clojure feel like language concurrency erlang feel like operating system languagewhat lfe flavor lfe object system pretty similar flavor object system lisp machine lfe flavor pure fun curiosity long time ago yr implementation flavor another lisp system portable standard lisp curious see would like one lfe worked quite well central part lot lisp machine specific transferred clos based flavor see heritagemy plan lfe flavor bake part lfe supported compatible plugin like keep core simple also plan implement general structs allow control data structure access would subsume record elixir structs amongst thingsa month ago sent email titled new macro handling compiled macro macro system work lfe changing currently macro work defining locally file used need share macro define include file new macro handling allow macro exported module much way function would call way module foo call function foo function macro foo macro making interface much consistent generic us include file disappearwhat think elixir ambivalent speak ruby much syntax feel strange foreign also manages push programming button example multiple way representing thing adding syntax special case feel wrong jealous ability clean otp module writing interface way avoid overlapping module name wonder complexity thing simplicityhave incorporated idea lfe taken idea directly elixir though share feature example multiple module one file sure like practical seen multimethods protocol mentioned time lfe community think clojure multimethods protocol one difficulty something like erlang erlang module must compiled one unit impossible add remove function afterwards without recompiling whole module make difficult method one module different place lessens usefulness multimethods imaoflavors get around compiling component flavor separately building object flavor mixin first instance created allows u create component separately long done first time used modifieddo think adding something like transducer lfe would good idea probably would really way think find tend explicit data type use fundamental choosing algorithm use mean polymorphic transformation function becomes le interesting mei know many people prefer working way see problem adding set standard lfe library integrated lfe lowest level able choosei seen discussion dialyzer lfe mailing list dialyzer branch lfe repository well lfe support dialyzer supporting dialyzer little tricky official interface dialyzer restricted either pas erlang file pas beam file containing erlang ast code compiling debuginfo option work lfe lfe compiler generates core erlang language used internally compilerhowever bit cunning generated alternate dialyzer interface module load core erlang form directly work really experiment better solution would proper fix dialyzer interface simple current interface cleanly coded actually quite ironic dialyzer us core erlang internallywhat think steel bank common lisp type system typed racket clojure coretyped shen type never tried say generally dynamically typed roadmap lfe far roadmap little want add one last feature release anyway plan new macro handling work properly integrated system feel well rounded release
389,Lobsters,erlang,Erlang development,ActorDB: a distributed SQL database with linear scalability,https://github.com/biokoda/actordb,actordb distributed sql database linear scalability,actordb distributed sql database apps actordb kv http wwwactordbcom http gitterimactordb thrift would like contribute adbtthrift learn http wwwactordbcomdocsabouthtml http http http wwwactordbcomdocsconfigurationhtml http githubcombiokodaactordbblobmasterchangesmd client libs http githubcombiokodaactordbclient http githubcomhqioactordbnet build ubuntudebian package http osx package http red hatcentos package http general linux build http window package http,actordb distributed sql database scalability kv store keeping query capability relational database actordb ideal server side database apps think running large mail service dropbox evernote etc require server side storage user data vast majority query within specific user many user server side database get large using actordb keep full relational database every user forced painful scaling strategy require throw away everything make relational database good actordb database hide sharding make explicit keep fully relational chunk ie actor database query even data model easily partitioned actordb powerful kv data type use instead actordb kv type sql table partitioned across server table sub table linked using foreign key run query transaction single actor across number actor actordb run single server many server writing one actor completely independent writes another actor unless participating transaction server added schema updated time database running homepage http wwwactordbcom question use http gitterimactordb actordb distributed relational sql database consistent eventually consistent distributed redundant massively concurrent single point failure acid connectable mysql protocol thrift replicated safely using raft distributed consensus algorithm advantage complete horizontal scalability node equivalent many node need full featured acid database suitable large datasets many actor server special driver needed use mysql driver language choice easy configure administer global lock actor one many involved transaction locked write actor unaffected us stable reliable sql storage engine sqlite top lmdb inherits sqlite feature like json support common table expression would like contribute would like see client library top thrift thrift generated code bit verbose generally much nicer implement interface hide boilerplate code us nicer type also idea thought possible improvement bug report contact u using github issue interested contributing use language choice generate thrift interface using adbtthrift write clean interface list outside contribution learn documentation http wwwactordbcomdocsabouthtml story http sqlite run top lmdb http configure run http wwwactordbcomdocsconfigurationhtml change log http githubcombiokodaactordbblobmasterchangesmd client libs erlang http githubcombiokodaactordbclient net http githubcomhqioactordbnet build ubuntudebian package http osx package http red hatcentos package centos http general linux build http window package http
390,Lobsters,erlang,Erlang development,Erlang : Pi2 ARM cluster vs Xeon VM,https://medium.com/@pieterjan_m/erlang-pi2-arm-cluster-vs-xeon-vm-40871d35d356#.8w5d0mmwi,erlang arm cluster v xeon vm,version francophone french version nederlandstalige versie dutch version tl dr introduction opteron test platform rolling raspberry pi model b raspberry pi cluster devx xeon server test application particular consideration environment comparative performance test testing methodology concept cycle agent multimechanize performance comparison devx influence cluster size like whatsapp folk pure compute test mandelbrot fractal generating function mnesia transaction mode test conclusion keep coming,version francophone french versionnederlandstalige versie dutch versiontl dra low cost energy efficient arm cluster prototype prof could viable alternative traditional platform realworld erlangotp server applicationwhat follows introduction description platform used short word application used compare resulting graphic observation conclusionintroductionthe release amd cpu opteron piqued interest hardware platform become powerful costly need virtualized multiple level computing storage network much layer added complexity order use full make idea using simple lowcost energyefficient hardware particularly refreshingwith right software tool handle loadbalancing failover challenge distributed computing idea become perfectly working prototypetest platformswhile development board using opteron already rolling settled raspberry pi model b cost effective testplatform run server o debian perfectly considering bit cpu one smartphone earlier slower architecture even need thermal dissipation fared pretty welli note application responsiveness absolutely satisfactory raspberry cluster regular use despite platform weakness given test turned almost convinced could handle current production workload without much pi clustersingle raspberry pi specification cpu cortex quad mhz ram slightly overclockedstorage samsung evo microsdcost consumption idle load mbps ethernet whole cluster apache load balancing proxy application cluster cost consumption idle load apache proxy ethernet port also act dhcp dns router nat cluster member cluster running internal networkdevxxeon serverthe face serious computingdevx application development server run vmware virtualized hp bladesystem environment storevirtual iscsi san storage air conditioned room benefit multiple hardware support contract specification vm core xeon gb ramstorage gb iscsiserver blade power consumption included storage air conditioning server blade cost around included support contract storage blade enclosure air conditioning rcp cpu alone server cost consumption adapted number vm running hardware test applicationthe application used comparative realworld server application ejustice platform belgian supreme administrative court based erlangotp run singleagent distributed multipleinstance mode test scenario us standard operation offered application representative real user would act much faster also heavily dependent database mnesia simple compute test addedthe application including database modified slightest besides recompilation run arm instruction set resourcelimited hardware platform fault stresstesting brought light application drowning high number concurrent request already corrected subject another articleparticular consideration application run single erlang node cluster member slow storage unforgiving random read write benchmark respectively slower networking fact db mnesia synchronize cluster member cause experience transaction backlog due overload aggravated slow storagedevx native environment application developed fast storage unforgiving random read write benchmark respectively single agent synchronization instance networking application divided across erlang node mochiweb server application core add latencycomparative performance teststesting methodology concept cycle single cycle involves several serial operation object creation browsing modifying deletion reflects human user might much greater speedagent agent executes cycle cycle successfully executed new cycle started multiple agent executed concurrently started test agent doubling count reaching depending timeout occurrencethe python multimechanize performance test framework used run test generating http query directed target environment webfacing apache proxy full test last second start concurrent agent within second probably favoured devx little performance comparison devxthis direct performance comparison environment one show strength pure cpu speed devx light load load balancing heavy loadwhen single active agent devx fast cpu clear advantage task split cluster member cpu working given time core devx start plateauing load concurrent agent core plateau steadily improving performance way achieving devx performance full load concurrent agent environment start experiencing timeouts query take long execute discarded concurrent agent score start negative mean even first cycle certain agent failed finish provokes negative score due peculiarity testing framework seen approached performance level devx amount cycle agent able perform remains stable longer time devxfrom concurrent agent onwards devx experiencing linear diminution successful cycle halving score doubling concurrent agent show much gradual diminution cycle count get linear concurrent influence cluster sizefor test cluster used line environment fewer cluster member one deactivatedthe fewer cluster member faster application initially due fewer database replication synchronization operation needed past certain load threshold advantage load balancing kick workload distributed among cluster member word application scale increase performance linear double amount cluster member double performance cost database distribution replication known behaviour mnesia taken account like whatsapp folk pure compute testin order show pure computing performance added simple mandelbrot fractal generating function cycle becomes single calculation liberating slow storage medium allowing unleash raw unrestrained maddening processing powermultiple environment configuration shown shown none cluster member deactivated devxundersteroids double core countthe linear performance increase show nicely load shared among cluster member core expected simple calculation outperforms devx concurrent agent active sure due unknown bottleneck testing pc network proxy test run devx using core effectively doubling score bottleneck notice better performance core devx used single agent versus core devx core make devx work faster still ghz difference erlang application spreading load single query core parallel programming make core arm cpu even interesting spread task single query single cluster member cpu different configuration virtually score testing agent true two agent configuration least member almost perfect linear increase performance along core count cluster member show scalable erlang vm nothing new mnesia transaction mode testthis interest erlang user mnesia way mnesia accessed different way without transaction synchronous asynchronous method benefit basically performance v consistency tradeoff experienced error asynchronous mode caused transaction backlog grew large failed keep consistency expected difference synchronous asynchronous mode clearly irrelevant devx cluster member synchronize exhibit expected behaviour performance v reliability tradeoff without added weight transaction synchronicity lightblue able almost reach devx level performance going flame noticeable difference devx dirty operation without transaction transaction table lock rollback case failure db consistency error rate reached asyncdirty asynchronous transaction mode none synchronized mode expected cluster performance hit synchronicity enforced although difference mostly disappears heavy load help avoiding remote node database overload guarantee consistency avoids useless operationsconclusionwith faster storage would certainly fighting chance put traditional virtualized server fraction cost energy usage failed mention test application serial bottleneck parallelized interaction prolog socket server must negative impact cluster performancethe prototype able demonstrate performance even viability modest arm cluster quite confident modern powerful arm chip keep coming serious storage networking capability justify presence server room introducing new era lowcost energy efficient server room depending live even need cooled moreps say go cloud opted storing nonpublic data court proceeding remember cloud
391,Lobsters,erlang,Erlang development,Erlang Scheduler Details and Why It Matters,https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html,erlang scheduler detail matter,erlang garbage collection detail matter scheduling green thread native thread preemptive cooperative erlang scheduling process reduction scheduling run queue scheduling scheduling migration logic controlling monitoring api scheduler thread process priority run queue statistic calculating prime number conclusion caf resource external link,underlying feature make erlang soft realtime platform one garbage collection mechanism talked previous article erlang garbage collection detail matter one scheduling mechanism well worth looking article explain history current status controlling monitoring api scheduling generally speaking scheduling mechanism assigns work worker work could mathematical operation string processing data extraction worker resource could virtual like green thread physical like native thread scheduler carry scheduling activity way maximizes throughput fairness minimizes response time latency scheduling main part multitasking system like operating system virtual machine divided two type preemptive preemptive scheduler context switching among running task power preempt interrupt task resume later time without cooperation preempted task done based factor like priority time slice reduction cooperative cooperative scheduler need task cooperation context switching way scheduler simply let running task voluntarily release control periodically idle start new task wait return control back voluntarily question scheduling mechanism suitable realtime system must response within specified time cooperative scheduling system satisfy realtime system running task system might never return control back return late deadline realtime system commonly use preemptive scheduling erlang scheduling erlang realtime platform multitasking us preemptive scheduling responsibility erlang scheduler selecting process executing code also garbage collection memory management factor selecting process execution based priority level configurable per process priority level process scheduled round robin fashion hand factor preempting process execution based certain number reduction since last time selected execution regardless priority level reduction counter per process normally incremented one function call used preempting process context switching counter process reach maximum number reduction example erlangotp maximum number reduction scheduling task erlang long history changing time change affected change smp symmetric multiprocessing feature erlang scheduling erlang smp support one scheduler run main o process thread accordingly one run queue existed scheduler picked runnable erlang process io task run queue executed erlang vm scheduler task task task task task n run queue way need lock data structure written application take advantage parallelism scheduling smp support added erlang vm could scheduler run one o process thread however version scheduler could pick runnable task one common run queue erlang vm scheduler task task task scheduler task task n scheduler n run queue resulting parallelism method shared data structure protected lock example run queue shared data structure must protected although lock provide performance penalty performance improvement achieved multicore processor system interesting known bottleneck version follows common run queue becomes bottleneck number scheduler increase increasing involved lock ets table also affect mnesia increasing lock conflict many process sending message process process waiting get lock block scheduler however separating run queue per scheduler picked solve bottleneck issue next version scheduling version scheduler run queue decrease number lock conflict system many scheduler many core also improves overall performance erlang vm scheduler run queue scheduler run queue migration logic scheduler n run queue n way locking conflict accessing run queue solved introduces new concern fair process dividing task among run queue one scheduler get overloaded task others idle based order scheduler steal task overloaded scheduler started many scheduler task concern lead erlang team introduce concept making scheduling fair efficient migration logic try control balance run queue based statistic collect system however depend scheduling remain exactly today likely changed future release order get better controlling monitoring api erlang emulator flag well internal controlling monitoring function scheduling behaviour scheduler thread number maximum available scheduler thread online scheduler thread specified passing two colonseperated number flag booting erlang emulator erl start script erl maxavailableschedulers onlineschedulers number maximum available scheduler thread specified boot time fixed run time number online scheduler thread specified changed boot time well run time example start emulator scheduler scheduler online inside shell online scheduler thread changed follows erlang systeminfo scheduler return erlang systeminfo schedulersonline return erlang systemflag schedulersonline return erlang systeminfo schedulersonline return also using sp flag set percentage process priority said scheduler select process execution based priority level priority specified inside process calling erlang function pid spawn fun processflag priority high end priority low normal high max atom default priority level normal max reserved internal use erlang runtime used others run queue statistic explained run queue hold process ready execution picking scheduler possible get count process ready execution available run queue erlang statistic runqueue function real example let boot erlang emulator online scheduler assign heavy cpubound process concurrently process could calculating prime number big number everything clean ready erlang statistic onlineschedulers erlang statistic runqueue spawn heavy number crunching process concurrently spawn fun calc primenumbers end list seq run queue remaining task erlang statistic runqueue erlang still responsive great calc primenumbers wait moment erlang statistic runqueue wait moment erlang statistic runqueue number concurrent process online scheduler take time scheduler execute process run queue make empty interesting thing spawning heavy process erlang emulator still responsive preemptive scheduling let heavy rogue process chew runtime without letting light likely important process execute great feature come implementing realtime system conclusion although implementing preemptive scheduling system could complex case erlang responsibility developer feature inside virtual machine hand extra processing cost tracking balancing selecting executing migrating preempting process totally affordable system need scale processing resource high level fairness also responds timely realtime system way worth mentioning fully preemptive scheduling feature nearly operating system support case high level platform language library claimed erlang virtual machine almost unique jvm thread depend operating system scheduler caf c actor library us cooperative scheduling golang fully preemptive also applies python twisted ruby event machine nodejs mean best option every possible challenge mean need implement realtime system low latency erlang good option resource external link
392,Lobsters,erlang,Erlang development,The Zen of Erlang,http://ferd.ca/the-zen-of-erlang.html,zen erlang,zen erlang vegur,zen erlang loose transcript long paraphrasing presentation given conference organized genetec invited speak assume people never used erlang possibly heard maybe name presentation cover high level concept erlang way may useful work side project even never touch language ever looked erlang heard let crash motto first encounter wondering hell erlang supposed great concurrency fault tolerance told let thing crash entire opposite actually want happen system proposition surprising zen erlang related directly nonetheless way would funny use let crash erlang would use blow rocket science blow probably last thing want rocket science challenger disaster stark reminder look differently rocket whole propulsion mechanism handling dangerous combustible explode risky bit controlled manner used power space travel send payload orbit point really control try see rocket science way properly harness explosion least force want let crash therefore seen light fault tolerance idea uncontrolled failure everywhere instead transform failure exception crash tool use backburning controlled burn real world example fighting fire fire region come blueberry field routinely burnt controlled manner help encourage renew growth prevent forest fire fairly frequent see unhealthy part forest cleaned fire done proper supervision control main objective remove combustible material way actual wildfire propagate situation destructive power fire going crop forest used ensure health crop prevent much larger uncontrolled destruction forested area think let crash embrace failure crash exception wellcontrolled manner stop scary event avoided instead become powerful building block assemble large reliable system question becomes figure ensure crash enablers rather destructors basic game piece erlang process erlang process fully isolated share nothing process go reach another one memory impact work corrupting data operates good mean process dying essentially guaranteed keep issue provides strong fault isolation system erlang process also extremely lightweight thousand thousand without problem idea use many process need rather many common comparison say objectoriented language could object running given time rapidly find overly constraining quite ridiculous build program language many small process ensure higher granularity thing break world want harness power failure good bit weird picture process work exactly write c program one big main function lot stuff entry point program erlang thing process designated master program every one run function function play role main within single process swarm bee probably hard direct strengthen hive communicate way bee dance erlang process pas message message passing intuitive form communication concurrent environment oldest one worked day wrote letter sent via courier horse find destination fancier mechanism like napoleonic semaphore shown slide case take bunch guy tower give message wave flag around pas data long distance way faster horse could tire eventually got replaced telegraph got replaced phone radio fancy technology pas message really far really fast critical aspect message passing especially olden day everything asynchronous message copied one would stand porch day waiting courier come back one suspect would sit semaphore tower waiting response come back send message go back daily activity eventually someone would tell got answer back good party nt respond stuck nothing waiting porch die conversely receiver end communication channel see freshly arrived message vanish change magic die data copied message sent two principle ensure failure communication yield corrupted unrecoverable state erlang implement read message process single mailbox everyone write process mailbox owner look message default read order arrived possible feature pattern matching discussed prior talk day temporarily focus one kind message drive various priority around noticed something mentioned far keep repeating isolation independence great component system allowed die crash without influencing others also mention conversation across many process agent every time two process start conversation create implicit dependency implicit state system bind together process sends message process b b dy without responding either wait forever give conversation latter valid strategy vague one unclear remote end died taking long offband message land mailbox instead erlang give u two mechanism deal monitor link monitor observer creeper decide keep eye process dy whatever reason get message mailbox telling react make decision newly found information process never idea monitor therefore fairly decent observer care state peer link bidirectional setting one bind destiny two process established whenever process dy linked process receive exit signal exit signal turn kill process get really interesting use monitor quickly detect failure use link architectural construct letting tie multiple process together fail unit whenever independent building block start dependency among start codifying program useful prevent system accidentally crashing unstable partial state link tool letting developer ensure end thing fails fails entirely leaf behind clean slate still without impacting component involved exercise slide picked picture mountain climber roped together mountain climber link would sorry state every time climber team would slip rest team would instantly die great way go thing erlang instead let specify process special flagged trapexit option take exit signal sent link transform message let recover fault possibly boot new process work former one unlike mountain climber special process kind prevent peer crashing responsibility peer using try catch expression example process trap exit still way go play another one memory save avoid dying turn critical feature implement supervisor nt heard get soon enough going supervisor still ingredient able successfully cook system leverage crash benefit one related process scheduled one real world use case want refer apollo lunar landing apollo mission went moon slide right see lunar module buzz aldrin neil armstrong board photo taken person assume michael collins stayed command module mission way land moon lunar module guided apollo pgncs primary guidance navigation control system guidance system multiple task running taking carefully accounted number cycle nasa also specified processor used capacity leaving free astronaut case wanted decent backup plan case needed abort left rendezvous radar case would come handy took decent chunk capacity cpu left buzz aldrin started entering command error message would pop overflow basically going capacity system going haywire possibly could nt job could end two dead astronaut mostly radar known hardware bug causing frequency mismatched guidance computer caused steal far cycle otherwise nasa people nt idiot reused component knew rare bug rather greenfielding new tech critical mission importantly devised priority scheduling meant even case either radar possibly command entered overloading processor priority low compared absolutely lifecritical stuff task would get killed give cpu cycle really really needed today still plenty language framework give cooperative scheduling nothing else erlang language use lifecritical system respect softreal time constraint hard real time one would nt good idea use scenario erlang provide preemptive scheduling process priority mean care developer system designer making sure absolutely everyone carefully count cpu usage going across component including library use ensure nt stall system wo nt capacity need important task always run must also get may seem like big common requirement people still ship really successful project cooperative scheduling concurrent task certainly extremely valuable protects mistake others also mistake also open door mechanism like automated loadbalancing punishing rewarding good bad process giving higher priority lot work waiting thing end giving system fairly adaptive production load unforeseen event last ingredient want discus getting decent fault tolerance network awareness system develop need stay long period time one computer run quickly becomes prerequisite nt want sitting golden machine locked behind titanium door unable tolerate disruption effecting user major way eventually need two computer one survive broken maybe third one want deploy broken computer part system plane slide twin mustang aircraft designed second world war escort bomber range fighter could nt cover two cockpit pilot could take relay time tired point also fit one would pilot would operate radar interceptor role modern aircraft still something similar countless failovers often crew member sleeping transit flight time make sure always someone alert ready pilot plane come programming language development environment designed ignoring distribution altogether even though people know write server stack need one server yet gon na use file gon na stuff standard library furthest language go giving socket library http client erlang acknowledges reality distribution give implementation documented transparent let people set fancy logic failing taking application crash provide fault tolerance even let language pretend erlang node build polyglot system basic ingredient recipe erlang zen whole language built purpose taking crash failure making manageable becomes possible use tool let crash start making sense principle seen part thing reused inspiration nonerlang system compose together next challenge supervision tree impose structure erlang program start simple concept supervisor whose job start process look restart fail way supervisor one core component otp general development framework used name erlangotp objective create hierarchy important stuff must solid accumulate closer root tree fickle stuff moving part accumulate leaf tree fact tree look like real life leaf mobile lot fall autumn tree stay alive mean structure erlang program everything feel fragile allowed fail move deeper hierarchy stable critical need reliable higher supervisor usage link trapping exit job begin starting child order depthfirst left right child fully started go back level start next one child automatically linked whenever child dy one three strategy chosen first one slide one one enacted replacing child process died strategy use whenever child supervisor independent second strategy one one used child depend dy supervisor kill child starting back would use losing specific child would leave process uncertain state let imagine conversation three process end vote one process dy vote possible programmed code handle replacing dead process new one would bring new peer table idea going either inconsistent state possibly dangerous nt really defined go process wreaks havoc voting procedure probably safer kill process start afresh known stable state limiting scope error better crash early suddenly slowly corrupt data longterm basis last strategy happens whenever dependency process according booting order name rest one child process dy booted killed process restarted expected supervisor additionally configurable control tolerance level supervisor may tolerate failure per day aborting others may tolerate per second comment usually come right mention supervisor usually tune configuration file corrupted restarting wo nt fix anything entirely right reason restarting work due nature bug encountered production system discus refer term bohrbug heisenbug coined jim gray recommend read many jim gray paper pretty much great basically bohrbug bug solid observable easily repeatable tend fairly simple reason heisenbugs contrast unreliable behaviour manifest certain condition may possibly hidden simple act trying observe example concurrency bug notorious disappearing using debugger may force every operation system serialised heisenbugs nasty bug happen thousand million billion trillion time know someone working figuring one see print page code go town bunch marker term defined let look frequency classifying bohrbugs repeatable heisenbugs transient bohrbugs system core feature usually easy find reaching production virtue repeatable often critical path encounter sooner later fix shipping happen secondary le used feature far hit miss affair everyone admits fixing bug piece software uphill battle diminishing return weeding little imperfection take proportionally time go usually secondary feature tend gather le attention either fewer customer use impact satisfaction le important maybe scheduled later slipping timeline end deprioritising work case somewhat easy find wo nt spend time resource heisenbugs pretty much impossible find development fancy technique like formal proof model checking exhaustive testing propertybased testing may increase likelihood uncovering depending mean used frankly u use unless task hand extremely critical billion issue requires quite lot test validation uncover chance seen wo nt able generate luck next connection want make regarding frequency type bug production experience obvious proof connection use finding bug incidence production system gut feeling would tell connection exist first easy repeatable bug core feature make production essentially shipped broken product amount restarting support help user require modifying code may result deeply entrenched issue within organisation produced repeatable bug sidefeatures pretty often make production think result taking time test properly also strong possibility secondary feature often get left behind come partial refactorings people behind design fully consider whether feature coherently fit rest system hand transient bug show damn time jim gray coined term reported bug noted given set customer site one bohrbug error encountered production tended heisenbugs hard catch truly statistical bug may show million time take load system trigger time billion bug show every hour system request second million bug could similarly show every second system occurrence would still rare test lot bug lot failure handled properly really efficient restarting strategy well repeatable bug core feature restarting useless repeatable bug le frequently used code path depends feature thing important small amount user restarting wo nt much sidefeature used everyone degree nt care much restarting ignoring failure altogether work well example facebook poke feature broken would still exist many user would notice see experience ruined failure transient bug though restarting extremely effective tend majority bug meet live hard reproduce showing often dependent specific circumstance interleavings bit state system appearance tends small fraction operation restarting tends make disappear altogether rolling back known stable state trying unlikely hit weird context cause like could catastrophe become little hiccup system something user quickly learn live make use logging tracing variety introspection tool come box erlang later find understand fix issue stop happening could decide tolerate effort required fix issue large question asked forum discussing programming stuff discussing erlang model copied verbatim great example question lot people ask hear restarting erlang feature want address specifically giving realistic example system could designed erlang highlight peculiarity supervisor rounded square start creating deep hierarchy process system election two tree tally tree live report tree tally tree take care counting storing result live report tree letting people connect see result order child defined live report run tally tree booted functional district subtree counting result per district wo nt run unless storage layer available storage cache booted storage worker pool would connect database operational supervision strategy mentioned earlier let u encode requirement program structure still respected run time boot time example tally supervisor may using one one strategy meaning district individually fail without effecting count contrast district quebec ontario supervisor could employing rest one strategy strategy could therefore ensure ocr process always send detected vote count worker crash often without impacting hand count worker unable keep store state demise interrupt ocr procedure ensuring nothing break ocr process could monitoring code written c standalone agent linked would isolate fault c code vm better isolation parallelisation another thing point supervisor configurable tolerance failure district supervisor might tolerant deal failure minute whereas storage layer could fairly intolerant failure expected correct shut permanently crash hour wanted program critical feature closer root tree unmoving solid unimpacted sibling demise failure impact everyone else leaf work lost fairly well absorbed data operated photosynthesis allowed go towards core defining isolate risky code worker high tolerance process monitored move data stabler process information matures system ocr code c dangerous fail safely restarted work transmits information erlang ocr process process validation maybe crash maybe information solid move count process whose job maintain simple state eventually flush state database via storage subtree safely independent ocr process dy get restarted dy often take supervisor bit subtree restarted without affecting rest system fix thing great process repeated upwards work whole system taken something clearly wrong ca nt cope restarts enormous value structuring system way error handling baked structure mean stop writing outrageously defensive code edge node something go wrong let someone else program structure dictate react know handle error fine specific error otherwise let crash tends transform code slowly notice longer contains ton ifelse switch trycatch expression instead contains legible code explaining code everything go right stop containing many form second guessing software becomes much readable taking step back looking program structure may fact find subtrees encircled yellow seem mostly independent term dependency mostly logical reporting system need storage layer query example would also great could example swap storage implementation use independently system could neat isolate live report system different node start providing alternative mean sm example need find way break subtrees turn logical unit compose reuse together otherwise configure restart develop independently otp application erlang us solution otp application pretty much code construct subtree along metadata metadata contains basic stuff like version number description app also way specify dependency application useful let keep storage app independent rest system still encode tally app need run keep information encoded system built independent block easier reason fact otp application people consider library erlang code base nt otp application nt reusable system sidenote way specify otp library actually contain subtrees module reused library done erlang system following property defined critical survival system allowed fail frequency longer sustainable software boot according guarantee order software fail meaning defines legal state partial failure find roll back known stable state happens software upgraded upgraded live based supervision structure component interdepend extremely valuable valuable forcing every developer think term early le defensive code bad thing happen system keep running go look log introspect live system state take time fix thing feel worth time done able sleep night right hopefully yes included small pixelated diagram new software deploy ran heroku couple year ago leftmost side diagram around september time new proxying layer vegur production maybe month ironed kink user problem transition going smoothly new feature used point team member got expensive credit card bill logging service using aggregate exception took look saw horror leftmost side diagram generating exception day holy cow lot issue heisenbug system seeing say request second odds happening something somewhat frequent impact service nt notice bandwidth storage bill came took u short figure error fixed see still low rate exception maybe dozen thousand day thing know impactfree two year later nt bothered fix system work fine despite time ca nt always sleep night failure control despite best design effort couple year ago flight vancouver starting descent pilot used intercom tell u something bit like captain speaking landing shortly alarmed stay tarmac minute fire department look plane lost hydraulic component want ensure risk fire two backup system broken one fine fine case airplane amazingly well designed image slide nt flight though another one two week ago eastern u burrowed inch snow plane flight united sure reliable landed runway came time break though made loud noise assume ab equivalent aircraft still kept going ran red light end runway see picture end tarmac plane skid runway missed onramp front wheel ended grass everyone fine example great engineering save day every time fact operation always remain huge factor successful system deployed slide heavily inspired pretty much stolen fact presentation richard cook nt know urge go watch video talk youtube pretty much fantastic proper system architecture development practice still replace broken inadequate operation efficiency usefulness tool playbook monitoring automation tend implicitly rely knowledge respect welldefined operating condition throughput load overload management etc defined operational limit let know thing go bad good problem limit operator get used get used frequently breaking without negative consequence risk slowly pushing envelope towards edge danger zone nasty largescale failure happen reaction time margin adapt higher load erodes eventually end position thing constantly broken respite sight careful aware kind thing importance people using operating software always harder scale good team scale program plan emergency even nt happen day happy ran simulation recipe follow fix case flight said nobody injured still circus deployed bus escort passenger back terminal since moving stranded plane could risky pickup truck escort bus safely runway terminal police car whole lot fire truck black car nt know sure super useful deploy despite everyone fine despite plane super reliable thing right another bunch thing gain using erlang nt really much say tend kind interest switching use last point worth commenting though one risk happen language flexible approach system design library use may want thing way feel would appropriate case left either using lib operate codebases incoherent design nt happen erlang everyone us proven approach thing nutshell zen erlang let crash really figuring component interact figuring critical state saved kept recomputed lost case come worstcase scenario survive using failfast mechanism isolation link monitor supervisor give boundary worstcase scenario scale propagation make really wellunderstood regular failure case sound simple surprisingly good feel wellunderstood regular failure case viable error handling fallthrough case longer need worry write defensive code write code let program structure dictate rest let crash zen erlang building interaction first making sure worst happen still okay fault failure system make nervous happens introspect everything run time sit back relax
393,Lobsters,erlang,Erlang development,How to build stable systems — An incomplete opinionated guide.,https://medium.com/@jlouis666/how-to-build-stable-systems-6fe9dcf32fc4,build stable system incomplete opinionated guide,build stable system incomplete opinionated guide preparation process people system planning factor app setup development picking database jepsen picking programming language configuration operation,build stable incomplete opinionated guidepreparationthe first decision easily important one ideology developer control software way around manager control software product owner control software developer people control software write itthe second decision small unit work control better solve minuscule subset full problem space first get deployed production large project die use initial small unit work ruthless test bed later explorationit responsibility developer always control software staple everything else measured bug occur dictate work schedule developer fix deadline draw close dictate work schedule developer software quality finish thus deadline hit deploy part software control fully roll back thing tany change software made succinctly quickly move system one stable point next err side fewer thing well mistake deployed alter production data make prohibitely expensive fix worst case rewrite year worth data wasted timethe software written series project project small selfcontained known point done people project project never longer month time every project win condition success criterion make project able worka project start small seed hour concentrated work lay core kernel rest project prototype viability system whole seed fails project aborted try new knowledge everything simplified cut seed kernel goal show feasability project whole make everyone confident projecta project usually single gamble something never done high riskreward gamble picking new programming language gamble using new framework gamble using new way deploy application gamble control risk knowing gambled stable part software prepared reroll mulligan gamble come unfavorablyevery project start list thing solve project many thing list sound desirable limiting scope help build needed focus define future extension project put separate project later onknow position project infrastructure component close core requires testing slower development attention error know general level testing business none aim getting smoketests place component adding test test core component leaf componentsknow experiment whole project experiment mike williamsmake experiment carry small analysis starting project proper flag analysis preplanning work real project tell everyone r right solutionknow code quality part interact guard look bad apisknow data quality data interact data requires several pass laundromat use chance project abandoned data cleanany project top existing system need transition plan gradually get current point new system big bang deployment tend associated lot risk good reason gamble wellestablished setting understand data source going updated gradually slide one data source next connecting multiple data source ondemand porting definitely optionthe developer always controlprocess peopleyou pick part agilexpscrumkanbanthisyearsfad work team kill everything elsedevelopment digital people working home efficient people working office avoid method require physical presence office thank year everyone hire world company office india germany sfprefer asynchronous communication email irc slack avoids interruption make easier catch later create hiding spot office people want work undisturbed managerdroids disturb themnot everyone drink coffee respect people different people love pair programming solving thing keyboard people tire interaction know different people team like work code basehours chair front keyboard equate hour productivity many solution come away keyboard flexibility work hour work place must productive people brilliant people offswitch brain flip leave work hold single parent three triathlonzealotin team individual member make mistake let learn mistake get solving problemsystem planningthe system built production system built toy accidentally throw fence put production later system built production consumption think configure system production think external dependency limit make system easy operate maintainyou build system factor appyour system flat set module loose coupling module one responsibility manages rest software module communicate loosely via protocol mean party communication changed long still speak protocol way design protocol future extension design module independence design module could ripped placed another system still workavoid deep dependency hierarchy breed tight coupling avoid monstermodules break apart avoid mess microscopic module well always remember power copying function thus breaking dependency fewer dependency time winin communication chain end point intelligence intermediary pas data exploit parametricity mulitple level build system opaque blob data accepted passed avoid intermediary parsing interpreting data code data change time parametric data simplifies changeyou supervisionrestart strategy write erlang already write erlang build scaffolding either inside application fine granularity via operating system coarse granularity system prefer ratcheting method via idempotence known stable state system attempt ratchet next step computation succeeds verify consistency stabilize step failure abort try essentially system stateless computation stateful ratchet flank especially important besteffort delivery mechanism distributed system unique id message mean always retry said message case timeout sure rerun receiving system receiver keep log already doneconstruct system always catch point time avoids building system separate mode online processing offline catching duplicating complicating code pathfollow unix principle tool one thing well avoid temptation add functionality build sibling tool insteaddefine capacity system front amount load targeting normal engineered operation load peak system operate nominally setupfirst build empty project add empty project continuous integration deploy empty project staging new project user also make deploy directly machine production setup line work start building application need arise add necessary configuration deployment chain wellcontinuous integration produce artifact artifact built code selfcontained fashion reliance host environment save simple setup seek preconfigure system need external dependency deploying save fiery situation later artifact deployed staging production pick context environment context configures configuration file disk consul etcd dns one downloaded err simple side use advanced technology early onthe artifact reproducible lock dependency specific tagsversions make upgrading dependency decision part aim build reproducible vendor everything control outside factor making sudden change application use messing buildthe artifact contains everything running software either binary directory tree containing binary binary statically linked go binary ocaml binary haskell ghc binary erlangelixir release good example artifact artifact also packed deployment information read deployment system usingtry make production deploy take le minute buttonpushtooperationalonthefirstinstancebuild default library include every application write library contains debuggingtracing utility tool gathering exporting metric way application become bot chat network let every application use librarydevelopmentcorrectness important fastelegant important fastcode quality important fastfast really importantthere goodenough point define starting optimize beyond point software fast fast part often separable mundane partsmeasure optimization algorithm data structure know change desired impactbuild system collect metric run ship metric central point analysis read gil tene work hdrhistogram use tool timeuse dirty trick respect tooling sleeve unit test property based test type system static analysis profiling really reason avoid tool help alleviate bug early late bug exponentially expensive remove chance altering production datathe software built run multiple different environment preferably unix embrace diverse culture landscape run change time lockdown specific platform often problemif ever run window screwed locked single vendor live die quality toolingdiscussions code formatting mostly pointless one defines standard haphazardly everyone follow suit go everyone run go fmt instance discussion overunderstand error kernel system part absolutely correct part lenient correctness separate error kernel isolate focus testing effort accordinglyuse load regulation border system order avoid overload situation regulate load inside reject work much going better give service select fail giving service everyoneuse circuit breaker break cascading dependency failure also indispensable maintenance needed since manually trippedpicking databaseed default text editor postgresql default databaseunless dataset terabyte pick postgresql need mongodblike functionality create jsonb column learn data postgres move learned postgres authoritative storage export elasticsearch postgres preheat data store postgres load increase run read replica postgres use pgbouncermost new database give dubious consistency security guarantee especially immature variant work call maybe fashion may accidentally fail store data particularly true network partition distributed database consult latest finding kyle kingsbury jepsen project use guide needed guaranteesmany newcomer database market narrow performance profile work well within narrow band use fail miserably try use outside narrow band put loadpressure handlebe vary start using complex transactional behavior make hard move away database design long run especially need distributed operation isolate complex transactional interaction part store usually money look idempotent ratcheting method alternative possiblepicking programming languageto get robust system pick erlang somewhere inside system language support robustness principle needed stable operationif pick erlang reimplement idea erlang avoid monoculture code written c java mean project able easily project become incredibly hard try healthy mix different language offer varying tradeoff maximizes chance picking language fare well problem spaceknow weakness language python well suited massive concurrency erlang work problem requiring raw computational power ocaml immature parallel execution story go fare well problem need good abstraction capability complex failure modesa language succeed way automatically deploy ease deployment tooling must place useall project language notwithstanding use tool configuring building make make call given language choice build tool common language continuous integration deployment make use make target project organization make easy onboard new people replay work ci tool also document build softwareconfigurationthe artifact come default configuration everything need different picked context prefer factor apps pick configuration environment variable persistent data life outside artifact path dedicated disk dedicated quota application log default location never log constant amount disk space predetermined rotation set upthe artifact path writable applicationuse different credential production staging avoids misconfiguration isolate network staging production staging deploy kill production environment deny developer laptop easy access production environment make jump hoopsavoid temptation early etcdconsulchubby setup unless large need fully dynamic configuration system file downloaded boot suffice many casesoperationsoptimize sleep system must avoid waking people middle night cost operation well developersthe system must able gracefully degrade perception partially degraded system often work whereas perception nonresponsive system failed use avoid waking people middle nightthe system run monit supervise upstart systemd rcng smf like never run tmuxscreen operating system gracefully restarts failing application giving upconsider using split stack software away system stack avoids work old software make easier move stack machine typesit always safe kill application control event amazon decides ward destroy rack randomly application must gracefully stop start given command booting active request option time must spent make work gracefully stopping internal part opposite order starteddevelopers usually never log production host every log file shipped indexed outside system every interesting metric developer work staging host enough information shipped reconstruct error without production access timemetrics often show failure occur oddoneout customer abuse system certain weird way often everyone use system line understand system spike around particular customer make fault handling proactive venture load increase extreme value become commonthe way make change production host redeploy way make change staging host redeploythe world elastic spinning new machine jail zone cheap use operation rebuild data center flip switch load balancer make easy roll back downgrade deployment gradually switch traffic new code high risk see fare letting take full load overprovision machine around risky deployment fix problem scale later software operates better wayit tempting handle production deployment error rolling forward time risk spinning control always way take step back want deploy production many time day group stable host hand rollbackdocker mature feb avoid production matures currently docker time sink fulfilling promise change time know adopt
394,Lobsters,erlang,Erlang development,Testing an Erlang Backend,http://www.slideshare.net/enriquepazperez/testing-an-erlang-backend,testing erlang backend,user agreement privacy policy privacy policy user agreement,slideshare us cooky improve functionality performance provide relevant advertising continue browsing site agree use cooky website see user agreement privacy policy slideshare us cooky improve functionality performance provide relevant advertising continue browsing site agree use cooky website see privacy policy user agreement detail
396,Lobsters,erlang,Erlang development,Rabbitmq Internals,https://github.com/rabbitmq/internals,rabbitmq internals,rabbitmq internals purpose guide basic publish guide basic publish deliver queue guide deliver queue queue message store queue message store variable queue guide backing queue module variable queue mandatory message publisher confirm guide deliver queue authentication authorization basic publish authorization authentication backends internal event subsystem internal event management plugin metric management plugin maturity completeness license creative common attributionsharealike unported,rabbitmq internals project aim explain rabbitmq work internally goal make easier contribute newcomer project time common repository knowledge shared across project contributor purpose interesting module rabbitmq project documentation essay sometimes quite extensive top aim duplicate provide highestlevel overview overall architecture guide order understand rabbitmq internals work better try follow logic message progress rabbitmq handled broker otherwise would end navigating many guide without clear context going without knowing read next therefore prepared following guide help understand rabbitmq work basic publish guide follow life message since received network routed exchange take look various processing step happen message right delivered one perhaps many queue basic publish deliver queue guide message routed broker need deliver message respective queue message sent queue also mandatory message publisher confirms need taken account also queue need try deliver message prospective consumer otherwise message end queued deliver queue queue message store provides overview erlang process back queue interact message store message index queue message store variable queue guide ultimately message end queued backing queue retrieved acked purged common implementation backing queue behaviour rabbitvariablequeue module explained following guide variable queue mandatory message publisher confirm guide explained deliver queue guide channel handle message published mandatory also take care publisher confirms process explained following guide authentication authorization explained basic publish rule see message accepted broker certain publisher explained following guide authorization authentication backends internal event subsystem case component running node communicate via event event consumed node internal event management plugin architectural overview version management plugin metric management plugin maturity completeness guide complete nt edited work progress general find wanting detail check code first license c pivotal software inc released creative common attributionsharealike unported license
398,Lobsters,erlang,Erlang development,How to analyze a BEAM (Erlang VM) core dump,https://www.erlang-solutions.com/blog/how-to-analyse-a-beam-core-dump.html,analyze beam erlang vm core dump,analyse beam core dump analyse beam core dump introduction story one core dump mongooseim starting gdb pointer point beam gdb macro macro erlang process stacktrace wombatoam opcodes register stack documentation solution google fixed summary acknowledgment lukas larsson simon zelazny go back blog,analyse beam core dump rafal studnicki analyse beam core dump tl dr relatively easy debug erlang system connecting erlang vm gdb see example click introduction ever happened erlang system running long time sudden beam process disappears one node o log see process killed segmentation fault besides nothing obviously prepared scenario core dump crashed process generated definitely happened many time even start without enabling core dump operating system setting ulimit c unlimited waiting long segmentation fault occur ended precious corexxx file next story one core dump section going describe example analysis core dump file generated loadtesting mongooseim fact first core dump analysis ever done suprisingly successful beginner luck prior knowledge gdb necessary still understand calling function work using stack pointer roughly erlang term built internally starting gdb let assume generated core dump file named gdb started simply pointing beam executable generated core dump file core dump file also useful pas directory source vm version c level output comprehensible gdb core gdb tell u caused crash code happened program terminated signal segmentation fault dominor val ptr see segmentation fault happened piece code belongs garbage collector gdb told u exactly function happened argument called line reponsible see clearly function tried dereference invalid pointer ptr pointer point considering used one command already know lot need answer question pointer corrupted let start basic gdb command backtrace print current stacktrace chatty version backtrace full also exists print value local variable function output gdb backtrace dominor minorcollection recl synthetic pointer ertsgarbagecollect processmain schedthreadfunc thrwrapper startthread clone unfortunately helpful positive note actually confirmed garbage collection triggered inside erlang process thing went bad beam gdb macro could print similar thing beam c code standpoint erlang process caused crash turn possible thanks set macro available erlang vm source code allow dump stack heap message queue inspect erlang term memory many inside gdb session load like gdb source system information otp release ert version compile date thu jan arch endianess little word size halfword hipe support smp support yes thread support yes kernel poll supported used debug compiled lock checking lock counting node name mongooseim localhost number scheduler number asyncthreads gdb print basic information erlang vm architecture good sign use macro file analyze core dump let first try find address dereferenced learn another useful feature gdb access local global variable like remember variable vm try dereference failed let try print value gdb print ptr optimized pity seems access particular variable since optimized compiler let take look near line maybe possible workaround issue infer value variable manually c file see something like case tagprimaryboxed ptr boxedval gval val ptr trying gdb print gval much better gval let present value hexadecimal number take look boxedval macro see simply subtracts argument case output therefore manually deduced value ptr two least significant bit pointer value exist tag boxed erlang term might tuple bignum something else moment need know definitely list erlang process stacktrace let try find ptr value mean start fetching information guilty process p pointer process struct local variable dominor function remember use gdb etpprocessinfo p pid state trappingexit garbagecollecting running active prqprionormal usrprionormal actprionormal cp cp iolibformat cp erlang heap size oldheap size mbuf size msgq len parent pointer process look almost like call erlang bif also see currently executed instruction continuation pointer let extend knowledge printing full callstack gdb etpstacktrace p stacktrace cp iolibformat cp iolibformat cp iolibformat cp iolib cp wombatplugincodetracer cp wombatplugin cp genserver cp genserver cp proclib cp terminate process normally stacktrace tell guilty process genserver process callback implemented wombatplugin module since generic module wombat plugins particular module implemented thewombatplugincodetracer module forgotten mention mongooseim question monitored wombatoam let also print full stack whole stackframes function gdb etpstackdump p stackdump cp iolibformat cp iolibformat cp iolibformat cp iolib cp wombatplugincodetracer portop procsig access memory address oops look like corrupted term present stack moreover match address ptr variable full picture let use macro try prettyprint term see full process stack gdb etpfstackdump p stackdump cp iolibformat cp iolibformat cp iolibformat cp iolib cp wombatplugincodetracer etpfcons corrupted etpfcons catch cp wombatplugin etpfcons etpfboxed cp genserver etpfboxed catch cp genserver catch cp proclib wombatplugin etpfboxed etpfboxed cp terminate process normally catch opcodes register stack erlang beam file compiler output erl file generate humanreadable form moment consists function exported local anonymous function defined module code erlang assembly simple term erlang assembler code consists lowlevel operation see instruction understood erlang vm besides instruction label assembler interpreter also us register proper control erlang process flow used call function argument stored register function call result always stored register code reference register since term need survive function call stack used memorize code reference stack element element first element top accessible code stack interpreter also need keep track instruction pointer ip currently executed instruction module continuation pointer cp point code executed returning currently executed function erlang function realizes actually compiler call another function non tailrecursive way allocates space stack executing allocate instruction order migrate term need survive call also save current value cp top stack whole stack accessible assembly code cp value replaced address current function next instruction instruction call family let explain example execution simple module max b c max max b c max b b max b b simplified assembly code execution max call explained following slide state register pointer shown particular instruction executed dumped stack relevant part convenient form stackframes separated look like stack element reffunction frame belongs top cp iolibformat cp cp iolibformat cp iolibformat cp cp iolibformat cp iolib cp cp iolibformat cp wombatplugincodetracer cp cp iolib etpfcons corrupted etpfcons catch bottom order find corrupted term need dive assembly code iolib generate humanfriendly erlang assembly following command erlc libstdlibsrcioliberl otp source directory assembly module look like snippet end call iolibformat fwrite function know sure return function format line location ioliberl funcinfo atom iolib atom format catch move move line location ioliberl extfunc iolibformat tell stack slot occupied originally cell line snippet second argument function moved top stack since inside iolib function fact data format string function called wombatplugincodetracer like taken wombat code iolib format p subject info p info subjectinfo subject know yet message originated call since wombat code many clause match different message let recall corrupted term looked like portop procsig access memory address turn term generated port long schedule notification documentation thus corrupted term result call case port result call erlang wombat code subjectinfo subject isport subject erlang portinfo subject well done found exactly call corrupts memory inside erlang vm solution something wrong erlang function let move source code first let use google check pure luck someone else already noticed issue function luckily enough race condition function recently fixed migrating erlangotp segmentation fault happen admit heck beginner luck trouble reproducing segmentation fault still want debug system gdb level generate core dump process currently running using gcore command alternatively attach gdb currently running process play keep mind freeze beam duration whole gdb session thing timer affected resuming process hand want learn part erlang vm covered builtin macro still create required dig beam c codebase order learn c structure field going access variable need decode see example attaching running beam fetching information using custom macro project needed verify somehow timer inside erlang vm synchronizing find existing function help decided write gdb macro summary gdb set macro shipped erlang vm really useful postmortem analysis debugging running system although knowledge beam internals required task learn lot experimenting currently existing macro implementing acknowledgment many thanks help first core dump analysis go lukas larsson simon zelazny go back blog
399,Lobsters,erlang,Erlang development,Hot-code burn marks,http://blog.ikura.co/posts/hot-code-burn-marks.html,hotcode burn mark,search ideal co web address,search ideal co web addressget gone
401,Lobsters,erlang,Erlang development,On Erlang's Syntax,http://ferd.ca/on-erlang-s-syntax.html,erlang syntax,erlang syntax learn erlang template english sentence done conclusion,erlang syntax first planned release text appendix entry learn erlang considering feel like editorial content exactly something reference text decided would fit better blog post many newcomer erlang manage understand syntax program around without ever getting used read heard many complaint regarding syntax ant turd token subjectively funny way refer annoying etc mentioned point book erlang draw syntax prolog give reason current state thing nt magically make people like syntax mean nt expect anyone respond saying oh prolog get make complete sense suggest three way read erlang code possibly make easier understand template template way personal favorite understand one must first get rid concept line code think expression expression bit erlang code return something shell period end expression writing must add period press enter expression ran return value module period end form form module attribute function declaration form expression nt return anything terminated different manner everything else given form expression could argued shell use terminate expression standard consequently suggest caring shell method reading erlang alright first rule comma separate expression easy enough however noted end case end begin end fun end try catch end expression example possible var x valid x invalid end get single value end explains sometimes see language construct followed comma mean another expression evaluate second rule semicolon two role first one separating different function clause fac fac n n fac second one separating different branch expression like end case end others x negative x positive x zero end probably confusing role last branch expression nt need semicolon following separate branch nt terminate think expression line people find easier illustrate role separator writing expression following way arguably readable x negative x positive x zero end make role separator explicit go branch clause semicolon used separate expression branch function clause becomes possible expression case construct followed followed another expression last position function clause last position function linebased logic terminating line c java must go window instead see code generic template fill hence name template args guard expressionn args guard expressionn headn args guard expressionn rule make sense need get different reading mode heavy lifting need done moving line block towards predefined template mean think thing like int x even weird syntax compared construct language supporting used see construct nt mind anymore english sentence although manner one like realize different people different way make sense logical concept one manner heard praised many time one comparing erlang code english imagine writing list thing well nt imagine read need item trip sunny sunscreen water hat rainy umbrella raincoat windy kite shirt erlang translation remain bit similar tripitems sunny sunscreen water hat tripitems rainy umbrella raincoat tripitems windy kite shirt replace item expression expression end seen nested list done another variant one suggested erlang user simply read done function declaration read series nested logical statement affirmation conclusion people never like ant turd token unable swap line code without changing token end line guess much done come style preference still hope text might useful syntax intimidating far difficult
402,Lobsters,erlang,Erlang development,Comparing Elixir and Erlang variables,http://blog.plataformatec.com.br/2016/01/comparing-elixir-and-erlang-variables/,comparing elixir erlang variable,case numbered variable summing,sometimes erlang programmer worried elixir variable may source hidden bug article discus concern show variable erlang produce related hidden bug eliminated elixir start short disclaimer elixir mutable variable rebinding mutability often associated storage elixir value stored changed erlang example mutable variable could look f f explicitly using mutable keyword eg let mutable x would allow u change value inside inner loop equivalent list comprehension inside enummap observe change loop mutability possible elixir erlang without using explicit storage like process ets back track article explore potential hidden bug changing code bug exist erlang elixir variable provide implicit behaviour elixir rebinds implicitly erlang pattern match implicitly bug may show developer add remove variable without mindful context let see example imagine following elixir code foobar code usefoobar foobar happens introduce foobar snippet foobar newly added line foobar code usefoobar foobar code would work fine compiler would even warn newly added foobar unused would happen however new line introduced foobar definition foobar code foobar newly added line usefoobar foobar semantics may potentially changed wanted usefoobar use first foobar variable indeed careless change may cause bug let check erlang given code foobar code usefoobar foobar happens introduce foobar definition foobar newly added line foobar old line error code usefoobar foobar erlang code crash runtime instead silently continuing certainly improvement still mean introducing variable erlang requires u certify variable matched later foobar longer assigned matched happens introduce definition foobar code foobar newly added line error usefoobar foobar time new line crash word due implicit matching erlang need worry code introducing variable also need mindful code introducing previous code cause future variable become implicit match word far elixir requires mindful later code introduction variable erlang requires know previous code introduction variable one benefit erlang far code may crash explicitly match however thing get complicated considering case expression case let say want match new value inside case elixir would write case someexpr ok safevalue performsomethingsafe performsomethingunsafe end would happen accidentally introduce safevalue variable elixir case statement safevalue newly added line code case someexpr ok safevalue performsomethingsafe performsomethingunsafe end nothing code work fine due rebinding let see happens erlang case someexpr ok safevalue performsomethingsafe performsomethingunsafe end happens introduce variable safevalue newly added line code case someexpr ok safevalue performsomethingsafe performsomethingunsafe end silently introduced potentially dangerous bug code erlang implicitly match may accidentaly perform unsafe operation first clause longer bind safevalue match similar bug happens erlang matching existing variable remove imagine working elixir code safevalue code case someexpr ok safevalue performsomethingsafe performsomethingunsafe end elixir explicitly match remove definition safevalue code even compile let see working version erlang one safevalue code case someexpr ok safevalue performsomethingsafe performsomethingunsafe end remove safevalue variable first clause bind safevalue instead matching silently changing behaviour code another bug elixir approach shielded u case point elixir requires analyse following code introducing variable failing may cause bug matching variable always safe due rebinding use explicit match erlang requires analyse previous code introducing variable sure match assignment failing cause runtime crash requires analyse following code introducing variable sure change later case semantics failing may cause bug requires analyse following code removing variable sure change later case semantics failing may cause bug numbered variable beginning mentioned someone may introduce new variable foobar elixir code change code semantics variable already used later however case desired example elixir foobar foobar foobar foobar foobar code usefoobar foobar erlang code usefoobar happens want introduce new version foobar elixir foobar foobar foobar foobar foobar foobar foobar newly added line code usefoobar foobar code work erlang code usefoobar must changed developer introduces new variable forgets change later code semantics changed introducing bug rebinding elixir would particularly troubling change miss one variable since code emit unused variable warning even prone error adding intermediate step say say benefit numbered variable code could use example code usefoobar somethingelse however would consider code poor practice nothing name hint different case variable name would reflect part code would prefer use one team much better giving explicit name instead versioned one summing elixir erlang variable provide implicit behaviour rebinding pattern matching respectively require care adding removing variable existing code therefore elixir source hidden bug shown erlang source similar bug different situation erlang requires previous knowledge context introducing new variable elixir requires knowledge way circumvent bug language either forbidding explicitly providing rebinding pattern match operation none language possible react article saying happen code truth happen even small function hand mean writing code erlang elixir going lead bug software erlang developer writing robust software decade quirk exist language endup internalized programmer get experienced exactly happen code come end day language guarantee safely change code without caring context always hidden bug example language like clojure javascript ruby variable function name exist namespace introducing variable may change semantics function call since erlang elixir provide two namespaces one variable another function shielded particular hidden bug furthermore type system compiler warning test suite technique help solve problem language may also provide pattern like elixir pipe operator help convert repetitive code readable le errorprone version least hope put rest claim elixir variable somehow unsafer erlang one viceversa thanks joe armstrong saša juric james fish chris mccord bryan hunter sean cribbs anthony ramine reviewing article providing feedback
403,Lobsters,erlang,Erlang development,"Purely Functional Retrogames, Part 1",http://prog21.dadgum.com/23.html,purely functional retrogames part,purely functional retrogames part part permalink previously,purely functional retrogames part started looking functional language come series project writing video game underpowered hardware super nintendo sega saturn early powerpcbased macintosh without graphic acceleration benchmark usefulness programming language used write complex performance intensive video game working basic tutorial coming grip lack destructive update started thinking write trivial game like pacman defender purely functional manner realized nt performance issue much fundamentali idea structure trivial game without using destructive updatespacman dead simple language fit general model c bunch globals representing position pacman score level ghost information stored short array structure array representing maze element either piece maze dot pacman eats dot maze array updated pacman hit blue ghost ghost structure updated reflect new state dozen dozen pacman clone early including tiny version could type magazinein purely functional language none work pacman eats dot maze ca nt directly updated pacman hit blue ghost way directly change state ghost could possibly work long time ago spent enough time functional language figured implement nontrivial interactive application like video game plan cover information short series entry sticking retrogames simple everyone know pacman look like nt want use abstract example involving hypothetical game design also sticking purely functional programming language feature challenge know ml reference process erlang used mimic object go road might well using cthe one exception purely functional nt care trying make io fit functional model game three io need input user way render graphic screen realtime clock fortunately matter highest level outer loop one look like repeat forever get user input process one frame draw everything screen wait frame worth time elapsed process one frame interesting part take current game state user input parameter return new game state game state used draw everything step draw everything also purely functional returning abstract list sprite coordinate list passed directly lower level inherently impure function talk graphic hardwarean open question purely functional even excepting io worthwhile suggested via email earlier year equivalent writing novel without using letter e part april
404,Lobsters,erlang,Erlang development,Sequential living,http://blog.ikura.co/posts/sequential-living.html,sequential living,search ideal co web address,search ideal co web addressget gone
405,Lobsters,erlang,Erlang development,rebar3 shell,http://ferd.ca/dev/rebar3-shell.html,shell,shell used automatically recompile modified file release configuration application configuration,shell took long time write article one thing shell expect project whether small large load code path boot application specified allows distributed node run let define custom script prime state let run task within taking care updating state work properly lot nifty feature opinion bare minimum shell tool erlang support trying showcase sound like bragging bare minimum supposed may better say nothing move still state usability erlang stuff historically pretty bad lot work contributor putting driven trying solve kind experience say mostly community plenty good tool independent making good use left exercise reader come first thing notice using shell command automatically compile project done yet add code path shell verifying dependency compiling vegur erlangotp source hipe kernelpoll false eshell abort g vegur moduleinfo module vegur export work project least get rid lot annoyance default setup requiring wire everything hand taken care good shell environment programming language interactivity therefore normal expect able quickly recompile code run test reload code without interruption needing lose state shell agent hidden behind module ready state management required recompile code run task example existing project either ask recompile job task run really compile feature experimental may modified removed time verifying dependency compiling vegur ok ct verifying dependency fetching websocketclient git git githubcom jeremyongwebsocketclientgit tag linking builddefaultlibcowboyku buildtestlibcowboyku linking builddefaultlibcowlib buildtestlibcowlib linking builddefaultliberequestid buildtestliberequestid running common test suite vegurbytepipesuite pipeproc ok vegurbytepipesuite pipeproccallback ok vegurbytepipesuite pipeproctimeout ok test passed ok dialyzer verifying dependency analyzing file ok task use latest version rebarconfig file run task take care switching path reloading module agent also given process name make callable outside world start shell name shell name myshell shell sname myshell use send instruction remotely either message direct rpc call shell snamemyshell erl sname remote eval rpc call myshell localhost ct halt noshell objective people tooling could used add hook ide editor erlang shell plugins written work agent also option example used automatically recompile modified file watching disk removing need editor ide integration altogether give place pretty sweet improvement example running debug cycle test code analysis interactive debugging take place environment make development cycle even seamless project grow shell automatically detect release configuration within build tool boot system way release would along application configuration mean long codebase configured ship executable release access code reloading feature shell within tooling would otherwise use using release application specified rebarconfig file either shell apps myapp command line argument apps shell apps vegur verifying dependency compiling vegur booted midjan booted quickrand booted uuid booted erequestid booted vegur eventuality development environment nt match production one arbitrary code run prime shell configure escript file specifically useful set specific dynamic environment variable boot mocked external dependency expand bit example follows show keep shell booting unless required environment variable set usrbinenv escript main osvars user pas checkisset var var osvars checkisset var case o getenv var false rebarapi error missing var var halt ok end file configured always run adding shell scriptfile pathtofile rebarconfig file called directly command line shell scriptfile testcheckenvescript verifying dependency compiling vegur erlangotp source hipe kernelpoll false eshell abort g missing var pas hopefully thing place life erlang developer made easier get tool coming box caveat shell development tool option vm configuration number scheduler example already place runtime modified replicate release configuration keep using release production deployment
406,Lobsters,erlang,Erlang development,Ranking 4 Million Quake Live duels in 1.5 seconds,https://medium.com/@jlouis666/ranking-4-million-quake-live-duels-in-1-5-seconds-fc84750aad1f#.kulgxz9w5,ranking million quake live duel second,ranking million quake live duel second erlang go opponent int int next step reference http githubcomjlouisfuse http githubcomjlouissafetyvalve http http godocorggithubcomjlouisnmoptim http godocorggithubcomjlouisrank http mediumcom http mediumcom,ranking million quake live duel secondsthe last couple day toying little hobby project minethe project rank player player quake live duel reported gathering duel since february project written hybrid code storage retrieval presentation written erlang ranking code written goat moment gathered exactly match deem eligible ranking sometimes quake live report match one player time match lasted couple second remove ranking think good enough around player database right average number played match varies lot player player played one duel clock duel week lot given duel often take minute everything stored database choice postgresql recently upgraded meant could change internal representation erlang conversion jsonb storage type directly postgres price storage erlang serialization format took gigabyte disk space jsonb take gigabyte advantage ease query directly json representation database take query exampleselect idfrom corerawmatchwhere content ranked int look inside content json column grab row ranked toplevel key integer representation equal simplifies lot processing use update statement preanalyze large swath duel without lowlevel work erlangerlangthe choice using erlang processing proved worth number restarts due fatal failure around reason faulttolerance erlang small mistake affect code whole often mistake end end quakelivecom site handle fusecircuitbreaker installed request code clamp operation site experience problem either unreachable trip timer request slow process mean end back quake live site experience troublein order limit concurrent access quakelive site installed safetyvalve application defines request queue policy fast request queue emptied mean run erlang system internal concurrency level around outstanding process try fetch quakelive queue control policy set limit many outstanding concurrent request allow frequency start new requestsin short erlang right tool choice longrunning daemon service must go even database foreign system rely one example power quakelive upgrade service take change line code order handle fuse simply blow system rechecks connectivity every minutesanother important design decision make database operation idempotent since postgresql give u atomic operation simply make sure job idempotent retried later system always trying catch current state system always behind real time small factor go handle situation catching virtue idempotence save u quakelive remove match week played nonpaying bet keep internally least day act grave problemgoerlang shine due fault tolerance robustness nice functional language write succinct code go somewhat opposite imperative explicit data layout statically typed simple type system however go compiled native code provides good parallelism nice unique feature interface channelbasedmessagepassing thing think go shine syntax clike imperative language first language year actually innovate simplify language writing go necessary important another brilliant decision get rid semicolon use simple layout rule still keeping mostly lalr grammar provide excellent go fmt tool reindent code predefined defaultpackages go way handling library imported code something language picking trick import statement string like external tool understands parse string automatically fetch source code library compile coalesces concept package dependency language remove lot external boilerplate managementtoolchain quick recompilation software help lot developing remove overhead compilation coming language fast compiler like ocaml erlang nice wait compiler one design decision transitive dependency recompiled depends b depends c compiling b everything related c pulled resulting object file turn compiling look b avoid c help compilation time lotinterfaces go package interface structuring tool allows break large system smaller part increase modularity code base since altering one module code le likely yield alteration module decoupling far important construction handling large code base erlang write independent application ocaml create module functor go write separate package eventually use interface abstraction provided different parameterization java generic ocaml functor really experienced limitation approach yetin earlier post mine looked ranking different approach different language ended choosing go ocaml erlang erlang strong number crunching floating point domain ocamls current lack parallelism excluded recently updated go package better simpler use everthe main interface package following type opponent interface r rd sigma sj func rank r rd sigma opponent opponent tau nr nrd nsigma rank player call rank player parameter r rd sigma set opponent given slice configuration parameter system called tau opponent interface implement making opponent interface avoid problem caller take code mangle fit scheme rather wrap data structure provide opponent interface turn rank gamesthe code also optimize configuration parameter tau initial rd use system running neldermead optimization routine api isfunc optimize f func start cf func int int optimize function f subject start value start constraint cf note speed concern overhead f function computation make everything work adapted simple parallel variant ranking computation speed full ranking week match take le second full optimization completed second core gigabyte ram lenovo technical code next stepsthe next phase project employ order provide nice graphical output data initially tested output r nice plotting package ggplot version wickham order make easier everyone use system decided build frontend us plot result work currently ongoing done way present datareferences http githubcomjlouisfuse http githubcomjlouissafetyvalve http http godocorggithubcomjlouisnmoptim http godocorggithubcomjlouisrank http mediumcom http mediumcom
407,Lobsters,erlang,Erlang development,Interview with Jesper Louis Andersen about Erlang and the JVM,https://medium.com/this-is-not-a-monad-tutorial/interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and-5628fe591295#.61ohano83,interview jesper louis andersen erlang jvm,advantage erlang vm jvm vice versa erlang vm us asynchronous io present normal api developer callback needed like nodejs practical term gain using vm like erlang vm preemptive scheduler wrote miss type class ml module erlang possible implement rich static type system also message passing time think monad erlang useful tried erlando think idris erlang http lenarycoukpublicationsdissertation http simonjfcomwritingmscthesispdf since common use pool gen server erlang good idea erlangotp default genpool implementation,advantage erlang vm jvm vice versa perspective history choice building beam vm erlang correct one massive concurrency le radar many people ericsson needed platform controlled furthermore beam exploit executing functional language gc need generation forward set instancethe rollyourowndesign decision proven valuable even though compared jvm otp team far smaller guess every hour sunk beam least hour work jvm turn thing efficiently beam still bytecode interpreted jit mean raw execution computationally intensive task time slower typical wellwritten java project quasarpulsar akka promise erlangstyle concurrency jvm recently developed whereas beam production many yearsthe key differing design criterion come design space originating bjarne däcker thesis notably soft realtime constraint need seamless hardware interaction also need running large software system feature interaction complex turn world major problem rarely raw execution speed rather part system operate coherent whole many problem design space requires different approach sheer execution brute force especially multicore world fast execution important would addressed long time ago turn every major release beam provides far important set new feature lot power large industrial company backing system new feature tend operationalindustrial naturethe key difference implementation beam built ground resource sharing system much like operating system o two process b isolated get fair share resource b badly written considerably le impact suppose instance b bad gc productivity allocates lot gc b run far often b pay either lower throughput worse latency time keep running without b bad impact operation beam isolates resource way b application directly impact application resource standpointthe contrast system one large shared heap used hedge b gc heap hoping fast enough power clearly badly written b affect well written far matter verylargescale development since hope every part system perfectly writtenif erlang vm us asynchronous io present normal api developer callback needed like nodejs nodejs us cooperative scheduling algorithm seen old operating system macos window running legacy code msdos method program explicitly yield cpu next task number advantage easy adapt existing language system method highly efficient throughput allows pack lot work single processthe weakness cooperative model fragility server setting one task task queue monopolizes cpu hang block impact worse throughput higher latency deadlocked server fragility avoided largescale system erlang runtime built preemptively normal code instrumented call may block automatically put process sleep switch next one cpu furthermore erlang functional process must loop calling function internal funcall counter measure reduction used process forced cpu next one switched process entirely automatic follows modern idea timesharing operating system amigaos unix window nt onnote erlang way call blocking operation since handled runtime mean model coherent use library like without fear something bad example beam us pcre regex library cooperatively yield expensive nfa traversal also break expensive cryptocomputations longrunning gc costly term serialization even includes blocking monitor builtin get notified monopolization happened call foreign code written c harder though since take blocking behavior accountyou get much language using appropriate framework however breed fragmentation library code one framework usable another framework without adaptation code written framework inspected eventual blocking behavior turn code colored different color mix thema far better approach seen quasarpulsar take existing bytecode rewrite instrumentation much like erlang insert forced preemption loop protect potentially blocking call lightweight fiber switch add io manager underneath almost full implementation erlang model take serious amount work get lower part run fast model since reimplement erlang vm inside javain practical term gain using vm like erlang vm preemptive scheduler preemption exchange sacrifice explicit control gain productivity first adapt existing code model save time language without proper abstraction barrier calling wrong function wrong time block scheduler second postdevops world run system productivity directly tied maintenance overhead existing system lower fragility model mean time actually write new code rather fix old problem afford let bad behavior live longer system since impact simply gracefully degrades system bitmost importantly however worry every nook cranny code rarely run code written slightly le performanceoriented since cost automatically amortized whole program scheduler even critical path smearing operation scheduler help lot alleviate spike long running background job simply started without much worryanother gain observation n start small grows say time piece software get handle gradually data without preemptive scheduler growth often end considerable latency throughput impact erlang system errs side maintaining good lowlatency slightly worse throughput situation load increase system often desirable behavior le likely affect system directly system simply degrades gracefully rather abruptlyyou wrote haskell type class often abstraction way go ml key use modulesdon miss type class ml module erlang miss lot rely efficient type world order function adding untyped language like erlang going rather hard far reasonable way go erlang program look inside elixir clojure community clojure procotols would good addition think fit erlang design space far another good place inspiration implementation module took inspiration standard ml functors among thing report algorithmic language scheme implementation also share lot design space erlangit often said haskell type class construction implemented ml module correspondence erlang would use process process force code modularize isolate since communication done exchange message granted happens runtime used correctly yield emergent behavior source code module executed many isolated process runtime interaction defines behavior program literature swarm intelligence provide information areais possible implement rich static type system also message passing time yes system introduces kind box typed box containing type x box often singlemessage mailbox channel type system even need rich work go show work box thread type put thing box extract thing box statically reason type extractedinserted valuehaskell several highly interesting communication model enjoy rich typing also john reppy concurrentml take communication step channel first class value manipulated event first class cml algebra manipulating event combining call sync event scenario play akin able receiveclauses value join sync join mindaltering operation reppy calculus withnack event firing another event picked often used cancellation situationsmost model assume nondistributed setting though assume communication fail code upgraded running cmls event resolution distributed setting likely run cap theorem instance type system assume total static knowledgecontrol something rarely distributed system hence verify interaction distributed agent somewhat defeat holistic aspect static typingwhat think monad erlang useful tried erlando use monad construction erlang time time code going flow better monad rarely use tool erlando package assumes monad module whereas often use record monad work monad always tool best used special case understand formal logic personally much prefer hybrid approach ocaml erlang language imperative rather approach haskell purity latter force monad upon way always appreciatethe monad story erlang somewhat weaker would like haskell nice compiler use type implicitly infer monad used use monad lot power come ability interweave monadic bind code haskell weakness monad transformer stack code change whenever reorder stack perhaps work free er monad kiselyov amend weakness feel productivity slightly le eg ocaml need explicit reference monad order use erlang simple monad easy comprehend raise complex system abstraction really need proper type system guide get erlang turn erlang code tends le abstraction heavyi necessarily think bad idea code us relatively abstraction code style even ocaml haskell tend rely simple principle rather high level abstraction introduce many abstraction also introducing need reader knowledge possible go overboard end code people world read understand might efficient elegant get many programmer looking code hence tend use couple abstraction really help code refrain using situation preferring rewrite code simpler meanswhat think idris erlang sam elliot wrote thesis subject take work asking among contribution proofofconcept erlangbackend idris allows take idris module compile erlang module proper backend would definitely need work target erlang core rather concatenating string together form erlang program yet one remember goal thesis say producing production quality backends language thesis also explores another path perhaps bit overlooked type message communication looking erlang message model squinting eye lot get essentially ipudp communication message arbitrary size know process id know ip capability send pid message also property message loss might occur unlikely unless something going seriously wrong since risk failure low usually handle restarting known good state rather implementing complex recovery schemesthis model extremely flexible build almost kind messaging top hand generality weakens metatheoretic property protocol say anything wellformedness messageswhat elliot point thesis notion constraining communication certain limited pattern giving general messaging suddenly define typed world understand going turn prove welltyped pattern enjoy desirable property enough work may able capture essentially healthy pattern communication rejecting bad one could lead removal subtle concurrencydistribution mistake come long wayanother thesis mention passing simon fowler monitoring communication pattern erlangotp fowler explores idea monitoring messaging runtime altered genserver construct one major observation many erlang message pattern captured typical twoparty session type let alone multiparty session type particular multiparty session type allow dynamic introduction new member termination member session ongoing fowler proposes several interesting solution path thesis adapt system handle problemsall observation seem suggest need research work area understand full interplay language idris highly concurrent ecosystem erlang beam vm would seem erlang generic fabric top could patch restriction improves quality system automatic fault removal case typing concurrentdistributed programming general communication model erlang seems hardwe also need explore messaging pattern erlang typeable type system usually pattern additional desirable structure embedded type system enforces rigidity researching area one may hope improve understanding certain pattern used http lenarycoukpublicationsdissertation http simonjfcomwritingmscthesispdfsince common use pool gen server erlang good idea erlangotp default genpool implementation erlang tenet provide tool solution provide tooling building pool provide pool reason fact pool alike last year come across perhaps different pool implementation key observation valid implementation hand resource pool differ roundrobin proxying queue request hand fifo order us lifo order distributed jobidle queue implementation whereas run single machine provide automatic health check reconnections block caller work others error queue caller erroringthe observation pool handle failure reclaim stale resource handle error pool implementation etc clear implementation would correct operation mostly function context pool usedmy experience problem space requires either chaos monkey concuerror quickcheckpulse remove fault hard get entirely right tool require specification correct operation several specificationshad erlangotp provided default genpool implementation people would use even fit problem space tend create subtle hardtofind fault
408,Lobsters,erlang,Erlang development,Interview with Jesper Louis Andersen,https://medium.com/@unbalancedparen/interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and-b0de06440fbd,interview jesper louis andersen,reply picture modern comfortable programming language java case oop language tweeted real haskell ocaml erlang agile language think clojure tweeted could elaborate opinion regarding dependent type like one idris think ocaml go compete space experience two language think compare great post explained drawback json rest http apis also wrote could give u recommendation rfc book article read exercise learn design protocol,reply picture typical application write erlang function call stackmodern comfortable programming language java case oop language really artifact oopstyle language much artifact develop software biology observed solution usually rewriting code rather patching code imagine world inclined build top already rather go rewrite older part think new generation programmer tend add layer top already mostly put mark programming simplify abstract part lower level common use also hiding rare part get deep call stack another similar view would geology see older layer go back time older period much java stack iterlang different outset smallcommunity language le susceptible patching especially easy rewrite code mean itch scratched writing something new rather building top others brings call stack frame however process erlangsystem typical web request served cooperation process call stack add together approach size isolation small eventual error result crash report thing backtrace state process crashed incoming message made crash reason original state functional programming every data structure persistent version usually enough quickly isolate figure error went wrongyou tweeted let talk agile ultimate agile language one deliver working code quickly also maintainable hence agile language existence haskell ocaml erlang go javascript python rest lack necessary abstraction regarded agile end recode however real solution stop agile idea bullshit first place haskell ocaml erlang agile language waterfall model risk building right product agile risk building product right fond erlang creator mike williams point make experiment starting project whole project experiment hunch lot agile process miss need experiment buildif instead ask prototyping need programming language certain trait team usually small need expressive language need address core kernel system isolation first need lot interfacing foreign system general care much system build fast also usually need operate prototype production since simply proof conceptfrom perspective rapid prototyping proofofconcept development functional language tend edge imperative one higher level expressivity allows said succinctly fewer line code also tend describe data structure algorithm way clearer help understanding problem spacein turn since agile value minimum viable product moving fast making experiment need language easy experiment unknown idea many agile project face language haskell erlang ocaml often iterate far design limited time window thus carry experiment often lead better product even final product even written functional language general feel value experimentation little build throw away rewrite new knowledgewhat think clojure sadly experience clojure limited carrying set koan language ever used anything serious work must admit find language especially compelling general find lispdialects interesting language root closer standard ml may reason catch interest finally tried toying scheme common lispthat said people lot outright amazing stuff clojure think datomic project genuinely interesting database system work kyle kingsbury done jepsen framework knossos linearizability checker clojure solid work also following david nolen work interest pretty sure language tweeted functional programming semantics far important static typing removing error programswhy could elaborate somewhat alluded never character imperative program function depends two thing parameter passed also current state machine store functional language former matter consequence choice far reaching one state space reason human being far smaller fp make harder make programming mistake two test function isolation rather confident covered function execution well three data processing inductive nature recursing structure data rather manipulating store afar programming closer proof induction force programmer handle corner case rigorouslythe ease reasoning also come play found bug often easier figure program wrong taking close look rare need attach debugger concurrent andor distributed system part outside direct controlwhen add typing obtain another dimension system automatically checked additional rigor often find people forget much power functional programming regard type experience functional program tend order magnitude fewer error imperative counterpart program especially subtle cornercase error type naturally type functional programming help even choice imperative programming type functional without know pick without hesitationwhat opinion regarding dependent type like one idris studied idris much yet work agda coq employ dependent type albeit type theory subtly different deliberately pushing ahead like also done rust mostly like settle mature bit start looking probably start looking around research perspective idris extremely important need explore area real world program well language designed program rather proofassistance fairly important course one would like see mature language one understand much sunk idris make happen currentlyi yet entirely convinced necessarily want add dependent type mainstream language full form perhaps turn rather want simpler type system area order extend along dimension somewhat interested curryhoward correspondence distributed programming epistemic logic instance priori clear even understand mean marry dependent type beast may cut cake differently order understand typelevel interactionsdon think ocaml go compete space experience two language think compare squint eye hard enough ocaml imperative language top added lambda calculus lambda calculus primitive operation imperative execution either way go ocaml much alike core garbage collected natively compiled language tend provide execution speed ballpark usually order magnitude come executing programswhat set two language apart underlying ideology design programming language go modest cleanup c semantics top add channel goroutines interface ocaml programming language tradition milners metalanguage ml drawing inspiration several source including haskell standard ml among othersgo usually opts simplicity separation feature small basis language specifically addressing concern programming large yield program highly coherent programmer relatively abstraction tool disposal addition interface concept go implicit mean le need alter part system large setting programmer altering code someone else owns usually measured day whereas local alteration take hour time lost lower abstraction deceivingthe simple coherent design go also foster fast compilation little abstraction overhead matter abstraction use program usually compile fast pretty obvious performance behavior program fast compilation speed matter large setting waiting compiler often wasted time rus cox noted abstraction generic instance make tradeoff putting onus programmer compiler execution speed leave generic programmer work around add generic compiler work compilation phase abstract away generic boxing construction affect execution speed go opts first theseocaml contrast heavily abstraction perspective leaf go dust support much efficient use programmer time compiler also relatively fast handle added abstraction well though current time overhead abstraction use notion cox current version ocaml sacrifice execution speed case new flambda ir ocaml shift onus around put compiler another important dividing factor current lack proper multicore support ocaml also mean lack proper concurrency runtime builtin default ocaml rely system lwt async achieve goroutines go fact two mean everyone support library situation far perfecti usually grab ocaml problem certain trait symbolic manipulation one thing ocaml excels proper algebraic datatypes thus would never write compiler proof assistant something else program generating program another area ocaml excels finally problem embarrassingly parallel structure easily handled spawning o process ocaml cogen ocaml quite efficienti usually write go simple bruteforce program interaction complex simple channel network inside program avoid anything complex interaction simplicity language often get way problem virtue simple construction make go really good languagepersonally prefer ocaml ideology add abstraction language build powerful module system functors program large βreducing module one another use compiler computer sacrifice pay additional abstraction program easier maintain easier recombinego ocaml best used program part program heavily cpubound memory bound vast majority program write little need run tight cpuschedule usually write erlang bound memory often end situation gain dropping ocaml go small bound outside interaction disk network almost gain fast compilation linking speed two major reason like erlang worthwhile aside mlton standard ml compiler take extreme compiling program one fell swoop thus able perform wholeprogram analysis optimization perfect knowledge program make lot abstraction free price long compilation timesin great post explained drawback json rest http apis also wrote need go back root start building protocol change never come large company rely open tinkerer culture need welldefined protocol multiple implementation protocol design quickly becoming lost art rather people satiated apis point recoverwe need decentralization internet built idea endtoend interaction machine current state clientserver infrastructure central entity drive status quowe need distribution rely big player tie solution bane going forward build infrastructure around vendor interesting lockinand finally need education lot current protocol design bad compared found old rfcs want implement something new need study past lot build reject old idea need explain reinvent old idea need know reinvented happened historically idea catch could give u recommendation rfc book article read exercise learn design protocol good protocol design art form goal produce protocol simple implement hard implement wrong future extensibility take tcp protocol instance implement hardware simple stopandgo protocol ignoring everything sliding window correct valid implementation protocol though slow work add layer top make protocol faster addition rfcs tcp james e white rfcs dear heart written handle lot problem still day distributed machine communicatethe bittorrent protocol deserves mention well defines client communicate give relatively rule client supposed implement behavior set forth start implementing protocol however find one true way part could left specification instead minimal viable protocol given detail altered go along also note original bt protocol used bitarray bit handshake rendezvous order negotiate additional feature supported later replaced fully extensible system proved inadequate whenever see patch protocol design think could avoided first placeanother incredibly welldesigned protocol protocol generic enough adapted lot situation well implement many good idea like outoforder messaging proper multiplexing message one channel request initiated end connection onthe general advice cut part nominates peer behave internally need maximize freedom implementer establish basis communication cut cut cut leave everything destroy coherency internal consistency protocol layer protocol push thing separate layer layered protocol much easier reason formally better though either model checking quickchecking protocol internalsone read critique got protocol suffers rushed work sadly read simpler alternative approach example push message server client grows white observation peer protocol need able initiate communication http skewed like rpc since communication initiated client toward servera good approach roy fielding define constraint need squeeze hard minimal protocol come start defining large framing need protocol create protocol property tcp defined constraint stream protocol connection oriented without data loss zeromq message channel connection oriented without data loss udp message oriented datagram oriented loss sctp onprotocols far better apis invite multiple competing implementation thing debug time virtue noninteraction peer open design space rather closing distributed world slave api design large megacorporations master protocol
409,Lobsters,erlang,Erlang development,"Would You Bet $100,000,000 on Your Pet Programming Language? (2007)",http://prog21.dadgum.com/13.html,would bet pet programming language,would bet pet programming language j permalink previously,would bet pet programming language proposition need application developed deliver time pay usd nt involve solving impossible problem difficult messy problem yeswhat language use write nt matter perfectly fine use multiple language got hangups matter get done worksas big project spec undoubtedly change along way promise completely confuse direction thing random request could add image editor feature photoshop plus couple enhancement automatic translation korean polish fuzzy llama ride around network transfer take long none realistic thing could see happening need handle data set five time larger anticipatedi also want run custom armbased hardware sure port itintel announced core chip code need scale level processing powerand also hang phone callsadly found google longer interested buying weblog rescinding offer sigh imagine offer true would bet hundred million dollar pet language task would change criterion judging programming language view library much important core language feature cayenne may dependent type cool binding flash file creation nativelook gui rich text format parsing library fetching file via ftp mercury really want write svg decoder clean reliability proven tool even important library anyone ever attempted similar problem dolphin smalltalk chicken scheme wallaby haskell er mean haskell anyone ever attempted problem scope language know compiler wo nt get exponentially slower fed large program profiler handle large program know track small variation function written result bizarre spike memory usage useful still experimental feature banged people working production environment window version tool actually used core developer viewed second rate platform native compilation big project result much code global slowdown something actually true erlang c translator dependent decision made language implementers think sure toy textbook problem tutorial example always seem work beautifully point find dependent obscure corner compiler runtime system odd case nt matter problem domain language created large impact trying say got program operates large set floating point value hundred megabyte floating point value one day objective caml program run memory dy smart course knew floating point number boxed time ocaml causing larger necessary array float always unboxed used big data structure still memory problem float ocaml mean double c would snap switch double type single precision float instantly saving hundred megabyte unfortunately something never considered important ocaml implementers got go mess compiler change picking ocaml issue applies many language floating point typesa similar harder fix example discover certain data set size garbage collection cross line noticeable paying attention bug report program going catatonic several second garbage collector already carefully optimized us multiple generation always point oldest generation need scavenged sit helplessly half gigabyte complex structure traversed copied fix theoretically better garbage collection methodology exists paper somewhere nt going make problem vanishby fan sort underdog programming language lighting torch collecting rotten fruit really trying put specific language trial easily accused showing favor forth spent time tinkering j honestly look like line noise way would blow mind critic level charge perl yes recovering language dilettantereal project tangible reward change perception however carrot hanging front looking solely real issue involved problem purely academic research project immediately look ridiculous scary become open writing key part application c put final say overall data size back control instead finding much later language system designer made choice tagging alignment garbage collection odds end goal python erlang get immediate boost used large commercial project though clearly different strength weakness worried needed support odd nonunixy embedded hardwarewhat would hundred million dollar change approach getting thing done quick reliable fashion nt standard approach permalink december
410,Lobsters,erlang,Erlang development,Efene: an Erlang VM language that embraces the Zen of Python,https://medium.com/this-is-not-a-monad-tutorial/efene-an-erlang-vm-language-that-embraces-the-python-zen-db9b4d840614#.h6w6o14v8,efene erlang vm language embrace zen python,efene erlang vm language embrace zen python mariano guerra efene efene quick introduction busylazy programmer unbalancedparen monad tutorial stay tuned create efene module function reia talk cowboy embrace zen python could show u short good example efene program biggest advantage coding language run top erlang vm beam difficulty find implementing efene recommendation u implemented language yet ast erlang ast python match expression introduce introduce expression arrow operator add http clojuredocsorgclojurecore http clojuredocsorgclojurecore saw creating new language beam called interfix wrote little riak core book gave talk called f rom working distributed system riakcore could explain riak core useful u implement distributed system reading blog could see used scala clojure apart erlang experience scala clojure advantage disadvantage find comparing scala clojure erlang,efene erlang vm language embrace zen pythonin ocasion interviewed mariano guerra creator efene efene alternative syntax erlang programming language focusing simplicity consistency ease use programmer ux reading interview mariano guerra check efene quick introduction busylazy programmer learning efenereach via twitter unbalancedparen comment interview request monad tutorial stay tuned create efene learn ago wanted learn erlang first functional programming language wanted learn coming c c asm java python looking toy project learn itfor find project interesting also matched strength erlang point decided would small calculator erlang see first commit full project hereat first eval stuff pretty quickly added support compile expression erlang module function next commit added function support realized programming language read rest commits see morphed oneat point beam language erlang reia planning anything particular powerful calculatorlanguage hybrid point people erlang factory asked wanted give talk language course said yes got dose impostor syndrome started project scratch proper programming language decided support every feature erlang support much point project changed toy actual programming languageafter talk initial excitement thing got quiet got engineer degree new job development stopped elixir appeared got much attention thought ok someone got right stop pushing efene year passed looking elixir saw elixir idea exactly idea efene decided rewrite try fill niche different syntax erlang reuse much possible erlang ecosystem unified tooling documentation core project language complete working documentation plugins andwaiting surrounding tool mature avoid redo documentation mainly cowboy embrace zen python zen pythonpython first language enjoyed coding coded c c asm java knew provided something needed python first time said python programmer programmer also python argentina community helped lot witht hatpython attitude simplicity community like instead coming ad hoc informallyspecified bugridden slow implementation half python zen decided copy itdavid nolen summarized well day efene mixture like language community philosophy python javascript erlang expect lot novelty efene remix could show u short good example efene program think particularly short snippet code show interesting bit efene mainly clever part efene idea regular simple explicit readablethis mean try win codegolf competition clever language trickbut think take look project client api support rest web socket server sent event comet start client send pseudorandom stuff test server reaction understand boring would happy course knowing erlang help understanding since efene semantics pattern erlang swhich biggest advantage coding language run top erlang vm beam semantics vm really thought really simple learnthe stability scalability platform great lot people worked really hard problem long time top erlang vm mean get really good advice help themone thing really like think mentioned much level runtime introspection visibility vm tooling build built around greatwhat difficulty find implementing efene learning limit parser syntax valid unambiguous learning avoid introducing crazy idea language syntax semantics always tricky want wat languagealso learning erlang vm itbut sum ended difficult thought requires persistence hammockdriven development recommendation u implemented language yet learn lexing parsing build calculator using sexpressions lisplike reversepolish syntax forthlike start interpreter copy semantics simple language already know coming good semantics hard try invent first timethen ride top language know either transpile language compile bytecode intermediate representationtry reuse much tooling language possible ast erlang ast python similar allow reuse tooling code built around representationsread lisp forth implement simple lisp scheme forthonce learn lex parse think syntax language try parse themwhat match expression introduce core efene rewrite concept everything revolves around main thing pattern matching function guard data pattern matching done using equal sign argument list function definition erlang expression wanted unify pattern matching single syntax reuse everywhere case clause came beif look efene yet shape efene expression something like keyword exprargs caseclauses else body enda caseclause shape case caseargs guard body example trycatch try body catch caseclauses else body body endreceive receive caseclauses else body afterexpr body endfunctions fn name caseclauses else body endyou see pattern since case keyword already taken erlang use match efene look new keywordone thing like python concept executable pseudocode like fact read python code aloud sound like thought matching expression case imperative would match case b case c else end ended matchwhy introduce expression initial idea efene familiar people coming algollike mainstream language focus learning interesting erlang semantics abstraction avoid learning new syntax way epiphanysince list comprehension available many language decided implement list comprehension familiar construct fact samewhat arrow operator add first quick introduction people unfamiliar efene arrow operatorthere thing erlang want apply sequence operation list create new binding intermediate result mylist createlist mylist want reorder remove operation rearrange name fitthe idea arrow operator help compile operation mean write mylist createlist compile mylist createlist thing erlang library standard position thing operating like language tends first argument inspired clojure http clojuredocsorgclojurecore http clojuredocsorgclojurecore created two variant add result evaluating expression left first argument function call right add result evaluating expression left last argument function call rightbut thinking symmetry common idiom erlang functional language higher order function passing function argument function decided create reverse restricted use add case clause right anonymous function last argument function call left add case clause right anonymous function first argument function call leftyou see say case clause anonymous function write fn keyword give expression dsl taste like example listsmap thing case zero case even else oddendgoing back restricted us righttoleft arrow since code read left right putting something right value help readability hence decided support iti saw creating new language beam called interfix said efene language try come anythingnew led avoid experiment efene still wanted experiment somewhere elsewith time number idea crazy language grew condensed point thought nice little language coming back conference lot dead time airport internet decided give tryafter landed language growing idea seem problem kept growing quite fast last day almost complete language sense everything erlang point finishing adding remaining feature everything know everything fit move cleaning code adding tooling doc around people want play experimental languagei say experimental sense crazy idea experimental crash break backward compatibility compile code wrong bytecodeyou wrote little riak core book gave talk called working distributed system riakcore could explain riak core useful u implement distributed system riak core foundation riak kv basho project generic reusable part dynamo style distributed system provides abstraction utility build multinode masterless distributed systemsin riak core based application build system implemented interface handle work application inside virtual node vnodes live inside ring vnodes work done routing command consistently vnodes hashing key specifyit also provides way run command one vnode compare result grow shrink cluster without downtime migrate vnodes physical node authenticationauthorization metadata system hold information cluster application distributed mannerthis free implement building block focus actually make application different building upon tested production ready foundationwhile reading blog could see used scala clojure apart erlang experience scala clojure advantage disadvantage find comparing scala clojure erlang experience programming language really good built similar system programming language kind pubsub system persistence reason moved backend initially scala liftakka clojure immutant system handled lot semistructured data frontend backend using lot time putting data rigid type serialize json againafter operation time shape data evolved frontend storage go change type backward compatible manner getting really tiring since backend really simple actually didso decided move clojure resulted huge reduction code code evolved saw implementing pubsub like system hand low level tool like agent atom promise copying erlang pattern point customer asking scalability clustering decided prototype using riakcore coding tried new project since could improve fast working quite nice decided adopt default backendi still using scala spark job use clojure internal tool internal frontends clojurescript backend erlangi want clarify backend quite simple moving language backend big deal bulk frontend code
411,Lobsters,erlang,Erlang development,The emergent elegance of Elixir scoping,http://thepugautomatic.com//2015/11/elixir-scoping/,emergent elegance elixir scoping,emergent elegance elixir scoping ruby elixir macro elixir scoping rule code example notorious javascript statement something else called civilized age ecto migration consulting mailing list see implementation gist overriding operator locally pipespect implementation scope twitter value explicitness drew olson,emergent elegance elixir scopingwritten november tagged ruby elixir macrosi struck emergent elegance elixir scoping rulesin native ruby importextend scattershot affair within individual method applies entire module module mymodule def sayhello sender put hello sender endendmodule myothermodule extend self def methodthatdidextend extend mymodule sayhello methodthatdidextend end def methodthatdidnotextend sayhello methodthatdidnotextend endendmyothermodulemethodthatdidextend myothermodulemethodthatdidnotextend elixir hand import require alias inside function applies within function actually go happens inside logic branch eg cond case applies within branchand simple fact elegance emergeswith importa day ago saw code example gutenexbegintext gutenexsetfont helvetica gutenextextposition gutenextextrendermode fill gutenexwritetext abc gutenexendtextit would nice get rid noise repetition import within current scope without spilling code def rendergutenex import gutenex begintext setfont helvetica textposition textrendermode fill writetext abc endtextenddef doallthethings rendergutenex endthis reminds notorious javascript statement could easily implement withalike elixir defmodule defmacro module block quote fn import unquote module unquote block end end endenddefmodule run import def run string ioputs hi reverse end endendrunrunin macro create immediately call anonymous function limit scope importwe could also limit scope dummy conditional come higher wtf factor true import unquote module unquote block endnote macro function definition quote end block would limit scope import part macro infrastructure generate code effectively disappear scoping hierarchyalso note elixir may gaining something else called future start using nt get attached instanceeval civilized agewhen started learning elixir found wanting understand thing like ecto migration work painstakingly reimplemented interesting part syntaxlet say want support create table user add name stringendin first implementation add function could call inside anywhere else well wanted betterin ruby would used instanceeval evaluate block code context add method availableby consulting mailing list elegance elixir scoping finally revealed meof course solution simply import module limited scope like aboveif interested see implementation gistoverriding operator locallyanother elegant effect override operator within single function single logic branchthe pipespect library replaces regular one inspects every intermediate valueits implementation import scoping rule one discussed somecondition use pipespect inspected stringreverseelse stringreverseendout scopethat interesting implication elixir scoping rule let know comment twitter related reading also see value explicitness drew olson
412,Lobsters,erlang,Erlang development,Keynote: Elixir Should Take Over the World,https://www.youtube.com/watch?v=X25xOhntr6s,keynote elixir take world,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature elixirconf keynote elixir take world jessica kerr youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature elixirconf keynote elixir take world jessica kerr youtube
413,Lobsters,erlang,Erlang development,Life is More Than a Series of Cache Misses,http://prog21.dadgum.com/204.html,life series cache miss,life series cache miss still issue permalink previously,life series cache missesi nt know make continual stream people fixation lowlevel performance control mean people deride cacheobliviousness linked list writeoff language nt near top benchmark table rant hopelessness garbage collection right way wrong timeyes detailed analysis linked list traversal realize hey looping array much faster news anyone different language different performance characteristic garbage collection little trickier unfortunately still issue depending situation rarely eitheri could take little erlang scheme program put show publicly tearing piece analyzing inefficiency dynamic typing immutability virtual machine would foot stomping cheering everyone would leave convinced fooling way write code frame problem term cache architecturesand reveal massively inefficient erlang program take couple millisecond runback decided modernize skill experience heavily skewed toward lowlevel c assembly work went tutorial number modern language settling erlang learning wrote program problem college thing like tree manipulation binary search classic remember messy c pascal writing erlang fun giving fun help fun productive fun lead better understanding problem domain lead fast code even might order magnitude away optimal viewed microscopethere exception imagine expert building specific type application shipped five got map sinkhole poorly lit place chance maybe depending background knowledge transcends capability provided higher level programming language easily crystallize simple static architecture cbut expert take funpermalink february
414,Lobsters,erlang,Erlang development,Heroku Proxying becomes Free Software,http://engineering.heroku.com/blogs/2015-10-21-vegur-free-software,heroku proxying becomes free software,listen article random sticky vegur readme heroku private space,listen article http routing heroku made three main logical layer state synchronization layer ensures node routing stack aware latest change domain application dyno location across platform routing layer chooses dyno handle http request random sticky performs logging errorreporting http proxying layer handle validation normalization forwarding request client dynos last part one platform team happy opensource today vegur library vegur thought bit like nginx reverseproxy except entire list host configuration fully programmable making easy hardcode use file use database push state update directly proxy router state also allowing dynamism feature routing algorithm choice debugging header turned critical feature none existing proxying mechanism could support scale size heroku vegur written way compatible router could use proxying job without compromising routing logic making easier focus higher level task allows following part name delegated erlang code base domain name lookup selection one many backends domain choice interface given backend checkoutcheckin mechanism resource management customizeable error page every potential kind failure proxying request perapplication even perbackend control feature tunneling request ability add header upstream downstream everything documented readme project example code sample example vegur used production year heroku platform also currently used power router heroku private space hope make easier community large develop interesting routing product enriches ecosystem whole
416,Lobsters,erlang,Erlang development,"The stack we choose: Erlang, SmartOS, Clojure",https://blog.project-fifo.net/the-stack-we-choose-erlang-smartos-clojure/,stack choose erlang smartos clojure,o smartos zfs compression arc zil dalmatinerdb checksumming zone dtrace low level code c real pain control plane backend erlang client server ui frontend clojurescript om ombootstrap,often hear project fifo us unusual technology stack looking past year development experience stack proven positive one continues prove right choice following serve rationale choice behind component experience along way o choose run fifo related service smartos reason simple since fifo manages smartos cloud would silly eat dog food run fifo something else use vanilla smartos dependency fifo running vm could switch fifo vm would continue work also come number great advantage opinion zfs simply file system ever used period compression arc zil work incredibly well especially dalmatinerdb achieves amazing throughput partially thanks purpose built take advantage feature zfs checksumming get rid lot potential headache zone wonderful way achieving isolation allows fifo deploy infrastructure manages taking away need extra dedicated server cloud system require allows fifo manage dtrace helped lot debugging especially dalmatinerdb performance matter lot component big win custom dtrace probe sprinkled throughout system allow accurate tracking insight going dtrace helped find interesting bug may otherwise discovered low level code obvious reason low level code written c efficiently interface c library like dtrace kstat libzdoor much way around one biggest pain point probably good part pain due lack experience c language availability good tooling good grief multi threaded c code real pain upside erlang nifs make integrating c code rather easy control plane backend erlang language designed control plane application perfect fit whole design fit wonderfully building block make lot easier language build reliable code failure characteristic fantastic visibility nearly unmatched ability cluster multiple vms major factor design existence library like riakcore corner stone highly available design fifo offer made possible build masterless system keep operating face node failure network partition people find syntax odd yet experience match task rather well make easy express kind problem dealing catch problem cause wave failure recovery come fifo design outstanding small problem might otherwise crashed le capable system prevented escalating supervisor restarting process giving u time analyze fix issue without impact given fifo distributed application deal lot socket http nice edge simply good format internal communication erlang handling socket make using tcp easy expanded adding library building client server application around mdns discovery use extend automatic failure recovery edge service ui frontend rather unpleasant experience angularjs ended rewriting entire ui clojurescript om extraordinary system clojure joy write om make web development least halfway fun expressiveness clojure stunning one guess fact use erlang backend thing functional programming ombootstrap present convenient wrapper around many bootstrap component still bit rough around edge nice get something quickly make responsive design lot easier starting something scratch
417,Lobsters,erlang,Erlang development,"Spawned Shelter - the best articles, videos and books for learning Erlang",http://spawnedshelter.com/,spawned shelter best article video book learning erlang,,page collection best article video book learning erlang internals virtual machine language run top like elixir lfe efene
418,Lobsters,erlang,Erlang development,Erlang Garbage Collection Details and Why It Matters,https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html,erlang garbage collection detail matter,soft realtime garbage collection immutable memory layout pcb stack heap list tuples binary gc detail private heap gc scenario scenario scenario scenario shared heap gc fred hebert erlang anger conclusion go language memory model documentation page resource external link,one main problem erlang tried solve creating platform implementing soft realtime system high level responsiveness system require fast garbage collection mechanism stop system responding timely manner hand garbage collection get importance consider erlang immutable language nondestructive update property high rate producing garbage language memory layout digging gc essential inspect memory layout erlang process divided three main part process control block stack heap similar unix process memory layout shared heap erlang process memory layout pid status registered name process control initial call current call block pcb mailbox pointer function parameter process return address stack local variable v free space refc binary mailbox message linked list compound term list tuples process private term larger word heap procbin pointer large binary pcb process control block hold information process identifier pid process table current status running waiting registered name initial current call also pcb hold pointer incoming message member linked list stored heap stack downward growing memory area hold incoming outgoing parameter return address local variable temporary space evaluating expression heap upward growing memory area hold physical message process mailbox compound term like list tuples binary object larger machine word floating point number binary term larger byte stored process private heap called refc binary reference counted binary stored large shared heap accessible process pointer refc binary pointer called procbin stored process private heap gc detail order explain current default erlang gc mechanism concisely say generational copying garbage collection run inside erlang process private heap independently also reference counting garbage collection occurs global shared heap private heap gc gc private heap generational generational gc divide heap two segment young old generation separation based fact object survives gc cycle chance becoming garbage short term low young generation newly allocated data old generation data survived implementation specific number gc separation help gc reduce unnecessary cycle data become garbage yet context erlang garbage collection two strategy generational minor fullsweep major generational gc collect young heap fullsweep collect young old heap let review gc step private heap newly started erlang process scenario spawn gc terminate gc occurs shortlived process use heap minheapsize terminates way whole memory used process collected scenario spawn fullsweep generational terminate newly spawned process whose data grows minheapsize us fullsweep gc obviously gc occurred yet separation object young old generation first fullsweep gc heap separated young old segment afterward gc strategy switch generational remains process terminates scenario spawn fullsweep generational fullsweep generational terminate case process lifetime gc strategy switch generational back fullsweep first case certain number generational gc occurs certain number specified globally per process fullsweepafter flag also counter generational gc per process upper bound fullsweep gc minorgcs fullsweepafter property respectively seen return value processinfo pid garbagecollection second case generation gc collect enough memory last case garbagecollect pid function called manually case gc strategy reverts fullsweep generational remains aforementioned case occurs scenario spawn fullsweep generational fullsweep increase heap fullsweep terminate scenario second fullsweep gc collect enough memory heap size increased gc strategy switch fullsweep like newly spawned process four scenario occurred question matter automatic garbage collected language like erlang firstly knowledge help make system go faster tuning gc occurrence strategy globally per process secondly understand one main reason make erlang soft realtime platform garbage collection point view process private heap gc time gc occurs inside process stop erlang process collected stop process soft realtime system need shared heap gc gc shared heap reference counting object shared heap refc counter reference held object procbin stored inside private heap erlang process object reference counter reach zero object become inaccessible destroyed reference counting gc cheap help system avoid unexpected long time pause boost system responsiveness unaware wellknown antipatterns designing actor model system could make trouble case memory leak first refc splitted subbinary order cheap subbinary new copy splitted part original binary reference part however subbinary count new reference addition original binary know cause problem original binary must hang around subbinary collected known problem sort longlived middleware process acting request controller message router controlling transferring large refc binary message process touch refc message counter increment collecting refc message depends collecting procbin object even one inside middleware process unfortunately procbins pointer hence cheap could take long happen gc inside middleware process result refc message remain shared heap even collected process except middleware shared heap matter reduces io passing large binary message process also creating subbinaries fast pointer another binary rule thumb using shortcut faster cost cost well architecting system way become trapped bad condition also wellknown architectural pattern refc binary leak issue fred hebert explains free ebook erlang anger think explain better strongly recommend read conclusion even using language manages memory like erlang nothing prevents u understanding memory allocated deallocated unlike go language memory model documentation page advice must read rest document understand behavior program clever clever believe must clever enough make system faster safer sometimes happen unless dig deeper going resource external link
419,Lobsters,erlang,Erlang development,"Flake: A Decentralized, K-Ordered Unique ID Generator",http://www.boundary.com/blog/2012/01/flake-a-decentralized-k-ordered-unique-id-generator-in-erlang/,flake decentralized kordered unique id generator,click,information please fill form see domain sale click
420,Lobsters,erlang,Erlang development,"Erlang and distributed systems expert, gives his views on BEAM languages, Hindley–Milner type system",https://medium.com/this-is-not-a-monad-tutorial/eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley-a09b15f53a2f,erlang distributed system expert give view beam language type system,eric merritt erlang distributed system expert give view beam language type system new technology monad tutorial eric merritt erlang otp action joxa relx lisp flavored erlang brian mckenna roy mirageos unikernel functional geekery podcast stated erlang vm beam brilliant get right vms elang preemptive scheduler also play big part apart erlang vm beam think erlang language implemented joxa lisp erlang vm opinion lfe lisp flavored erlang think elixir think laziness programming language case think useful like type system type system used ml family standard ml caml ocaml f haskell http learnyousomeerlangcom think would possible create language hindley milner type system erlang vm without affecting power erlang semantics roy clojure coretyped think would worthwhile adding algebraic data type erlang vm using record erlang joxa tagged map elixir enough practical purpose past create client console application python ruby great building quickly however able easily generate standalone binary o architecture shortcoming language testing nim go since good cross compilation library support tried could ocaml good alternative jane street capital core async library language technology keeping eye check osv mirage bsd rump kernel system orchestration nix package manager nixos,eric merritt erlang distributed system expert give view beam language type system new technologiesin case monad tutorial interviewed eric merritt author erlang otp action joxa small semantically clean functional lisp running erlang vm relx best release creation tool erlang following week talking robert virding erlang coinventor lisp flavored erlang creator brian mckenna language mirageos unikernel dev team stay tuned functional geekery podcast stated erlang vm beam brilliant get right vms beam reasonably popular vm took language model case actor leveraged model make platform efficient find brilliant two major example approach beam garbage collector work runtime io worksin many system java included garbage collector gc must examine entire heap order collect garbage optimization like using generation generational gc optimization still optimization walking entire heap beam take different approach leveraging actor model based approach basically following tenet process run need collectedif process run ended next gc run needto collectedif end process need collected thatsingle process need stopped collection occursthose three tenet one primary reason erlang softreal time system elang preemptive scheduler also play big part fact model subset work gc allows work remain small manageable impressive achievementanother big win beam approach leveraging erlang actor model leverage low level efficient nonblocking asyncronous io primitive operating system io present comfortable blocking interface language layer developer using platform use human understandable synchronous io primitive gaining advantage asyncronous io impressive achievement gave talk topic seattle scalability meetup apart erlang vm beam think erlang language think bad language benefit declarative simple big win distributed system complexity composes quickly becomes unmanagable tend prefer language algebraic type system type inferencing reasonable meta programming capability erlang neither unfortunate said implemented large number reliable system erlang hesitate againyou implemented joxa lisp erlang vm working problem best solved via suite dsl platform built based erlang beam erlang really lend dsl decided write joxa facilitate dsl development beam happens creating dsl problem generally good idea make joxa decent general purpose languagewhat opinion lfe lisp flavored erlang joxa took different direction lfe even though lfe predated quite time ran problem caused joxa created investigated rather deeply see would solve problem ran issue investigating general found implementation hard follow bad implementation different way think language confounded made difficult expand iti also looking something simple semantics could build language lfe quite literally lisp flavored erlang erlang sexpression based syntax problem unless looking something much lower level syntax build upon finally really nitpick macro interpreted lfe interpreter limited rest language interpreted beam remember something going run inside macro interpreter inside normal runtime bothered lotand think elixir think elixir brought lot people erlang world otherwise come good thing powerful contribution erlang ecosystem however big fan elixir find macro system bit inconsistent really dislike elixir try hide immutability make slightly easier beginner leaky abstraction immutability eventually bleeds think also introduces additional complexity within binding elixir macro among thing help never fan ruby syntax elixir borrows heavily spherewhat think laziness programming language case think useful love lazyness concept think idea computation occurs needed right line trend occurring functional programming many decade problem lazyness pragmatic easy create space leak writing good tool detect debug space leak yet exist make hesitant use language lazy default production haskell guy working hard resolve think yetwhy like type system type system used ml family standard ml caml ocaml f haskell image stolen http learnyousomeerlangcomessentially lazy much like resource management contract management slow manual painful process contract management mean verifying form data function recieves form data expects hindleymilner style type system allows offload tedious work compiler computer essentially better kind tedious work humansa type system like evolution ongoing effort offload work computer originally wrote machine code moved assembly one step higher long started using higher level language like fortran cobol lisp bit later started offloading resource management computer well form gc algebraic type system continuation type system offloading contract checking computer like resource management contract checking must happen many language force human compiler much effectivelydo think would possible create language hindley milner type system erlang vm without affecting power erlang semantics think possible planning time limiting factor main problem run mismatch untyped bit erlang native system typed bit new language dialyzer attempt solve success typing may better way something like roy programming language try meld javascript semantics feature common static functional language type system clojure coretyped sure fun solvable problemdo think would worthwhile adding algebraic data type erlang vm using record erlang joxa tagged map elixir enough practical purpose type system little vm much language usually compile time thing rather runtime thing might actually useful add simply beam take advantage type annotation run optimized version code especially helpful effort run well typed language top vmin past create client console application python ruby great building quickly however able easily generate standalone binary o architecture shortcoming language testing nim go since good cross compilation library support tried could ocaml good alternative tried either nim go unfortunately used python extensively ruby well though lesser extent also used ocaml extensively type work find like ocaml best like reason talked said different shell programming approach take bit getting used also note vast majority work ocaml conjunction jane street capital core async librarieswhat language technology keeping eye check seen new language pop recently grabbed interest technology think microkernels interesting thing like osv jvm based language mirage ocaml bsd rump kernel rest think going become fundamental building block system orchestration near future thing keep eye nix package manager nixos technology like atlas hashicorp going much longer declaratively describe system well code looking forward
421,Lobsters,erlang,Erlang development,"asdf - extendable version manager for Ruby, Elixir, Erlang & Node.js",http://github.com/HashNuke/asdf,asdf extendable version manager ruby elixir erlang nodejs,asdfvm manage multiple runtime version single cli tool extendable via plugins doc asdfvmcom use asdfvm documentation please head documentation site information contributing contributingmd repo contributing section doc site community question github issue stackoverflow tag,asdfvm manage multiple runtime version single cli tool extendable via plugins doc asdfvmcom asdfvm cli tool manage multiple language runtime version perproject basis like gvm nvm rbenv pyenv one simply install language plugin use asdfvm single cli multiple language consistent command manage language single global config keeping default one place single toolversions config file per project support existing config file nodeversion nvmrc rubyversion easy migration automatically switch runtime version traverse directory simple plugin system add support language choice shell completion available common shell bash zsh fish documentation please head documentation site information contributing see contributingmd repo contributing section doc site community question github issue report bug raise feature request asdf core team stackoverflow tag see existing q asdf core team watch tag addition helpful community
423,Lobsters,erlang,Erlang development,Elixir in times of microservices,http://blog.plataformatec.com.br/2015/06/elixir-in-times-of-microservices/,elixir time microservices,martin fowler entry topic background elixir application application process process phoenix communication location transparency start breaking monolithic application umbrella project mix otp guide microservices elixir good building distributed system getting started guide many learning resource wrapping jamie windsor talk erlang factory able leverage build game platform plug phoenix,since microservices common topic lately lot question elixir fit microservice architecture post focus merit microservices many already discussed exhaustion particular martin fowler entry topic aligns well thought definitely worth reading also worth mentioning seen many company pursuing microservices fail organize large application tooling language framework provide good abstraction manage microservices often seen solution structuring code imposing separation concern top bottom unfortunately prematurely adopting microservices often negatively impact team productivity therefore also important language framework provide proper abstraction handling code complexity codebase grows background elixir concurrent distributed programming language run erlang virtual machine erlang vm focusing productivity maintainability go microservices would like first argue elixirerlang may best platform developing distributed system regardless microservices architecture erlang vm standard library designed ericsson building distributed telecommunication system decision done past continue relevant day explore far know erlang runtime virtual machine used widely production designed upfront distributed system application elixir runtime notion application elixir code packaged inside application started stopped unit elixir node virtual machine instance run series application elixir one starting stopping system matter starting application provide unified directory structure configuration api worked one application know structure configure one contains application supervision tree process state throughout post process mean lightweight thread execution managed erlang vm cheap create isolated exchange information via message impact application project highly beneficial mean elixir developer writing application given explicit approach code started stopped contained isolated inside application process make part application therefore application state introspect application tree introspect process therefore component make application application process react affected case crash something go wrong tooling around application great elixir installed open iex type observerstart besides showing information graph live node kill random process see memory usage state example running phoenix application see application part node left side clicking application show process tree application doubleclicking process open window information process function executing particular state furthermore kill process see impact system compared language difference application process give abstraction reason system production many language provide package object module mostly code organization reflection runtime system class attribute singleton object reason code manipulates memory leak bottleneck find entity responsible visibility one major benefit building system elixir ask anyone running distributed system kind insight want elixir building block communication building distributed system need choose communication protocol data serialized although many option unfortunately lot developer choose http json verbose expensive combination performing end becoming rpc call elixir already communication protocol serialization mechanism box via distributed erlang want two node communicating need give name ensure share secret cookie done elixir process communicate via message passing runtime provides feature called location transparency mean really matter two process node different one still able exchange message wrote quick introduction elixir cover get started elixir creating brand new project node communication start check information distributed erlang protocol serialization mechanism also documented therefore used communicate language erlang vm ship binding java others found python go breaking monolithic application earlier mentioned seen many company pursuing microservices fail organize code project level often prematurely split architecture microservices affect productivity short long run martin fowler article elixir breaking large application smaller one simpler anywhere else process tree already outline dependency communication dependency always happen explicitly via message passing example imagine application called abc grown larger time break apart application b c extracting supervision tree different application common aspect working elixir project build tool called mix provides feature called umbrella project project composed many application may depend fashion umbrella project allows compile test run application unit also perform task required quick example mix new abc umbrella cd abcapps mix new mix new b sup mix new c sup snippet creates new umbrella project enters apps directory create three application b c last two contain supervision tree run mix test abc project root compile test project still go inside application work isolation main application abc broken apart may also move part separate repository desired may benefit developer able handle growing code complexity small granular step without making large decision upfront cover detail mix otp guide microservices far talked microservices point really matter already designing system around tiny process isolated distributed call nanoservices like process packaged application group entity started stopped unit combined distributed erlang want deploy b c application b c b c little trouble due inherent design builtin communication word focus deploy application based driving break apart code complexity work separately still deploy unit scability multitenancy reason c requires instance application user specific concern reasonable isolate deploy multiple instance c elixir good building distributed system familiar elixir reading far may wondering elixir good building distributed system elixir excellent building kind long running system exactly insight application even deployed single node language also expressive pleasant learn work certainly biased though getting started guide many learning resource already available learning curve abstraction outlined elegant simple tooling excellent job guiding build first application command mix new myapp sup executed generate application process tree directly use explore learn wrapping hope illustrated design decision done elixir erlang vm provide great foundation building distributed system also exciting see company starting enjoy explore characteristic elixir programming language particular worth watching jamie windsor talk erlang factory able leverage build game platform finally lot post focus building system distributed erlang although distributed erlang definitely productive approach reason leverage benefit outlined using elixir another protocol like apache thrift end day want use http json fine library like plug framework like phoenix guarantee productive anywhere else enjoying performance characteristic robustness abstraction outlined happy coding note covered technique like bluegreen canary deployment depend system communication protocol running elixir provides convenience process grouping global process shared node still use external library like consul zookeeper service discovery rely haproxy load balancing http based frontends
424,Lobsters,erlang,Erlang development,Flow-based programming and Erlang message passing - A biology-inspired idea of how they fit together,http://bionics.it/posts/flowbased-vs-erlang-message-passing,flowbased programming erlang message passing biologyinspired idea fit together,think erlangelixir fit great control plane servicetoservice messaging layer distributing service built flowbased programming erlang user conference erlang elixir language flowbased programming flowbased programming erlangelixir seems like great fit peter c mark elixirfbp talk paul butcher slide video presented tweet info page talk difference paradigm hipe vm news otp team session benchmark bunch language edit slowness turn disputed see note v top page erlang great control plane embedded erlang talk learn advanced information system know human cell b dna rna protein processing chain implemented human cell celltocell signalling robust signalling outside safe predictable nature within cell wall implemented biological system learn inside conclusion flowbased programming erlangstyle message passing note hackernews flowbased programming mailing list note ii blogged comment check elixirfbporg note iii meetup page improvement code example,think erlangelixir fit great control plane servicetoservice messaging layer distributing service built flowbased programming back one day visit erlang user conference find erlang virtual machine fascinating new elixir language built top fix pain point erlang language ecosystem got even interesting find exciting erlangelixir virtual machine ability utilize multiple cpu computer across multiple computer commonly referred distributed computing flowbased programming fbp often pitched basically purpose good running thing parallel general two paradigm compare flowbased programming erlangelixir seems like great fit hard think flowbased programming paradigm multiple black box process talking channel erlang messagepassing model highly isolated process sending message mail box process would lot overlap functionality one would think architecture one system easy enough implement system actually least one project trying implement fbp elixir peter c mark elixirfbp project worth checking looking closer turn number challenge though eg backpressure easily supported implicitly erlangelixir fbp language boundedbuffer channel provide implicit backpressure blocking sends outport connected buffer full implementing something like channel bounded buffer fbp elixir would require another process channel would mean another copying step bad performance also bit different behavior process connected fbp process explicitly connected channel named inoutports process erlangelixir hand process send message single mailbox recipient process filtering multiple routing happening code applied single mailbox thus implement general way something like fbpstyle inports outport would probably require creating even specialized erlangelixir process maybe need one inportoutport would mean even data copying architectural difference way something touched upon highly recommended talk paul butcher last year see slide video one thing still wondering though whether overhead copying might big problem since pipeline parallelism elixir josé presented see original tweet info page talk slide video show difference paradigm anyways whole set aspect make fbp erlang vm quite different though example despite great work hipe vm compiled erlang code work going jitcompilation erlang mentioned news otp team session erlang current state kind slow many type computation scalable yes slow example tried simple string processing algorithm elixir recently used benchmark bunch language found elixir something like time slower unoptimized vanilla python task around time slower compiled language task sincerely hope serious mistake make slow edit slowness turn disputed see note v top page hand erlang vm truly outstanding come aspect crucial distributed multicompute node computing process isolation faulttolerance inspectability hot codereloading much erlang great control plane mean typically want use erlang thing like control plane distributed system actual computation part optimally implemented something faster c computation demand large costenergy efficiency also importance combining erlang faster language actual processing actually exactly done company erlang born first place ericsson embedded erlang talk anders danne ericsson revealed detail interesting project resulted new product base station erlang control plane real crunching code implemented inwith c fpga learn advanced information system know human cell lead idea think two paradigm best fit together even strengthen case let also take example amazing information system implemented human body biology full information system different scale two strike excellent example item play post dnatornatoprotein information processing chain commonly known central dogma b celltocell signalling dna rna protein processing chain dna rna protein processing chain lowlevel intricate chain information processing happens partly cell nucleus partly space outside nucleus still within cell wall requires exceptional performance since large amount information need poured short time process might kick concentration certain molecular machine known enzyme need quickly increase example eaten enzyme breaking certain food product need processed specialized enzyme implemented human cell well think word fall short describing amazing process let watch little minute animation instead video see molecular machine producing long stream information eg mrna strand continuously reading another stream information eg dna strand thing protein strand mrnastrands nt know look lot like flowbased programming highly optimized process physical proximity molecular letter stitched together strand stream information processed streaming mode molecular machine another stream information celltocell signalling robust signalling outside safe predictable nature within cell wall celltocell signalling contrast dna rna protein processing chain involve le amount information could still least significant since highlevel form communication heavily dependent shared context cell sending receiving cell share much common knowledge immediately able interpret received message correctly even actual message contains little amount shannon information compare eg group swat soldier made detailed plan attack positioning awaits simple go message via radio go message contain hardly one bit information measured shannon information metric due high amount shared context information among soldier highly significant message trigger detailed plan precisely right time thus computational requirement le demanding hand requirement robustness failure since signalling molecule leave cellular wall environment le reliable predictable implemented biological system let look animation example process rather trying explain step detail video video show one specific cell signaling pathway called basic principle hold many pathway signaling molecule excreted one cell interacts receptor surface another cell actually span cell wall trigger chain reaction inside recipient cell thing like robustness handled especially executing excess signaling molecule probably reach receptor cell learn learn two biological information processing example well idea including example two different solution information processing problem different scale cell dna rna protein processing chain heavy lifting translating high amount structural information molecular machine produced various celltocell signaling pathway kind alerting system cell notify various state change behavior needed nearby cell due eg something happening closeby area personally think interesting match two information system two information processing paradigm discussed article erlang style message passing flowbased processing see match like dna rna protein processing chain flowbased programming celltocell signaling erlang style message passing one celltocell signaling aimed synchronizing state nearby cell dna rna protein chain heavy lifting processing large amount data inside cell first one loose process signaling molecule released excess chance eventually reach receptor surface nearby cell initiate kind response would compare situation tcpip network predictability really within safe wall cpu would robustnessincreasing feature erlang really shine dna rna protein processing chain hand strict requirement performance tight even physical coupling input data processing machinery output data placement data stream strand biological term mean pulling information item nucleotide processing machinery next item process automatically pulled would streamprocessing nature flowbased programming really shine conclusion based study biological information system would suggest flowbased programming well suited high performance heavy lifting within one microservice similar unit comparable biological cell erlangstyle message passing perfect paradigm communication service maybe like ericsson using erlang control plane c fpga code maybe erlangelixir used control plane microservices built highly optimized flowbased programming principle maybe would even simultaneously solve erlang performance problem solving flowbased programming problem robustness large distributed system well one speculate least yeah also test practice note interesting discussion post happening hackernews flowbased programming mailing list note ii elixirfbp creator peter c mark blogged comment post discussion triggered check elixirfbporg note iii slowness erlangelixir mention disputed see discussion meetup page particular johan lind improvement code example
425,Lobsters,erlang,Erlang development,Understanding Erlang's time correction mechanisms,http://learnyousomeerlang.com/time,understanding erlang time correction mechanism,postscript time go leap second ntp note time warp,hey appears javascript disabled fine site work without however might prefer reading syntax highlighting requires javascript postscript time go time tricky thing physical every day world least one certainty time move forward generally constant rate start looking fancypants physic anything relativity involved fancypants time start drifting shifting around clock plane go slower clock ground someone nearing black hole age different speed someone orbiting moon unfortunately programmer computer people need nifty phenomenon like involved time go weird clock computer great spring forward spring backwards stall accelerate get leap second get readjusted distributed system different processor run different speed protocol ntp play around time correction may crash time therefore need leave room computer time dilate ruin understanding world even single computer possible time move frustrating way reliable context erlang care lot time want low latency specify timeouts delay millisecond almost every operation socket message receiving event scheduling also want fault tolerance able write reliable system question make something solid unreliable thing erlang take somewhat unique approach since release seen interesting evolution release erlang time work one two major way operating system clock represented tuple form megaseconds second microsecond o timestamp virtual machine clock represented tuple form megaseconds second microsecond erlang autoimported operating system clock follow pattern whatsoever move however o feel like moving vm clock move forward never return value twice property named strictly monotonic order respect property requires coordinated access erlang process whenever called twice row close interval time gone backwards vm increment microsecond make sure value nt returned twice coordination mechanism acquiring lock whatnot act bottleneck busy system note monotonicity come two main flavor strict nonstrict strict monotonic counter clock guaranteed return always increasing value always decreasing value sequence strictly monotonic regular nonstrict monotonic counter otherwise require return nondecreasing value nonincreasing value sequence monotonic strictly monotonic time never go back useful property many case enough one common one encountered people programming erlang home laptop sitting computer running erlang task frequent interval work well never failed one day hear chime ice cream truck outdoors put computer sleep running outdoors grab something eat minute come back wake laptop everything start exploding program happened answer depends time accounted counted cycle seen n instruction fly cpu second could fine counted looking clock wall going gee golly last time went past going sleep would hurt lot task expected run every second hand use cycle keep stable never really see clock program synchronize underlying operating system mean either get accurate value accurate interval reason erlang vm introduces time correction time correction make vm timer bit receive erlang erlang along timer module dampen sudden change adjusting clock frequency go slightly faster slower instead seeing either curve would see time correction version prior undesired turned passing c argument erlang vm model seen version prior fairly good ended annoying specific way time correction compromise skewed clock inaccurate clock frequency would trade accelerated slowed frequency order get closer proper o time avoid breaking event clock corrected slowly could inaccurate clock inaccurate interval long period time people used wanted monotonic strictly monotonic time useful order event people used wanted unique value lifetime given node time megasecs sec microsecs annoying remnant time bigger integer impractical vm represent converting proper time unit pain good reason use format erlang integer size backwards leap time would stall erlang clock would progress microsecond time call general problem two tool o timestamp fill following task find system time measure time elapsed two event determine order event tagging event create unique value made clearer exploding time erlang multiple component starting o system time also known posix time o monotonic time operating system provide nt tends fairly stable available avoids leap time erlang system time vm take posix time vm try align posix may move around bit depending chosen strategy strategy described time warp erlang monotonic time erlang view o monotonic time available vm monotonic version system time available adjusted clock used event timer stability make ideal count time interval note time monotonic strictly monotonic meaning clock ca nt go backwards return value many time time offset erlang monotonic time stable source authority erlang system time calculated given offset relative erlang monotonic time reason allow erlang adjust system time without modifying monotonic time frequency visually offset constant vm monotonic system time offset modified positively negatively erlang system time may made match o system time erlang monotonic time left independent practice possible monotonic clock large negative number system clock modified offset represent positive posix timestamp new component another use case remains unique value always increment high cost function due necessity never return number twice mentioned earlier erlang monotonic time strictly monotonic possibly return number twice called time two different core example comparison would nt compensate strictly monotonic number generator added vm time unique integer could handled separately new component vm exposed user following function erlang monotonictime erlang monotonictime unit erlang monotonic time may return low negative number never get negative erlang systemtime erlang systemtime unit erlang system time offset applied erlang timestamp return erlang system time megasecs sec microsecs format backwards compatibility erlang timeoffset erlang timeoffset unit figure difference erlang monotonic erlang system clock erlang uniqueinteger erlang uniqueinteger option return unique value option list contain either positive force number greater monotonic always grow larger option default mean integer unique might positive negative greater smaller previous one given erlang systeminfo ossystemtimesource give access tolerance interval value o system time erlang systeminfo osmonotonictimesource o monotonic clock tolerance interval value fetched unit option function either second millisecond microsecond nanosecond native default type timestamp returned native format unit determined run time function convert time unit may used convert erlang converttimeunit second native meaning linux vps unit nanosecond actual resolution may lower possible millisecond accurate nonetheless natively work nanosecond last tool arsenal new type monitor usable detect time offset jump called erlang monitor timeoffset clockservice return reference time drift message received change monitorref timeoffset clockservice newtimeoffset time get adjusted get ready time warp old style erlang stuff would make clock drift faster slower matched whatever o gave okay keep semblance real time clock jumped around also meant time event timeouts would occur faster slower small percentage across multiple node also single switch vm c disabled time correction altogether erlang introduces distinction thing done make lot powerful complex whereas version prior time drift meaning clock would accelerate slow introduced time correction thing called time warp basically time warp configured c choosing offset therefore erlang system time jump around stay aligned o time warp time jump time correction configured c erlang monotonic time behaves o monotonic clock jump two strategy time correction three time warp problem time warp strategy chosen impact time correction impact therefore end stunning possible behaviour make sense following table might help c notimewarp c true work exactly time warp jump clock frequency adjusted compensate default backwards compatibility c false o system time jump backwards erlang monotonic clock stall o system time jump back forward take c multitimewarp c true erlang system time adjusted backwards forward via offset match o system time monotonic clock remain stable accurate possible c false erlang system time adjusted backwards forward via offset time correction monotonic clock may pause briefly without freezing long c singletimewarp special hybrid mode used embedded hardware know erlang boot o clock synchronized work two phase c true system boot monotonic clock kept stable possible system time adjustment made c false notimewarp user call erlang systemflag timeoffset finalize erlang system time warp match o system time clock become equivalent notimewarp whew short best course action make sure code deal time warping go multi time warp mode code nt safe stick time warp find system time erlang measure time difference call erlang twice subtract define absolute order event node erlang uniqueinteger monotonic measure time make sure absolute order defined erlang monotonictime erlang uniqueinteger monotonic create unique name erlang uniqueinteger positive couple node name want value unique cluster try using following concept code fine use multi time warp mode time correction enabled benefit better accuracy lower overhead information hand able drift warp time
426,Lobsters,erlang,Erlang development,Erlang Programming Language Erlang/OTP 18.0 has been released,http://www.erlang.org/news/88,erlang programming language erlangotp released,http githubcom http http http http http http wwwerlangorgdoc,erlangotp service release track mostly bug fix contain number new feature characteristic improvement well highlight release ssl add possibility downgrade ssltls connection tcp connection give back socket control user process ssh following new key exchange algorithm implemented raise security level considerably kernel stdlib sasl mechanism limiting amount text builtin error logger event produce introduced useful limiting size log file cpu time used produce mechanism experimental sense may changed based feedback see config parameter errorloggerformatdepth kernel application find release note detailed info http note unpack tar archive need gnu tar compatible program installation instruction please read readme part distribution also find source code githubcom official erlang repository git tag http window binary distribution downloaded http http also download complete html documentation unix manual file http http also read documentation online see release note mentioned release note updated doc new functionality http wwwerlangorgdoc also want thank sent u patch suggestion bug report erlangotp team ericsson
427,Lobsters,erlang,Erlang development,How I Start Erlang updated with rebar3,http://www.howistart.org/posts/erlang/1,start erlang updated,erlang intro installing erlang download follow instruction environment ohmyzsh custom theme hgprompt vimerl erlangmotions blog post example project prototype making library otp application configuration value provide guarantee regarding state supervisor bridge muumuufsmerl module publish library hex package proper plugin release email protected test common test github dependency code,written fred hebert june erlang intro erlang release bit like magnet everyone think share thought f king release work fortunately since year emakefiles reltool systools erlang community stood improved tooling continuously rebar improving nonstop keep getting better many function newest generation try provide endtoend experience building erlang project along installing erlang version least getting hold gon na need rebar download follow instruction basically generate selfexecutable store repository install globally computer tutorial expects installed system made available path installed somewhere system arm text editor ide choice mine vim terrible person get ready write thing environment despite free develop whatever want gon na go whatever setup use zsh ohmyzsh using custom theme depends hgprompt script stuck vimode vim vim vim vim work erlang use two line vimrc file autocmd bufread bufnewfile erl e hrl yaw xrl set expandtab au bufnewfile bufread erl e hrl yaw xrl setf erlang depend two plugins vimerl erlangmotions use lot material outside o tend ide project tend work lot use tmux script see blog post example get everything going early project avoid usual hello world stuff tutorial use somewhat fun application get running basic erlang app run within module proper otp library included project release selfexecuting distributed client computer server project replication one wellknown software program popular history used lifecritical situation homer simpson console episode fat work home episode infer following software program boot asks press key program ask question answered yesno also yn yn question turned command assertion equivalent answering given question positively example vent radioactive gas yesno turned vent gas command nothing go wrong keep pressing time given delay new question asked many time without venting radioactive gas risk exploding everything behaviour defined tv show go somewhat anyway feel like finitestate machine created one follows explains understood possible notice really good consistent notation event state press key key pressed check core temperature first yesno venting radioactive gas first yes gas blow away crop venting prevents explosion yes v wait command get data timeout ask question yes show result based able draw first prototype required state transition also looked transcript show extracted following question consequence check core temperature yesno yes core temperature normal vent radioactive gas yes gas blow away corn crop venting prevents explosion allow yes show first time sound alertness horn yes horn sound distance decalcify calcium duct special case denying venting many time valve must disabled manually simplest way write basic fsm one use bunch function call given erlang last call optimization call happens return value leave stack trace therefore happen infinitely many time adequate sequence state b c programmed b b c c done course going data case prototype glorious application called muumuu whenever exactly know going decide prototype stuff stress importance prototype despite fact often end production yeah avoided decide start basic stuff prototype state transition go fairly simple manner topdown module muumuufsm export define maxnovent start seed prng crypto randbytes random seed b c waitanykey state transition waitanykey io getline start press keyn firstcorecheck firstcorecheck case option check core temperature yes coretemperature noop end firstgasvent firstgasvent case option vent radioactive gas yes blowcropsaway ventingpreventsexplosions end waitforcommand waitforcommand case waitcmd timeout opt yes randomoption case option opt yes yes end cmd case matchoption cmd yes yes noop end end waitforcommand bit code see main state waitanykey firstcorecheck firstgasevent waitforcommand rest code le going event input management check transition printing question getting response eventually waiting command take long generate option randomly look code find whatever want disgusting general idea want code time add option management stuff option response handling option prompt showoption prompt data io getline case iolisttobinary data binary yes binary yes n binary n binary ambiguous end showoption str io format yn n str waitcmd timeout parent self pid spawn fun parent io getline end receive data data timeout exit pid kill timeout end randomoption po random uniform tuplesize opts val element po opts val matchoption data case vals pattern vals tupletolist opts nomatch run data pattern caseless opt opt invalidopt end cool fantastic looking yet basically option fetch line text entered user look first response return showing option wrap thing look like prompt interestingly enough command waited different process problem erlang standard library support timeout mode io operation would tell u wait second input quit therefore need move process rest relies elusive opts function apparently return question option offered user defining optionsevents opts checkcoretemp check core temperature fun fun ventradgas vent radioactive gas fun fun soundalerthorn sound alertness horn fun fun calcduct decalcify calcium duct fun fun basically tuple use tuple make random selection fixed position efficient question positive negative response consequence paired regular expression represents fuzzy matching example someone typing check temperature match check core temperature question return option code back execute function finally action consequence implemented noop ok ventingpreventsexplosions case option venting prevents explosion yes blowcropsaway noop end coretemperature io format core temperature normaln blowcropsaway io format gas blow away corn crop n soundhorn io format horn sound distance n pressuretoohigh io format pressure high tank must shut manuallyn ventgas maxnovent pressure shut manually unsupported program case get missed maxnovent pressuretoohigh put missed blowcropsaway end noventing case get missed undefined put missed n put missed end two last function implement special last requirement denying venting many time valve must disabled manually use dirty ugly counter prototyping sake fact forgotten requirement time bolted way prototype helped figure requirement final version designed mind run code try shell λ erlc srcmuumuufsmerl erl muumuufsm noshell start press key check core temperature yn n vent radioactive gas yn venting prevents explosion yn yes gas blow away corn crop sound alertness horn yn horn sound distance work using module run function module using noshell make erlang vm fight io call user input ownership sadly implementation kind ugly go production making library two way make something reach production distributing distributing library erlang developer use latter prerequisite former going start default everyone using erlang open source community us otp application otp kind often treated super advanced topic gon na show take nonotp compliant code turn otp application fun fun first directory structure src muumuufsmerl need term structure installed system add file src called muumuuappsrc file basically telling erlang library application muumuu description fat go power plant app vsn registered application kernel stdlib crypto mod muumuuapp env registered entry specifies process going globally registered node case none application tuple list application depend application depend kernel stdlib entry always hand crypto optional apps need use seed pseudorandom number generator env tuple contain configuration value need none right option considered mod library requires process started shipping code around done case however starting process want therefore specify application module named muumuuapp module also src module muumuuapp behaviour application export start type args muumuusup startlink stop ok module basically giving callback erlang vm see bit main function c except also provide stop function clean process exit case need nothing muumuusup module final step glued otp otp concept called supervisor supervisor charge checking otpcompliant process start stop provide guarantee regarding state unfortunately process otpcompliant guy ericsson long ago hit problem developed supervisor bridge basically act wrapper could use kind person want otp process done correctly everywhere time stick regular supervisor rewrite fsm right module muumuusup behaviour supervisor export export startlink supervisor startlink module init ok oneforone console muumuufsm startlink permanent worker muumuufsm start muumuufsm permanent worker die every second entire system crash good way pick frequency second sound like something reasonable someone mash key way bad enough cause error come rewrite prototype genfsm stuff covered multiple tutorial going skip instead look book doc genfsm follow along final module muumuufsmerl see biggest change outside providing genfsm callback required otp behavior related general information flow rather really direct sequence function whatever want otp version module becomes lot declarative longer enter state function ask question wait response within context logic moved event state say firstgasvent cause question asked transitioning state handle response make code particulalry harder read different init crypto randbytes random seed b c ok waitanykey prompt waitanykey state waitanykey state nextstate firstcorecheck prompt firstcorecheck state firstcorecheck state nextstate firstgasvent prompt firstgasvent state firstcorecheck yes state showcoretemperature nextstate firstgasvent prompt firstgasvent state firstgasvent state statename ventingpreventsexplosions nextstate statename prompt statename state firstgasvent yes state showblowcropsaway nextstate waitforcommand prompt waitforcommand state form along experience gained prototype allows simpler state management via state variable allows u transparent usage venting limit example also instantly benefit everything otp give u term transparency tracing logging statistic see sys module code place compile run entire application λ compile verifying dependency compiling muumuu compiled run funky command λ erl env erllibs builddefaultlib eval application ensureallstarted muumuu noshell start press key check core temperature yn core temperature normal vent radioactive gas yn gas blow away corn crop kind ugly command run app app something people use pull within system order run actually ship customer need build release case though may want publish library hex package help proper plugin release directory structure using application turn looking like src ebin simplest level release basically group application put together reason change directory structure bit apps muumuu src ebin rebarconfig application need go apps moved src appsmuumuu rebarconfig file look like relx release muumuu list apps include muumuu nt ship erlang vm default includeerts false profile called prod command prod relx override relx specifically includesrc false nt include source code includeerts true include vm release basically tell releasebuilding tool includes relx give u release release include custom erlang code use currently installed erlang vm run thing rather installing fully selfcontianed program magic happens λ release verifying dependency compiling muumuu starting relx build process resolving otp application directory resolved release successfully created release born run λ builddefaultrelmuumuubinmuumuu noshell start press key pretty cool shipped distributed people want make release bit fancier though seen still need put noshell hand totally unacceptable fix add config repository open vmargs file vim show programmed prompt noshell remote access debugging name email protected needed smp disable argument merged one good practice erlang system give name let connect running case could go debug console user maintaining powerplant last argument smp disable basically optimization app remove erlang parallelism running single active process thing bother remove number asynchronous thread io single one reason one active process bother serious apps tweaking vm option worthwhile outside text scope config file need update relx release muumuu list apps include muumuu nt ship erlang vm default includeerts false vmargs configvmargs profile called prod command prod relx override relx specifically includesrc false nt include source code includeerts true include vm release last line profile new one compile argument implicitly passed node λ release verifying dependency compiling muumuu starting relx build process resolving otp application directory resolved release successfully created λ builddefaultrelmuumuubinmuumuu start press key tab check core temperature yn cool everything work binary executable link anywhere system require magical argument work test much like try get testing done ahead time time super terrible crappy often end adding fact know maintain app test add test directory appsmuumuu tool choice common test kind full annoying overhead unit testing mostly useless shell output got ta deal html file scale fairly well integration system test test suite going muumuusuiteerl module muumuusuite includelib commontestincludecthrl compile exportall copypasting suite record state pid yes demosession first gon na make one runthrough test testing muumuu going hard purely sideeffectful application going say trick getting working use meck pretty much best codemocking application around adding meck done declaring rebarconfig dependency profile test deps meck called prod command prod note rather toplevel deps entry usually would define one test profile allow dependency fetched used running test avoid bundling shipping application pull stuff package repository one github dependency also option add lock file fetch compiles later back muumuusuite time set state initpertestcase demosession config mockio ok pid muumuufsm startlink pid pid config endpertestcase config meck unload io pid config pid config unlink pid exit pid shutdown waitfordeath pid mocking io system fun way basically take make return message look take place mockio place start muumuu instance directly application needed mockio one mock io system instead printing message getting input user instead messagepassing interface inspectable note io module precompiled vm unstick first careful keep mocked little possible parent self code unstickdir filename dirname code whereisfile iobeam meck new io passthrough nolink meck expect io format fun str parent str ok end meck expect io format fun str args parent iolib format str args ok end meck expect io getline fun prompt parent self receive parent end end ugly first step unstickying directory erlang code module require erlang standard library unstickying allows load new version code run time meck dynamically mocking function io io io send message form msg msg input output respectively meck unload io undo also call using everywhere test timer enemy good concurrent testing rely timer sleep sort make sure everything clean wrong function poll return asap tiny sleep heat room much via cpu waitfordeath pid case isprocessalive pid true timer sleep waitfordeath pid false ok end done start planning test something always want write library maybe day right redo crap hand every time test case pressing given key messagepassing interface yield expected output prompt waiting key state cycled using yn answer demosession config pid config pid config press key tab character nt matter check core temp temperature normal vent radioactive gas venting prevents explosion yes gas blow crop genfsm sendevent pid timeout force timeout faster yn question care vent gas force command gas blow crop basically write test way want look like start expecting message match regex press key output insert tab rinse repeat desire pretty much turn interaction write shell bunch function call match planned messagepassing interface write function wrap functionality helper input receive pid pid self input ct pal mbox p processinfo self message error toolong input end look back mocked function mocked function sends u processthatwaitsforinput take input argument send back mocked function run process never receive message crash printing debugging information interestingly function use ct pal work exactly like io format except output shell html log common test gon na used production system surely never going mocked unlike io helper slightly complex fuzzily match input string waiting expected receive prompt ct pal expected pnprompt p expected prompt match run prompt expected dotall caseless global ct pal mbox p processinfo self message error toolong expected end one make assertion regular expression rest similar receive output match go run test λ ct ct verifying dependency fetching meck pkg meck compiling meck compiling muumuu running common test suite test output omitted test passed check rebar lock file version control go something else pretty much done see code
429,Lobsters,erlang,Erlang development,Michał Ślaski - 'Lessons from Erlang VM' ElixirConf EU 2015,http://www.youtube.com/watch?v=TkCftBMJyy0,michał ślaski lesson erlang vm elixirconf eu,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature michał ślaski lesson erlang vm elixirconf eu youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature michał ślaski lesson erlang vm elixirconf eu youtube
430,Lobsters,erlang,Erlang development,What makes erlang scalable?,http://erlang.org/pipermail/erlang-questions/2015-May/084509.html,make erlang scalable,erlangquestions make erlang scalable jesperlouisandersen redacted yashgt redacted http information erlangquestions mailing list,erlangquestions make erlang scalable jesper louis andersen jesperlouisandersen redacted sun may cest sat may pm yash ganthe yashgt redacted wrote think good question let try answer one one working article describing fundamental technology used scalable system first come definition scalable mean setting usually add load system system behavior change usually scalable meant understood noticeable change add load change behavior graceful degradation system normal operating capacity simultaneous user add load simultaneous user expect processing either stay become roughly time slower user nt expect system fail user take time much processing time sudden making sure know exactly measurable quantity concerned scaling system important implementation erlang make scalable make able run concurrent process efficiently technology like java concurrent process take resource resource process take le erlang beam vm pretty efficient million process naive javasolution based thread quickly come trouble running resource furthermore thread overhead typically larger process overhead beam vm however implement central aspect erlang vm top java jvm give capability see instance erjang project yield many advantage idea roughly keep process userspace involve kernel map number process scheduler onto thread toward kernel n threading architecture relation functional programming parallelization declarative syntax erlang achieve runtime efficiency execute part program parallel need least two independent task computed without depending directly would allow u spread work two core parallel section utilize core principle functional program without sideeffects tends expose many place independent task identified principle mean easy way turn sequential program parallel one lure functional programming paradigm wrt parallel execution nt limited functional programming however logic programming prolog mercury also highly amenable parallel execution model look like actor model also amenable actor execute independently interestingly erlang nt employ functional programming parallel methodology rather one based actorlike model part erlang runtime try run list comprehension f x x list parallel currently though many case could done process state make heavy thousand concurrent user spawn equal number process genserver equivalent pattern process would maintain state many process drain ram erlang process grows dynamically around kilobyte memory practice proven quite efficient even large number process corresponds around gigabyte memory one million process currently server environment hardly problematic drain small embedded device problem want run million process even space ram getting cheaper every day process make db operation spawn multiple instance process eventually db become bottleneck happens even use traditional model like apachephp almost every business application need db access gain using erlang key difference keep part computation memory push back db whenever want classical php application state lost invocation suppose implementing server keeping track chess game php would store chess game state db move made erlang keep state inmemory process every time minute pas send message db asynchronously telling move made meantime lower load db considerably fact control load db dynamically optimizing interval store data back database php solution would able track inapplication state redis memcached mean would still retrieve state another unixprocess whenever wanted move usually waste resource process restart help process crash something wrong logic data otp allows restart process logic data change would process crash keep crashing always gist nondeterministic error many error distributedasynchronous system spurious occur certain event happens certain order bad eventorder highly unlikely retrying operation often suceeds let system continue time user thing different order next time order avoids problem network tcp window stall might make data arrive opposite order normally intended hand say genuine programmer error always hit codepath nothing fault tolerance restarting system effect wo nt correct error j next part html attachment scrubbed url http information erlangquestions mailing list
431,Lobsters,erlang,Erlang development,"This Erlanger Used The Process Dictionary, Look What He Found",http://videlalvaro.github.io/2015/05/erlang-process-dict.html,erlanger used process dictionary look found,erlanger used process dictionary look found process dictionary article erlprocessdictc copy experiment time,erlanger used process dictionary look found erlang something called process dictionary sort keyvalue store belongs erlang process use store value simple manner inside erlang program avoiding limitation pure functional programming antiflames suit sold separately tho article describing good bad us process dictionary want get big picture go read talking want talk something found reading erlang process dictionary implementation find source code github erlprocessdictc caught attention function called ertsdictionarycopy defined function name clear erlang copy process dictionary whywhen according comment function plus quick search place called see mostly reporting purpose whenever ask erlang particular process dict copied case dict copying happen specifically request dictionary info key store lot thing process dictionary note erlang app could see ram usage spike perhaps oom u know something similar could happen inspect several thousand process accessing dicts via using process dictionary source discussion proper erlang code etiquette tell sure could problematic production system reason stated tl dr use process dictionary care call erlang extra care experiment time brave enough want unrealistic experiment try following create module following code purpose module start process store value process dictionary module memory export start spawn fun loop receive set key val put key val loop end start repl like erl k true run following command note need file similar science compile module c memory load file size arbitrary file big make vm crawl follows ok bin file readfile l binarytolist bin pid memory start keep n low value make vm unresponsive ram retina mac n pid set key l key list seq n use activity monitor similar check beamsmp memory usage next line double memory usage since dictionary duplicated erlang processinfo pid dictionary everything ran expected seen beamsmp ram usage spiking double called rather artificial experiment prove point academia taught anything run artificial carefully selected experiment prove point
432,Lobsters,erlang,Erlang development,"Look ma, no OS! Deploying an Erlang/OTP application as a LING unikernel in EC2",http://slides.com/technolo-g/intro-to-unikernels-and-erlang-on-xen-ling-demo,look o deploying erlangotp application ling unikernel,,order reap benefit true unikernel architecture offer required design redesign application run environment lack general posix support true unikernel approach much leaner le complex existing linux based stack luckily language like java erlang mostly done runtime level requiring minimal application code change app support running ephemeral soa environment like app
433,Lobsters,erlang,Erlang development,Folding Erlang Records,http://videlalvaro.github.io/2015/04/folding-erlang-records.html,folding erlang record,folding erlang record rabbitmq delayed exchange foldexampleerl credit ran yanviv hartstein,folding erlang record april developing new rabbitmq delayed exchange plugin problem extracting value deeply nested record like one created message delivery rabbitmq imagine following record need access header filed innermost pbasic record delivery message basicmessage content content property pbasic header h course could pattern matching function header extract innermost value like delivery message basicmessage content content property pbasic header h h besides point kind destructuring get bit hairy would happen point want access content property basicmessage solve decided function access specific property record ending function getmsg delivery message msg msg getcontent basicmessage content content content getprops content property prop prop getheaders pbasic header h h use function could call one succession return header delivery msg getmsg delivery content getcontent msg prop getprops content header getheaders prop header situation would happen field trying access record undefined one solution would add extra clause get function handle undefined case getmsg undefined undefined getmsg delivery message msg msg getcontent undefined undefined getcontent basicmessage content content content getprops undefined undefined getprops content property prop prop getheaders undefined undefined getheaders pbasic header h h would work seems better solution enter foldl list following deliver list foldl fun f acc f acc end delivery fun fun fun fun calling fold using current record accumulator list function thing apply iteration fold successive call able go deeper record structure find header looking still problem happens record property try access return undefined thanks erlang pattern matching function header easily address delivery list foldl fun undefined undefined f acc f acc end delivery fun fun fun fun last version function handle undefined case still problem fold short circuit first time find undefined value let add delivery catch list foldl fun undefined throw undefined f acc f acc end delivery fun fun fun fun added throw shortcircuit fold catch handle successful case catch would return header want access case undefined returned soon record field undefined using fold list fun decide deep record want go providing right list function hope idea folding erlang record useful btw look awful lot like composition maybe monad gist code example foldexampleerl credit photo credit ran yanviv hartstein license cc
434,Lobsters,erlang,Erlang development,Troubleshooting Down the Logplex Rabbit Hole (2013),https://blog.heroku.com/archives/2013/11/7/logplex-down-the-rabbit-hole,troubleshooting logplex rabbit hole,listen article logplex crash dump script quickly scan large crash dump cowboy loïc ets table mahesh paolinisubramanya blog post procbins refc binary recon library manually track binary size force gc hibernation call simple module nifs lukas larsson erlang solution ltd source linkedin driver async thread single block carrier threshold sbct mmsbc mmsbc mbsd useful erlang shell work application master lager library batchio recon batchio pobox mechanical resonance newer failure,listen article name fred spend time logplex since joining heroku march become main developer product handle maintenance support go post explain heroku routing team needed make logplex stable decrease workload keep morning quiet productive remote employee heroku routing team live east coast mean usually first one routing room company hipchat later tristan life illinois join hour later rest team join u west coast heroku employee located usually silent hour work without interruption email question scheduled meeting distraction relaxing productive way start day customer support ticket get escalated team nagios pagerduty alarm try intercept wake oncall teammate interruption otherwise productive morning generally alarm rare morning becoming increasingly uneventful back june may however array alarm interruption exhausting entire routing team alarm coming stack customer support ticket also started rolling problem compounded make bad situation worse alarm interrupt team work flow slows ability resolve problem issue cropped hour day night team especially engineer call worn becoming le productive time consumed interruption fire extinguish although area focus routing team mainly work heroku http routing stack logging infrastructure centered around logplex sizeable number alarm related individual logplex node kept crashing increasing frequency time generating alert chat system via email ultimately routing team worst enemy pagerduty going explain logplex otherwise entire post may bit confusing simplest way explain logplex take log data coming everywhere heroku dynos router runtimes push data around endpoint specifically logplex accepts syslog message either tcp http stream node cluster node store log message redis buffer line accessed heroku log allow distributed merging incoming stream given application order displayed live heroku log tail forward drain drain buffer logplex node accumulate message received node forward remote endpoint designated application user addon provider done tcp syslog custom http syslog format required workflow make simple look bit like also http api let tool user manipulate drain tail session used system dealing log get unpredictable load may bursty example application crash generates line stack trace thus overload constant issue logplex generally speaking overload dealt three way scale forever adding machine block input slow producer shed load dropping request first option good head matter current system never handle load quality service bad second option hand one want avoid within logplex nt want overloaded logplex node slow heroku application trying log data application busy crashing leaf u third option shedding load handle overload important decision make first designing system impact data flow throughout process system chooses block must synchronous operation bottleneck located deep within app impact accept rate api edge system app chooses shed load must mostly asynchronous internally slowest component data tends accumulate must able drop overload logplex written erlang load shedding process writes outside world tail buffer redis buffer locally within single drain work way drain thought combination two state machine state machine representing connection protocol negotiation state socket remote endpoint state machine handling buffering log line input output first type basic machine mean drain disconnected connected given endpoint transition two second type buffering represented machine conceptually simple http drain example use one process message passing overhead model easy reason conserve resource tcp drain execute state machine within single erlang process accumulating extracting buffer operation made implicit every operation input stream process never stopping impossible regulate directly never blocked operation without compromising stability system mean operation sending message must made asynchronous prompting additional state practice drain implementation far complex result plethora small business rule behavior want enforce batching retrying failed message loss reporting send time out exponential backoffs key point http buffer conceptually simpler thus safer cost term resource tcp buffer efficient trickier reason consequently easier mess accident skyhigh view work dive logplex mentioned alarm rolling particularly frustrating team system designed architecture could cope individual node failure problem received alert useless actionable logplex node would go get page acknowledge wait clear go sleep next day would start investigating ended turning alarm node failure still wanted reduce failure rate user log transit node lost crash although losing log opposed losing customer information nt big deal always generate still make bad user experience make forced analogy system painkiller still fix causing pain thus needed figure node kept dying almost randomly fix problem stopped happening frequently able wait day investigating crash erlang node go generate crash dump file containing basic information example slogan say node died inability allocate memory entire node dump also provides state process running time minus detail dump range hundred mb gb size rummaging relevant detail challenging first dump intimidating remain get used node dying get better understanding crash dump common pattern pop often message queue process excessively large number process open port socket size process memory failure going caused one condition finding pattern crash dump lead specific part code help reproduce bug later finding pattern wrote script quickly scan large crash dump find report plain text using script manual digging logplex crash dump could see frequent pattern single process large mailbox causing node go memory looking faulty process call stack ancestor dump could see problem almost always tcp syslog drain never seen http drain fault failure failure could nearly order magnitude tcp syslog drain http drain could due tcp syslog drain implementation blocking without knowing attack experiment could nt much debugging splunk graphite data showed node memory would progressively go sometime minute combined large mailbox told problem related slow input rather fast input drain could nt keep given data set decided blame tcp syslog drain implementation problem even though hunting individual blocking element tcp syslog drain possible routing team decided try refactoring use two distinct finite state machine like http drain would make code infinitely simpler promised lower latency memory price higher drop rate message stay shorter process mailbox dropped fewer held back gobbling memory point time taking day implementing change running test benchmark returned team solution seemed achieve goal outlined agreed send code staging matured proved absolutely stable problem staging however need sustain load production generating kind daily traffic logplex must deal locally staging would serious undertaking far generating kind traffic worth routing team term developer resource crossed finger added one production node run modified code day could monitor ass code could sustain production load correctly looked team internal tool displayed live statistic logplex node new one performed terribly node still acceptable throughput found stopstart cycle roughly second millisecond pause time stopstart cycle meant node hard time scheduling erlang process time necessary work heavy load may understandable eventually node may recover load quite regular point new node considerably worse older sibling hour freeze would last longer longer eventually node would come crashing wanted fix thing dove application log considerably long event sequence comb typical logplex node log anywhere message second internally crashing one bring multiple thousand event useful diagnose failure could happened minute earlier studying log able attribute initial failing call cowboy acceptor library use http input stream short cowboy server architecture bit like architecture regular pattern tcp server erlang manager supervisor open listen socket share group acceptor acceptor concurrently accept new connection handle pas third party usually allows far better connection time shorter delay thing sequentially one single process special thing cowboy implementation however every time acceptor accepted connection reported back manager central process track connection check configuration change manager bottleneck execution program loïc cowboy maintainer knew bottleneck also showed benchmark fix problem albeit temporarily trick erlang application ever raised process priority understand implication fix aware erlang vm preemptive scheduling process fairly across process based work accomplished b busy node c work accomplish eg mailbox full balancing important system process often need larger share processing power erlang vm therefore support four process priority low normal default high max every process high priority run code right normal process run normal process run low process work reasonably well know load characteristic system higher priority task truly higher priority however case cowboy priority merely workaround speed artificial benchmark supposition woe became rather evident refactoring nearly doubled number process node creating contention scheduler cowboy hogging scheduler time accept connection communicate acceptor process handling request starved cpu time blame cowboy issue keep mind logplex running old version server newer version gone architectural change entirely removed central bottleneck call dropped priority back normal first tested hypothesis manually changing scheduler priority cowboy process without otherwise altering server design crash became bit le frequent new node still reliable enough lead solid conclusion test despite team best effort little data way reproduce hiccup anywhere production still held onto idea cowboy architecture might problem still central bottleneck despite scheduler priority right time upgrade newer cowboy version settled cowboy new internal architecture unfortunately required upgrading erlang version erlang version tend backwards compatible deprecation come warning wanted eliminate biggest issue interface change cowboy library required extensive testing ensure full backwards compatibility seamless deployment also contained promised sweet scheduler optimization hoped get hand optimized work done ets table parallel require le data copying also shipped important bug fix make sure worth upgrading ended bit complex bug urgent deployed production node running ported forward work forked make work new cowboy version merged back branch one point running monitoring four different version logplex time production see one would win nt smartest option given difficult isolating variable practical option time one apparent result regular node well without stopstart cycle eventually replaced production node one kept four node running split tcp syslog drain monitoring system week saw minor improvement split drain node seemed lock le frequently far le violently every four five day one new node would go radio silent would appear running nothing would come vm minute time thousand line log nothing connecting node remote shell killing way generated crash dump impossible node never would recover fully always flapping poorly usable usable decided give week worth work way run code time maybe routing team changed internal mechanism system vm still made progress scheduler running code would possible back dead end nt admit total defeat however time proved node fleet updated without changing drain model stopped crashing almost entirely ported rest optimization nt yet branch made standard entire cluster boost reliability could archive trello card related task could start working stuff roughly three week later nagios started screaming routing team internal chat room every five minute day time node cluster memory bubble never gave back o node would nt crash fast instead grow close ulimit set hover taunting nagios u extension clearly needed work first decided wait see node would crash point hoped crash dump would hold detail memory could help maybe logplex node resentful wanted work something else would nt ever go memory limit wait nag die refuse attention eventually logged onto misbehaving production node ran following expression within erlang shell erlang garbagecollect pid pid process effectively go process erlang node force garbage collection alarm stopped manually forcing garbage collection turned work wonder question answering though needed data node nt crashed garbage gone node could display annoying behavior took week little choice wait fortunately phenomenon happened frequently time node eventually managed go overboard die analysis crash dump revealed single process holding criminal amount memory neither single mailbox largest looking like would explode process high level memory live profiling nt give single process culprit plot thickened kept manually calling garbage collection nagios memory alert cropped something looked table one node memory consumption reported erlang o forced global garbage collection erlang memory total beam process node total pre gc gb gb gb post gc gb gb gb delta gb gb gb relatively fresh node look like erlang memory total beam process node total memory gb gb gb fairly weird highlighted two big thing garbage collection seems trouble job entire node without prompted memory allocated directly erlang language seems stay around grow time decided focus first point gc trouble immediately actionable showed tangible result could prevent error crash idea culprit point one node started triggering error sat terminal waiting see change metric o would report following vm would internally report following scale different confusing number memory statistic time logplex ipinternal k v math pow k v erlang memory waiting minute logplex ipinternal k v math pow k v erlang memory show heavy memory growth binary memory going remembering mahesh paolinisubramanya blog post binary memory leak decided try confirming indeed root cause erlang binary two main type procbins refc binary binary byte allocated directly process heap take place use binary bigger get allocated global heap binary process hold local reference local heap binary referencecounted deallocation occur reference garbagecollected process held binary case mechanism work entirely fine case however process either little work warrant allocation garbage collection eventually grow large stack heap various data structure collect get work lot refc binary filling heap binary even though virtual heap used account refc binary real size may take lot time giving long delay garbage collection case logplex latter case one occuring confirmed polling process node processinfo pid binary return list binary reference process list length list used know process hold reference quite enough yet reference may valid building list calling global garbage collection node building new list calculating delta know process held outofdate reference needed done next logplex ipinternal mostleaky fun n logplex ipinternal list sublist logplex ipinternal list usort logplex ipinternal fun end logplex ipinternal try logplex ipinternal pre erlang processinfo pid binary logplex ipinternal erlang garbagecollect pid logplex ipinternal post erlang processinfo pid binary logplex ipinternal pid length post length pre logplex ipinternal catch logplex ipinternal pid logplex ipinternal end pid process logplex ipinternal n logplex ipinternal end logplex ipinternal mostleaky since added function recon library nobody required call hand little data dump showed process held stale reference refc binary lot held told process held lot binary investigating individual process revealed drain buffer kind bad news meant way logplex built le playing right one rare case erlang gc nt delivering result par promised general case logplex application looked like perfect match erlang got trapped implementation detail made pathological case vm generally refc binary memory leak solved different way call garbage collection manually given interval icky manually track binary size force gc defeat purpose garbage collection first place may worse job vm virtual binary heap stop using binary desirable add hibernation call appropriate possibly cleanest solution decided put quick fix place still life production day simple module basically loop given interval poll reported memory check see whether go past threshold garbage collect node required module also allows manual call script worked expected high memory warning quickly tamed logged delta waiting inspected later week looking log seeing incident node could related memory issue log showed garbage collection happening required everything looked great resorting emergency measure way get node drop high amount memory nt ideal however never know fast spike usage happen decided add bunch hibernation call nonintrusive location inactive drain disconnecting remote endpoint would allow u garbage collect globally much le frequently keeping memory lower overall people register mostly inactive drain everything went fine except five week one node crashed despite fix place global garbage collection nt even get triggered looking log o logplex node internally revealed o allocated ram logplex node internally reported using le half serious memory leak incredibly frustrating point hitting limit knew erlang virtual machine suspected either memory leak going outside memory vm reported node victim memory fragmentation using nifs lzf decompression vm could fault knowing contacted lukas larsson year back spent first two week erlang solution ltd london lukas also day acted guide city company since lukas moved internally consult otp team ericsson moved adgear heroku still connect occasionally conference irc lukas always helped answer tricky question erlang vm asked lukas could pinpoint leak showed collected data sharing learned process addition interesting information documented anywhere source amount returned erlang amount memory actively allocated erlang term laid memory amount represent amount memory o given virtual machine linux nt actually reserve memory page used vm understand memory go one must first understand many allocator used tempalloc temporary allocation short use case data living within single c function call eheapalloc heap data used thing erlang process heap binaryalloc allocator used reference counted binary global heap etsalloc ets table store data isolated part memory nt garbage collected allocated deallocated long term stored table driveralloc used store driver data particular nt keep driver generate erlang term using allocator driver data allocated contains locksmutexes option erlang port etc slalloc shortlived memory block stored include item vm scheduling information small buffer used data type handling llalloc longlived allocation example include erlang code atom table stay fixalloc allocator used frequently used fixedsize block memory one example data used internal process c struct used internally vm stdalloc catchall allocator whatever nt fit previous category process registry named process entire list given data type live found source default one instance allocator per scheduler one scheduler per core plus one instance used linkedin driver using async thread end giving structure bit like drawing split n part leaf suballocators request memory msegalloc sysalloc depending use case two possible way first way act multiblock carrier mbcs fetch chunk memory used many erlang term mbc vm set aside given amount memory default case configured tweaking vm option term allocated free go look many multiblock carrier find decent space reside whenever item allocated greater single block carrier threshold sbct allocator switch allocation single block carrier sbcs single block carrier request memory directly msegalloc first mmsbc entry switch sysalloc store term deallocated looking something binary allocator may end something similar whenever multiblock carrier first mmsbc single block carrier reclaimed msegalloc try keep memory next allocation spike hit vm use preallocated memory rather needing ask system time call erlang memory total get nt sum memory set aside carrier whatever msegalloc set aside future call actually used erlang term filled block drawing information least explained variation o report vm internally report expected needed know node variation whether really leak fortunately erlang vm allows u get allocator information calling n data tempalloc eheapalloc binaryalloc etsalloc driveralloc slalloc llalloc fixalloc stdalloc instance n data erlang systeminfo allocator allocator call nt pretty data worse entire data dump retrieve data allocator kind block size metric use dive detail part instead refer function put inside recon library perform diagnostics outlined next section article figure whether logplex node leaking memory check allocated block memory summed something roughly equal memory reported o function performs duty recon reconalloc memory allocated function also report actively used reconalloc memory used ratio reconalloc memory usage fortunately logplex memory allocated matched memory reported o meant memory program made use came erlang term allocator leak came c code directly unlikely next suspected culprit memory fragmentation check idea compare amount memory consumed actively allocated block every allocator amount memory attributed carrier done calling reconalloc fragmentation current current value reconalloc fragmentation max peak usage looking data dump function similar one lukas figured binary allocator biggest problem carrier size large utilization impressively low worst case best case normal situation would expect utilization well hand looked peak usage allocator binary allocator usage lukas drew conclusion turned match memory graph whenever logplex node huge spike binary memory correlate spike input given deal binary data operation bunch carrier get allocated giving something like memory get deallocated remnant kept logplex buffer leading much lower rate utilization looking similar result bunch nearly empty block freed erlang vm never defragmentation memory keep hogged binary data may take long time go away data may buffered hour even day depending drain next time usage spike node might need allocate ets table eheapalloc allocator memory longer free nearly empty binary block fixing problem hard part need know kind load system kind memory allocation pattern example knew binary smaller equal hard cap put line length log message need know different memory allocation strategy erlang virtual machine best fit bf address order best fit aobf address order first fit aoff address order first fit carrier best fit aoffcbf address order first fit carrier address order best fit aoffcaobf good fit gf fit af best fit bf vm build balanced binary tree free block size try find smallest one accommodate piece data allocate drawing piece data requires three block would likely end area address order best fit aobf work similarly tree instead based address block vm look smallest block available accommodate data many size exist favor picking one lower address piece data requires three block still likely end area need two block strategy favor first mbcs diagram area instead area could make vm tendency favor carrier many allocation address order first fit aoff favor address order search soon block fit aoff us aobf bf would picked area allocate four block one get area first priority given address lowest diagram allocate four block favor block block address lower whereas bf would picked either aobf would picked address order first fit carrier best fit aoffcbf strategy first favor carrier accommodate size look best fit within one allocate two block diagram bf aobf would favor block aoff would pick block aoffcbf would pick area first mbcs accommodate fine area fit better area address order first fit carrier address order best fit aoffcaobf similar aoffcbf multiple area within carrier size favor one smallest address two rather leaving unspecified good fit gf different kind allocator try work like best fit bf search limited amount time nt find perfect fit pick best one encountered far value configurable mbsd vm argument fit af finally allocator behavior temporary data look single existing memory block data fit af us data ca nt fit af allocates new one strategy applied individually every kind allocator heap allocator binary allocator necessarily share strategy lukas recommended go address order best fit strategy aobf along reduction size average mbcs binary allocator strategy used cpu pick data would go vm hopefully would favor existing free block case meaning would much fewer nearempty mbcs sitting around usage spike enabled setting node production waited problem setting failure could take five week show regular node multiple dozen slowly ramp frequency measuring success experiment put production took excessively long time node used cpu thing three four week without crash decided push experiment pushed change production node option kick node needed restarted usually use erlang hot code loading feature deploy software without terminating single connection instead restarting node waited crash took week crash roughly cluster running new memory allocation option ran old one first node passed time issue cropped seemed stable new memoryrelated crash happening older node new node never seemed crash considered experiment successful still knowing nonnegligible probability age sole reason older node new one kept dying eventually new erlang version came gave final push cluster roll course hour production logplex node running newest stable erlang version tweaked memory allocation setting week month depending age node verified found practice reduction nt perfect fragmentation still occurring see improvement whereas binary allocator saw significant amount usage fix would usage rate new node seeing significant amount usage tend least usage well across cluster double efficiency memory usage high enough yet lose vm without first able trigger global garbage collection call fact nt lost memory due outofmemory error directly attributable drain logplex built nt mean cluster component never fail anymore still see failure resulting bad loadbalancing node connection service going incorrectly built around remediating also saw case node would fail degraded quality service glaring example bad behavior node heavy load high drop rate logplex message delivered user investigation routing team learned one process erlang node tended risk user process erlang io based around idea group leader group leader process take charge handling io forwarding around already went useful erlang shell work focus state affair every otp application running vm application master process act secret toplevel supervisor application top vm process named user atrisk process handle io charge standard io port varying number process depending interacting vm may may moreover every io call synchronous io client process call io io server application master ultimately user default vm logging regular io call result following structure command come erlang shell log volume made reasonable optimization telling io format communicate directly user process calling io format user fmt args removed middleman allowed faster communication le overhead peak time vm o given cloud hiccuped many connection could time logged event get storm individual process would block waiting confirmation message also created memory bubble meant logging wanted source problem waiting buffer would accumulate message drain could nt sent time filling resulting dropped message first replaced logging call lager library fantastic library highly recommend lager library us middleman process middleman act buffer allows communication asynchronous certain point switching lager worked well except node occassionally unpredictably io slowed crawl lager would thousand message backlogged happens io switched synchronous mode avoid going memory entirely sane behavior logplex meant critical path code example tcp syslog drain never block would suddenly lock endangering node way risk overflowing mailbox additional process going synchronous simply shifted danger around trouble saw two option log le would temporarily solve problem cost visibility try buffering batching log message asynchronously could let u keep log nt sure work batching long recommended solution throughput issue raising latency bit lead better resource usage regrouping similar operation together getting throughput decided try buffering option implementing excessively complex promised quick fix would win term speed data logged idea take log message send middleman buffer process pair would accumulate optionally drop merge log string larger page send larger page user process would replacing earlier diagram describing io flow root cause problem message passing overhead solution could work problem total bandwidth log logplex producing little could done help solution worked promptly released batchio library contains buffer process pair wrap behind glorified io call batching operation estimated reduction number message sent across vm io much according backoftheenvelope calculation mine without decreasing amount data logged case overflow library drop message instead blocking far message needed dropped even though moved fully asynchronous model also kept lager active node error log opposed default erlang handler batchio could nt handle error log lager better handling error log default error handler node prevent overload better way month long debugging session routing team gained much higher time individual component failure mean fewer interruption u fewer silently lost log user additional bandwidth let heroku focus pressing nonoperational issue improvement gleaned project went far direct reliability system additional system performance improvement came right time demand increased end result satisfying course project number log message transit logplex increased nearly whereas number message dropped reduced order magnitude time period result effort also released library erlang community recon contains script module help diagnose erlang issue including script deal crash dump memory allocation diagnostics general debugging function safely used production batchio io buffering library although good full logging library hope used model help existing logging library offer alternative going synchronous overloaded pobox generalization logplex buffer http drain designed geoff cant technical leader routing team library used core batchio started using internal project require batching loadshedding still plan work debugging logplex example process helping logplex faulttolerant external service failure although overload still take node least take load overload logplex every project life production requires scaling end weird complicated issue issue attributed one root cause difficult reproduce nobody else community encounter solve issue crop matter language stack framework hardware correct think software kind production problem modern version bridge collapsing many people cross creating heavy mechanical resonance although modern bridge able handle issue safely past failure even newer failure led safer structure unlike bridge design software engineering still young field hopefully article offer glimpse daily work heroku engineer perform sharing experience helpful greater development community
435,Lobsters,erlang,Erlang development,Erlang gen_microservice,https://github.com/videlalvaro/gen_microservice,erlang genmicroservice,erlang genmicroservice microservice feature full hot code reload asynchronous synchronous callback iojs fault tolerance distributed systmemes usage license,erlang genmicroservice library solves problem implementing microservices erlang code need add behaviour genmicroservice module implement couple callback microservice ready use stealth startup bring magic let whatsapp scale million user dollar free feature full hot code reload library implement magic let app upgraded without downtime behind scene asynchronous synchronous callback library fully asynchronous code like modern iojs apps use sync callback like old monolithic apps choice nt limit fault tolerance know senior developer nt write bug particular case junior dev allowed push code production need covered library integrates seamlessly erlang nine nine runtime got covered well distributed systmemes distributed system talk day user todo app scalability distributed consensus need library anticipates problem written erlang language distributed system problem really solved usage module need implement several callback function called microservices orchestrator system launch genmicroservice code still us synchronous call functionality implemented using callback modernized app app logic mostly reside inside callback microservice receive external message via callback magic reloading upgrading microservice live production happens called time scale decommission microservice instance check example dockittygenmicroserviceerl license see licensemd
436,Lobsters,erlang,Erlang development,Panel on language design with the creators - Erlang Factory '15,http://www.youtube.com/watch?v=oZwfi8JZ3kU,panel language design creator erlang factory,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature erlang factory sf panel discussion youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature erlang factory sf panel discussion youtube
437,Lobsters,erlang,Erlang development,Erlang Factory SF 2015 - Jose Valim - What Elixir is about,http://www.youtube.com/watch?v=Lqo9-pQuRKE,erlang factory sf jose valim elixir,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature erlang factory sf jose valim elixir youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature erlang factory sf jose valim elixir youtube
438,Lobsters,erlang,Erlang development,Erlang Factory SF 2015 Videos Online,https://www.youtube.com/user/ErlangSolutions/videos,erlang factory sf video online,,
439,Lobsters,erlang,Erlang development,Solving the Go Challenge 1 in Erlang,https://medium.com/@jlouis666/solving-the-go-challenge-1-in-erlang-8b1e0a0a5044,solving go challenge erlang,testing parsing atom intermezzo rendering iolist datatype note,testingfirst set function return test data testtable saved hw version tempo kick x x x x n snare x x n clap xx n hhopen x xxx xn hhclose x x x xn cowbell x n saved hw version tempo kick x x n snare x x n hhopen x xxx xn cowbell x n returned list pair filename expected file name binary file read pattern textual representation correct output allows u implement system us list tabledriventest verify every output correct followed simple function test single test case file expected ok dat file readfile privfixtures file output iolisttobinary render p dat output listtobinary expected okthis us erlang binding rule two way reading binary file asserts output ok dat file read return error lead crash code common pattern erlang failure crash program install strategy restarting failing part program later use function parse file content send function finally convert output binary data stuff value output finally line attempt stuff expected output value binding semantics erlang take assertion expected output match output code crashthis contrast many programming language would overwrite value output language like erlang prolog us define assertion often used trick erlang since avoids write assertion check lot code particular need commonif err nil common go programswe write testdriver system test list foreach fun testtable testing code amount call function every data point testtable list code crash test passed code crash erlang return structural error information need figure wrong larger erlang program usually employ one test system eunit common test simple program somewhat simpler use simple function call make sure thing work shouldparsingnow ready implement parser function format contains identifying header followed global information drum pattern followed instrument present drum pattern parse order handle format sake simplicity parse data represent internally abstract syntax tree tree fed rendering function later order render data textual format principle writing compiler binary format textual formatan atom intermezzo needed explain concept may helpful following erlang unquoted alphanumeric identifier starting uppercase character payload variable alphanumeric starting lowercase character instrument atom atom interned representing integer internally vm file loaded atom mapped integer picking new integer atom seen atom already occurs vm designated number atom used course used tag program discriminate data erlang also used represent module name function name situationsthe advantage atom quick equality check one walk costly string comparison sotospeak paid advance module loaded system foreign data enters vm node back identifying header following function p splice payload lenbinary binary pdata payload function defines called binary pattern match function expects binary data function proceeds destructuring picking apart binary data according specfication given specification say first come byte ascii code splice next come bigendian integer parse value lennext come payload len byte binary datafinally come data disregard needed pattern includes errornous data end match itany parsing error crash function manage parse data send payload function pdata databinary instrument instrument data format splice hardwarestring trimhwstring hwstr tempo tempo instrument instrument match expected content first come byte hardware string identification information come bit ieee floating point value littleendian form rest instrument data parse helper function called return value map containing data found parse language dynamic predeclare content map simply create one add necessary field function used get rid trailing end hardware id string trimhwstring b str binarytolist b string strip str right two function remain first one decoding instrument line instrument name lbinary restbinary instrument num name pattern pattern instrument rest instrument two possible match first match one pick instrument apart expect integer bitsa length bit bigendian integera name whose length givena pattern byte pattern datathe rest remainder binary datawe create tuple instrument num name pat instrument part identifying atomsymbol use later discriminate instrument data function recurses remainder data call instrument rest call return frontappends current instrument list builtthe variant identifies empty binary instrument parse return empty list recursion gradually build list instrument recursing end instrument data building list instrument reverse need parse pattern pattern binarytolist p p pattern split group byte use listcomprehension convert pattern binary list byte read p list replace p binarytolist p return list list byte come handy want render outputas example let u run pattern print output erlang repl come handy exploratory ok file readfile ok decoderdm p format splice hardwarestring instrument kick snare clap hhopen hhclose cowbell tempo look right parser line code begin focusing next part rendererrenderingfor rendering need couple helper function conv pat renderc c c pat renderc renderc xthese two function helper going used convert pattern ascii byte x use list comprehension work list converting element listwe also need handle tempo output floating point value rendered integer trailing function erlang default test result close convert output integer case formatfloat f case ab f trunc f k k integertolist trunc f floattolist f decimal compact endand ready rendering function however need another little intermezzo iolists erlangthe iolist datatype way output data erlang inductively generated datatype type part type specification istype iolist list binary iolist one read iolists defined list consisting alternate thing integer range binary iolists last part make definition inductive iolists really tree built list convenient avoid explicitly concatenate string many situation say want quote string done writing following function quote string string notation x evaluates ascii code symbol x form quoted string without ever copying string since term erlang persistent immutable risk constructionmany typical output point erlang program accepts iolists well data writing socket file instance highly convenient often avoid manually concatenate data build iolist structure system handle concatenation later also mean erlang vm free optimize data output instance precalculating size needed concatenated target use writev system call gather output writingthe render function drum machine decoder us iolists also employ another trick parsed element unique representation hence simply analyse element recurse deeper abstract syntax tree render function always return iolists plug larger iolist test function aptly us function convert iolist binary use test expected outputrender format splice tempo tempo instrument instrument hardwarestring hws saved hw version hws n render tempo tempo n render instrument render list islist list render elem elem list render tempo tempo formatfloat render instrument n name pattern prefix iolib format b st n name grid render pattern pattern prefix grid n render pattern conv conv conv conv renderer pattern match different possible input handle outputting something right input two trick used make discrimination explicit rendering tempo call recursively tempo tempo pattern rendering call recursively pattern pat ensures input term unique thus employ rendering function casesin language static type system function must often broken several different small function also advisable erlang rendering function larger renderer small however fine keep function close otherwe line done exploratively test code noting pattern output shell command use input later io format iolisttobinary decoderdm render v saved hw version kick x x x x snare x x clap xx hhopen x xxx x hhclose x x x x cowbell x oknotesthere little copying going parsed binary never copied match context generated recursing data somewhat equivalent slice go standard ml large part output never copied since using iolists rather pointer underlying persistent data used vmpattern matching efficient pattern match compiler analyzes pattern compiles alternative jump table andor analysis binary split positive negative match information propagated start possible match rely data already successfully matched rejected earlier patternsthere error handling code whatsoever typical erlang program error return structural error analyzed erlang program printed common erlang system error logger handle crash writes structured error disk postmortem analysis system whole crash erlang truly concurrent environment one process logically isolated process hence system always able clean process crash trailing garbage inconsistent state left behindit took minute come solution programming time standard erlang code without magic trick thing would act clever word implementation straightforward one experienced erlang programmerthe implementation reasonably speedy clock microsecond machine parsing pattern optimization possible think necessary go roughly time faster problem eg ocamlthe test directly portable common test us assertion method used common test requires boilerplate go testing package
440,Lobsters,erlang,Erlang development,Incuriosity Will Kill Your Infrastructure,http://yellerapp.com/posts/2015-03-16-incuriosity-killed-the-infrastructure.html,incuriosity kill infrastructure,incuriosity kill infrastructure boundary incuriosity killed infrastructure example would handy right background vector clock meat incuriosity killed infrastrcture main dashboard distributed jvm profiling yeller distributed jvm profiler got paged inbuilt webapp profiler takeaway operation yeller read yeller learn debug production error,incuriosity kill infrastructure long back folk working boundary time coined phrase loved ever since incuriosity killed infrastructure idea cover helped many folk since dense phrase idea running modern software system hard work see thing make sense investigate later sign towards thing mess obvious counterpart actively curious thing lead stable happy infrastructure getting ahead game getting paged putting head fire extinguisher every day week paying attention small niggling thing quite understand pay avoided page example would handy right good story involving hit recently background first little bit background riak data store yeller us store exception data solution resolving concurrent writes locking transaction ca last write win like many traditional database instead us vector clock detect concurrent writes vector clock let know hey modification historically relate operation riak upon detecting concurrent writes store copy writes read return value writes say descend two parent like git merge commit point concurrent copy resolved cleaned keep track vector clock inside codebase typical way always readmodifywrite every piece data typically supplying function riak client library get store many many copy particular value destroy network memory use client latency reading thousand value get request guess one going meat week ago shipped patch yeller caused sibling explosion see number sibling client side explode dramatically incuriosity killed infrastrcture real meat saying pay attention weirdness infrastructure missing warning sign thing wrong putting pressing thing hurt road sibling explosion managed avoid seeing following case main dashboard main dashboard data ingest yeller track time main bucket time taken full readmodifywrite cycle chugging along happy value hitting looked went weird must graphite continued distributed jvm profiling courtesy riemann yeller distributed jvm profiler whilst investigating another performance issue saw profiled trace contained call riak get call contain everything go modify call said little weird guess might somewhere unimportant got paged latency one key web page spiked like mad weird dug using inbuilt webapp profiler saying read time bucket hundred millisecond extremely odd turned graphite dashboard riak bucket saw shitshow number conflicting writes fixed bug small coding error kicked spotted way earlier well getting paged incuriosity hurt infrastructure pretty damn badly deploy letting system run thing returned normal luckily still spotted early enough thing irrevocably broken customer impact whole issue slow page load two best thing world awful either takeaway operation basic principle super important sometimes going throug teach understanding system flawed still incredibly valuable learning front rather whilst trying debug something else paying attention thing let get ahead game infrastructure instead reacting fire time detect symptom affect customer blog development yeller exception tracker answer read yeller learn debug production error put together course debugging production web application cover whole heap technique speed debugging shortcut take change make system make debugging easier common mistake avoid bunch wo nt spam send exactly email course
441,Lobsters,erlang,Erlang development,Fault Tolerance 101,http://www.infoq.com/presentations/fault-tolerance-101-erlang,fault tolerance,infoq homepage presentation fault tolerance summary bio conference related sponsored content,infoq homepage presentation fault tolerance fault tolerance summary joe armstrong discus fault tolerance relates scalability concurrency erlang help build faulttolerant system multicore cluster bio joe armstrong principal inventor erlang coined term concurrency oriented programming ericsson developed erlang chief architect erlangotp system formed bluetail developed product erlang obtain phd royal institute technology stockholm author book software concurrent world conference build stuff conference software development conference created developer team leader software architect technical project manager goal bring world class speaker share innovation latest development new trend direction software development world baltic recorded may related sponsored content
444,Lobsters,erlang,Erlang development,SICP: Lisp-flavored Erlang edition,http://lfe.gitbooks.io/sicp/content/,sicp lispflavored erlang edition,structure interpretation computer program structure interpretation computer program contributing let u know building book,structure interpretation computer program lfe edition gitbook available work progress converting mit classic structure interpretation computer program lisp flavored erlang forever indebted harold abelson gerald jay sussman julie sussman labor love intelligence needle say gratitude also extends mit press generosity licensing work creative common contributing huge project use help got idea found bug let u know building book build local copy book install dependency make deps linux need run sudo install gitbook module make setup finally build book make book
445,Lobsters,erlang,Erlang development,Highly Distributed Computations Without Synchronization,http://www.infoq.com/articles/Highly-Distributed-Computations-Without-Synchronization,highly distributed computation without synchronization,paxos statemachine replication dynamo related sponsored content conflictfree replicated data type conflictfree replicated data type version vector vector clock project voldemort riak conflictfree replicated data type semilattices distributed deterministic dataflow concept technique model computer programming joinsemilattice generalizing joinsemilattices lvars latticebased data structure deterministic parallelism distribution model replication variable replication application application advertisement counter go causal consistency different distribution model feedback author christopher meiklejohn blog,synchronization data across system expensive impractical especially running system scale seen institution deploy application mobile device provide internet thing iot service cost increase number client increase also possible synchronize operation client limited access connectivity make traditional approach paxos statemachine replication inviable coordinating replicated state highavailability faulttolerance system also major concern given company downtime linked directly revenue exemplified amazon work dynamo popularized concept eventual consistency one solution problem however minimum much state reduced still performing useful distributed computation consider large mobile gaming company need share client state across user device example shared virtual wallet across device owned particular user shared list item across member team device related sponsored content ideal situation would like operation performed using shared replicated data able succeed client offline however allowing operation performed shared data structure avoiding synchronization vacuous recipe incorrect program therefore aim creating deterministic application operating data structure guarantee convergence event concurrent operation guarantee convergence application rest article explore basic building block crafting application conflictfree replicated data type conflictfree replicated data type crdts provide one solution semantic resolution problem described amazon dynamo paper description highlyavailable shopping cart problem exists concurrent addition removal item replicated shopping cart result divergence shopping cart case causality tracking mechanism version vector vector clock used determine ordering event system determine operation occurred concurrently dynamo address storing copy divergent item returning copy user next time attempt retrieve key note several dynamo clone surfaced publication original dynamo paper also take strategy linkedin project voldemort basho riak point user supposed resolve conflicting writes write back resolved object shopping cart example two shopping cart joined using set union operation perform resolution however depending item set modeled deleted item may resurrected resolution logic conflictfree replicated data type shapiro et al formulate model strong eventual consistency sec object meet criterion object eventually consistent strong convergence property convergence property defined correct replica delivered update equivalent state model object longer susceptible concurrency anomaly object observe strong eventual consistency designed converge correctly concurrency failure property make data type powerful ensuring correctness distributed system especially distributed database use optimistic replication technique data type come two flavor statebased rely property semilattices operationbased spaceefficient rely commutativity operation data type take principled approach eventual consistency data structure design encode information event used create metadata resolve concurrent operation deterministically article going focus statebased crdts compose conflictfree replicated data type program ensuring strong convergence property individual crdts preserved composition distributed deterministic dataflow solve problem turn deterministic dataflow programming form functional programming series agent process synchronize binding variable shared singleassignment variable store following figure show example process communicating shared constraint store detail model see chapter concept technique model computer programming following figure show example process communicating shared constraint store model σ represents shared variable store process store provides two primitive operation read bind read blocking operation store read variable operation block variable bound bind operation allows assignment variable store particular value value another variable joinsemilattice extend model statebased conflictfree replicated data type previously discussed recall statebased conflictfree replicated data type rely monotonicity property joinsemilattices joinsemilattice joinsemilattice partially ordered set binary operation called join join operation associative commutative idempotent computes least upper bound respect partial order give example natural number form lattice join operation max operation generalizing joinsemilattices start looking singleassignment case lattice consider following generalize model allow variable rebind long update inflation trigger bind new state higher lattice let walk example see work example simplicity assume singleassignment version dataflow language allows variable bound natural number represent unbound state represent error state lattice serf state chart show direction variable state allowed travel case change unbound variable value however value bound attempt change value move error state consider following natural number lattice computes maximum observed value example subsequent bind operation compute join argument passed operation current value result join used value variable similar think state chart long number keep increasing continue change value whereas triggered error subsequent change additionally extend model provide additional primitive similar related threshold read operation described kuper lvars latticebased data structure deterministic parallelism additional read primitive take activation value prevents read operation completing variable read value equal strictly higher semilattice order distribution distribution also important highavailability faulttolerance model assume either replication variable data store replication entire application model model assumes dynamostyle partitioning replication data model use hashspace partitioning consistent hashing break hash space group disjoint replication set group replica responsible full replication data within set shown following figure click image enlarge replication variable partitioning replicating variable assume client application run outside cluster spread across series node internal external cluster operation bind read turned request sent across network cluster responsible managing constraint store either succeeds fails based whether quorum replica contacted shown figure b replication application also provide ability run entire application replicated introducing two new primitive operation register remotely load program execute remotely execute program consider case program going operate data stored one replica set rather run entire application remotely perform roundtrip quorum operation replica set push entire application replica set execute application get result simply select one replica result return user shown figure c application let look example application requires communication series client server eventually consistent advertisement counter going look erlang code written using library called lasp implement programing model discussing advertisement counter example advertisement counter written prototype programming language called lasp support programming model discussed article made two set coordinating process server responsible tracking advertisement impression client client responsible incrementing advertisement impression example use growonly counter refer gcounter growonly counter counter handle concurrent increment option safe convergent manner track decrement doc client process standard recursive looping server client id ad receive message server process receive respond view advertisement message viewad choose advertisement display simply choose first item list ad hd ad update ad incrementing value issue update increment counter ok lasp update ad increment id increment id value client id tl ad ad removead ad remove ad client id ad ad end snippet initialize series client given list advertisement responsible displaying user client represent process running client near end user client process handle three thing returning list active advertisement viewing advertisement removing advertisement use simple recursive process block receiving message perform operation request view advertisement arrives choose advertisement display increment counter particular advertisement bind operation succeeds case value pushing back constraint store inflation lattice counter ever going grow next initialize one server process per advertisement code look like doc server function advertisement counter server ad client perform blocking read unblock counter reach least ok lasp read ad client send message telling client disable advertisement displayed list map fun client tell client remove advertisement client removead ad end client print message screen advertisement limit reached io format advertisement p reached display limit ad server process performs threshold read counter advertisement tracking threshold read operation block thereby suspending execution server process counter reached least five impression threshold reached server process unblock notify client stop displaying advertisement go programming model eventually consistent computation still much early stage development continues ongoing research driven requirement industry partner feedback reference implementation term feature identified series work planned explore next year development programming model example work include following causal consistency change needed programming model distribution model support causal consistency possible programming model detect causal consistency required weaker consistency model suffice given program requirement different distribution model rewrite application operate particular set data smaller application operating disjoint subset executed parallel faulttolerant manner possible break program hierarchical set client transparently programming model order support offline correct operation feedback would love hear feedback given large part evaluation based whether programming model make easier reason program behavior correctness author christopher meiklejohn senior software engineer basho technology inc contributing member european research project syncfree christopher also frequently blog distributed system blog
446,Lobsters,erlang,Erlang development,OlegDB: More on Go vs. Erlang,https://olegdb.org/blog/0007_More_on_Go_vs_Erlang.html,olegdb go v erlang,go v erlang erlang go latest release rewrite bus factor dependency wrote http server nt user really issue port driver look bad boy long time figure erldrventry struct nt used nifs make sense go contributor shipping binary right architecture o x witch brew unix signal handling ignore new erlang shell rabbitmq actordb conclusion erlang anger mochi webserver,go v quinlan pfifferduring recent episode olegdb muckery glossed migrated erlang go latest release also promised would go detail switched benefit even line addedremoved samethe first thing would like clarify olegdb primarily written go primarily written erlang olegdb always giant c hairball say hairball fondest conotations neurotic developer conjure seems many people confused concept repeat rewrite olegdb go rewrote communication layer erlang goso go switched elaborate reason gave last time detail busfactorthe port drivereasier find go contributorsshipping binary infinitely easier handling vmunix signal handling bus factorthis erlang fault completely mine circle olegdb devs run push kind tyrannical dependency policy result lot reinvented wheel wrote http server recently learned erlang ignored lot best practicesthere otp fundamental dialyzer type check test made kind mess nt help everyone talk scared death erlang syntax reason really maintaining erlang code made kind liability luckily nt user really issue port driver look bad boy thats line weird looking c used talk erlang line took long time figure even half callback erldrventry struct nt used there lot weird serialization occur c erlang layer nt always decipherable people talked port driver looked code one big black box complexity guess probably fault completely fallible programmeri could gone erlang nifs designed short stateless sideeffectless computation basically opposite database port driver remain fastest way interface foreign librariesthe go ffi stuff make sense onetoone mapping c function type call etc make really easy readablei used ffi stuff erlang ffi solution definitely favorite would love know others using port driver interconnectivity erlang see good example go contributorsmaybe infobubble find gopher friend erlang friend since imperative syntax mostly familiar people guess make openwhen project mayonnaise themed take get shipping binaryi would rather ship binary rather beam file day find much easier ship plain old cgo source code around erlang code depends eih header apparently nt even compiled right architecture o x take real witch brew properly find include link header could never get link properly o x unix signal handlingthis really killed erlang idea program running vm together seperate plane existance userland ca nt send sigterm program send event based instead send signal running erlang shell tell ignore bi bash catch send signal via new erlang shell telling program halt cleanupall make nightmare deal bigger erlang program rabbitmq actordb use ctl script sort thing want fun peruse couchdb init script sometime conclusionserlang great love much rather create project erlang go made concession next time probably follow guideline listen community otp erlangmk rebar everythingerlang thing project weird dependency erlang stand strong alone see riak couchdb rabbitmqread erlang anger read find doi would really love see people talking done port driver nifs bifs stuff spelunking mochi webserver source code figure acceptor pool thing really fun erlang community really need visibility stick go c
447,Lobsters,erlang,Erlang development,"Early bird registration opens for LambdaConf 2015 (May 22 - 24, Boulder CO)",http://degoesconsulting.com/lambdaconf-2015,early bird registration open lambdaconf may boulder co,ranjit jhala jared roesch gershom bazerman john de go chris allen sharon steed sergii dymchenko richard eisenberg andrew cherry paige bailey chandu tennety alejandro serrano mena joe nash phil freeman alex gremm steven proctor adam foltzer cryptol mark farrell brian mckenna idris idrismode idrisvim andi mcclure deian stefan lio hail doug mcilroy marconi lanna paul phillips brendan mcadams alejandro serrano mena adelbert chang adam pingel daniel spiewak brian l troutwine gershom bazerman john de go richard feldman marconi lanna riccardo terrell joe nash rob norris justin campbell zeeshan lakhani colt frederickson chris allen nick heiner aysylu greenberg priyatam mudivarti david greenberg jon sterling andrew cherry emiliano firmino chandu tennety derek chenbecker andré van delft anatoliy kmetyuk wwwsubscriptlangorg mike stew oconnor harold carr vlad patryshev matt farmer joseph tel abrahamson joseph tel abrahamson ron toland rahul kavale jeanrémi desjardins kris nuttycombe pawel szulc alex burkhart,haskell liquidhaskell refinement type haskell ranjit jhala haskell many delightful feature perhaps beloved type system allows developer specify verify variety program property compile time however many property typically depend relationship program value impossible least cumbersome encode within haskell type system refinement type enable specification verification valuedependent property extending haskell type system logical predicate drawn efficiently decidable logic talk start high level description refinement type next present overview liquidhaskell refinement type checker haskell particular describe kind property checked ranging generic requirement like like totality head crash termination mergesort loop forever application specific concern like memory safety code segfault data structure correctness invariant various library like container hscolour bytestring text vectoralgorithms xmonad rust introduction rust got type system programming jared roesch workshop intended deep dive rust starting basic advanced type level programming rust new experimental programming language currently designed mozilla research language active community language inspired several variant ml haskell c well novel research idea performance safety programming language one key feature reification memory explicit part language semantics provides low level control memory allocation without sacrificing safety garbage collection goal workshop show use rust write high level code provides excellent safety performance haskell art program derivation parallel computation gershom bazerman program derivation practice beginning specification function series mechanical step deriving efficient implementation algebra programming approach pioneered richard bird oege de moor lambert merteens derive efficient functional program series algebraic manipulation much schoolchildren take typical algebraic function solve x simplify earlymid school research turned attention problem parallel computing developed many foundation called mapreduce workshop run famous nifty algorithm derivation parallel sequential alike attendee walk away weird trick level equational reasoning everyday programming context hopefully enough intuition dive deeply rich body literature purescript learn functional programming purescript john de go workshop designed programmer skill level want learn functional programming purescript ideal learning functional programming language simple clean semantics run platform compiles ubiquitous javascript workshop learn mean think functionally write functional code explore core concept purescript end written first functional program simple game able call rookie functional programmer else instructor promise buy coffee haskell modeling data haskell beginner chris allen pattern modeling data obvious widely covered haskell require application basic algebraic datatypes explore approach dual purpose introducing thinking term algebraic datatypes haskell audience expected know haskell conversation stuttering teach talking human sharon steed developer trained communicate thing goal mind talking something like say computer type code responds giving back want nine time ten work perfectly difficult thing talking client project updating superior progress pitching investor milliondollar idea talking people requires special set skill namely empathy little bit storytelling industry filled brilliant mind great idea mass disruption best brightest know tell compelling story takeaway workshop learning value listener use vulnerability improve social connection prolog introduction constraint logic programming sergii dymchenko constraint logic programming paradigm allows solving hard combinatorial problem minimal programming effort workshop learn basic prologbased constraint logic programming system eclipse solve several puzzle get hint constraint logic programming useful reallife project haskell practical introduction haskell gadts richard eisenberg burgeoning haskeller soon discovers proper use descriptive type help capture realworld idea catch error aid refactoring speed development indeed make programming fun haskeller drunk welltyped koolaid go answer even type generalized algebraic datatype gadt core allows compiler make different assumption type within different branch pattern match leveraging power allows programmer encode detailed invariant datatype algorithm invariant checked compile time clever use gadts also let remove certain us unsafecoerce long proved safe workshop handson interactive tutorial using haskell gadts practical setting f freya f http system andrew cherry freya stack library f designed let get close http functional typed way well providing useful set abstraction http also offer graph based approach modelling http response enabling creation wellbehaved http application simply correctly take tour stack exercise various part individually diving write complete http application see easy write application take full advantage http standard look way extending application past world rfcs world hypermedia graph session comfortable building application using freya almost certainly come great idea freya graph based approach logical design could extended even introduction clojure programming language longing paige bailey grab repl prettiest pair parenthesis beginnerfriendly workshop even never coded learn think clojure would want get opportunity handson experimentation zach oakes nightmod developer tool making livemoddable game clojure relatively new powerful dynamic lisp dialect compiles many target environment including jvm javascript clr important single principle behind clojure simplicity abstraction simple orthogonal mean compromise power la carte polymorphism careful support name namespaces reference succession model wide selection small composable protocol make clojure programming swift surgical accurate perfect game development ready brave programmer time get atomic clojurescript datadriven webapps clojurescript om chandu tennety om flavor facebook reactjs take advantage immutable data structure make virtual domdiffing algorithm much faster clojurescript environment work simple example get understanding state represented passed component order build fast functional uis haskell developing web application haskell alejandro serrano mena web development easy fun haskell course type safe let take birdseye tour creating web application haskell scratch initial project creation deployment cloud end workshop deployed small server notetaking workshop divided four slot dealing different facet web development first simple routing building html returned client adding database capability using persistent esqueleto next step taking input user via digestive functors finally deployment heroku considered along integrating middleware application elm adventure elm writing adventure game elm joe nash elm functional reactive language compiles html cs javascript haskelllike syntax thanks combination smart language design innovative webbased tool incredibly easy write interactive application elm workshop cover basic concept language syntax dive hotswapping editor timetravelling debugger build adventure game using functional reactive technqiues purescript purelyfunctional web apps using react purescript phil freeman react popularized idea user interface pure function application state approach perfectly suited language like purescript workshop learn use react purescript create clean wellfactored web application workshop assumes basic knowledge purescript related language haskell reason considered continuation earlier purescript workshop beginner haskell introduction haskell focus highperformance computing alex gremm workshop give introduction haskell programming language work basic concept functional programming specifically haskell implementing simple diffusion algorithm convergence check using naive implementation learn identify performance bottleneck overcome order achieve highperforming sequential code erlang introduction erlang steven proctor heard nothing else erlang probably heard something otp people chanting process thread process really cheap ohmmmm workshop get overview erlang syntax otp process management cheap erlang process really implement markov chain generator state possible transition represented process cryptol intro cryptol highassurance crypto engineering adam foltzer cryptol open source pure functional language expressing reasoning bitprecise computation particularly cryptographic algorithm like haskell built upon polymorphic static type system offer similar mathematical function sequence comprehension notation type system feature size polymorphism arithmetic type predicate designed express constraint naturally arise cryptographic specification advanced type system restricted domain cryptol enables theoremdriven development style correctness property expressed directly language tandem development specification specification evolves property continually fuzztested random quickcheckstyle testing even sent external sat smt solver mathematical proof correctness workshop give quick introduction cryptol language geared toward folk working knowledge typed functional programming together implement classical cryptosystem learn basic syntax semantics language program express check correctness property implementation using quickcheck smt finally demonstrate cryptol specification zuc stream cipher used lte communication show theoremdriven development approach reveals bug required revision cipher typed racket introduction typed racket mark farrell workshop give introduction typed racket give overview feature type system go example typing old untyped racket code provide accompanying typing exercise people try also discus current issue trusting typed racket eg sketchy example mixing typed untyped code finally discus need add type annotation significant number existing racket module try get people interested contributing typed racket prior experience using lisplike functional programming language schemeracket could asset understanding content workshop though none required idris write idris brian mckenna idris dependently typed programming language unlike dependently typed system idris designed specifically writing executable program workshop slowly walk writing program using dependent type motivate us around correctness expressivity workshop modeled similarly lambdaconf new example demonstrate idris capable prerequisite knowledge familiarity algebraic data type important idris repl installed optionally interactive editor configuration emacs idrismode vim idrisvim emily introducing emily simplifying functional programming andi mcclure emily experimental language project focusing simplifying basis programming language model language operation composition functionlike entity equivalent combinators state mean function object class variable scope interface generally interchangeable goal make fp language capability accessible entrylevel fpwary programmer mean simple concept configurable scriptinglanguagelike syntax haskell building secure system haskell deian stefan modern particular web userspecific often sensitive information unfortunately protecting user data notoriously difficult framework provide way declaring enforcing applicationspecific security policy response developer often specify enforce security policy adhoc fashion eg strewing security check throughout codebase even one manages get check right place application rely third party library may expose vulnerability case happen malicious recent headline alone serve highlight existing approach application plagued privacy leak talk first describe lio haskell library building secure system lio information flow control ifc provides apis specifying policy data allowed readwrite data enforces policy code leveraging haskell monad strong type system describe hail web framework built top lio make easy specify policy declarative way defining application data type hail application construction protect user privacy integrity haskell haskell nugget power series brought life doug mcilroy operation power series showcase elegance expressiveness overloading lazy evaluation simple oneliners sum product integral derivative functional composition functional inverse etc vividly embody underlying mathematics even improve upon banishing subscript series solution differential equation come practically free generating function actively generate scala new scala marconi lanna programming scala martin odersky et al one comprehensive de facto reference scala however book originally published scala updated since second edition covering scala meantime scala major release numerous fresh advanced feature wait third edition programming scala describe latest greatest scala feature introduced last year talk present main feature introduced scala well exciting peek beyond scala future none virtual filesystem change everything paul phillips talk paul phillips expands idea keynote deliver compelling vision properly conceived implemented virtual file system ability literally change every single thing interact computer scala skeptic look scalaz gateway drug practical exploration brendan mcadams seen corner local software development neighborhood fp purist shamelessly peddling scalaz unsuspecting developer lured promise free monoids semigroups endofunctors developer soon seem lost throe ecstatic coding skeptical stubbornly practical among u might ring little true especially read rod serling voice image gibbering horror lurking depth mathematical perfection swim eye true value world scalaz possible use tool good little bit evil fun use learning evil profit without getting hopelessly lost opium den fp talk look gateway drug scalaz validation nonemptylist monad transformer work practical standpoint value real world application use without advanced math phd fun really code tool haskell pattern functors wandering around fixpoints free monad generic alejandro serrano mena free monad generic programming fixpoints coproducts data type usually considered advanced topic haskell programmer talk look concept unifying lens combining enriching pattern functors pattern functor strippeddown description data type shape constructor remain recursive structure gone using haskell manipulate pattern functors create new data type various like functional programming adelbert chang shortly adelbert chang entered college computer science major contemplated changing major several time usually direction physic mathematics changed introduced functional programming mysterious beautiful talk adelbert elaborate early perspective computer science math physic discus ended enamored functional programming scala axle spirebased dsl adam pingel axle scalaembedded domainspecific language built spire talk cover architecture objective project live coding example show design pattern abstract algebra apply range domain including machine learning bioinformatics game theory statistic data visualization various selfish purity functional programming make everyday job easier daniel spiewak functional programming toooften viewed academic discipline fp imposes constraint seem aesthetic pedantic practical almost motivating example fp involve oneliners mapping list handwaving endomorphisms rather something earth talk take different approach functional programming make thing easier make easier write code test code design component abstraction make turnaround time faster bug rarer even improves application throughput talk explains possible precisely never work serious application without fp also touch briefly fp work nt work common industrial language like java javascript gain benefit expanding toolset bit erlang faulttolerance cheap making system probably wo nt fall brian l troutwine building computer system reliable hard functional programming community invested lot time energy upfrontcorrectness guarantee type like unfortunately absolutely correct software timeconsuming write expensive result faulttolerant system achieve systemtotal reliability accepting subcomponents fail planning failure firstclass concern system company embrace wave asaservice architecture failure subsystem become pressing concern using example heavy industry aeronautics telecom system talk explore design faulttolerance functional programming technique get u way none abstract method general gershom bazerman programming abstraction abstraction surely programming need keep reinventing even recognize see across many domain something abstract necessarily useless even though definitionally removed specific use even case often teach functional programming met response taught abstraction good certain realm mathematics category theory often elicit similar response talk investigation consider abstraction process applying next great functional programming language john de go john clue next great functional programming language like happy hop stage rant type class nominative typing data module pattern matching recursion well basically everything else associate functional programming john argue make radical progress cheaply building correct software need take one step backward two step forward embracing dependenttyping total function turingcomplete compiler host language automated proof search attend talk question assumption functional programming heckle either way welcome elm shipping production web app elm richard feldman happens take coffeescript web app designed edit novel scratchrewrite elm turn result faster robust massively easier maintain elm simple design mean even functional programming novice quickly get speed static type inference pervasive immutability firstclass frp system excellent language also great introductory fp language javascript developer pick talk dive nut bolt shipping production web app elm including question like choose elm transition imperative architecture frp extent leverage javascript library ecosystem without sacrificing functional invariant come see pleasant functional programming browser scala idiomatic scala option match marconi lanna scaladoc page option say idiomatic way use scalaoption instance treat collection monad use map flatmap filter foreach lessidiomatic way use scalaoption value via pattern matching talk show use option monad idiomatic functional style leveraging comprehensive set higherorder function solve coding situation concise declarative manner talk never pattern match option f building concurrent faulttolerant scalable application f using akkanet riccardo terrell writing correct concurrent faulttolerant scalable application simple task struggle generally result using wrong tool wrong level abstraction actor based concurrency model aim simplify process actor model mathematical model concurrent computation originated carl hewitt peter bishop richard steiger actor programming one widely applicable programming model provides support concurrency improving distribution error detection fault tolerance good fit kind programming problem find faced today increasingly distributed world actor raise abstraction level provide better platform build correct concurrent scalable application presentation introduce concept architecture immutability isolation asynchronous processing utilizing tool akkanet net port popular jvm framework akka goal provide solid knowledge foundation actor model following presentation attendee take enough material start use leverage actor model write successful concurrent application haskell accelerating haskell gpgpu programming haskell joe nash many machine device come equipped powerful graphical processing unit gpus unit hundred processing core exploited accelerate application offloading applicable code gpu instead cpu talk cover basic concept general purpose programming gpus show exploited functional programming language haskell via accelerate library scala program value pure composable database access scala rob norris fp often glibly described programming function equivalently say fp programming value function value failure value effect value indeed program treated value talk explores consequence idea programsasvalues looking doobie purefunctional database library scala examine lowlevel implementation via free monad algebra jdbc type show naturally enables expressive safe highlevel api familiar lightweight composable abstraction including streaming result set trivial compatibility pure library like remotely even market database layer talk provide practical outline general solution dealing terrible apis like jdbc principled way various make hello world justin campbell many language strength weakness different community surrounding evaluate new language technology pragmatic introducing thing production let talk language exploration discus learn new language consideration introducing thing production come idea ruby ecosystem plan dipping toe elixir go haskell ruby rust scala session lispflavored erlang meaning lfe zeeshan lakhani enjoy lispbased language built sexpressions homoiconicity like writing syntactic abstraction pattern matching could use lisp write faulttolerant highlyavailable distributed datastore welcome wonderful world lfe lispflavored erlang cover basic lfe toolchain macro system intermediate representation step core erlang ending beam erlang virtual machine scala scalaz level scalaz foo colt frederickson scalaz massive library full many critical fp abstraction bit dense dipped scalaz couple thing either validation sure else use talk haskell learn haskell le year chris allen haskell known hard result pedagogy catching different way thinking structuring program make teaching others something effective enjoyable right imagination make programming language nick heiner used typing code editor seeing computer something run familiar easy take granted go sequence character something machine execute knowing help program effectively empower create programming language give overview pipeline text editor machine behavior dive look specific tool help u create programming language also discus different language design decision static versus dynamic typing see implemented behind scene end ready bring new language world clojure loom functional graph clojure aysylu greenberg graph ubiquitous data structure algorithm analyzing fascinating loom opensource clojure library provides many graph algorithm visualization discus graph represented functional world bridge gap procedural description algorithm functional implementation learn way loom integrates graph representation clojureclojurescript fullstack fp datomic clojure clojurescript priyatam mudivarti happens prototype app entirely fp choosing functional database building http apis designing template possible day stay entirely fp land talk share experience building functional prototype clojure clojurescript using following library datomic ring om garden discus trade popular database web toolkits template engine even le sas favor simpler library embrace immutable data sequence value none dynamic v static discussion without sounding like lunatic david greenberg type remain highly contentious issue programmer industry rail python massive community drive highprofile hightraffic successful business github reddit dropbox clearly dynamic language better choice java c unless course count myriad business powered statically typed language eg java statement infuriate engineer academic know hindleymilner type system type system reduce defect improve code quality talk take look type system different lens type system actually business decision frequently cast emotional decision none type theory meaning explanation jon sterling heart intuitionistic type theory lie intuitive semantics called meaning explanation crucially meaning explanation taken definitive type theory core notion longer proof verification explore type theory sort arise naturally enrichment logical theory judgement contrast modern prooftheoretic type theory interpret judgement proof logic proposition verification expect following question answered difference judgement proposition meaning explanation difference proof verification socalled semantical approach type theory speaker view immediately philosophically acceptable modern syntactic one also provides basis future partiality effect may treated naturally refinement behavioral typing rather mean termlevel monad similar kludge none http functional programming andrew cherry http fascinating standard one use every day many different way reasoning http mean look approach taken model http layer particularly functional programming graph proof type system fair game ooerlang ooerlang programmerfriendly approach oop erlang emiliano firmino objectoriented programming oop dominates industry developer experience oo new functional programming help bring functional programming developed ooerlang extension erlang fully support oo simpler syntax previous approach talk present implemented ooerlang start using clojurescript bird eye view clojurescript chandu tennety bird travel thousand mile year migrate flying hour little food rest comparison migrating database seems like paltry feat birdwave way visualize amazing phenomenon bird migration using clojurescript om allowed app written declarative concise manner taking full advantage javascript interoperability well clojure awesome builtin feature persistent data structure async module also prepare dazzled dataviz powerhouse bird harmed creation birdwave talk scala scalazstreams functional approach compositional streaming io derek chenbecker serious announcer voice world gone mad data one library stand alone fight sloppy unsafe processing serious announcer voice scalazstream library brings type safety flexibile composition powerful abstraction world streaming data processing talk start basic building block move advanced technique covering good bad ugly along way scala reactive programming algebra andré van delft anatoliy kmetyuk r reactive programming growing delivered many language construct library tool scala programmer use thread timer actor future promise observables async construct others still seems u state art mature reactive programming relatively hard confidence correct operation depends mainly extensive testing better support reasoning correctness would useful address timing dependent issue algebra communicating process acp potential improve let one concisely specify event handling concurrency facilitates reasoning parallel system acpbased extension scala named subscript show help describing internal behavior akka actor combine future information see wwwsubscriptlangorg scala cat fresh look functional programming scala mike stew oconnor cat library aim fill gap scala standard library think necessary pure functional programming scala way scalaz attempt fill role project intends create functional library intends create community welcoming opportunity start library like scratch give u many delicious opportunity rethink past decision allowing u innovate unexpected way haskell programming math harold carr design pattern useful way organize software unfortunately gangoffour like pattern composable due sideeffects pure ie sideeffects language function composed make possible leverage pattern mathematics talk show algebra function composition identity function isomorphism co product gluing function compose functors show algebra relates realworld programming goal talk provide initial intuition apply pattern math programming motivate continue studying perhaps looking uber pattern category theory note knowing pattern necessary getting work done functional language talk give glimpse may useful talk illustrates idea using haskell aimed fp beginner none introduction intuitionistic type theory vlad patryshev traditionally computer science set assumed basis type theory together boolean logic version type theory need set boolean logic intuitionism enough principle excluded middle required underlying math topos theory required even aware existence theory described using diagram traditional tricky deduction rule resulting theory turn dependent type simple reallife example two illustrate none case cuttingedge matt farmer story road le traveled talk going take look impact choosing le common technology like scala clojure organizational level elemica include thing worked well u thing nt work well myth two able dispell along way land process figuring worthwhile endeavor haskell give freedom forgeddaboutit free really mean joseph tel abrahamson haskell community often abuzz free monad stick around long enough also see notion free monoids free functors yonedacoyoneda free seminearrings etc clearly freedom larger concept free f f free f talk explores briefly origin freedom category theory explains mean free x thing x talk little bit useful free structure exist haskell haskell finally tagless dsl mtl joseph tel abrahamson finally tagless dsl dsl embedding technique pioneered oleg kiselyov jaques carrette chungchieh sense dual notion freemonad interpreter mtl popular monad library haskell happens unbeknownst finally tagless dsl talk explores finally tagless dsl style offer show use concept extend effecttyping vocabulary mtl clojure clojure v design pattern ron toland talk look design pattern oop translate clojure unnecessary embedded language others easier build scala simple collection distributed processing functional way rahul kavale presentation talking way functional programming idea affect fit distributed computing world introduction apache spark idea implemented quiet successfully talk implementing live coding distributed collection abstraction using basic principle functional programming start computation simple memory collection evolve fully distributed collection property like fault tolerance etc scala computation expression scala jeanrémi desjardins computation expression generalization donotation idiom bracket provide single notation us least powerful abstraction order translate sugared code desugared code flexible way possible present project working implement computation expression scala particular show notation help write asynchronous code little cognitive overhead various parametricity essence information hiding kris nuttycombe introductory talk designed help student new functional programming understand type parameter enable u easily reason behavior function create apis enforce invariant typelevel constraint cover principle universal existential quantification review example reasoning behavior function type discus implication compositionality api design example haskell discus principle generalize even code written unityped language scala monad asking right question pawel szulc entering world functional programming one quickly introduced concept monad concept reason really hard grasp comprehend querying internet monad likely learn need know category theory understand monad asking right question first thing came mind struggling dilemma well right question talk looking right question answering talk hope find knowing understanding concept able apply daily programming routine rust rust trust alex burkhart rust aim build solid foundation building safe software system faster ensure fewer mistake enter code base immutability default concept null proven memory safety rust state art compiler help developer catch error early possible without paying penalty runtime developer write high level code modern language without sacrificing expressiveness development time execution speed explore rust concept ownership key providing compiletime safety guarantee apply even face concurrency allowing easily write multithreaded program correctly first time rust released may start building better software today
448,Lobsters,erlang,Erlang development,Lisp flavoured erlang,http://lfe.io/,lisp flavoured erlang,script standalone library bread butter otp application otp release sophisticated machinery,script addition heavyduty power lfe get free virtue erlang vm also create small easytowrite oneoff main script lfescripts even escripts either single file additional module help organise larger script standalone library building library use lfe application even erlang beam language application bread butter lfe hacker erlangbeam ecosystem fully accessible lfe application also freedom lfe otp application take advantage otp lfe mere second creating faulttolerant application builtin process monitoring supervision tree genservers behaviour never go otp release lfe prototype ready bigtime run sophisticated machinery otp release fact nt wait start prototype release zero pain benefit
449,Lobsters,erlang,Erlang development,Composable Queries with Ecto,http://blog.drewolson.org/blog/2015/01/23/composable-queries-with-ecto/,composable query ecto,composable query ecto previous post ecto ecto querying ecto keyword query syntax select post select published post select comment post query expression select post select published post select comment post query composition putting together phoenix wrap update,january composable query ecto previous post briefly covered lesson learned building kind real web app elixir today like take indepth look composable query ecto first brief introduction ecto ecto think ecto lightweight orm ecto us elixir structs represent database table provides dsl building executing database query boring going use agesold many example demonstrate capability assume following model defmodule myapppost use ectomodel import ectoquery schema post field body string field published boolean field publishedat datetime field title string hasmany comment myappcomment end end defmodule myappcomment use ectomodel import ectoquery schema comment field commenter string field title string field vote integer belongsto post myapppost end end querying ecto ecto provides two style querying syntax keyword query syntax query expression note query style construction query distinct separate process execution query style constructed query passed repo executed keyword query syntax keyword query syntax closely mirror sql feel lot like linq demonstrate using example query select post myapprepoall p myapppost select p select published post myapprepoall p myapppost ppublished true select p select comment post myapprepoall c myappcomment join p assoc c post pid select c query expression query expression follow pipeline concept often seen elixir apis important note query start model module eg myapppost model queryable object represents item given table example using query expression select post myapppost myapprepoall select published post myapppost p ppublished true myapprepoall select comment post myappcomment join left c p assoc c post p pid select c c myapprepoall query composition easy see query built query expression style composed simply add new constraint pipeline immediately obvious compose query built keyword query syntax compose query differing type first must understand important feature keyword query syntax clause token queryable object query queryable example query p myapppost select p p query ppublished true myapprepoall knowing mix match query syntax type query p myapppost select p query p ppublished true myapprepoall putting together add function ecto model nice descriptive name defmodule myapppost use ectomodel import ectoquery schema post field body string field published boolean field publishedat datetime field title string hasmany comment myappcomment end def published query p query ppublished true end def sorted query p query orderby desc ppublishedat end end defmodule myappcomment use ectomodel import ectoquery schema comment field commenter string field title string field vote integer belongsto post myapppost end def forpost query post c query join p assoc c post pid postid end def popular query query c cvotes end end used style querying show interchangability come composition use function build query normally type composition phoenix controller alias myapppost alias myappcomment publishedposts post postpublished myapprepoall lastpost post postpublished postsorted myapprepoone recentpopularcomments comment commentforpost lastpost commentpopular myapprepoall wrap hope give idea power flexibility ecto provides extracting reusable query component composing build complex query found technique reduce duplication complexity aiding testing update find talk gave subject elixirconf
450,Lobsters,erlang,Erlang development,Building an Elixir Web App,http://blog.drewolson.org/blog/2015/01/19/building-an-elixir-web-app/,building elixir web app,building elixir web app elixir ecto phoenix pipeline friend rack separate api endpoint scope create custom json serializers build query model execute controller create shared partial adding shared view wrap chris eric update follow post,january building elixir web app past month building small internal application work using elixir ecto phoenix absolute blast thought would useful put together blog post technique found helpful using tool build databasebacked web app post intended introducion tool assume knowledge elixir ecto phoenix note elixir ecto phoenix thing move fast post may quickly become date pipeline friend phoenix concept pipeline series plug think rack middleware executed order send request given scope url pipeline application pipeline browser pipeline authentication pipeline api request mix match pipeline accept browser request without authentication api request without authentication routerex look something like defmodule myapprouter use phoenixrouter pipeline api plug accepts w json end pipeline auth plug myappplugauthentication end pipeline browser plug accepts w html plug fetchsession plug fetchflash plug myappplugcsrf end public route via browser scope alias myapp pipethrough browser end private route via browser scope alias myapp pipethrough browser auth end public route via api scope alias myapp pipethrough api end private route via api scope alias myapp pipethrough api auth end separate api endpoint scope lead next point chose separate api distinct scope give convenience using controller action expose api using serve browser request also allows flexibility exposing subset route entirely new action route suppose resource application accessible via browser index action accessible via api could following scope alias myapp pipethrough browser auth resource page pagecontroller end scope alias myapp pipethrough api auth resource page pagecontroller index end pagecontrollerindex action serve api browser request user try access pagecontrollershow via api refuse serve json create custom json serializers creating custom json serializers phoenix easy powerful first override appropriate render function view continue previous page example assume render function called collection page object defmodule myapppageview def render indexjson page page page end end note return value render call provided page quite work yet phoenix expects anything returned json action implement poisonencoder protocol put custom serialization logic defimpl poisonencoder myapppage def encode page option title pagetitle body pagebody poisonencoderencode end end tada create custom json data phoenix poison smart enough iterate collection page build json yahoo build query model execute controller found convenient model responsible building query controller responsible executing query defmodule myapppage use ectomodel import ectoquery schema page field title string field body string field published boolean end def published p myapppage ppublished true end end defmodule myapppagecontroller use phoenixcontroller plug action def index conn params page myapppagepublished myapprepoall render conn index page page end end biggest benefit style composibility query started writing query expect prior query chain together controller defmodule myapppage use ectomodel import ectoquery schema page field title string field body string field published boolean field pubishedat datetime end def published query p query ppublished true end def recent query p query ppublishedat myapphelperdateyesterday end end defmodule myapppagecontroller use phoenixcontroller alias myapppage plug action def index conn params page page pagepublished pagerecent myapprepoall render conn index page page end end create shared partial adding shared view wanted able render common html snippet across many template rendering form error created sharedview explicitly rendered shared template defmodule myappsharedview use myappview end render myappsharedview errorshtml error error wrap topic deserves full post many technique covered testing changesets custom validation etc awe speed elixir ecto phoenix communites moving expect great thing chris eric rest hold butt update see follow post composing ecto query detailed information topic
451,Lobsters,erlang,Erlang development,The eleventh year: what to do after having taught yourself programming in ten years,https://medium.com/@unbalancedparen/the-eleventh-year-what-to-do-after-having-taught-yourself-programming-in-ten-years-a607edfcef03,eleventh year taught programming ten year,lucky stiff programmer sysadmin average novice erlang also led haskell lispclojure parsec cleaning closet gut gut template tinyerl tinyerl become erlang cowboy tame wild wild web part lunfardo fish oh fish dwm tiling window manager nature lisp git client evil prelude lunfardo sublime spawned shelter spawned shelter superherojs distributed system cassandra zookeeper inaka erlang solution brujo distributed system fun profit reading list post riak riak core trytrytry venti jesper l andersen code fuse safetyvalve dispcount workerpool epocxy pobox fred hébert programming language programming language compiler lexical analysis parser generator bnf grammar context free grammar lalr flex bison lemon antlr ragel bnfc rpython hyperglot parsing weakest link software security build lisp create programming language parsec peg parser limitation real world haskell learnhaskell introtoparsing haskell llvm write scheme hour done based real evidence really awesome already done leex yecc luerl lfe toy language indie programming language need cool project guide little book o development end friend end,create thing become defined taste rather ability taste narrow exclude people create lucky stiffchristmas new year eve passed kilogram fatter spent last day reading hacker news reddit playing league legend gta v finally even never accomplish know time write goal new yearafter working decade programmer sysadmin know nothing average developer novice know little bit many thing developing quite time c c ruby python javascript wanted move something else bored thankfully working erlang year half introduced amazing world functional programming distributed system parallalelism concurrency way going back erlang also led haskell lispclojure world found haskell awesome parsec parser combinator library bottom rabbit hole compiler programming language design finally lisp selling point made migrate vim emacsin post try share goal year check next year measure outcame really hope find interesting link least encourages write goal next year check much improvement made cleaning closetgutfirst need finish project gut pronounced goot short gutenberg gut template printing aka scaffolding tool erlang like rail generate yeoman created last job something erlang developer know often creating project scratch erlang application many setup file rebarconfig makefile erlangmk projectappsrc relsysconfig configvmargs tipically projectapperl projectsuperl creating every time need create new project new customer pretty boring overwhelming newcomer created gut tool us project generator instantiate new project generator created user need add gut anybody use since gut fetch latest erlang build tool similar concept called template aware created gut try change gut gut generator fully compatible template way template solve problem gut however gut automatically download demand generatortemplate available github instantiate new projecttinyerltinyerl really small project show easy create url shortener service erlang using different http server cowboy axiom elli leptus meant teach erlang need polish little bit update become erlang cowboy tame wild wild web part writing part ii based tinyerllunfardolike devs tested used many ides eclipse netbeans xcode visual studio intellij idea rubymine pycharm code block aptana nevertheless last year could never move away combination good shell like fish good configuration like oh fish customized vim based distribution simple great dwm tiling window managerafter reading nature lisp interested using lisp never invested enough time really play watching coworker use emacs good ruby minor mode started using emacs elisp emacs like mini operating system package manager best git client used great mode like editing undotree treating history treethis video show really well easy hack emacs lisp issue emacs like modal editing á la vi hopefully emacs great mode called evil transforms emacs best vim editor viminspired bbatsov prelude distribution coded distribution called lunfardo still alpha stage yet great elisp coder keep adding removing mode shortcut yet commited code managing programming language use python ruby javascript erlang c haskell already used emacs shortcut really like changing modern one final objective use emacs platform default shortcut based sublime shortcut quickly toggle vim modal editing see work quite excited completely sure possible easily change everthing want emacs specially shorcuts recommend test lunfardo yet since break often pretty sure find cool idea modesspawned shelterfinally year started acollection best article video presentation related erlang called spawned shelter wanted create static web page like superherojs erlang way busy pretty sad since could yet end year completely sure finisheddistributed systemsusing erlang apache cassandra zookeeper last project final step needed take fully interested distributed system thankfull previous employer inaka erlang solution giving oportunity work tool learn great teammate cto brujodistributed system fun profit mini book best place start reading topic christopher meiklejohn reading list also seems good good place start without knowing thing beforefinally aphyr post talk also excellent place learn reading playing riak already decided next work project need use distributed database keyvalue store give try process reading riak found riak core toolkit building distributed scalable faulttolerant application giving try want implement something like trytrytrynext want implement venti network storage system hash data act address using riak erlang different jesper l andersen code objective learn create something newi hope spare time play following list interesting erlang library fuse safetyvalve dispcount workerpool epocxy pobox read latest book fred hébert programming languagesafter going programming language compiler coursera course become interested programming language design implementation started experimenting reading lexical analysis parser generator bnf grammar context free grammar lalr parsing flex bison lemon antlr ragel bnfc rpython hyperglot parsing weakest link software security reading needed get hand dirty followed build lisp create programming language process got really interested simplicity parsec peg parser saddly important limitation worth mentioning found parsec reading mindblowing book real world haskell check learnhaskell introtoparsing interested haskell parsecone goal year start writing programming language using haskell llvm something easier write scheme hour also us haskell obviously trying create next programming language might even impossible programming language design done based real evidencesomeday hope implement erlang clone run really awesome beam vm us indentation á la python way delimit block code instead would sort exact copy erlang without prolog terminator apparently already done ulf wiger would like leex yecc lex yacc erlang toolset used example luerl lfe mariano guerra implemented toy language incredible useful learning purpose using leex yecc implementing efene programming language clike syntax run erlang platformsince noob area like share learn continue interviewing language developer good devs indie programming language collection publish two interview following week meanwhile read need cool project able year hope next year able go linux scratch guide little book o development scratch surface operating system workthis end friend endas read free time trying code anything groundbreaking moment interested exploring thing workeven eleventh year world development pretty new stress enough much functional programming open mind least case mindblowing experience since opened hell gate distributed system programming language implementation design someday might time return old powerful c
452,Lobsters,erlang,Erlang development,"SyncFree / Programming Models, Part 4: Ad Counter, Part 2",http://christophermeiklejohn.com/lasp/erlang/2015/01/10/ad-counter-orset.html,syncfree programming model part ad counter part,post lasp intro post comprehensive study convergent commutative replicated data type motivation advertisement counter example creating advertisement counter initialize client process monotonic read extremely important initialize server process simulating request evaluation conclusion resource syncfree talk,discussed first post lasp name distributed deterministic programming model basis research providing expressive way working crdts eventual consistency intro post continuation work building eventually consistent advertisement counter using lasp get benefit article read first post series post look alternative method tracking list active advertisement replicated data structure support arbitrary number concurrent addition removal operation element set data structure called observedremove set orset originally formalized shapiro et al comprehensive study convergent commutative replicated data type motivation using observedremove set tracking active advertisement beneficial several reason removal handled correctly without coordination given propagation delay acceptable client longer need maintain list advertisement client track reference set active advertisement maintained variable store client periodically cache active advertisement list based divergence control strategy chosing client tracked list active advertisement would wait message server disable advertisement inevitably disable message demonstrated evaluation previous example delayed request view advertisement lead advertisement displayed significantly advertisement counter example broken example application four component create counter advertisement initialize process client viewing ad initialize process server tracking ad simulate bunch advertisement viewed creating advertisement counter alter original approach modeling advertisement counter growonly counter gcounter however instead tracking advertisement counter normal erlang list use observedremove set shown generate orset tracking advertisement counter ok ad lasp declare riakdtorset build advertisement counter add set list map fun ok id lasp declare riakdtgcounter ok lasp update ad add id undefined end list seq begin declaring new variable type riakdtorset advertisement want count impression update observedremove include initialize client process spawn client process respond request view advertisement generate orset tracking client ok client lasp declare riakdtorset client take full list ad start read variable store list map fun id clientpid spawnlink module client id ad undefined ok lasp update client add clientpid undefined end list seq client need track identifier active advertisement set instead list advertisement doc client process standard recurisve looping server client id ad previousvalue receive viewad get current ad list ok lasp read ad previousvalue adlist riakdtorset value case length adlist advertisement left display ignore message client id ad select random advertisement list active advertisement ad list nth random uniform length adlist adlist increment ok lasp update ad increment id lager info incremented ad counter p ad client id ad end end client longer responsible removing advertisement list display requested server process request view advertisement arrives client process either us locally cached copy advertisement displayable request variable store current list active advertisement monotonic read read operation used referring monotonic read monotonic read operation take previously observed value provided data type lattice block variable current value inflation previous simplicity think greaterthanorequalto relationship natural number want ensure never view value already observed value behavior extremely important variable store replicated using optimisic replication strategy failure condition may read replica contains earlier value would render program incorrect case observedremove set monotonic read operation allows u ensure always read value causal order never read empty set reading set value unless value specifically removed compared alternative case coordinationfree case would observe earlier value value added yet initialize server process previous example initialize one server process per advertisement launch server process advertisement block advertisement disabled create orset server list ok server lasp declare riakdtorset get current advertisement list ok lasp read ad adlist riakdtorset value advertisement launch one server tracking impression wait disable list foldl fun ad server serverpid spawnlink module server ad ad ok lasp update server add serverpid undefined server end server adlist however take slightly different approach first iterate current list advertisement spawning process one spawning process provide identifier list advertisement actual list advertisement doc server function advertisement counter view disable advertisement server ad ad blocking threshold read advertisement impression ok lasp read ad remove advertisement ok lasp update ad remove ad ad lager info removing ad p ad like blocking monotonic read unblock counter given advertisement reach least five read unblocks instead sending message client notifying remove ad modify set directly issuing update simulating request finally code run advertisement counter simulation start client simulation get client list ok lasp read client clientlist riakdtorset value viewer fun pid list nth random uniform clientlist pid viewad end list map viewer list seq example launch request view random sequence advertisement exercise code verify behavior correct evaluation let compare divergence approach gathering total impression impression impression impression impression original ad counter advertisement removal message interleaved request view advertisement suffer high amount divergence counter stop around stop get worse higher level concurrency introduced gathering total impression impression impression impression impression obviously reading directly variable store time cut divergence however dealing offline application approach viable valuable approach compared original client cache advertisement locally choose synchronize alters model shift divergence control client client update connectivity available diverge offline period instead relying delivery message server conclusion post introduced new concept monotonic read operation ensures read always advancing lattice defined data type object read ensures never read earlier value program evolve monotonically using observedremove set lasp build richer application additionally alleviated following problem previous example client longer need track possible state need act client control divergence choose long cache active list advertisement refresh instead relying message server shown evaluation method much better term divergence thanks reading resource interested research would like discus assist feel free contact using detail footer information syncfree use case focused research recommend talk given annette bieniusa ricon la vega
453,Lobsters,erlang,Erlang development,Scientific Computing on the Erlang VM,http://blog.lfe.io/tutorials/2015/01/01/1215-scientific-computing-on-the-erlang-vm/,scientific computing erlang vm,lsci py previously discussed background similar tutorial hy ipython notebook clojure incanter tutorial lsci example directory introduction py erlport setup loading data incanter linear regression tutorial nist filipdat note value plotting data curve fitting nist data set polynomial linear regression coefficient determination linear model class plotting model observed data conclusion development task,tutorial brings new year introducing erlanglfe scientific computing library lsci port wrapper numpy scipy among others erlang ecosystem topic tutorial polynomial curvefitting given data set additionally post demonstrates py usage previously discussed erlanglfe library running python code erlang vm background content post taken similar tutorial done author python lisp hy ipython notebook turn completely inspired clojure incanter tutorial subject david edgar liebke content also available lsci example directory introduction lsci library pronounced elsie provides access fast numerical processing library become popular scientific computing community lsci written lfe used easily erlang lsci provides following set feature wrapper function many generated dynamically via macro py wrapper erlport make calling python modulelevel function object attribute method constructor function object etc easy custom encodersdecoders wrapped data type lsci brandnew thus far go completely wrap functionality numpy scipy etc however enough done one perform task like polynomial curvefitting statistical regression setup run tutorial need following system erlang tested rebar lfetool python git place let get ready git clone git githubcom lfexlscigit cd lsci make pythonvenvbinactivate download erlang python dependency compile erlang libs set python virtualenv working directory familiar python last command allows one actually use python virtualenv library downloaded ready lfe repl loading data observed data going use data set used incanter linear regression tutorial nist filipdat file data file use conversion original nist file csv let load experimental data set data lscinp genfromtxt examplespolyfitfilipcsv delimiter listtobinary name true erlportopaque python b data returned function erlport binary wrapping python pickle numpy array take look data converting list lscinp list data note value nt noticed yet certainly run example lfe repl keep getting opaque binary data back numpy ca nt lsci convert would nice data presented u repl way could actually tell would run counter whole purpose using library like numpy scipy erlang vm first place would several thing add latency calculation reduce precision available numpy data type converted first python native type erlang data type bring erlangnative data type repl thus requiring u create new numpy data type pas back python wanted benefit numpy speed another way saying make difficult pas result back numpy processing lsci compromise providing convenience function converting returned result something look use function list float remainder tutorial purpose plotting data csv file header told genfromtxt use name true option easily extract axis data let look value separately set x lscinp get data x erlportopaque python set y lscinp get data erlportopaque python lscinp list x lscinp list y let plot data terminal lsciasciiplot scatter x y give something like oo oo ooo ooo oo oooo oo ooo oo oo oo ooo oooo oo oo ok curve fitting nist data set provided polynomial describing data x x x x e prefer latex begin equation x b x e end equation using numpy easily fit polynomial curve data use numpypolyfit finding least square polynomial fit passing value data fit well degree polynomial set coeffs lscinp polyfit x y erlportopaque python let peek data lscinp list coeffs numpypolyfit return data inclined passing full true option set coeffs residual rank singularvalues rcond lscinp polyfit x y full true erlportopaque python lscinp list coeffs lscinp list residual rank lscinp list singularvalues lscinp list rcond convenience class numpy instantiated fit data use evaluate given point let try set model lscinp coeffs erlportopaque python let call function several value sanity check lscinp list py func model lscinp list py func model lscinp list py func model lscinp list py func model lscinp list py func model lscinp list py func model examining original data set see check fine polynomial linear regression next let see linear model match nist provided going need calculate coefficient determination value indicates well statistical model fit measured data start feeding value model set ypredicted py func model x erlportopaque python lscinp list ypredicted also need several value order calculate per equation given wikipedia page linked mean value observed original data total sum square regression sum square sum square residual already following value observed nist data value generated model able calculate calculation set ymean lscinp lscinp sum y lscinp size y erlportopaque python set sstot lscinp sum lscinp lscinp y ymean erlportopaque python set ssreg lscinp sum lscinp lscinp ypredicted ymean erlportopaque python set ssres lscinp sum lscinp lscinp y ypredicted erlportopaque python instead lscinp may use lscinp prefer eg set ssres lscinp sum lscinp lscinp y ypredicted erlportopaque python use shortened alias may prefer long form set ymean lscinp divide lscinp sum y lscinp size y erlportopaque python set sstot lscinp sum lscinp power lscinp subtract y ymean erlportopaque python set ssreg lscinp sum lscinp power lscinp subtract ypredicted ymean erlportopaque python set ssres lscinp sum lscinp power lscinp subtract y ypredicted erlportopaque python let sanitycheck result lscinp float ymean lscinp float sstot lscinp float ssreg lscinp float ssres ready get value model set rsquared lscinp lscinp ssres sstot erlportopaque python lscinp float rsquared compare value original nist data file see model pretty well lscinp float lscinp rsquared pretty tiny difference linear model class linear model code bit cumbersome would much convenient multipleuse python class arithmetic u could get attribute value created class polynomiallinearmodel convenience class creating polynomial linear model def init self x y degree selfxs selfys x y selfdegree degree selfymean selfgetymean selfresults selfmodel selfyspredicted selfsstot selfssreg selfssres selfrsquared none none none none none none none selfcoeffs selfresiduals selfrank selfsingularvalues selfrcond none none none none none selfpolyfit def polyfit self selfcoeffs selfresiduals selfrank selfsingularvalues selfrcond nppolyfit selfxs selfys selfdegree fulltrue selfmodel selfcoeffs selfyspredicted selfmodel selfxs selfsstot selfgetsstot selfssreg selfgetssreg selfssres selfgetssres selfrsquared selfgetrsquared selfresults coeffs selfcoeffstolist residual selfresidualstolist rank selfrank singularvalues selfsingularvaluestolist rcond float selfrcond ymean float selfymean sstot float selfsstot ssreg float selfssreg ssres float selfssres rsquared float selfrsquared def predict self x return selfmodel x def getymean self return selfyssum selfyssize def getsstot self return selfys selfgetymean sum def getssreg self return selfyspredicted selfgetymean sum def getssres self return selfys selfyspredicted sum def getrsquared self return selfgetssres selfgetsstot def str self return str selfresults def repr self return selfstr saved python module lscinumpysupl lscinp wrapper function lscinp polylinearmodel added easily create linear model provides everything needed one go set model lscinp polylinearmodel x y erlportopaque python py ptype model lscinumpysuplpolynomiallinearmodel py attr model result dict rcond rank coeffs residual ssreg singularvalues rsquared ssres ymean sstot also extract need set rsquared py attr model rsquared erlportopaque python lscinp float rsquared created first model ran several value see output fit measured data one value returned let try new object lscinp float py method model predict nice plotting model observed data going need data feed fittedpoly function create smooth polynomial curve overlay scatter plot let create linear space minimum maximum x value point give u nice smooth curve let use fittedpoly generate value set xsfitted lscinp linspace py method x min py method x max num erlportopaque python set ysfitted py method model predict xsfitted ready put together defun plotboth lsciasciiplot scatter x y lsciasciiplot line xsfitted ysfitted hold true plotboth call plot function get following show scatter plot original data marker polynomial curve fit overlaid marker oo oo oo oo ooo ooo ok conclusion fast polynomial curvefitting lfe using python numpy scipy work begun lsci sort thing float boat sure take look development task come give u hand even though lot lot reward every little function get converted brings enormous satisfaction ability perform sort computing task without leave erlang ecosystem wonderful change hope one get used ca nt live without
454,Lobsters,erlang,Erlang development,termite - Erlang-style concurrency for Gambit Scheme,https://code.google.com/p/termite/,termite erlangstyle concurrency gambit scheme,,google code archive requires javascript enabled browser
455,Lobsters,erlang,Erlang development,Experience Report: Erlang in Acoustic Ray Tracing,http://homepage.cs.uri.edu/faculty/hamel/pubs/icfp08.pdf,experience report erlang acoustic ray tracing,,obj stream vݫ p g і ݳ f ҹ r q z g ϧ lmo j j x z g c q f n ilg lh wbdmo dy ʁ x l x u q aiœ bm v e g r r endobj obj endobj obj stream τ f kgr e jzz x q k x u zuy x lcf
456,Lobsters,erlang,Erlang development,Why do we need modules at all?,http://erlang.org/pipermail/erlang-questions/2011-May/058768.html,need module,erlangquestions need module erlang redacted http information erlangquestions mailing list,erlangquestions need module joe armstrong erlang redacted tue may cest need module braindumpstreamofconsciousnessthing thinking proposing slightly different way programming basic idea away module function unique distinct name function lot meta data function go global searchable keyvalue database need letrec contribution open source simple contributing single function open source project open source keyvalue database function content peer reviewed discussed particular order erlang module good bad side module good provides unit compilation unit code distribution unit code replacement bad difficult decide module put individual function break encapsulation see later aside libmiscerl programming often get point say function listserl nt nt small self contained thing listserl feel right string list two module listserl stringerl decide module new stringlist processing function go avoid mental anguish need small function somewhere else nt stick module export following find convenient write new small utility function stick mental anguish choosing module name involved observation find veryconvenient telling something module like feel right aside seems many development project private libmiscs brings point question need module erlang program composed lot small function place module seem useful hide letrec classic example fibonacci want expose hide helper function using module say module math export fib n fib n fib n b n fib n b fib ab downside invent one module name math whose purpose hide definition nt want made callable put second function module math second function could call break encapsulation could say let fib fun n fib n end fib n b n fib n b fib ab end hardly dare suggest syntax since following another thread forum syntax discussion seem encourage much comment please suggest alternative syntax comment people suggestion would like talk module another question idea module come idea function stored somewhere store file slurp file unit system file becomes module file store database would change thing thinking would nice function keyvalue database unique name lookup would get definition foo database unique name bit interesting good idea qualified name ie name like xxx sound like good idea programming invent xxx abc difficult also involves decision problem namespaces xxx abc already exist choose put new function think might case ali joe could used developing joe would expand horrible random local string real name would able publish code make available thirdpart chosen sensible name managing namespaces seems really tricky lot peoople seem thing problem go away adding name managing namespace namees like foobarbazz complex managing namespace name like foobarbazz name like problem go symbolic name like wwwab reference like discover initial name wwwab two answer given name ie click link know name search fo program small live code module ratio code meta data high program large need lot metadata understand would like see function metadata data base like say lookup attribute attribute codesourcedocumentationtype signaturesrevision historyauthors think think program development viewed changing state keyvalue database imagine function unique name module discover name function searching metadata describing function database public function think open source database could make system think would make opensource project easier since granularity contribution go could contribute single function entire application problem gut style open source project one database function often one function project another function another project granularity reusable part individual function function really easy reuse module difficult reuse entire application difficult reuse unless isolated communication channel possible extension voting promotion review process given raw database function could derive approved function database popular function could moved approved database review process would need discussed kind peerreviewwiki stuff comment volunteer joe next part html attachment scrubbed url http information erlangquestions mailing list
457,Lobsters,erlang,Erlang development,Example code: Websockets with Cowboy and Elixir,https://github.com/IdahoEv/cowboy-elixir-example,example code websockets cowboy elixir,cowboy elixir example cowboy web server elixir usage example included contributor contributing license,cowboy elixir example example using cowboy web server elixir wrote newcomer elixir found documenation cowboy inscrutable difficult command often take deep data structure argument structure sparsely documented best also uptodate example erlang rather elixir goal show simple usage main feature cowboy plenty documentation save others time spent puzzling tested work elixir edit dependency cowboy cowboy see branch usage make sure elixir installed clone repo change directory run following command mix depsget mix depscompile iex mix open browser example included serving static file dynamic html custom handler opening websocket pushing message client periodically planned accepting get request replying json object planned update cowboy contributor contributing pull request welcomed since example designed folk new elixir cowboy make sure code thoroughly documented please license code released mit license see license
458,Lobsters,erlang,Erlang development,Musings on mostly defensive programming styles,https://medium.com/@jlouis666/erlang-and-code-style-b5936dceb5e4,musing mostly defensive programming style,erlang code style musing mostly defensive programming style effect silly intentional data flow defensive programming process process isinteger scourge undefined open data representation src include cowboyreq value true false type atom edit closing remark,erlang code stylemusings mostly defensive programming stylescorrect erlang usage mandate write kind defensive code called intentional programming write code intentional control flow path expect code take write code path think possible furthermore write code data flow intention programit effect sillyif erlang program go wrong crash say opening file guard file open call like ok fd file open filename raw binary read readahead happens file exist well process crash note write code path default erlang crash match valid get badmatch error reason could open filea process crashing problem program still operating important faulttolerance concept make sure try little say introduced race condition file open accident happens rarely program would still run even file open fails time timeyou often see code look like ok foo ok bar ok asserts call went well making sure code crash control data flow expectednotice complete lack error handling writecase foo ok case bar end error reason throw error reason end fall trap go programming language write re err foo err nil panic err bar err nil panic also plain silly tedious cumbersome writethe key crasheffect erlang interpreter invoke default crash process something go wrong another process clean good erlang code abuse fact much possibleintentional note word intentional case expect call fail handle like everyone else would since emulate sumtypes erlang better language concept sumtype case file open filename raw read binary ok fd error enoent end written intention file might exist however worry non existencewe crash eaccess mean access error due permissionslikewise eisdir enotdir enospcwhy leaner code whywe skip lot defensive code often half code size project much le code maintain refactor need manipulate le code wellour code littered thing nothing normal code flow make far easier read code determine going onerlang process crash give lot information something dy proper otp process get state process died message sent triggered crash dump enough case reproduce error looking crash dump effect eliminates lot silly logging codedata flow defensive programminganother common way messing erlang program mangle incoming data pattern matching stuff like following convert isinteger convert f isfloat f round f convert l islist l listtointeger l function convert anything integer proceed use process anything convert anything problem process function callsites process function callsite different opinion data passed code lead situation every subsystem handle conversion like thesethere several disguise antipattern another smell convert x x convert b isbinary b x binary split b x stringified programming data pushed string manually deconstructed caller lead lot ugly code little provision extension laterrather trying handle different type enforce invariant early api process isinteger never test correctness inside subsystem dialyzer good inferring use integer littering code isinteger test going buy anything something wrong subsystem code crash go handle errorthere something said static typing force unityped world easily statically typed language could still obtain thing would define something along line standard ml code follows datatype anything int int string string real realand quickly becomes hard write pattern match hence people defines anything type really need gilad bracha partially right identified runtime check value omitted fact programmer decision avoid costly runtime check gilad scourge undefinedanother important smell undefined value story undefined often used program optionmaybe monad typetype option undefined value static typist erlang type system based success type figuring error one type definition straightforward define reflectionreification exceptioneffect jakob sievers library already well define monadic helper called though monad errortype rather option seen spec dox x ty undefined x undefined integer dox undefined undefined dox lead complicated code need control value fail value construction like silently pass undefined wary see code like undefined value essentially null car hoare billion dollar mistakethe problem code nullable default erlang never nulllike value introducing used sparingly think long hard value nullable check time tend make code convoluted complicated better test thing front leave main part code base much possible open data representationswhenever data structure set module know operates data structure single module emulate common pattern standard ml ocaml concrete data structure representation abstract program single module operate abstract typethis entirely true erlang anyone introspect data keeping illusion handy maintainabilitythe module manipulate data structure harder alter data structure consider putting record header file two level possible creeping insanity put record definition header file src case application see record leak outyou put record definition header file include case record leak application often willa good example http server cowboy request object manipulated cowboyreq module mean internal representation change keeping rest world stable module apithere case make sense export record think record manipulated several module chance win lot rethinking structure programthe value true false type atom final little nod see much code looking like f x true false true true hard read since erlang use better name true false value pick atom make sense produce atom also advantage catch bug early argument get swapped accident also note bind information result passing tuples much said concept boolean blindness typical program mean rely much boolean value problem get true say know true want evidence truth passing evidence tuple example function like case api resourceexists id true resource api fetchresource id false endbut could also write direct style case api fetchresource id ok resource notfound end edit originally used function name resourceexists richard carlsson correctly point misleading name changed something better name long run le error prone accident call fetchresource call look resource also get hold evidence resource really want use resource throw awayclosing remarksrules thumb exists broken must broken however hope learnt something stop reflect something happened get unless scrolled past interesting stuff also interested petpeeves missing way become better programmer study style others
459,Lobsters,erlang,Erlang development,"SyncFree / Programming Models, Part 3: Ad Counter, Part 1",http://christophermeiklejohn.com/derflow/erlang/2014/11/16/ad-counter-derflow.html,syncfree programming model part ad counter part,github post post derflow intro advertisement counter example creating advertisement counter initializing client initializing server simulating request go greater divergence support offline operation resource syncfree talk,updated january derflow since renamed lasp open source github information surrounding name change see post discussed first post derflow name distributed deterministic programming model basis research providing expressive way working crdts eventual consistency intro one use case focused research around eventually consistent advertisement counter example consider rather large game company million unit deployed field device online offline point day device number advertisement display game advertisement need displayed minimum number time read advertisement impression case acceptable display advertisement time number impression paid allows u loosely coordinate tracking counter important guarantee client online particular time use coordination make change configuration removing advertisement maximum display limit reached design look define correct operation application never losing advertisement impression eventually converging correct number impression depending divergence control strategy advertisement counter example let start examining application code initialize application begin performing four main task create counter advertisement initialize process client viewing ad initialize process server tracking ad simulate bunch advertisement viewed creating advertisement counter model advertisement counter growonly counter gcounter use growonly counter provided riakdt library riakdtgcounter example code creates five advertisement counter lager info initialize advertisement counter generator fun lager info generating advertisement ok id derflow declare riakdtgcounter id end ad list map generator list seq return list five unique advertisement counter use tracking number impression advertisement initializing client following initialize series client given list advertisement responsible displaying user client represent derflow client running client near end user lager info launching client launcher fun id clientpid spawn module client id ad lager info launched client id p pid pn id clientpid clientpid end client list map launcher list seq client process handle three thing returning list active advertisement viewing advertisement removing advertisement use simple recurisve process block receiving message perform operation doc client process standard recurisve looping server client id ad lager info client p running ad pn id ad receive activeads pid pid ad client id ad viewad choose advertisement display use hd simplicity example ad hd ad lager info displaying ad p client pn ad id update ad incrementing value ok value derflow read ad ok updated riakdtgcounter update increment id value ok derflow bind ad updated client id ad removead ad remove ad lager info removing ad p client pn ad id client id ad ad end request view advertisement arrives choose advertisement display choosing first could random also omitted code actually display advertisement screen haden noticed increment counter particular advertisement bind operation succeeds case value pushing back constraint store inflation lattice gcounter ever going grow initializing server next initialize one server process per advertisement code look like lager info launch server advertisement server fun ad serverpid spawn module server ad client lager info launched server ad pn ad serverpid end server list map server ad server process performs threshold read counter advertisement tracking threshold read operation block thereby suspending execution server process counter reached least doc server function advertisement counter view disable advertisement server ad client lager info server launched ad p ad ok derflow read ad lager info threshold reached disable ad p client ad list map fun client tell client remove advertisement client removead ad end client io format advertisement p reached display limit ad threshold reached server process unblock notify client stop displaying advertisement simulating request finally code run advertisement counter simulation lager info running advertisement viewer fun pid list nth random uniform client io format running advertisement pid pn pid pid viewad end list map viewer list seq example launch request view random sequence advertisement exercise code verify behavior correct go far assumed client online go update state constraint store able contact however largescale distributed system especially dealing large amount mobile client understood mechanism true given active research answer yet slowly working towards one idea able automatically decompose program point use shared conflictfree replicated data type client server supporting greater divergence without sacrificing correctness let look example greater divergence support offline operation look closely client code see time advertisement viewed update shared counter update ad incrementing value ok value derflow read ad ok updated riakdtgcounter update increment id value ok derflow bind ad updated view trigger counter incremented shared replicated faulttolerant constraint store derflow cluster however required willing allow greater divergence lead greater overcounting approach take still allows correct operation greater divergence use second counter locally merge state counter stored server periodically instance increment local counter stored client ok local riakdtgcounter update increment id periodically update upstream ok value derflow read ad merged riakdtgcounter merge local value ok derflow bind ad merged course mechanism easily exploited coded explicitly using crdts example transformation trivial given operating growonly counter however goal remains integrate programming model layer given transformation composition complex data type trivial previous adhoc approach proven error prone thanks reading resource interested research would like discus assist feel free contact using detail footer information syncfree use case focused research recommend talk given annette bieniusa ricon la vega
460,Lobsters,erlang,Erlang development,"gut: a scaffolding tool for Erlang, like rails generate or yeoman",https://unbalancedparentheses.github.io/gut/,gut scaffolding tool erlang like rail generate yeoman,gutenberg gut good lfetool caution erlang solution roadmap tl dr install curl wget rtfm heapster,gutenberg gut good gutenberg massive template printing aka scaffolding tool erlang like rail generate yeoman gutenberg highly inspired lfetool caution erlang superior needed however due ssl bug supported please update erlang solution downgrade previous version roadmap version released week get input comment community please test let know think obviously tool meant erlang newcomer people like like tool available nodejs clojure ruby python community present basic functionality november support many variable generator better documentation example create generator odds end tl dr install curl curl l http githubcomunbalancedparenthesesgutrawmasterbingut chmod x gut sudo mv gut usrlocalbin wget wget http githubcomunbalancedparenthesesgutrawmasterbingut chmod x gut sudo mv gut usrlocalbin rtfm generator searched downloaded github like yeoman anybody create generator use gut gut help escriptize turn erlang application escript help print help information implode remove gut associated file new creates new project file search search available generator update get latest version gut executable updategens version print gutenberg version gut search fetching list generator github name description owner star ranch ranch project generator unbalancedparentheses library library project generator jfacorro application application project generator jfacorro supervisor supervisor file generator unbalancedparentheses genserver genserver file generator unbalancedparentheses cowboybones erlang cowboy web app gutenberg generator templating gmr supervisedgenserver supervised genserver project generator jfacorro cowboywebsocket cowboy websocket handler igaray cowboy cowboy project generator unbalancedparentheses cowboycrudjson cowboy crud json handler igaray cowboyrestbasic basic cowboy rest handler igaray cowboyhttpbasic basic cowboy http handler igaray cowboyrestfull full cowboy rest handler igaray cowboylasse cowboy sse handler generator jfacorro genfsm genfsm file generator jfacorro elli elli project generator web server jfacorro genevent genevent file generator jfacorro downloads ranch generator instantiates provided name name eventi case gut new ranch eventi cloning ranch hosted http githubcomunbalancedparenthesesranchgutenberggenerator please submit github issue find problem generator working dir usersunbalancedparenthesesprojectsguteventi creating gitignore creating makefile creating readmemd creating erlangmk creating relsysconfig creating srceventiappsrc creating srceventierl creating srceventiprotocolerl generator want run following list command make sure want continue yn n message generator run make app shell launch application job done bos tree eventi eventi makefile readmemd erlangmk rel sysconfig src eventiappsrc eventierl eventiprotocolerl directory file heapster
461,Lobsters,erlang,Erlang development,rivus_cep: Complex event processing in Erlang,https://github.com/vascokk/rivus_cep,rivuscep complex event processing erlang,overview gproc bert basho bench,overview rivus cep erlang application complex event processing us declarative sqllike dsl define operation event stream cepbased system event data processed arrive opposite db data first persisted fetched processed cep engine datasource continuous query result subscriber provider event stream time interval result consumer query two type query select sum within second query join event type arrived whithin last second sliding window case join query event within time window persisted memory query require join result calculated immediately wihout event persistence pattern matching query select within second result generated case strictly follows within second window patternbased query always persist event pattern matching mechanism based directed graph fsm using digraph module window window rivus actually mean two thing time window time interval query operates temporary storage event within time window persisted two type window currently implemented sliding window default moving length window contains event last x second new result generated received event batch window contains event given moment past moment result generated amount time x expires result calculated window cleaned underlying persistence mechanism pluggable see rivuscepwindowerl module default implementation based ets table filter filter used remove event stream based certain criterion speed result generation reduce memory requirement select within second multiple criterion separated could used query filter event satisfy condition also true difference using filter using clause filter executed event persisted memory way user reduce event volume result calculation aggregation following aggregation function currently supported event representation event tuples format name attribute attribute attribute n name must unique event type must module implementing eventbehavior name name event important function need implemented getparambyname event paramname define event runtime using following statement rivuscep define name attribute attribute attribute n see following example usage usage use rivus clone build git clone http githubcomvascokkrivuscepgit rebar getdeps rebar compile update relvarsconfig according preference use default value create release using relx start application relrivuscepbinrivuscep console try following erlang console define event recognised engine define define rivuscep execute rivuscep execute deploy query querystr define select within second producer ok subscriberpid resultsubscriber startlink ok querypid querydetails rivuscep execute querystr producer subscriberpid sharedstreams true create evetnts b c bbb c b c b cc bb cc send event care producer use rivuscep notify producer rivuscep notify producer rivuscep notify producer rivuscep notify producer rivuscep notify producer result get ok b cc b b cc b genserver call subscriberpid getresult query started rivuscep previously deprecated take argument query string list event producer list query result subscriber option proplist query worker register gproc process registry event listed clause event sent via rivuscep event received query subscribed event type query subscribed particular producer receive event query must least one subscriber receive query result see testsrivusceptestserl example streaming event via tcp stream event via tcp connection ok host port application getenv rivuscep rivustcpserv ok socket gentcp connect host port active false nodelay true packet binary b c bbb c b c b cc bb cc dd gentcp send socket termtobinary event gentcp send socket termtobinary event gentcp send socket termtobinary event gentcp send socket termtobinary event gentcp send socket termtobinary event currently erlang client supported event serialization using bert work progress shared stream memory efficiency sharedstreams true provided option list case query work shared event sliding window window size equal maximum within clause sharing query query based event pattern use nonshared window benchmarking loadtest query using basho bench use basho bench driver bashobenchdriverrivuserl configuration file rivusconfig provided priv directory edit rivusconfig according need result single query single process rivusconfig running gce cloud instance cpu ram minute dependency disclaimer production ready project use risk
462,Lobsters,erlang,Erlang development,MongooseIM: Jabber / XMPP server with focus on performance and scalability,https://github.com/esl/MongooseIM,mongooseim jabber xmpp server focus performance scalability,mongooseim platform get know mongooseim erlang solution mongooseim platform component learn download package public testing documentation http mongooseimreadthedocsioenlatest mongooseim documentation highligts tutorial user guide configuration rest api swagger documentation operation maintenance server developer guide participate,mongooseim platform get know mongooseim mongooseim robust efficient chat instant messaging platform aimed large installation designed enterprise faulttolerant utilise resource multiple clustered machine easily scale capacity simply adding box vm mongooseim accept client session vanilla xmpp rest api sse well websockets bosh http longpolling platform mongooseim includes several serverside backend clientside frontend component provide test suite metric load testing platform monitoring server recommend thirdparty open source client library xmpp rest api brought erlang solution mongooseim platform component learn download package quick start download public testing check test result documentation uptodate documentation mongooseim master branch found readthedocs http mongooseimreadthedocsioenlatest latest release mongooseim documentation highligts developing new featuresmodules please make sure add basic documentation doc directory add link document docreadmemd tutorial learn user guide learn use mongooseim project explore feature supported xeps rfcs database backends well architecture deployment strategy configuration explore available option including database backend configuration access control list listener extension module rest api explore mongooseim feature using rest api swagger documentation operation maintenance see consider building monitoring testing distributing mongooseim cluster server developer guide get information need expand mongooseim platform participate suggestion question thought contact u directly
463,Lobsters,erlang,Erlang development,Disco: a Map/Reduce framework for distributed computing,https://github.com/discoproject/disco,disco mapreduce framework distributed computing,disco massive data minimal code disco integration talk disco http discoprojectorg travisci,disco massive data minimal code disco distributed mapreduce bigdata framework like original framework publicized google disco support parallel computation large data set unreliable cluster computer make perfect tool analyzing processing large datasets without bother difficult technical question related distributed computing communication protocol load balancing locking job scheduling fault tolerance taken care disco writing disco job simple example following job count number word document discocore import job resultiterator def map line params word linesplit yield word def reduce iter params discoutil import kvgroup word count kvgroup sorted iter yield word sum count name main input http discoprojectorgmediatextchekhovtxt job job run inputinput mapmap reducereduce word count resultiterator jobwait print word count note installing disco use zip targz package generated github instead clone repository develop branch contains newest feature recommended use production master branch latest stable release tested production important bug fix first merged develop branch backported master branch disco integrates lot different tool following screenshot example show using ipython notebook write disco job using matplotlib plot result learn disco ecosystem see disco integration resource check talk disco visit discoprojectorg http discoprojectorg information build status travisci
464,Lobsters,erlang,Erlang development,Hex: a package manager for the Erlang ecosystem.,https://hex.pm/,hex package manager erlang ecosystem,,specify mix dependency twoitem tuples like plug dependency list elixir ask want install hex nt already
465,Lobsters,erlang,Erlang development,Building Fault Tolerant Teams at Basho,https://www.youtube.com/watch?v=O4KKxlX5590,building fault tolerant team basho,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature building fault tolerant team basho youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature building fault tolerant team basho youtube
467,Lobsters,erlang,Erlang development,"SyncFree Consortium / Programming Models, Part 2: QuickChecking Derflow",http://christophermeiklejohn.com/derflow/erlang/2014/10/01/quickchecking-derflow.html,syncfree consortium programming model part quickchecking derflow,github post post derflow modularization lot setup derflowets building model singleassignment store lattice store stateful testing talk generating command riakdt precondition postconditions conclusion test pull request,updated january derflow since renamed lasp open source github information surrounding name change see post discussed first post derflow name distributed deterministic programming model basis research providing expressive way working crdts eventual consistency today look go building first version erlang quickcheck model testing distributed variable store work expected modularization start building model language quickcheck first recall language us distributed single assignment store distribution supported riakcore unfortunately testing application dependency riakcore extremely difficult due amount setup required attempted basho requires lot setup make easier first separate logic virtual node control distributed store backend actually writes value disk purpose created derflowets backend provides api distributed store run test building model building model straightforward model variable store backed ets use dict invariant langauge let enumerate recall language provides operation singleassignment variable lattice operating lattice want ensure allow variable rebind given value inflation lattice want test following operation singleassignment store property singleassignment store declare variable singleassignment variable bind variable value rebind variable value different value read anything bound get correct value lattice store property lattice store declare lattice variable bind variable value rebind variable new value inflation lattice perform threshold read return threshold value supplied stateful testing testing use eqcstatem behavior statemachine based approach testing function sideeffects information testing using facility check talk laura castro generating command let take look code generates command variable dict fetchkeys store oneof call module declare oneof element type undefined ets let variable generatedvalue element variable nat begin value value variable store generatedvalue threshold threshold variable store oneof call module bind variable value ets call module read variable threshold ets end length variable generating command need model three basic type operation read bind declare use oneof generator select one following command declare operation generated without constraint composed one lattice type undefined type specify want singleassignment variable read bind operation need ensure generate variable declared done length variable predicate list comprehension additionally command also need called correct type value example read threshold lattice need called valid lattice value similarly bind need triggered correct type well example use let macro materialize symbolic actual value inspect type generate appropriate threshold value threshold value generator currently doc generate value threshold based operating type threshold variable store case dict find variable store ok variable typeundefined undefined ok variable typetype let object update type new type genop begin ok x type update update undefined object x end end doc generate value bind based operating type value variable store defaultvalue case dict find variable store ok variable typeundefined defaultvalue ok variable typetype let object update type new type genop begin ok x type update update undefined object x end end case type one caller crdt provided riakdt library data type provided riakdtgset growonly set export function genop generates random operation allowing u generate random type crdts example operation generator riakdtgset genop oneof add int addall nonempty list int let examine precondition command generation precondition precondition want check running model well given derflow read operation blocking blocking unbound singleassignment variable threshold read operation threshold yet met want prevent u executing test value following precondition read precondition state storestore call module read id threshold store case dict find id store error declared false ok variable valueundefined bound false ok variable typeundefined true ok variable valuevalue typetype case derflowets thresholdmet type value threshold true true false false end end let examine postconditions command generation postconditions two important postconditions model must verify bind operation fail fail valid reason read operation succeed must succeed correct value performing read assert ever read value observed bound variable executing model threshold read assert value returned threshold value least threshold would failed precondition shown ensure always read value expecting postcondition state storestore call module read id threshold ok v case dict find id store ok variable valuevalue case threshold undefined value v threshold v end false end asserting bind fails supposed verify time allowed fail attempting reassign already bound variable new value bind failed allowed variable already bound undefined postcondition state storestore call module bind id v error case dict find id store ok variable typetype valueundefined false ok variable typetype valuevalue case derflowets isinflation type value v true false false true end end true conclusion brief overview began testing derflow using erlang quickcheck deeper view please checkout test github love hear could clean model make easier understand please let know send pull request thanks
468,Lobsters,erlang,Erlang development,Death by Accidental Complexity,http://www.infoq.com/presentations/Death-by-Accidental-Complexity,death accidental complexity,infoq homepage presentation death accidental complexity summary bio conference related sponsored content,infoq homepage presentation death accidental complexity death accidental complexity summary ulf wiger show concurrency lead accidental complexity badly implemented code becoming project point failure wiger also advises concurrency addressed order avoid complexity bio ulf wiger cto erlang solution worked ericsson chief designer axd development nearly million line erlang code axd complex system ever built erlang recent year ulf involved several product based axd architecture active member open source erlang community conference qcon conference organized community communitythe result high quality conference experience tremendous amount attention investment gone best content important topic presented leader community qcon designed technical depth enterprise focus interest technical team lead architect project manager recorded jul related sponsored content
469,Lobsters,erlang,Erlang development,"Programming Models and the SyncFree Research Project, Part 1",http://christophermeiklejohn.com/derflow/erlang/2014/09/28/try-derflow.html,programming model syncfree research project part,github post syncfree work dataflow programming bloom lvars derflow new hope ivars ozma erlang workshop paper erlang user conference erlang workshop derflow lattice strike back ladis workshop lvars join u conclusion,updated january derflow since renamed lasp open source github information surrounding name change see post one main goal syncfree project build programming model working eventual consistency conflictfree replicated data type well way goal influenced heavily peter van roy work dataflow programming bloom work university california berkeley well lvars work indiana university post aim give high level overview inspiration work general progress link video publication provide instruction build language wish experiment future blog post dig implementation detail programming model derflow new hope initial prototype put together may focused distributed deterministic dataflow model erlang think distributed ivars build top riak core equally something similar ozma core model relies distributed singleassignment variable store replicated using dynamostyle quorumbased replication variable program hashed distributed set node ensuring faulttolerance version prototype documented erlang workshop paper presented year goteborg sweden also couple talk available well discus implementation well one erlang user conference one erlang workshop derflow lattice strike back second work due presented ladis workshop october expands model operate bounded joinsemilattices providing threshold read operation variable ensure determinism know lvars work sound familiar addition explore alternative approach executing program program guaranteed deterministic replicate entire program model explore providing api entire program registered cluster executed faulttolerant manner result returned user come future post join u play along home first assume got erlang installed unfortunately given dependency riakcore latest supported version erlang currently first clone build derflow git clone git githubcom cmeiklejohnderflowgit cd derflow make build packaged release development release way would riak looking develop language recommend building stagedevrel build independent release sharing compiled application code ease cluster deployment testing make stagedevrel building sample application built test harness using riaktest executes application verifies correct result harness compiles local derflow program creates cluster node execute remotely deploys program cluster return result configure riaktest following cd git clone git githubcom bashoriaktestgit cd riaktest make done make sure copy included riaktestconfig file riaktestconfig update path referenced file running test pretty simple cd derflow make riaktest theory test pas well research research conclusion article serf provide general overview work pointer relevant resource interested contributing assisting playing around prototype language next series begin dig different model derflow implemented well various tradeoff please let know run problem playing around prototype love hear feedback
470,Lobsters,erlang,Erlang development,Optimizing Native Code for Erlang,https://www.youtube.com/watch?v=57AkoJfojK8&feature=youtu.be,optimizing native code erlang,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature optimizing native code erlang youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature optimizing native code erlang youtube
471,Lobsters,erlang,Erlang development,QuickCheck Advice,https://medium.com/@jlouis666/quickcheck-advice-c357efb4e7e6,quickcheck advice,common model advice one time rewrite sut algebraic property amplification positive negative testing generator generate measure shrinking parting word http robertoaloicomerlangnotesonerlangquickcheck http githubcomjlouissafetyvalve http githubcomisaiahtransiterlang http githubcomjlouisfuse,roberto aloi written nice writeup quickcheck lot good advice attempt add note come set additional advice usethere one problem hear qc start particular project premise existing project want magically quickcheck know work however lead first problem writing qc test coming good modelsin qc model reign supreme check thing define model constructing good model definitely one thing want cover expositionmost model construction currently happens example see one model lead understand build model hope crosspollination different example lead person able model ownit turn good model construction art form much like good code beautiful elegant delight read proper quickcheck model skill need create one somewhat aligned math programming approached new set skill train trained order become good programming first placethere still pitfall generic viewpoint may want think reading accellerate learning new programming language conceptcommon model advicei think common problem try build model complicated complete system test sut never ever work want simple model cut corner way reimplement solution twice furthermore two equivalent implementation one model one sut going good use timeso advice simplify model suppose checking data structure kind often simple implementation vastly different performance characteristic good example finite map implemented association list language idea model run association sut disagree know bug one allows use simple model lookup n test advanced sut lookup lg n model complexity suta common trick use time come trivial model trivial one totality model basically random thing sut verifies sut fail exception crash make sure system robust odd inputsanother trick dilute precision model check stack queue model model many element stack queueif check queue say simplify model one element queuesay configuration parameter vary n alter vary model support subset sutthe goal simplify model point understand paint layer layer advance complexity model afterwards good example built model safetyvalve started model queue system empty full simplifies model whole lot yet simplified model still found nasty bug implementationanother example transiterlang model started able generate value null generated test case value null gradually extend added string integer timepoints uuids uris primitive type worked started adding array map list set first version model contain systemmore oneuse single model much rather want model simple covering one large model try everything modularization important qc code code base model grows becomes size quviq autosar model need think split model module handle thing separately otherwise becomes mess maintainlayer model well write small model checking one aspect system assume part right write model top assumption fuse plug fakemock timing system control passing time next section timing model separate qc model sure correct use larger set thing might say quickcheck property theorem model layer lemma analogy true entirely similarity way work strikingtimetime problem almost advanced development state part system part system call kind sleeping timing library handle erlang call timer erlang receive clause clause dead giveaway two way handle time model inject time mock time injection solution rewrite sut call take extra parameter use parameter inject current time system often write system happens silently user system since time injected become part model model choose want advance timeanother solution write code mock timing plug another timing module normal one fuse control passing time mock choose time advance mean reproduce shrink work time another parameter systemrewrite sutif control code sut rewrite often necessary make testing much easier write testable code inject parameter rather call thema common rewrite add kind introspection sut call expose internal state helpful become part invariant check want catch invariant breach early shrinking get work right error early safetyvalve expose internal queue size among thing used postcondition checksalgebraic propertiesexploit algebraic property data transiterlang use algebraic principle inverse one direction x decode encode x work lowest level transfer format lowlevel protocol obvious inverse good algebraic property stem monoids group theory category theory sometimes group rule commutativity associativity neutral element inverse applies sometimes isomorphic property exploit problem working triangleinequality use fact modelsif problem property often kind monotonicity balance guarantee monetary transaction involving two account change add zero time flow backwards system convergence property exploit adding two positive number yield number strictly larger largest oneanother algebraic property use transformation another domain algebraic topology turn topology algebraic structure algebraic structure topology x differ topology must differ instance working functors top grp quickcheck idea exploited easily view system kind transforming functor verify property functoramplificationthe trick qc amplification want simple model randomization model lead model much better amplification factor qc excels word torben hoffman case rather thing sut thing composed complexity possibility arising composition exactly make hard make sure caught every corner casetransiterlang example whereas fairly easy test transitterms hard make sure caught interaction transit come large unittest base exemplar test implementation yet qc model found many additional interaction problem unit test unable find easily caught doubleescaping problem standard exemplar find since input interactionto maximize amplification important build system many small part compose want think generatorspositive negative testingthere two polarity testing positive supply valid input system behaves shouldnegative supply invalid input system misbehavemost testing positive important inject fault system test system behaves correctly even fault injected used check system certain robustness property one want one common thing make sure error system report consistent fault injected word want test happy path system proceeds along successful path also want test system stray happy path step onto errornous onewhen negative testing important model know injecting failure otherwise check expected output simple property enough generate input among valid input system must generate kind error give back common thing test system stable crash even supplied invalid inputsnegative testing also similarity security scenario namely notion supply data system stochastic process order make fail idea input leading crash try altering input slightly order exploit missing safety property underlying language buffer overflow integer overunderflow weak type coercion forced cast worseon generatorsthe half efficient quickcheck generator idea generate interesting specimen data random input also set apart good quickcheck implementation excellent onethe thing actually want uniform generator want generator exploit fact number much problematic system also nt work automatically derive generator algebraic data type often want finetuning control generated valuesin transiterlang turn power two interesting generator formsign math pow x pwhere x natural number sign either p small pertubation range highly useful instantly found bug erlangotp implementation also found numerous bug interesting thing often happens power two valuesof course pick generator time also pick deliberately small large value know three way transit use format number need fairly sure roundtrip formatting possibilitiesthe power generator measured fast find trouble ideally want generator uncover trouble test case le generator need several thousand sample generate trouble weak reason compose several generator number work inherently multiplicative make much harder find problematic casewhat generateit important discus table driven unit test table driven unit test one large number test case driven table given input foo bar expect output baz essentially enumeration generation try generate possible input check outputwhere enumerate generator fall short set possibility grows exponentially many possibility hope list lifetime case want generate thing stochastic way skew distribution tends toward place believe hard get right stochastic process aim capture fact might forget generate certain particular state randomness process solves occasionally generating thing think aboutthus want weight generator generate state occur rarely real system real system continously check common case production want corner case exposed test amount fact certain command fire rarely occurring state case might make command likely occur particular state one vary sofirst inflate chance running command large factor system always generate command state mean get generate command state making model weakersecond may beneficial weigh system state rare occurs often command nt need changing since state merely uncommon raremeasurethe command aggregate classify collect reason make sure generating right distribution need measure generating thing like expect distribution skews much toward state want tune generator use distribution command measure get right statesfurther fuse add classification model model record set requirement us verify requirement hit test run given requirement hit bound worry way work set model path taken model annotated requirement path cover heal noninstalled fuse must never triggered heal installed fuse blown already group install installation fuse invalid installation fuse valid configurationgroup reset reset uninstalled reset installed fuse blown nonblown group melt melting installed melting uninstalled fusegroup use ok use melted use ok fuse melted use uninstalled fusegroup blow blowing removing melt window expirygroup ask installed ask uninstalled fuseafter test run see requirement hit run make easy check generating right valuesshrinkingthe final key good generator make shrink well failing test use figure wrong fix help crucial generate failing test generate minimal failing testwhen building generator worth spending time shrink roberto post much detail one additional trick build stuff binary tree rather list shrink toward one subtrees also good generating command sequence transiterlang following snippet illustrating idea transitl n g transitl n g let e g n e transitl sz n g letshrink l r transitl sz div n div g transitl sz div n div g l r idea generate list size sz generate two half l r join letshrink combinator shrink either left right subtree allows system shrink test case like ferb taggedvalue u phineas z undefined ab transitdatetime n transitdatetime transitdatetime undefined transitdatetime u taggedvalue undefined taggedvalue taggedvalue taggedvalue ab taggedvalue transitdatetime taggedvalue taggedvalue taggedvalue u transitdatetime taggedvalue u undefined taggedvalue u transitdatetime taggedvalue u taggedvalue abcdefg taggedvalue u taggedvalue u taggedvalue u transitdatetime taggedvalue u candace taggedvalue candace undefined taggedvalue u taggedvalue undefined much easier work figure outthis proper shrinking matter somewhere inside big blurb text complicated variant simple test hiding minimize input find chance catching kind bugsthis also know combinators generator shrink knowing minimization pattern get much better generatorparting wordsthis ended much longer envisioned took two hipsterretro latte one coffee shop liqorice overhearing conversation study happy waitress waiting boyfriend get work rainy day full downpour write interestingly since forgot headphone music involved making http robertoaloicomerlangnotesonerlangquickcheck http githubcomjlouissafetyvalve http githubcomisaiahtransiterlang http githubcomjlouisfuse way sql injection variant weak type coercion sql expression get intermingled parameter hole expression often due weak stringly typed identification see problem sql injection
472,Lobsters,erlang,Erlang development,Supervisor Trees for Go,http://www.jerf.org/iri/post/2930,supervisor tree go,programming golang let crash philosophy suture exactly erlang supervisor tree erlang process developed late supervision tree supervisor tree ported erlang comparing go erlang suture library addendum go never asynchronous exception port clispscript java eventually pull,posted apr programming golang supervisor tree one core ingredient erlang reliability let crash philosophy wellstructured erlang program broken multiple independent piece communicate via message piece crash supervisor piece automatically restarts may sound impressive never used witnessed system written experience dozen crash per minute function correctly user even writing suture occasion astonished flip screen console go program written suture surprised discover actually merrily crashing away manual testing soldiering well nt even know course immediately followed improving logging know happens future crashresistant good one spend valuable resource frivolously porting system erlang go various reason missed supervisor tree around decided create go one case need transliteration erlang code go one thing simply impossible two mutually incompatible fundamental way want idiomatic translation functionality retains much possible original perhaps introducing whatever new local capability make sense correctly step one deeply examine erlang supervision tree figure translate exactly erlang supervisor tree erlang process want get must still cover let start bottom work way abstraction stack erlang like go support many simultaneous execution context running simultaneously appropriate definition erlang called process recall erlang developed late major competing concurrency construct thread thread separate execution context run memory space able freely read write shared heap erlang called execution context process draw analogy o process idea like o process erlang process freely read write ram process normal erlang process completely described local memory content feasibly couple hundred byte believe idea originates erlang one earlier practical manifestation went beyond latex paper anything wrong sidebar definition goroutines like thread best practice isolate goroutines much possible nothing language enforces even particularly help convention still better nothing create relatively wellisolated core library erlang system built process like go erlang fire million single system process id pid firstclass value erlang contrast go firstclass value representing goroutine next must understand process relate two process may send arbitrary erlang value another process message via target process pid sending asynchronous side sender message simply lob get life receiver ability choose receive freely including choosing receive message order received erlang runtime hold message process chooses receive given message via erlang pattern matching primary communication method erlang even case may appear message sent api sending message hood erlang direct use message send operator seems code smell general almost always using gen sort using supported mechanism talking gen process process may monitor link another process purpose going skim difference get ability one process say let know process dy either sending message killing listening process sound violent us instance process managing resource process b may want kill either dy instance socket closing something make resource management easy missed go find manually wiring relationship two goroutines together process may kill another process believe called asynchronous exception programming language theory world go capability postscript post added go almost certainly never work node may live different physical system pid may reference process another connected erlang node functionality work including linking monitoring true key understanding erlang design understand pervasive focus reliability rather getting caught method us accomplish erlang working multiple independent chunk hardware simultaneously parlor trick erlang philosophy includes idea impossible make software reliable resides one piece hardware crossnode communication erlang world reliability sharing work supervision tree piece easy see build basic structure supervisor process process tell runtime interested whether target process dy runtime tell take desired action usually restarting though exotic option little else possible nt really want supervisor crash still must plan possibility reason memory corruption erlang focus reliability mean possibility ignored scale memory corruption real thing since erlang nt mutation restarting process take form spawning new process using given function given argument instance service run multiple port provide service supervisor monitor listening process conceptually know port process crash need spawn new process provideserviceon whereas port service crash need spawn new process provideserviceon erlang otp library wrap nice declarative functionality various default behavior motley handful default bit functionality like basic server basic finite state machine think supervising process process supervising create tree process supervising supervisor practice nt necessarily lot value really deep tree imagine erlang supervisor tree quite bushy tree indeed erlang expected define application concrete bit functionality wrapped toplevel supervisor fire supervisor actually implement functionality start stop independently application access additional functionality like applicationspecific configuration special command start stop dependency graph even simplest application least two level deep top level tree also treated specially die bringing entire o process default presumably something restart remember moment shock realized node running one erlang application make process run another application run application start newapp erlang also developed safer restart method something sits crash endlessly startup supervisor stop restarting done setting maximum number crash permitted within certain number second crashing supervisor exceeded logging crash integration nice tuned bit dropin functionality writing erlang writing supervisor tree wrong supervisor tree ported erlang port supervisor tree go maximum value carefully examine exactly made carefully examine piece go figure translate idiomatically possible seeing anything useful pick go erlang nt along way erlang arguably structured top bottom support supervisor tree safely supervisor made isolated process immutability identification process via globallyshared including node pid multiprocess concurrency signaling asynchronous exception safe restarting wo nt endlessly retry bulletproof etc many strictly speaking required supervisor tree work improve work case affect feature instance set feature around linking way enables one crashing service take supervisor turn taking restarting child necessarily apply language lack primitive whatever reason ca nt added comparing go erlang let compare go erlang point isolated process enforced convention community language least consider ideal go nt enforce separation course suture simply tell suturemonitored process ought isolated possible immutability yeah total wash affect suture design quite bit identification process go equivalent go give sort goroutine id fully purpose sure unlikely change however turn put information need stack state using defer problem supervisor relationship supervisees stereotyped nt need generalized messaging system multiprocess concurrency mostly yes subject usual caveat isolated convention language enforcement signaling asynchronous exception erlang give prepared solution go give tool build solution ca nt stop goroutine happens go infinite loop enough async communication able shut cooperating process work simple implementation stop goroutine sending message special stop channel received service core select loop enough time safe restarting matter writing desired policy adjust erlang bit since go crash early crash often language nt actually terminate supervisor client start acting suture instead us backoff approach event service never start properly least gulp cpu trying endlessly restart let u forget thing go erlang use user defined type method interface think coworkers may tired tying kingdom static type system team chat room ready get dynamic typing erlang think understand erlang type system way though would another post still tired mutability come problem going use harness advantage suture library let look go trying pull many advantage possible staying idiomatic using strength least enough primitive obtain basic functionality looking lightweight process albeit sharedstate one cobble together something enough like linking get need supervisor tree rest shall wait another library thing erlang implement supervisor tree reaction erlang design need carry along instance description set service specifying module function initial set argument erlang must create entirely new instance supervised process scratch way break function deal difference initialization execution something often initially confusing new user go instead requiring wrap service formalized creation method simply let user create new instance value implement service interface initialization handled user like initialization value thus simplify nt need behavior interface certainly simpler probably useful compiler statically verify try use service implemented correct feature fact memory isolated something fix supervisor tree library service crash clear much state possible service try avoid case corrupted state cause infinite crashing possible try specify heavyhanded framework initializing new service indeed initially wrote way noticed trivial programmer bypass anyhow leaving init blank writing everything start fact first thing consumer library sort clue library author ignore choose simplicity instead bondage merely advise clean state much possible service restart nt link pid possible factor idea catching crash service restarting logging possible implement smarter restart logic centralized location simply wrap call start function service something catch panic log restarts service restart logic could probably use tuning current logic least start allows u create service interface contains following type service interface serve stop admit small bit pleasure interface simple believe went several iteration got far seems enough happy surprise minimal suture service implementation much smaller minimal erlang gen easier understand well since linking v initialization confusion go sortof structural typing also mean package easily provide suture service without depending suture easily provide nonsuturedependent start function desirable supervisor chunk code accepts service manages course supervisor service creating tree matter hooking supervisor create special support application found advantageous pack service top level supervisor erlang even relatively small go team already great fun composing service together various executables topic composing also turn powerful service compose supervisor instance fact sort composite give potentially complicated service simple startup api example come supervisor also bundle logging supervisor log failure service including stack trace easily adapted call local logging code provide callback end quite slick erlang frankly erlang sense built around supervisor tree least set feature provides ability build hard compete however even limited experience adapting style go still carry enough benefit worthwhile feel net benefit library writing using everything possibly suture service already witnessed taking functional code making something deploy without completely failing good stuff plus proceeding build stay tuned addendum go never asynchronous exception mentioned erlang allows remotely kill target process accomplished exit function throw asynchronous exception target pid including possibility throwing uncatchable exception force termination much like kill unix understand called asynchronous look exception point view process receiving exception usual sense term programmer used exception synchronous either occur nt occur particular point program synchronous original meaning time code produced instance language going throw exception file found occur try open random time contrast thread point view asynchronous exception occur time thread accounting time completely unrelated anything currently subtle thing erlang paradigm since process share state process even resource held arm length via port feasible asynchronously kill erlang process reasonably safely killed process automatically drop value resource open via port erlang process linked using process thus using process dy process port also die killed process welldefined way cleaning resource even asynchronously killed still perfectly safe resource may leak depending interacts thread etc reasonably safe erlang arguably writing code nt safe kill would bug erlang get away rigidly partitioned process nt think immutability enters rigid partitioning accomplishes language immutable value easier time providing asynchronous exception though would observe took haskell several iteration get correct case arguably laziness making harder still clear strict immutable language shared value would trivial time either however flamingly bad idea asynchronous exception sharedstate mutable language despite fact go us convention try avoid sharing state sharedstate mutable language possible program correctly mutationbased language asynchronous exception happen time particular know operation thread middle never supposed observed instance goroutine middle critical section protected mutex possible clean mutex goroutine dying way roll back anything goroutine half lot subtle issue arise instance trying protect goroutine toplevel defer nt prevent asynchronous exception ruining day get asynchronous exception middle deferred function code safe world without asynchronous exception end bubbling panic past top goroutine stack due something control running goroutine current semantics morally indistinguishable segfault program terminates attempt get around brings problem went couple paragraph deleted due redundant thar fractal fail feel like exploring space remember treat hostile environment like threading case helpful imagine hostile adversary trying find worst possible time thread experience asynchronous exception remember receive arbitrary number exception important may implementing guarantee ignoring reason failure easy answer immediately leaping mind bear mind tried nt work venerable problem faced clispscript language fairly well established practical solution even java eventually pull mention java necessarily paragon software engineering project demonstrably massive effort poured every motivation world make functionality work reverse compatibility could nt given fundamental nature problem mutable state language probably nobody else either therefore point waiting functionality exist writing supervision tree library
474,Lobsters,erlang,Erlang development,Elixir v1.0.0 released,http://elixir-lang.org/blog/2014/09/18/elixir-v1-0-0-released/,elixir released,contributor january elixir new semantic versioning elixir eex exunit iex logger mix hex package manager expectation learn getting started guide video elixirconf language history elixir change way code even hear story elixir used production released elixir sticker,glad announce elixir finally commits contributor including initial commit january elixir elixir dynamic functional language designed building scalable maintainable application elixir leverage erlang vm known running lowlatency distributed faulttolerant system also successfully used web development embedded software domain new release consolidation work done year reached stable milestone growth software project written elixir elixir follow semantic versioning mean code written elixir continue compile run correctly version branch eg elixir composed application versioning constraint elixir elixir compiler runtime standard library eex elixir templating library useful generating kind document dynamically exunit elixir unit test library support concurrent testing custom formatters filter much iex elixir interactive shell code reloading autocomplete easy access documentation typespecs logger latest addition group logger provides reliable logging configurable backends syslog file many backends provided community mix elixir build tool generates compiles test project well manages dependency providing stable platform community leverage extend extremely excited project possibility ahead u hope hex package manager home many project remember whole erlang ecosystem also available elixir developer expectation would like elaborate expectation regarding elixir although expect vast majority program remain compatible time impossible guarantee future change break program unlikely circumstance may introduce change break existing code security security issue implementation may arise whose resolution requires backwards incompatible change reserve right address security issue bug application undesired behaviour program depends buggy behaviour may break bug fixed reserve right fix bug compiler frontend improvement may done compiler introducing new warning ambiguous mode providing detailed error message lead compilation error running warningaserrors tooling failure asserting specific error message although one avoid reserve right improvement import new function may added kernel module autoimported may collide local function defined module collision resolved backwards compatible fashion using import kernel except list function want imported kernel reserve right addition elixir binary guaranteed backwards compatible within branch code compiled shall work elixir runtime code compiled elixir recompiled work elixir onwards expectation also apply future release branch except experimental feature explicitly marked provide compatibility guarantee stabilized learn get started elixir via getting started guide quite elixir book getting sent press quite found sidebar also includes screencasts resource also learn elixir checking video elixirconf first far best elixir conference ever learn language history elixir change way code even hear story elixir used production finally popular demand released elixir sticker available discounted price celebrate
476,Lobsters,erlang,Erlang development,The Elixir language just hit 1.0!,https://github.com/elixir-lang/elixir/commit/52ff7e96867c027745d29f5d3feb77f546f22c4f,elixir language hit,permalink addition deletion changelogmd reload reload,permalink showing changed file addition deletion changelogmd changelog enhancement logger add backwards incompatible change genevent longer support swaphandler callback return value list removed toggle file note perform action time signed another tab window reload refresh session signed another tab window reload refresh session
479,Lobsters,erlang,Erlang development,Elixir v0.15.0 released,http://elixir-lang.org/blog/2014/08/07/elixir-v0-15-0-released/,elixir released,please check changelog logger logger module syslog many attribute supported research work done andrew thompson folk basho behind lager mix alias mix documentation anthony grime phil halgelberg work lein elixir web installer window chris hyndman elixir web installer window download current version chocolatey welcome alexei alexei next four open issue tracker tagged milestone getting started guide,hello everyone glad announce released spent last month tidying existing apis ensuring consistency improving performance result last minor branch elixir also planned deprecation backward incompatible change mean extremely likely code run run exactly elixir interested specific detail release please check changelog post focus three new feature release logger mix alias fresh elixir web installer window share exciting news end logger elixir ship new application called logger application provides logger module main api developer use logging require logger loggerdebug hello default code log following message console debug hello logger provides multiple backends message logged elixir ship console backend developer already working file support external log rotation syslog backends started logger main objective translate erlang message elixir term formatted elixir syntax release following code taskasync fn raise oops end logged following report error report task terminating started function fun argument reason termination exception true struct elixirruntimeerror message oops elixirtasksupervised file libtasksupervisedex elixirtasksupervised file libtasksupervisedex proclib file procliberl logger get report error task pid started pid terminating function function args exit exception raised runtimeerror oops elixir elixir stdlib soon started working logger realized could go simply translating erlang message provide fully featured logger library moment logger also support log level debug info warn error custom formatting specify format string tell exactly message logged default string time metadata level messagen many attribute supported custom translator translate log message coming erlang application elixir syntax metadata metadata allows developer store information current process available logged message example web application generate requestid store metadata message logged request properly identified requestid log also relied lot research work done andrew thompson folk basho behind lager ensure logger performant robust front logger alternate sync async mode logging message keep performant required also apply backpressure stress format truncates message client avoid clogging backends provide highwater mark around erlang errorlogger avoid overflowing looking forward everyone feedback using logger production mix alias mix elixir build tool mix know manage dependency compile test project much designed mix since day one extensible developer always able define new task simply defining module defmodule mixtaskshello use mixtask def run ioputs hello world end end task invoked mix hello defining custom mix task useful project library want better integrate standard development workflow elixir however bit verbose creating oneoff task task used locally given project furthermore far mix allow developer extend existing task example imagine want perform extra work mix clean invoked release possible mix alias solve problem providing simple api defining overriding alias project use mix contain mixexs file project configuration order define alias need add new key project configuration defmodule myproject use mixproject def project app myproject alias alias end defp alias c compile hello clean clean end defp printhello ioputs hello world defp cleanvendor filermrf vendor end project defined three alias mix c shortcut mix compile mix hello equivalent mixtaskshello defined earlier although easily defined alias mix clean extends existing clean task ensure invoke afterwards word alias three different structure string containing task argument invoked anonymous function invoked passing task argument list containing string anonymous function find information alias reading mix documentation section alias around middle also would like thank anthony grime support phil halgelberg work lein mix borrows lot elixir web installer window beginning summer chris hyndman joined u google summer code student help u improve elixir story window chris essential chris also built elixir web installer window web installer check available elixir version allows pick one install also fetch install erlang machine case installed yet want give elixir web installer try download current version chocolatey thing remember also install elixir window running cinst elixir welcome alexei also would like welcome alexei team elixir maintainer alexei one first actively participate elixir community done excellent job guaranteeing quality throughout code documentation wiki website alexei also interested extend tooling erlang ecosystem whole bringing mix hex package manager developer well adding task specific erlang project next close launch elixir planned feature already elixir codebase moment four open issue tracker tagged milestone estimated date first release candidate elixir august mean better time learn elixir started yet get started elixir reading getting started guide checking one many learning resource sidebar
482,Lobsters,erlang,Erlang development,Designing for Actor Based Systems,http://blog.erlware.org/2014/07/23/designing-for-actor-based-systems/,designing actor based system,,
483,Lobsters,erlang,Erlang development,Elixir vs Ruby Showdown - Phoenix vs Rails,http://www.littlelines.com/blog/2014/07/08/elixir-vs-ruby-showdown-phoenix-vs-rails/,elixir v ruby showdown phoenix v rail,phoenix rail tl dr faq apple orange benchmark meaningful comparing elixir phoenix framework ruby rail wrk router controller view localhost result throughput phoenix rail heroku result dyno throughput le cpu load phoenix cold phoenix warm load rail cold rail warm load summary get involved github jason stiebs,second post elixir v ruby showdown series latest installment exploring performance phoenix rail web framework put task get code sample benchmark result answer common question kind test tl dr phoenix showed throughput rail performing task fraction cpu load faq apple orange test direct comparison favorite aspect ruby rail elixir phoenix elixir promise provide thing love ruby productivity metaprogramming elegant apis dsl much faster battletested concurrency distribution model goal post explore elixir match exceed favorite aspect ruby without sacrificing elegant apis productive nature web framework use benchmark meaningful benchmark meaningful work upfront make result reliable possible program tested even benchmark provide performance moral story never trust benchmark always measure comparing elixir phoenix framework phoenix cowboy webserver single elixir node erlang ruby rail rail puma webserver worker per cpu core mri ruby measuring throughput phoenix rail app specific task isolated possible best compare feature performance measuring match request webserver route controller action merging named parameter route controller action render view based request accept header contained within rendered parent layout within view render collection partial view data provided controller view rendered pure language templating engine erb eex return response client testing standard route matching view rendering stack go beyond hello world example apps render layout view collection partial test realworld throughput general web framework task view caching used request logging disabled apps prevent io overhead wrk benchmarking tool used test localhost remotely heroku dynos rule wrk overhead localhost enough talk take look code router phoenix defmodule benchmarkerrouter use phoenixrouter alias benchmarkercontrollers get title controllerspages index page end rail benchmarker applicationroutesdraw root page index get title page index page end controller phoenix request parameter patternmatched directly second argument defmodule benchmarkercontrollerspages use phoenixcontroller def index conn title title render conn index title title member name chris mccord name matt sears name david stump name ricardo thompson end end rail class pagescontroller applicationcontroller def index title params title member name chris mccord name matt sears name david stump name ricardo thompson render index end end view phoenix eex team member ul member member li render biohtml member member li end ul b name b membername rail erb team member ul member member li render partial biohtml local member member li end ul b name b member name localhost result phoenix showed throughput much consistent standard deviation latency concurrency model really shine result single elixir node able use cpumemory resource requires puma webserver must start rail process cpu core achieve councurrency phoenix reqs stdev max latency rail reqs stdev max latency phoenix mix depsget compile mixenvprod mix compileprotocols mixenvprod elixir pa buildprodconsolidated mix phoenixstart running elixirbenchmarkerrouter cowboy port wrk timeout http running test http thread connection thread stats avg stdev max stdev latency reqsec request read requestssec transfersec rail bundle rackenvproduction bundle exec puma w puma starting cluster mode version ruby codename sir edmund percival hillary min thread max thread environment production process worker phased restart available listening tcp wrk timeout http running test http thread connection thread stats avg stdev max stdev latency reqsec request read requestssec transfersec heroku result dyno phoenix showed throughput much consistent standard deviation latency le cpu load ran available socket connection trying push phoenix dyno harder match cpu load seen rail dyno possible phoenix app could throughput available client network link higher capacity standard deviation particularly important remote host rail app struggled maintain consistent response time hitting second latency result real world term phoenix app respond much consistently load rail app phoenix reqs stdev max latency rail reqs stdev max latency phoenix cold wrk timeout http running test http thread connection thread stats avg stdev max stdev latency reqsec request read socket error connect read write timeout requestssec transfersec phoenix warm wrk timeout http running test http thread connection thread stats avg stdev max stdev latency reqsec request read socket error connect read write timeout requestssec transfersec load sample sample sample sample sample sample rail cold wrk timeout http running test http thread connection thread stats avg stdev max stdev latency reqsec request read requestssec transfersec rail warm wrk timeout http running test http thread connection thread stats avg stdev max stdev latency reqsec request read socket error connect read write timeout requestssec transfersec load sample sample sample sample sample sample sample summary elixir provides joy productivity ruby concurrency faulttolerance erlang shown best world elixir encourage get involved phoenix much work phoenix match robust ecosystem rail getting started big plan year application available github want recreate benchmark would love see result different hardware particularly hardware put greater load phoenix app shoutout jason stiebs help getting heroku application setup remotely benchmarked
486,Lobsters,erlang,Erlang development,Programming Rules and Conventions,http://erlang.se/doc/programming_rules.shtml,programming rule convention,programming rule convention table content program development using erlang programming rule convention see process one role page see flush unknown message page see error message page see message description page see file header description page see comment function page,programming rule convention table content author epknp klas eriksson euasu williams j armstrong document epknp program development using erlang programming rule convention abstract description programming rule advise write system using erlang note document preliminary document complete requirement use ebc base system documented must followed early design phase base system used requirement documented uen map start error recovery paper list aspect taken consideration specifying programming software system using erlang attempt give complete description general specification design activity independent use erlang erlang system divided module module composed function attribute function either visible inside module exported ie also called function module attribute begin placed beginning module work system designed using erlang done process process job use function many module process communicate sending message process receive message sent process decide message prepared receive message queued receiving process prepared receive process supervise existence another process setting link process terminates automatically sends exit signal process linked default behavior process receiving exit signal terminate propagate signal linked process process change default behavior trapping exit cause exit signal sent process turned message pure function function return value given argument regardless context call function normally expect mathematical function function pure said side effect side effect typically occur function sends message b receives message c call exit call bif change process environment mode operation eg etc warning document contains example bad code module basic code structuring entity erlang module contain large number function function included export list module called outside module seen outside complexity module depends upon number function exported module module export one two function usually easier understand module export dozen function module ratio exportednonexported function low desirable user module need understand functionality function exported module addition writer maintainer code module change internal structure module appropriate manner provided external interface remains unchanged module call function many different module difficult maintain module call function different module time make change module interface check place code module called reducing interdependency module simplifies problem maintaining module simplify system structure reducing number different module called given module note also desirable intermodule calling dependency form tree cyclic graph example commonly used code placed library library collection related function great effort made ensuring library contain function type thus library list containing function manipulating list good choice whereas library listsandmaths containing combination function manipulating list mathematics bad choice best library function side effect library function side effect limit reusability often problem solved using mixture clean dirty code separate clean dirty code separate module dirty code code dirty thing example us process dictionary us erlang strange purpose anything supposed concentrate trying maximize amount clean code minimize amount dirty code isolate dirty code clearly comment otherwise document side effect problem associated part code nt make assumption function called caller function wish result example suppose call routine certain argument may invalid implementer routine make assumption caller function wish happen argument invalid thus write code like dosomething args case checkargs args ok ok doit args error string formattheerror io format error sn string nt error end instead write something like dosomething args case checkargs args ok ok doit args error error end errorreport error formattheerror former case error string always printed standard output latter case error descriptor returned application application decide error descriptor calling application convert error descriptor printable string print required may desired behavior case decision result left caller whenever pattern code two place code try isolate common function call function instead code two different place copied code requires much effort maintain see similar pattern code ie almost identical two place code worth taking time see one change problem slightly make different case write small amount additional code describe difference two avoid copy paste programming use function write program using topdown fashion bottomup starting detail topdown nice way successively approaching detail implementation ending defining primitive function code independent representation since representation known higher level code designed nt optimize code first stage first make right necessary make fast keeping right system always respond manner cause least astonishment user ie user able predict happen something astonished result consistency consistent system different module thing similar manner much easier understand system module thing different manner get astonished function either function solves wrong problem wrong name erlang several primitive side effect function use easily reused since cause permanent change environment know exact state process calling routine write much possible code sideeffect free code maximize number pure function collect together function side effect clearly document side effect little care code written sideeffect free manner make system lot easier maintain test understand best illustrated simple example define simple module called queue implement queue module queue export add item q list append q item fetch ht ok h fetch empty implement queue list unfortunately use user must know queue represented list typical program use might contain following code fragment newq nt queue add joe newq queue add mike bad since user need know queue represented list b implementer change internal representation queue might want later provide better version module better module queue export new add item q list append q item fetch ht ok h fetch empty write newq queue new queue add joe newq queue add mike much better corrects problem suppose user need know length queue might tempted write len length queue nt since know queue represented list bad programming practice lead code difficult maintain understand need know length queue length function must added module thus module queue export new add item q list append q item fetch ht ok h fetch empty len q length q user call queue len queue instead say abstracted detail queue queue fact called abstract data type go trouble practice abstracting internal detail implementation allows u change implementation without changing code module call function module changed example better implementation queue follows module queue export new add item x faster addition element itemx fetch x ht ok h x fetch empty fetch x perform heavy computation sometimes fetch list reverse x len x length x length deterministic program one always run manner matter many time program run nondeterministic program may deliver different result time run debugging purpose good idea make thing deterministic possible help make error reproducible example suppose one process start five parallel process check started correctly suppose order five started matter could choose either start five parallel check started correctly would better start one time check one started correctly starting next one defensive program one programmer trust input data part system programming general one test input data function correctness code system written assumption input data function question correct small part code actually perform checking data usually done data enters system first time data checked enters system thereafter assumed correct example args option allnormal getserverusageinfo option asciipid pid listtopid asciipid case option getallinfo pid normal getnormalinfo pid end function crash option neither normal caller responsible supplying correct input hardware isolated system use device driver device driver implement hardware interface make hardware appear erlang process hardware made look behave like normal erlang process hardware appear receive send normal erlang message respond conventional manner error occur suppose program open file something close later coded dosomethingwith file case file open file read ok stream doit stream file close stream correct solution error error end note symmetry opening file file open closing file close routine solution much harder follow obvious file closed nt program like dosomethingwith file case file open file read ok stream doit stream error error end doit stream stream stream file close stream nt nt clutter code normal case code designed handle exception far possible program normal case code normal case fails process report error crash soon possible nt try fix error continue error handled different process see process one role page clean separation error recovery code normal case code greatly simplify overall system design error log generated software hardware error detected used later stage diagnose correct error permanent record information helpful process kept one basic element system design identifying part system correct part system correct conventional operating system design kernel system assumed must correct whereas user application program necessarily correct user application program fails concern application failure occurred affect integrity system whole first part system design must identify part system must correct call error kernel often error kernel kind realtime memory resident data base store state hardware code implementing single process contained one module process call function library routine code top loop process contained single module code top loop process split several module would make flow control extremely difficult understand mean one make use generic server library helping structuring control flow conversely code one kind process implemented single module module containing code several different process extremely difficult understand code individual process broken separate module process basic system structuring element nt use process message passing function call used instead registered process registered name module make easy find code process register process live long time deciding whether implement thing using sequential parallel process structure implied intrinsic structure problem used main rule use one parallel process model truly concurrent activity real world onetoone mapping number parallel process number truly parallel activity real world program easy understand process different role system example clientserver model far possible process one role ie client server combine role role process might supervisor watch process restarts fail worker normal work process error trusted worker allowed error many circumstance good idea use generic server program generic server implemented standard library consistent use small set generic server greatly simplify total system structure possible protocol handling software system message tagged make order receive statement le important implementation new message easier nt program like loop state receive mod funcs args nt apply mod funcs args loop state end new message getstatusinfo option introduce conflict placed mod func args message message synchronous return message tagged new atom describing returned message example incoming message tagged getstatusinfo returned message could tagged statusinfo one reason choosing different tag make debugging easier good solution loop state receive execute mod funcs args use tagged message apply mod funcs args loop state getstatusinfo option statusinfo getstatusinfo option state loop state end every server alternative least one receive statement avoid filling message queue example mainloop receive mainloop mainloop flush message queue errorlogger errormsg error process w got unknown msg wn self mainloop end server must tailrecursive otherwise server consume memory system run nt program like loop receive loop stop true errorlogger log error processgotother self loop end io format server going nt tailrecursive correct solution loop receive loop stop io format server going errorlogger log error processgotother self loop end tailrecursive use kind server library example generic automatically avoid mistake use function interface whenever possible avoid sending message directly encapsulate message passing interface function case ca nt message protocol internal information hidden module example interface function module fileserver export openfile filename fileserver openfilerequest filename receive openfileresponse result result end code careful using receive statement make sure handle case message arrives later see flush unknown message page process possible trap exit signal process either trap exit usually bad practice process toggle trapping exit use record principle data structure record tagged tuple introduced erlang version thereafter see epknp similar struct c record pascal record used several module definition placed header file suffix hrl included module record used within one module definition record beginning file module defined record feature erlang used ensure cross module consistency data structure therefore used interface function passing data structure module use selector constructor provided record feature managing instance record nt use matching explicitly assumes record tuple example demo p person name joe age person name p use matching p personname use selector like nt program like demo p person name joe age person name age phone misc p nt use tagged return value nt program like keysearch key key value tail value nt return untagged value keysearch key wrongkey wrongvalue tail keysearch key tail keysearch key false key value contain false value correct solution keysearch key key value tail value value correct return tagged value keysearch key wrongkey wrongvalue tail keysearch key tail keysearch key false use catch throw unless know exactly use catch throw little possible catch throw useful program handle complicated unreliable input outside world reliable program may cause error many place deeply within code one example compiler use get put etc unless know exactly use get put etc little possible function us process dictionary rewritten introducing new argument example nt program like tokenize ht tokenize case getcharactersfromdevice get device nt use eof value char tokenize char end correct solution tokenize device ht tokenize device case getcharactersfromdevice device better eof value char tokenize device char end use get put cause function behave differently called input different occasion make code hard read since nondeterministic debugging complicated since function using get put function argument also process dictionary many run time error erlang example badmatch include argument function never process dictionary nt use import using make code harder read since directly see module function defined use exref cross reference tool find module dependency make distinction function exported function exported following reason example user interface module interface function module called apply spawn etc within module use different export grouping comment accordingly example user interface export intermodule export export export export use within module export nested code code containing caseifreceive statement within caseifreceive statement bad programming style write deeply nested code code tendency drift across page right soon becomes unreadable try limit code maximum two level indentation achieved dividing code shorter function module contain line source code better several small module one large one nt write function line code split large function several smaller one nt solve problem writing long line nt write long line line character example fit page erlang thereafter string constant automatically concatenated example io format name age w phone w n dictionary wn name age phone dict choose meaningful variable name difficult variable name consists several word use capitalized letter separate example myvariable myvariable avoid using nt care variable use variable beginning instead example name later stage need value variable remove leading underscore problem finding underscore replace code easier read function name must agree exactly function return kind argument implied function name surprise reader use conventional name conventional function start stop init mainloop function different module solves problem name example module moduleinfo bad function name one common programming error good choice name difficult kind naming convention useful writing lot different function example name prefix could used signify function question return atom true false true false check ok error erlang flat module structure ie module within module often however might like simulate effect hierarchical module structure done set related module module prefix example isdn handler implemented using five different related module module given name isdninit isdnpartb isdn consistent programming style help people understand code different people different style concerning indentation usage space etc example might like write tuples single comma element people might use comma followed blank adopted style stick within larger project style used part must always correctly attribute code module header say idea contributing module came code derived code say got code wrote never steal code stealing code taking code module editing forgetting say wrote original example useful attribute revision revision created date createdby eklas erlang modified date modifiedby mbj erlang provide cross reference code document relevant understanding code example code implement communication protocol hardware interface give exact reference document page number document used write code error listed together english description mean separate document see error message page error mean error detected system point program detect logical error call error logger thus errorlogger errormsg format descriptor make sure line descriptor added error message document use tagged tuples principle data structure sending message different part system record feature erlang introduced erlang version thereafter used ensure cross module consistency data structure english description data structure documented see message description page comment clear concise avoid unnecessary wordiness make sure comment kept date code check comment add understanding code comment written english comment module shall without indentation start three percent character see file header description page comment function shall without indentation start two percent character see comment function page comment within erlang code shall start one percent character line contains comment shall indented erlang code kind comment shall placed statement refers comment placed line statement preferred comment function someusefulfunctions usefulargugument anotherfunctions usefulargugument comment end line comment complicatedstmnt level indentation complicatedstmnt important thing document purpose function domain valid input function data structure argument function together meaning domain output function possible data structure return value together meaning function implement complicated algorithm describe possible cause failure exit signal may generated nonobvious run time error note difference failure returning error side effect function example function purpose get various information process args option normalall return list key value error reason process dead getserverstatistics option pid pid pid record defined together plan text description example file mydatastructuresh data type person name string default undefined age integer default undefined phone list integer default dict dictionary containing various information person key value list default empty list record person name age phone dict file source code must start copyright information example copyright ericsson telecom ab right reserved part computer program may used reproduced stored retrieval system transmitted form mean electronic mechanical photocopying recording otherwise without prior written permission ericsson telecom ab file source code must documented revision history show working file done revision history rev date author fred bloggs etxxxxx intitial pre release function adding deleting foobars incomplete rev date author johanna johansson etxyyy added function adding deleting foobars changed data structure foobars allow need baz signalling system file must start short description module contained file brief description exported function description module foobardatamanipulation foobars basic element baz signalling system function manipulating data foobars etc etc etc export createfoobar parent type return new foobar object etc etc etc know weakness bug badly tested feature make note special comment nt try hide part module incomplete add special comment add comment anything help future maintainer moduleif product module writing success may still changed improved ten year time someone may never meet add comment revision history effect remember source code control system help non trivial project must use source code control system rcs cv clearcase keep track module section describes system level document necessary designing maintaining system programmed using erlang one chapter per module contains description module exported function follows meaning data structure argument function meaning data structure return value purpose function possible cause failure exit signal may generated explicit call format document defined later format interprocess message except defined inside one module format document defined later description registered server system interface purpose description dynamic process interface format document defined later description error message format document defined later
487,Lobsters,erlang,Erlang development,Elixir vs Ruby Showdown - Part One,http://littlelines.com/blog/2014/06/27/elixir-vs-ruby-showdown-part-one/,elixir v ruby showdown part one,hour elixir workshop phoenix linguist tl dr edit gist benchmark result,taken huge interest elixir littlelines office year gave hour elixir workshop railsconf april busy building phoenix elixir web framework earlier week put together linguist elixir internationalization library shocked little code required taking look ruby implementation using metaprogramming facility able define function head pattern match key approach simply generates function per key whose function body return translation required interpolation see action tl dr elixir implementation faster gem edit joel vanderwerf put together ruby implementation response post run making elixir implementaiton fast gist defmodule use linguistcompiler locale en foo bar flash notice alert alert hello hello first last end iex en flashnoticealert alert iex en flashnoticehello first chris last mccord hello chris mccord calling use linguistcompiler code would expand compile time defmodule def en foo en foo end def en foo binding bar end def en flashnoticealert en flashnoticealert end def en flashnoticealert binding alert end def en flashnoticehello en flashnoticehello end def en flashnoticehello binding hello dictfetch binding first dictfetch binding last end end notice last function definition interpolation handled entirely string contcatenation instead relying regex splittingreplacement runtime level optimization possible ruby code implementation requires complex algorithm split key hash allow performant lookup runtime since elixir implementation produce function definition let erlang virtual highly optimized pattern matching engine take lookup value result strikingly le code equivalent functionality get le code also get speed improvement ruby benchmark ran see elixir implementation compared ruby elixir defmodule benchmark defmodule use linguistcompiler locale en foo bar flash notice alert alert hello hello first last bye bye name user title user profile title profile end def measure func func timertc elem kernel end def run measure fn enumeach fn en foo en usersprofilestitle en flashnoticehello first chris last mccord en flashnoticehello first john last doe end end end end iex benchmarkrun ruby en foo bar flash notice alert alert hello hello first last bye bye name user title user profile title profile class benchmarker def selfrun benchmarkmeasure foo usersprofilestitle flashnoticehello first chris last mccord flashnoticehello first john last doe end endreal end end irb benchmarkerrun benchmark result elixir average across run ruby mri average across run speed improvement elixir ruby toplevel api careful use metaprogramming able produce clean implementation compiletime optimized lookup elixir provides metapgramming ability well beyond dream rubyists resource learn never trust benchmark result always measure
488,Lobsters,erlang,Erlang development,How I Start: Erlang,http://howistart.org/posts/erlang/1,start erlang,erlang intro installing erlang download follow instruction environment ohmyzsh custom theme hgprompt vimerl erlangmotions blog post example project prototype making library otp application configuration value provide guarantee regarding state supervisor bridge muumuufsmerl module publish library hex package proper plugin release email protected test common test github dependency code,written fred hebert june erlang intro erlang release bit like magnet everyone think share thought f king release work fortunately since year emakefiles reltool systools erlang community stood improved tooling continuously rebar improving nonstop keep getting better many function newest generation try provide endtoend experience building erlang project along installing erlang version least getting hold gon na need rebar download follow instruction basically generate selfexecutable store repository install globally computer tutorial expects installed system made available path installed somewhere system arm text editor ide choice mine vim terrible person get ready write thing environment despite free develop whatever want gon na go whatever setup use zsh ohmyzsh using custom theme depends hgprompt script stuck vimode vim vim vim vim work erlang use two line vimrc file autocmd bufread bufnewfile erl e hrl yaw xrl set expandtab au bufnewfile bufread erl e hrl yaw xrl setf erlang depend two plugins vimerl erlangmotions use lot material outside o tend ide project tend work lot use tmux script see blog post example get everything going early project avoid usual hello world stuff tutorial use somewhat fun application get running basic erlang app run within module proper otp library included project release selfexecuting distributed client computer server project replication one wellknown software program popular history used lifecritical situation homer simpson console episode fat work home episode infer following software program boot asks press key program ask question answered yesno also yn yn question turned command assertion equivalent answering given question positively example vent radioactive gas yesno turned vent gas command nothing go wrong keep pressing time given delay new question asked many time without venting radioactive gas risk exploding everything behaviour defined tv show go somewhat anyway feel like finitestate machine created one follows explains understood possible notice really good consistent notation event state press key key pressed check core temperature first yesno venting radioactive gas first yes gas blow away crop venting prevents explosion yes v wait command get data timeout ask question yes show result based able draw first prototype required state transition also looked transcript show extracted following question consequence check core temperature yesno yes core temperature normal vent radioactive gas yes gas blow away corn crop venting prevents explosion allow yes show first time sound alertness horn yes horn sound distance decalcify calcium duct special case denying venting many time valve must disabled manually simplest way write basic fsm one use bunch function call given erlang last call optimization call happens return value leave stack trace therefore happen infinitely many time adequate sequence state b c programmed b b c c done course going data case prototype glorious application called muumuu whenever exactly know going decide prototype stuff stress importance prototype despite fact often end production yeah avoided decide start basic stuff prototype state transition go fairly simple manner topdown module muumuufsm export define maxnovent start seed prng crypto randbytes random seed b c waitanykey state transition waitanykey io getline start press keyn firstcorecheck firstcorecheck case option check core temperature yes coretemperature noop end firstgasvent firstgasvent case option vent radioactive gas yes blowcropsaway ventingpreventsexplosions end waitforcommand waitforcommand case waitcmd timeout opt yes randomoption case option opt yes yes end cmd case matchoption cmd yes yes noop end end waitforcommand bit code see main state waitanykey firstcorecheck firstgasevent waitforcommand rest code le going event input management check transition printing question getting response eventually waiting command take long generate option randomly look code find whatever want disgusting general idea want code time add option management stuff option response handling option prompt showoption prompt data io getline case iolisttobinary data binary yes binary yes n binary n binary ambiguous end showoption str io format yn n str waitcmd timeout parent self pid spawn fun parent io getline end receive data data timeout exit pid kill timeout end randomoption po random uniform tuplesize opts val element po opts val matchoption data case vals pattern vals tupletolist opts nomatch run data pattern caseless opt opt invalidopt end cool fantastic looking yet basically option fetch line text entered user look first response return showing option wrap thing look like prompt interestingly enough command waited different process problem erlang standard library support timeout mode io operation would tell u wait second input quit therefore need move process rest relies elusive opts function apparently return question option offered user defining optionsevents opts checkcoretemp check core temperature fun fun ventradgas vent radioactive gas fun fun soundalerthorn sound alertness horn fun fun calcduct decalcify calcium duct fun fun basically tuple use tuple make random selection fixed position efficient question positive negative response consequence paired regular expression represents fuzzy matching example someone typing check temperature match check core temperature question return option code back execute function finally action consequence implemented noop ok ventingpreventsexplosions case option venting prevents explosion yes blowcropsaway noop end coretemperature io format core temperature normaln blowcropsaway io format gas blow away corn crop n soundhorn io format horn sound distance n pressuretoohigh io format pressure high tank must shut manuallyn ventgas maxnovent pressure shut manually unsupported program case get missed maxnovent pressuretoohigh put missed blowcropsaway end noventing case get missed undefined put missed n put missed end two last function implement special last requirement denying venting many time valve must disabled manually use dirty ugly counter prototyping sake fact forgotten requirement time bolted way prototype helped figure requirement final version designed mind run code try shell λ erlc srcmuumuufsmerl erl muumuufsm noshell start press key check core temperature yn n vent radioactive gas yn venting prevents explosion yn yes gas blow away corn crop sound alertness horn yn horn sound distance work using module run function module using noshell make erlang vm fight io call user input ownership sadly implementation kind ugly go production making library two way make something reach production distributing distributing library erlang developer use latter prerequisite former going start default everyone using erlang open source community us otp application otp kind often treated super advanced topic gon na show take nonotp compliant code turn otp application fun fun first directory structure src muumuufsmerl need term structure installed system add file src called muumuuappsrc file basically telling erlang library application muumuu description fat go power plant app vsn registered application kernel stdlib crypto mod muumuuapp env registered entry specifies process going globally registered node case none application tuple list application depend application depend kernel stdlib entry always hand crypto optional apps need use seed pseudorandom number generator env tuple contain configuration value need none right option considered mod library requires process started shipping code around done case however starting process want therefore specify application module named muumuuapp module also src module muumuuapp behaviour application export start type args muumuusup startlink stop ok module basically giving callback erlang vm see bit main function c except also provide stop function clean process exit case need nothing muumuusup module final step glued otp otp concept called supervisor supervisor charge checking otpcompliant process start stop provide guarantee regarding state unfortunately process otpcompliant guy ericsson long ago hit problem developed supervisor bridge basically act wrapper could use kind person want otp process done correctly everywhere time stick regular supervisor rewrite fsm right module muumuusup behaviour supervisor export export startlink supervisor startlink module init ok oneforone console muumuufsm startlink permanent worker muumuufsm start muumuufsm permanent worker die every second entire system crash good way pick frequency second sound like something reasonable someone mash key way bad enough cause error come rewrite prototype genfsm stuff covered multiple tutorial going skip instead look book doc genfsm follow along final module muumuufsmerl see biggest change outside providing genfsm callback required otp behavior related general information flow rather really direct sequence function whatever want otp version module becomes lot declarative longer enter state function ask question wait response within context logic moved event state say firstgasvent cause question asked transitioning state handle response make code particulalry harder read different init crypto randbytes random seed b c ok waitanykey prompt waitanykey state waitanykey state nextstate firstcorecheck prompt firstcorecheck state firstcorecheck state nextstate firstgasvent prompt firstgasvent state firstcorecheck yes state showcoretemperature nextstate firstgasvent prompt firstgasvent state firstgasvent state statename ventingpreventsexplosions nextstate statename prompt statename state firstgasvent yes state showblowcropsaway nextstate waitforcommand prompt waitforcommand state form along experience gained prototype allows simpler state management via state variable allows u transparent usage venting limit example also instantly benefit everything otp give u term transparency tracing logging statistic see sys module code place compile run entire application λ compile verifying dependency compiling muumuu compiled run funky command λ erl env erllibs builddefaultlib eval application ensureallstarted muumuu noshell start press key check core temperature yn core temperature normal vent radioactive gas yn gas blow away corn crop kind ugly command run app app something people use pull within system order run actually ship customer need build release case though may want publish library hex package help proper plugin release directory structure using application turn looking like src ebin simplest level release basically group application put together reason change directory structure bit apps muumuu src ebin rebarconfig application need go apps moved src appsmuumuu rebarconfig file look like relx release muumuu list apps include muumuu nt ship erlang vm default includeerts false profile called prod command prod relx override relx specifically includesrc false nt include source code includeerts true include vm release basically tell releasebuilding tool includes relx give u release release include custom erlang code use currently installed erlang vm run thing rather installing fully selfcontianed program magic happens λ release verifying dependency compiling muumuu starting relx build process resolving otp application directory resolved release successfully created release born run λ builddefaultrelmuumuubinmuumuu noshell start press key pretty cool shipped distributed people want make release bit fancier though seen still need put noshell hand totally unacceptable fix add config repository open vmargs file vim show programmed prompt noshell remote access debugging name email protected needed smp disable argument merged one good practice erlang system give name let connect running case could go debug console user maintaining powerplant last argument smp disable basically optimization app remove erlang parallelism running single active process thing bother remove number asynchronous thread io single one reason one active process bother serious apps tweaking vm option worthwhile outside text scope config file need update relx release muumuu list apps include muumuu nt ship erlang vm default includeerts false vmargs configvmargs profile called prod command prod relx override relx specifically includesrc false nt include source code includeerts true include vm release last line profile new one compile argument implicitly passed node λ release verifying dependency compiling muumuu starting relx build process resolving otp application directory resolved release successfully created λ builddefaultrelmuumuubinmuumuu start press key tab check core temperature yn cool everything work binary executable link anywhere system require magical argument work test much like try get testing done ahead time time super terrible crappy often end adding fact know maintain app test add test directory appsmuumuu tool choice common test kind full annoying overhead unit testing mostly useless shell output got ta deal html file scale fairly well integration system test test suite going muumuusuiteerl module muumuusuite includelib commontestincludecthrl compile exportall copypasting suite record state pid yes demosession first gon na make one runthrough test testing muumuu going hard purely sideeffectful application going say trick getting working use meck pretty much best codemocking application around adding meck done declaring rebarconfig dependency profile test deps meck called prod command prod note rather toplevel deps entry usually would define one test profile allow dependency fetched used running test avoid bundling shipping application pull stuff package repository one github dependency also option add lock file fetch compiles later back muumuusuite time set state initpertestcase demosession config mockio ok pid muumuufsm startlink pid pid config endpertestcase config meck unload io pid config pid config unlink pid exit pid shutdown waitfordeath pid mocking io system fun way basically take make return message look take place mockio place start muumuu instance directly application needed mockio one mock io system instead printing message getting input user instead messagepassing interface inspectable note io module precompiled vm unstick first careful keep mocked little possible parent self code unstickdir filename dirname code whereisfile iobeam meck new io passthrough nolink meck expect io format fun str parent str ok end meck expect io format fun str args parent iolib format str args ok end meck expect io getline fun prompt parent self receive parent end end ugly first step unstickying directory erlang code module require erlang standard library unstickying allows load new version code run time meck dynamically mocking function io io io send message form msg msg input output respectively meck unload io undo also call using everywhere test timer enemy good concurrent testing rely timer sleep sort make sure everything clean wrong function poll return asap tiny sleep heat room much via cpu waitfordeath pid case isprocessalive pid true timer sleep waitfordeath pid false ok end done start planning test something always want write library maybe day right redo crap hand every time test case pressing given key messagepassing interface yield expected output prompt waiting key state cycled using yn answer demosession config pid config pid config press key tab character nt matter check core temp temperature normal vent radioactive gas venting prevents explosion yes gas blow crop genfsm sendevent pid timeout force timeout faster yn question care vent gas force command gas blow crop basically write test way want look like start expecting message match regex press key output insert tab rinse repeat desire pretty much turn interaction write shell bunch function call match planned messagepassing interface write function wrap functionality helper input receive pid pid self input ct pal mbox p processinfo self message error toolong input end look back mocked function mocked function sends u processthatwaitsforinput take input argument send back mocked function run process never receive message crash printing debugging information interestingly function use ct pal work exactly like io format except output shell html log common test gon na used production system surely never going mocked unlike io helper slightly complex fuzzily match input string waiting expected receive prompt ct pal expected pnprompt p expected prompt match run prompt expected dotall caseless global ct pal mbox p processinfo self message error toolong expected end one make assertion regular expression rest similar receive output match go run test λ ct ct verifying dependency fetching meck pkg meck compiling meck compiling muumuu running common test suite test output omitted test passed check rebar lock file version control go something else pretty much done see code
489,Lobsters,erlang,Erlang development,Become an Erlang Cowboy and tame the Wild Wild Web — Part I,https://medium.com/erlang-lisp-and-haskell/37f8dd1df160,become erlang cowboy tame wild wild web part,objective http disquscom audience requirement inaka ugly duckling performance developer expressiveness developer productivity top list rust run blazingly fast prevents almost crash http wwwrustlangorg java highperformance application http wwwjavacomenabout haskell allows rapid development robust concise correct software http wwwhaskellorghaskellwikihaskell python work quickly integrate system effectively http wwwpythonorg ruby dynamic focus simplicity productivity elegant syntax natural read easy write http www ruby langorgen arc feel like driving http wwwpaulgrahamcomdesignhtml porsche go make programmer productive expressive concise clean efficient easy write program get multicore networked machine fast statically typed compiled language feel like dynamically typed interpreted language http golangorgdoc erlang used build massively scalable soft realtime system requirement high availability http wwwerlangorg syntax erlang grammar great article expressiveness exit shell using twice controlc since going use http library ibrowse following example instead setting everything git githubcom http wwwgooglecom http wwwgooglecomar gferdcr http wwwgooglecomar gferdcr amp sendreq ibrowse linked list integer atom ruby lisp iolists http wwwgooglecom http wwwgooglecomar gferdcr http wwwgooglecomar gferdcr amp termn ok http wwwgooglecomar gferdcr proplist http wwwgooglecomar gferdcr amp http wwwgooglecom http wwwgooglecomar gferdcr make compiler work god alter past though historian developer samuel butler referential transparency process message tail recursion final fight moving foward,objectivein following series post creating commenting system like http disquscom system normal httprest handler also sse websockets handler background job uploading image amazon sending push notification io android client via amazon sn end series connect erlang system programming language task difficult erlangby mean attempt create new reference learning syntax type function language already three great book cover purpose point need read want work erlang objective create hand erlang guide hopefully small book use important useful erlang concept create working real system see highly scalable concurrent parallelizable battleproof especially well designed erlang platform separate erlang language plataform even intertwined could change erlang syntax using another language run top beam like elixir lfe lisp flavored erlang still get almost erlang benefit even more get wrong really like language per se real power come ecosystem system general point view c java c objectivec python ruby even javascript similar sure different syntax small different way thing learn new way thinking changing one another learn syntax erlang language hour able learn concurrentfault tolerant paradigm one day nobody learnt object oriented paradigm lapse time looking learn new syntax new railslike framework come wrong placeif interested moving comfort zone come right place best help learn new different way thinking designing application length journey however depend entirely play reimplement idea different way obviously fight new compiler conquer victoryaudiencethis series post oriented towards developer need create backend server normally use language framework python flask twisted celery ruby railssinatragrape sidekiqrescue concurrent ruby jruby rubinius javascript nodejs expresskoa go worked technology year creating http server produced json consumed single page application io android client comfortable last year using erlang even still like ruby python javascript regret say erlang superior area building type systemsmy idea show easily cleanly create distributed resilient system thanks erlang semantics awesome beam virtual machine great library like cowboy convince use erlang next project hope least respect awesome poweron first post show basic erlang code next one start working first handler systemrequirementsbefore starting must say thankful employer letting write part post working hoursthe ugly duckling programming language defined set goal put performance developer expressiveness developer productivity top list let see say compare erlang description rust system programming language run blazingly fast prevents almost crash eliminates data race http wwwrustlangorgjava designed enable development portable highperformance application widest range computing platform possible http wwwjavacomenabouthaskell advanced purelyfunctional programming language opensource product twenty year cuttingedge research allows rapid development robust concise correct software strong support integration language builtin concurrency parallelism debugger profilers rich library active community haskell make easier produce flexible maintainable highquality software http wwwhaskellorghaskellwikihaskellpython programming language let work quicklyand integrate system effectively http wwwpythonorgruby dynamic open source programming language focus simplicity productivity elegant syntax natural read easy write http wwwrubylangorgenthe reliable plan design performance performance mean speed taking metaphor literally speed count programming language first tool thinking want thinking arc feel like driving http porsche go programming language open source project make programmer productive go expressive concise clean efficient concurrency mechanism make easy write program get multicore networked machine novel type system enables flexible modular program construction go compiles quickly machine code yet convenience garbage collection power runtime reflection fast statically typed compiled language feel like dynamically typed interpreted language http golangorgdoclet see erlang say erlang programming language used build massively scalable soft realtime system requirement high availability us telecom banking ecommerce computer telephony instant messaging erlang runtime system builtin support concurrency distribution fault tolerance http wwwerlangorgerlang seems ugly duckling compared programming language since describe fast clean expressiveerlang created building faulttolerant system natural since erlang root telecommunication world important design choice language taken fulfill requirement however mean clean expressive let take closer looksyntaxerlang grammar simple le line code make erlang syntax easy understand even different mainstream language important really consistent enough talk commentmodule foo define module called fooexport export function bar argumentsbar define function bar io format hello world n let compile run inside erlang shell bar function module foo erlc fooerl erl foo bar call bar functionhello world oklet show example little complex module test compile exportall factorial implemented would normally imperative languagesfacif n n true n facif n end factorial implemented case n match return n match value call faccase n case n n n faccase n end factorial implemented function clause fac fac n n fac n let save testerl compile call erlang shell erlc testerl erl last case us something called pattern matching function head line learn pattern matching call fac test fac test fac syntax difficult different algol c based syntax see many reserverd word language construct think lisp way simpler language syntax grammar point viewi wanted add noticed erlang us terminator big fan since change moving line code general like indentation la python way delimit block code however erlang terminator big pain get used also agree robert virding co creator erlang erlang syntax small simple regular concise difficult agree even like erlang syntax mainstream language used eg c java c objectivec much complex le consistent syntax returning terminator issue fred hebert great article tip understand use read themlet move onto important thing expressivenesswhen thinking erlang expressiveness first thing come mind message passing process creation management nevertheless pattern matching big player field serf big purpose making thing easier receiving message let start showing simple example pattern matching moving message passing process body variable body header variable header unboundfirst tried access content body header variable variable erlang must start capital letter shell answer obvious variable unbound time something interestingexit shell using twice controlc since going use http library ibrowse following example instead setting everything git clone git githubcom unbalancedparentheseserlskeletorcowboygit cd erlskeletorcowboy makemake fetch dependency compile project executed erl launch erlang shell going use make shellmake shell start erlang dependency need see lot output return ibrowse sendreq http wwwgooglecom get ok cachecontrol private contenttype texthtml location http wwwgooglecomar gferdcr contentlength date thu may gmt server alternateprotocol quic html head meta httpequiv contenttype content texthtml n title moved title head body n moved nthe document movedn href http wwwgooglecomar gferdcr amp rn body html rn call sendreq function module ibrowse http erlang client first argument string url string linked list integer since erlang real string type common use string erlang atom ruby lisp symbol binary iolists atom binary really common handy moment important wanted mention start rambling afterwardsthe second argument call sendreq list header want send request sending header case last third argument specify verb request used atom get variable begin lowercase letter atom atom start lowercase letter enclosed single quote see sent get request http wwwgooglecomlet inspect result call ok cachecontrol private contenttype texthtml location http wwwgooglecomar gferdcr contentlength date thu may gmt server alternateprotocol quic html head meta httpequiv contenttype content texthtml n title moved title head body n moved nthe document movedn href http wwwgooglecomar gferdcr amp rn body html rn result tuple four element termn erlang denotes tuple tuples fixed number term element erlang tuples similar python tuples first element atom ok let u know everything went fine second element string content found http status code usually used redirect user somewhere else third element result list header answer google sent u cachecontrol private contenttype texthtml location http wwwgooglecomar gferdcr contentlength date thu may gmt server alternateprotocol quic see header represented list tuples tuple two element key value type proplistthe first header key type string cachecontrol string value private also check location key url value redirect google want u go know different used difficult understand hour reading proplists tuples list erlang feel naturalthe last element answer call ibrowse sendreq big string html google sent u html head meta httpequiv contenttype content texthtml n title moved title head body n moved nthe document movedn href http wwwgooglecomar gferdcr amp rn body html rn let store ok header body ibrowse sendreq http wwwgooglecom get pattern pattern pattern matching everything sent get request google got answer ok atom string assigned since variable use equal sign assign well erlang equal sign exactly assignment since erlang support pattern matching mechanism equal sign used match operator try find equivalence two side bind value unbound variable thus assigning valueso getting result call ibrowse sendreq erlang asserts got tuple four element started element ok since know header body unbound assigned header proplist variable header html returned google variable header cachecontrol private contenttype texthtml location http wwwgooglecomar gferdcr contentlength date thu may gmt server alternateprotocol quic sum pattern matching way another syntax writing c switch ifelseelif python language pattern matching get normal branching conditionals complex structure comparing simple value also extract specific value comparison orand assignment make compiler work youat last wanted show beautiful example pattern matching dissect tcp segment bit payloadbinary tcpsegmentain good example erlang expressiveness god alter past though historian developer samuel butlervariables either bound unbound might know value inmutable erlang variable bound assign new value one assignment allowed modify variable value message hello lady hello lady message die die darling exception error match right hand side value die die darling inmutability single assignment first might seem awkward uncomfortable useful property since minimize side effect even impossible write erlang code race condition way difficult general imperative stateful language see next sectiona really interesting property helped single assignment inmutability referential transparency plain english mean result function always provide argumentsinput might think property programming language notthe output calling method object oriented language like example c java ruby depends state object previous call method change state object used method calling result depend argument also method called referential transparency greener side grass since degree determinism also writing test case way easier since general need mock entire object use dependency injection since call function argument wantyou might think using complicated word showing see following post thanks referential transparency pattern matching able refactor nested branching implemented case calling small simple function many language inspired java c implemented oop code damn interdependent difficult refactor itprocesses messagesfunctions functional programming language first class citizen mean discriminated assigned variable passed argument function returned value function say racism treat function type f fun x operation operation x end fun plus fun x x end fun f plus divideplustwo fun b b end fun f divideplustwo new process erlang really simple use spawn primitive function want launch another g fun end fun g spawn g spawn g spawn creates new process return pid unique process identifier process might ask return value go well apparently disappeared black magic process return anything send result message another let show shell process get self exit self exception exit self self got pid actual process case obviously shell pid exited process new shell process automatically launched pid changed pid self h fun pid end fun spawn h flush shell got bang symbol primitive sends message right process identified pid left process mailbox queue store message process receives flush see message process hashowever general want something based message received see shell receive statement appears save game echofun fun echo receive x io format message pn x end end fun echopid spawn echofun echopid testmessage testtestwe created echofun function receives message print receive block receives message receive similar case statement message correctly pattern match associated expression get executedreturning example saved echofun function echo variable spawned function stored pid finally sent atom message using bang symbol message received process message pattern match variable x io fomat line get executed first parameter io format string contains p p get replaced element list second argument call io echopid testtestif send message process print message test function already finished execution need recursively call function keep running receiving fun echo receive x io format message pn x echo end end fun spawn testmessage testmessage testmessage testtestnow receiving printing first message function call wait next message receivederlang functional programming language great property called tail recursion thanks process long great life without making stack grow explode facelet add new clause inside receive kill fun echo receive die io format process pid p diedn self x io format message pn x echo end end fun instead spawning function process storing pid register process besides addressing process using pid also built function bifs registering process name name must atom automatically unregistered process register echoprocess spawn register process created spawn name echoprocess testmessage echoprocess dieprocess pid dieddiekilling process thanks message echoprocess test exception error bad argumentin operator echoprocess testthe receive process function running new process pattern match message receives since first message match die atom check match x variable since x variable unbound message always match message get printed outwe send die atom message process since die match first clause receive sentence stating process died call function effectively process dieswhen try send test atom message process registered via echoprocess get bad argument exception happens since process died echoprocess atom reference process anymore obviously send messagethe final fightnow going play three process client shell project manager developer shell send message project manager project manager forward task developer simple dev fun devfun receive task io format dev p n got new task p n n self task devfun endendas see dev variable contains function receives message print call pm fun pmfun receive task io format pm p n received following task pn job forward developer n n self task dev task pmfun endendwell project manager different developer receives task print finally sends task received dev process need spawn register dev pm process register process spawn dev function would able send message let register dev spawn dev register pm spawn pm finally going create really simple function sends task newtask fun task io format client p n pn n self task pm taskendtime send task newtask add cover tps report get ouput printed client add cover tps report pm received following task add cover tps report job forward developer dev got new task add cover tps report dev process could running one server u pm process europe based server client shell could running computer buenos aire argentina another language would require really big code change using erlang requires adding line code technically would register process globally set kind vpn virtual machine see local network point erlang distribution built getting point system run cluster difficultfor following post leave error detection supervision process area erlang really really shinesmoving fowardyou might asking would want create process send message sooner rather later relative big project need parallelize code example call third party api taking much time example need use concurrency construct programming language thread process construct related concurrency parallelism something rarely use university something learn first programming course might used threadpool java even pthread c something generally use often defining class instantiating object calling function writing conditional statement even changing really interesting library framework toolkits like akka java world concurrentruby celluloid ruby even language clojure already set pretty high bar truth told concurrency cornerstone language erlang use frequently use construct c cheap great designing systemsmessage passingup played process see easy use concurrency based primitive erlang since require external library support like language see real us nexts post must add pattern matching play essential role well integrated rest make easy select based message receivedto sum thanks message passing pattern matching light process avoid thread mutex semaphore lot deadly weapon sooner rather later backfirestay tuned work real stuff next week comment thread http endpoint commenting system first hour playing erlang
490,Lobsters,erlang,Erlang development,About Skel - Skel: A Streaming Parallel Skeleton Library for Erlang,http://skel.weebly.com/about-skel.html,skel skel streaming parallel skeleton library erlang,,
491,Lobsters,erlang,Erlang development,"Elixir v0.14.0 released with derive, deeply nested traversal, and more",http://elixir-lang.org/blog/2014/06/17/elixir-v0-14-0-released/,elixir released derive deeply nested traversal,derive protocol consolidation nested access access protocol documentation mix otp server supervisor application agent task mix otp get started next set previous release kernel module open issue upcoming backwards incompatible change summary change release note getting started guide elixirconf,hello everyone glad announce released previous release brought important change language back introduced new associative data structure called map presented concept structs replace elixir record expanded work started replacing record structs integrating otp behaviour application configuration mix derive map elixir new associative data structure map elixir also introduced structs basically raw named map defmodule user defstruct name age end user name jose user name jose age structs allow u provide default value map field structs also validate compilation time field given struct construction valid field following example would fail user unknown field compileerror unknown key unknown struct user say structs raw implement protocol implemented map default instance call map us enumerable protocol enumeach foo bar fn k v ioputs got k v end got foo bar call would fail user struct enumeach user fn k v ioputs got k v end protocolundefinederror protocol enumerable implemented user age name however many situation may want enumerate key value struct release would require u manually implement enumerable protocol every struct elixir solves issue introducing derive allows u dynamically derive implementation structs based implementation map defmodule user derive enumerable defstruct name age end enumeach user name jose fn k v ioputs got k v end got struct elixiruser got name jose got age deriving functionality customized implementing example json protocol could define function derives specific implementation every struct implementation could access struct field generate json template compilation time avoiding work runtime protocol consolidation example called invoked enumerable protocol internally check implementation available user struct mean dispatching protocol incurs overhead check implementation available behaviour useful development production implementation protocol usually known upfront could avoid overhead direct dispatch exactly protocol consolidation protocol consolidation check code path project looking protocol implementions implementation found recompile protocol quick dispatch rule invoke manually consolidate protocol however inside mix project consolidate protocol simply invoking mix compileprotocols type mix help compileprotocols terminal get information task invoked deploying production opened issue elixir buildpack well existing build tool automatically consolidade protocol nested access elixir introduced functionality traverse deeply nested data structure show functionality let imagine gaming application user different dungeon dungeon may many room user talk room model game dungeon dungeon struct dungeon name room dungeon many room keep map room id key room struct value room id user hashdictnew room user since possibly hundred store hashdict user id key finally user may participate different device need keep set device code user user id username devicecodes hashsetnew nested access functionality ship elixir allows u quickly access update nested value example given dungeon named dungeon access device code given user follow dungeonrooms roomid user userid devicecodes nested access functionality update nested path directly example user change name change directly putin dungeonrooms roomid user userid username new username user sign one device delete code particular device updatein dungeonrooms roomid user userid devicecodes setdelete code macro work syntax sugar lowerlevel expects whole path given list putin dungeon room roomid user userid username new username read information nested access access protocol documentation doc friend mix otp otp set library ship erlang erlang developer use otp build robust faulttolerant application elixir closely integrates otp providing module building server supervisor application also introduced concept agent idea task supervised distributed application configuration made first class mix allowing developer configure dependency sometimes even using different configuration per environment dev test prod default functionality core building application erlang elixir reason published new guide called mix otp build distributed keyvalue store help explore concept mentioned guide quite fresh please submit pull request typo mistake feedback also welcome note mix otp advanced guide far expects read introductory guide case yet get started next reached many milestone set previous release brings u closer elixir handful task pending provide elixir logger know print format elixir exception stacktraces work already started front elixir already print error coming application startup nicely continue work cleaning kernel module added alternative conversion function like must properly deprecated removed support mix alias allowing developer easily define mix shortcut favorite task solve remaining open issue always kept issue tracker tidy little work left solve existing issue note also listed upcoming backwards incompatible change many change actually deprecated first developer able follow along without breaking change minor release breaking change sense work work differently time released elixir developer see summary change release note case new around get started elixir reading getting started guide hope see july elixirconf
492,Lobsters,erlang,Erlang development,BEAMJIT: An LLVM based just-in-time compiler for Erlang,https://www.youtube.com/watch?v=oF3qYFh_xuI,beamjit llvm based justintime compiler erlang,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature beamjit youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature beamjit youtube
494,Lobsters,erlang,Erlang development,Erlang and code style,https://medium.com/p/b5936dceb5e4,erlang code style,erlang code style musing mostly defensive programming style effect silly intentional data flow defensive programming process process isinteger scourge undefined open data representation src include cowboyreq value true false type atom edit closing remark,erlang code stylemusings mostly defensive programming stylescorrect erlang usage mandate write kind defensive code called intentional programming write code intentional control flow path expect code take write code path think possible furthermore write code data flow intention programit effect sillyif erlang program go wrong crash say opening file guard file open call like ok fd file open filename raw binary read readahead happens file exist well process crash note write code path default erlang crash match valid get badmatch error reason could open filea process crashing problem program still operating important faulttolerance concept make sure try little say introduced race condition file open accident happens rarely program would still run even file open fails time timeyou often see code look like ok foo ok bar ok asserts call went well making sure code crash control data flow expectednotice complete lack error handling writecase foo ok case bar end error reason throw error reason end fall trap go programming language write re err foo err nil panic err bar err nil panic also plain silly tedious cumbersome writethe key crasheffect erlang interpreter invoke default crash process something go wrong another process clean good erlang code abuse fact much possibleintentional note word intentional case expect call fail handle like everyone else would since emulate sumtypes erlang better language concept sumtype case file open filename raw read binary ok fd error enoent end written intention file might exist however worry non existencewe crash eaccess mean access error due permissionslikewise eisdir enotdir enospcwhy leaner code whywe skip lot defensive code often half code size project much le code maintain refactor need manipulate le code wellour code littered thing nothing normal code flow make far easier read code determine going onerlang process crash give lot information something dy proper otp process get state process died message sent triggered crash dump enough case reproduce error looking crash dump effect eliminates lot silly logging codedata flow defensive programminganother common way messing erlang program mangle incoming data pattern matching stuff like following convert isinteger convert f isfloat f round f convert l islist l listtointeger l function convert anything integer proceed use process anything convert anything problem process function callsites process function callsite different opinion data passed code lead situation every subsystem handle conversion like thesethere several disguise antipattern another smell convert x x convert b isbinary b x binary split b x stringified programming data pushed string manually deconstructed caller lead lot ugly code little provision extension laterrather trying handle different type enforce invariant early api process isinteger never test correctness inside subsystem dialyzer good inferring use integer littering code isinteger test going buy anything something wrong subsystem code crash go handle errorthere something said static typing force unityped world easily statically typed language could still obtain thing would define something along line standard ml code follows datatype anything int int string string real realand quickly becomes hard write pattern match hence people defines anything type really need gilad bracha partially right identified runtime check value omitted fact programmer decision avoid costly runtime check gilad scourge undefinedanother important smell undefined value story undefined often used program optionmaybe monad typetype option undefined value static typist erlang type system based success type figuring error one type definition straightforward define reflectionreification exceptioneffect jakob sievers library already well define monadic helper called though monad errortype rather option seen spec dox x ty undefined x undefined integer dox undefined undefined dox lead complicated code need control value fail value construction like silently pass undefined wary see code like undefined value essentially null car hoare billion dollar mistakethe problem code nullable default erlang never nulllike value introducing used sparingly think long hard value nullable check time tend make code convoluted complicated better test thing front leave main part code base much possible open data representationswhenever data structure set module know operates data structure single module emulate common pattern standard ml ocaml concrete data structure representation abstract program single module operate abstract typethis entirely true erlang anyone introspect data keeping illusion handy maintainabilitythe module manipulate data structure harder alter data structure consider putting record header file two level possible creeping insanity put record definition header file src case application see record leak outyou put record definition header file include case record leak application often willa good example http server cowboy request object manipulated cowboyreq module mean internal representation change keeping rest world stable module apithere case make sense export record think record manipulated several module chance win lot rethinking structure programthe value true false type atom final little nod see much code looking like f x true false true true hard read since erlang use better name true false value pick atom make sense produce atom also advantage catch bug early argument get swapped accident also note bind information result passing tuples much said concept boolean blindness typical program mean rely much boolean value problem get true say know true want evidence truth passing evidence tuple example function like case api resourceexists id true resource api fetchresource id false endbut could also write direct style case api fetchresource id ok resource notfound end edit originally used function name resourceexists richard carlsson correctly point misleading name changed something better name long run le error prone accident call fetchresource call look resource also get hold evidence resource really want use resource throw awayclosing remarksrules thumb exists broken must broken however hope learnt something stop reflect something happened get unless scrolled past interesting stuff also interested petpeeves missing way become better programmer study style others
495,Lobsters,erlang,Erlang development,How WhatsApp is scaling up,https://raw.githubusercontent.com/reedr/reedr/master/slides/efsf2014-whatsapp-scaling.pdf,whatsapp scaling,,äüöß obj stream dşgnb endstream endobj obj endobj obj stream jfif c c ltw n x b e g ʤ齙 p g mň ڬŉ x څ g eri e qd ri r r r rv r lv f w fdi aqq ml ܡ n g h nuu ĥlï n l j ɬ p j j qpo ĩ b ku r b j ul t
496,Lobsters,erlang,Erlang development,OlegDB 'Cartwheeling Trespassers' Released,https://olegdb.org/blog/0003_OlegDB_0.1.1_Released.html,olegdb cartwheeling trespasser released,olegdb cartwheeling trespasser released cartwheeling trespasser longstanding memory leak static analysis compression splay tree liboleg prefix matching alessandro gatti colby olson twitter,olegdb cartwheeling trespasser released quinlan pfifferproleg happy announce new improved olegdb nicknamed cartwheeling trespasser release pack whopping delta file changed insertion deletion hot damn bugfixes release include longstanding segfaultondeletionbutonlysometimes bug lot memory leak fix much rigorous attention static analysis also note compilation fix bsd hopefully see oleg running platformsas feature recently added compression work really well datasets others fast though save lot memory also added weird looking data structure called splay tree splay tree eventually allow use get cursorstyle iteration prefixmatching roll aroundprefixmatching nt quite ready via erlang frontend get hand wet liboleg prefix matching sort thingand finally thanks contributed alessandro gatti colby olsonlook forward sometime later may probably otherwise yell twitterwarning pretty loud
498,Lobsters,erlang,Erlang development,Minimal Downtime: In-flight Drone Firmware Upgrade,http://www.erlang-embedded.com/2013/10/minimal-downtime-in-flight-drone-firmware-upgrade-in-erlang/,minimal downtime inflight drone firmware upgrade,learn,whatsapp widely known erlang based messaging system significant project contributed support million active user billion message daily iconic example reliable scalable messaging solution offer level skill experience needed develop complex project similar scale learn
499,Lobsters,erlang,Erlang development,Some Thoughts on Go and Erlang,http://blog.erlware.org/2014/04/27/some-thoughts-on-go-and-erlang/,thought go erlang,,
500,Lobsters,erlang,Erlang development,Handling Clojure state the Erlang way,http://noobtuts.com/clojure/handling-clojure-state-the-erlang-way,handling clojure state erlang way,handling clojure state erlang way foreword ref atom var situation several thread simple state clojure pong game one thread erlang way erlang recursion function parameter n slightly complex example erlang receive end increment n clojure,handling clojure state erlang way foreword oldest question keep track value without defining globally changing time know clojure phenomenal way take care state ref atom var situation example let say want make game server keep track amount received packet obvious way would use atom def n atom defn thethread recvpacket received packet swap n inc increase counter recur infinite loop work fine forever thing like atom ref var unbelievably helpful come situation score accessed several thread simultaneously note helpful allow u use thing like transaction simple state however case like clojure pong game value state accessed one thread time quite common project course atom fine still thing define globally always avoided keep state headache far away possible erlang way let take look erlang see state taken care without going detail erlang process situation would handled erlang programmer defn thethread n n stored recvpacket received packet recur inc n infinite loop next time recur n infinite loop n word erlang process always use recursion function parameter store value several benefit approach one elegant code also fact nt define global variable anymore way anyone ever worry globally defined variable anyone ever accidentally change n live happily ever within function one ever see concept quite mind blowing seen first time around slightly complex example example still look bit obvious let look slightly complex example process store counter increment asked decrement asked respond value counter stop asked erlang let look erlang code first counter n receive increment counter n decrement counter n show n counter n stop exit normal end receive end clause mean wait message sent someone stuff surrounded curly bracket like increment mean message increment soon someone tell process increment counter continue recursively increased n plain beauty clojure thing clojure defn counter n case recvpacket increment recur inc n decrement recur dec n show sendpacket n recur n stop nil powerful beautiful time without state self contained process store thing thing asked note course one could argue kind state within function however still far le annoying global variable
501,Lobsters,erlang,Erlang development,"Elixir v0.13.0 released, hex.pm and ElixirConf announced",http://elixir-lang.org/blog/2014/04/21/elixir-v0-13-0-released/,elixir released hexpm elixirconf announced,hexpm elixirconf elixirconf summary getting started guide metaprogramming elixir stringio tag filter exunit changelog map module map chapter new getting started guide part part structs reading joe blog post matter structs chapter getting started guide protocol chapter map structs future record original map structs proposal still availble comprehension list comprehension protocol mix workflow hexpm hexpm next step catalyse change stream data functionality exposed otp getting started guide announcement elixirconf hexpm,hello folk elixir released contains change effectively shape developer write elixir code making important milestone towards post going cover change road elixir well announcement hexpm go change let briefly talk elixirconf elixirconf excited announce elixirconf first ever elixir conference happening july austin tx call proposal open waiting talk registration also open hope join u exciting event welcome elixir developer enthusiast looking forward part thrilling community summary nutshell new elixir run requires erlang erlang elixir also add support map keyvalue data structure support pattern matching explore map feature limitation post elixir also provides structs alternative elixir record structs flexible record provide faster polymorphic operation still provide compiletime guarantee many came love record getting started guide rewritten scratch previous guide comprised chapter become year old new guide feature chapter explores new map structs part release go deeper topic like io file handling also includes extra guide still development metaprogramming elixir elixir provides new comprehension syntax work list enumerable output comprehension also extensible via collectable protocol mix elixir build tool improved order provide better workflow compiling project working dependency many change like addition stringio support tag filter exunit please check changelog complete list even improvement elixir backwards compatible elixir upgrading clean process map map keyvalue data structure iex map hello world hello world iex map hello world iex map nil map explicit ordering key value term map pattern matched iex hello world map hello world iex world world iex map hello world iex value map matcherror match right hand side value map pattern match map key specified pattern value matching key must also match example hello world match map key hello assign value world hello world match map key hello value equal world empty map pattern match map developer use function map module work map information map compare associative data structure language please check map chapter new getting started guide elixir sip also released two episode cover map part part map also provide special syntax creating accessing updating map atom key iex user name john age name john age iex username john iex user user name meg name meg age iex username meg access update syntax expect given key exist trying access update key exist raise error iex user address argumenterror argument error mapsupdate address see functionality becomes useful working structs structs structs meant replace elixir record record elixir simply tuples supported module store record metadata defrecord user name nil age internally record represented following tuple tag name age user nil record also created pattern matched iex user user name john user name john age iex username john iex user name name user user name john age iex name john pattern matching work record metadata stored user module accessed building pattern however record came issue first since record made data underlying tuple module functionsbehaviour frequently misused attempt bundle data behaviour together elixir example defrecord user name nil age def firstname self selfname stringsplit enumat end end user name john doe firstname john record often slow protocol dispatch every tuple potentially record sometimes leading expensive check runtime since map meant replace many case record erlang saw introduction map perfect opportunity revisit elixir record well order understand reasoning behind structs let list feature got elixir record way organize data field efficient inmemory representation operation compiletime structure compiletime error basic foundation polymorphism elixir map naturally solve issue particular map key share keyspace memory update operation map seen relevant know updating existing key new map created result update operation share key space old map without extra check detail map efficient would recommend reading joe blog post matter structs added address feature struct need explicitly defined via defstruct defmodule user defstruct name nil age end user struct created without need explicitly list necessary field iex user user name john user name john age trying create struct unknown key raise error compilation iex user user address compileerror unknown key address struct user furthermore every struct struct field contains struct name iex userstruct user struct field also used polymorphic dispatch protocol addressing issue interesting note structs solve drawback earlier mentioned regarding record structs purely data polymorphic dispatch faster robust happens explicitly tagged structs information structs check structs chapter getting started guide may also want read new protocol chapter map structs future introduction map structs deprecation arrive upcoming release first listdict data structure deprecated phased record also deprecated language although going longer process many project elixir still use record diverse occasion note though elixir record deprecated erlang record basically syntax sugar around tuples remain language rare case elixir developer need interact erlang library provide record particular record updated provide new record api keeping old one backwards compatibility finally structs still active development new feature like derive land upcoming elixir release interested original map structs proposal still availble comprehension erlang also introduced recursion anonymous function feature still available elixir allows elixir provide flexible extensible comprehension syntax common use case comprehension list comprehension example get square value element list follows iex n n n say n part comprehension generator previous elixir version elixir supported list generator elixir enumerable supported range map etc iex n n n previous elixir version also support bitstring generator example receive stream rgb pixel binary break triplet iex pixel iex r g b pixel r g b default comprehension return list result however result comprehension inserted different data structure passing option example use bitstring generator option easily remove space string iex c hello world c c helloworld set map dictionary also given option general accepts structure long implement collectable protocol example io module provides stream enumerable collectable implement echo terminal return whatever typed shell upcase using comprehension iex stream iostream stdio line iex line stream stream stringupcase line n end make comprehension useful working inmemory collection also file io device source future release continue exploring make comprehension expressive following footstep functional programming research topic like comprehensive comprehension parallel comprehension mix workflow last big change want discus release improvement done mix elixir build tool mix essential tool elixir developer help developer compile project manage dependency run test previous release mix used download compile dependency per environment meant usual workflow le ideal every time dependency updated developer explicitly fetch compile dependency environment workflow would something like mix depsget mix compile mixenvtest mix depsget mix test elixir mix depsget fetch dependency accross environment unless flag specified support new behaviour dependency support option def deps ecto github elixirlangecto hackney github benoitchackney test end dependency also automatically compiled run command example mix compile automatically compile pending dependency current environment mix test test dependency interrupting le developer workflow hexpm release also mark announcement hexpm package manager erlang vm hex allows package publish project fetching performing dependency resolution application currently hex integrates mix contribution extend tool language erlang vm welcome next step seen announcement release dictate many development happen elixir community following week project recommended start moving record structs paving way deprecation record next month also focus integrating elixir tightly otp keynote erlang factory catalyse change dave thomas argued many useful pattern reimplemented everyday developer could make development productive within erlang vm exposed accordingly said next month plan integrate application configuration provided otp right mix provide elixir logger know print format elixir exception stacktraces properly expose functionality provided application supervisor genservers genevents study integrate elixir example consume event genevent stream data study pattern like task agent integrated language often picking lesson learned library like functionality exposed otp rewrite mix exunit guide focus application otp whole rebranding building apps mix otp learn elixir getting started guide download release announcement hope see elixirconf well pushing package hexpm
502,Lobsters,erlang,Erlang development,Erlang/OTP 17.0 released,http://erlang.org/pipermail/erlang-questions/2014-April/078563.html,erlangotp released,,
503,Lobsters,erlang,Erlang development,ErLLVM: An LLVM backend for HiPE (Erlang),http://erllvm.softlab.ntua.gr/,erllvm llvm backend hipe erlang,hipe compiler llvm compiler infastructure erlangotp system requirement hello world erllvm sandbox ikiwiki,erllvm project aiming providing multiple backends hipe compiler use llvm compiler infastructure moment erllvm support support currently unstable due architectural change hopefully fixed soon also ongoing work arm erllvm soon available experimentally part version erlangotp merged master branch april system requirement hello world erllvm write erlang module module test export hello name io format hello w n name fire erlang shell yiannis mosby gitotp erl erlangotp hipe kernelpoll false eshell abort g compile module native code using llvm backend c test native hipe tollvm ok test alternatively first generate beam bytecode compile native code load using c test hipe c test tollvm ok test work test hello world hello world ok wikis supposed sandbox one wiki powered ikiwiki
505,Lobsters,erlang,Erlang development,"Elixir - Peeking into Processes, OTP & Supervisors",https://speakerdeck.com/benjamintan/elixir-peeking-into-processes-otp-and-supervisors,elixir peeking process otp supervisor,fewer faster,copyright fewer faster llc slide content description owned creator
506,Lobsters,erlang,Erlang development,Parsing the Kafka protocol with Erlang,https://coderwall.com/p/1lyfxg,parsing kafka protocol erlang,http cwikiapacheorgconfluencedisplaykafkaaguidetothekafkaprotocol aguidetothekafkaprotocolmetadataresponse note kafka http kafkaapacheorg kafka client wild http godocorggithubcomshopifysarama http githubcomrmenkeekafka read protocol broker let reverse engineering begin code recursive conclusion http ekafka http pattern matching ftw bhaskerkode,post took raw response kafka broker looked like patched erlang kafka client convert blob topic undefined topic undefined topic undefined reading kafka wire protocol documented response correlationid responsemessage correlationid responsemessage metadataresponse metadataresponse broker topicmetadata broker nodeid host port nodeid host string port topicmetadata topicerrorcode topicname partitionmetadata topicerrorcode partitionmetadata partitionerrorcode partitionid leader replica isr partitionerrorcode partitionid leader replica isr http cwikiapacheorgconfluencedisplaykafkaaguidetothekafkaprotocol aguidetothekafkaprotocolmetadataresponse note kafka firstly word kafka kafka infrastructure commit log rethink message queue distributed world http kafkaapacheorg recommend begin reading wire protocol message published consumed topic partition replication factor topic set creation producersconsumers match sense kafka force decision node hit client publish fetch data must sent broker currently acting leader given partition data queried broker directly producer zookeeper consumer client client maintain querying metadata broker although broker may leader topic metadata topic partition leadership broker queried get metadata client kafka client wild kafka client written go shopify http godocorggithubcomshopifysarama far best documentation featureset outside javascalainhouse linkedin client imho client still connect zookeeper auto discovery broker enabled usually case kafka host provided config since working erlang day reminder catch erlangfactory video noticed several existing erlang client still connecting zookeeper get metadata broker instead directly pinging broker understood friendly folk apachekafka paradigm since producer need connect zookeeper find partition write may choose client personally prefer querying broker metadata unfortunately find library closest implementation sending packet broker http githubcomrmenkeekafka encodes query metadata encodemetadatarequest correlationid clientid topic metadatarequest encodearray encodestring topic topic topic encoderequest metadatarequest correlationid clientid metadatarequest since decode functionality however implemented gave chance explore kafka wire protocol read protocol let revisit documentation kafka doc say metadata api response metadataresponse broker topicmetadata broker nodeid host port nodeid host string port topicmetadata topicerrorcode topicname partitionmetadata topicerrorcode partitionmetadata partitionerrorcode partitionid leader replica isr partitionerrorcode partitionid leader replica isr note self someday going come elegant way describe headerpayloadprotocol information structured machine readable format read one paperlink kafka make one wire protocol first link pleasure read said several assumption made difficult new client developer see eg size host say string another section however talk size took find broker inside square bracket meant integer conveying many broker would padded broker anyhow presented evening make sense following valid metadata response kafka broker let reverse engineering begin worked reverse engineering aimoscar packet ymsg chat packet mqtt packet others presented interesting challenge information knew default kafka port started created topic back doc knew would looking broker first first byte nt make sense read response correlationid responsemessage correlationid responsemessage metadataresponse correlationid analogous request id pas request meant needed skip bit byte note parse first byte erlang binary primative data type erlang remainingbytesbinary case first byte next byte could construct first two byte correlationid node realised kafka liked follow headerlen header pattern followed welldesigned protocol started looking pattern x pattern could well used signify length binary representation port number like map something like try erlang shell repetitive pattern could signify common hostnames able fill field question several denoted byte corid byte node byte port byte port byte port going back doc easy dissect broker half packet metadataresponse broker topicmetadata broker nodeid host port nodeid host string port mapped correlation id node len len len broker part protocol seemed wrapped least visually understood next part would trickier since nested structure multiple topic could multiple partition partition could multiple replica isr topicmetadata topicerrorcode topicname partitionmetadata topicerrorcode partitionmetadata partitionerrorcode partitionid leader replica isr partitionerrorcode partitionid leader replica isr match remaining binary blob looked something like next part took correctly dissect nested partition replica topic len name len name partition len error code leaderid replica len isr len error code leaderid replica len isr len name len name partition len error code leaderid replica len isr len error code leaderid replica len isr len name len name partition len partition error code leaderid replica len isr len code clear picture chunk size time write erlang kafka metadata parser decodemetadataresponse packet case packet restbinary broker topic decodetobrokersandtopics rest metadata correlationid correlationid broker broker topic topic metadata end decodetobrokersandtopics packet broker topicspacket decodetobrokers packet topic rest decodetotopics topicspacket broker topic rest decodetobrokers packet case packet restbinary decodetobrokers len rest else end decodetobrokers packet previous previous packet decodetobrokers counter packet previous next rest decodetobroker packet decodetobrokers rest nextprevious decodetobroker host hostlenbinary restbinary broker nodeid nodeid host host port port rest decodetobroker rest broker rest decodetotopics packet case packet restbinary decodetotopics len rest e end decodetotopics packet previous previous packet decodetotopics counter packet previous next rest decodetotopic packet decodetotopics rest nextprevious decodetotopic name namelenbinary partitionsbinarybinary partition rest decodetopartitions partitionsbinary topic name name partition partition rest decodetotopic rest topic rest decodetopartitions packet case packet restbinary decodetopartitions len rest end decodetopartitions packet previous previous packet decodetopartitions counter packet previous next rest decodetopartition packet decodetopartitions rest nextprevious decodetopartition replicasbinarybinary replica isrs rest decodetoreplicasandisrs replicasbinary partition id id errorcode errorcode leader leader replica replica isrs isrs rest decodetopartition rest partition rest decodetoreplicasandisrs packet replica isrspacket decodetoreplicas packet isrs rest decodetoisrs isrspacket replica isrs rest decodetoreplicas packet case packet restbinary decodetoreplicas len rest end decodetoreplicas packet previous previous packet decodetoreplicas counter packet previous next rest decodetoreplica packet decodetoreplicas rest nextprevious decodetoreplica restbinary replica id id rest decodetoreplica rest replica rest decodetoisrs packet case packet restbinary decodetoisrs len rest end decodetoisrs packet previous previous packet decodetoisrs counter packet previous next rest decodetoisr packet decodetoisrs rest nextprevious decodetoisr restbinary isr id id rest decodetoisr rest isr rest recursive syntax error aside passed packet decode function first time thing fell place beautifully functional recursive goodness pseudocode roughly follows decodetoreplicasandisrs packet know blob begin replica end isr data replica isrspacket decodetoreplicas packet isrspacket basically part packet beyond replica length specified replica header isrs rest decodetoisrs isrspacket rest case could another partition defined partition header replica isrs rest function used replica isrs rest decodetoreplicasandisrs replicasbinary partition id id errorcode errorcode leader leader replica replica isrs isrs several function look apart part actually patternmatches specific entity sake readability clear distinction record left fact similar simply prof code refactored conclusion round input metadataresponse ekafkaprotocol decodemetadataresponse metadataresponse resulting output topic undefined topic undefined topic undefined suggestion issue patch welcome repo http also sent pull request ekafka looking forward continue contributing http pattern matching ftw bosky bhaskerkode p hattip rmenke getting ekafka started milindparikh inspring erlangkafka work erlang always
507,Lobsters,erlang,Erlang development,Intro to Haskell for Erlangers,http://bob.ippoli.to/haskell-for-erlangers-2014/,intro haskell erlangers,intro haskell erlangers bob ippolito erlang factory sf march exercismio mission bit learn haskell starting haskell appeal haskell haskell early history evolution domain general purpose consumer apps silk chordify bump mailrank bazqux commercial service janrain spaceport scrive openbrain skedgeme compiler ghc ajhc haste ghcjs agda idris elm fay pug standalone apps pandoc darcs xmonad gitit gitannex implicitcad haskell platform haskell battery included haskell syntax relative erlang list map list typed map typed list foldr sum type sum type product type product type product type record product type record abstract data type abstract data type using type pattern matching pattern matching pattern matching pattern matching infix prefix infix prefix function lambda function lambda function lambda function lambda function lambda function lambda function lambda function lambda guard guard guard builtin type list tuples list tuples typeclass syntax typeclass syntax typeclass syntax typeclass syntax typeclass syntax quickcheck quickcheck quickcheck syntax syntax io syntax syntax io syntax io syntax io syntax io syntax io syntax syntax syntax syntax syntax syntax syntax syntax syntax key feature show type information show typeclass info show value info show type info load module reload whatthe common combinators pure optimization ghc rule ghc rule ghc rule lazy call need nonstrict evaluation nonstrict evaluation nonstrict evaluation nonstrict evaluation nonstrict evaluation nonstrict evaluation nonstrict evaluation nonstrict evaluation type typeclasses abstraction monoid functor applicative monad foreign function interface haskell web framework snap yesod happstack scotty publishing doc haddock diagram hakyll pandoc parser combinators parsec attoparsec parallel distributed repa accelerate cloud haskell testing profiling quickcheck hunit hpc threadscope criterion ekg,intro haskell erlangers bob ippolito etrepum erlang factory sf march classically trained c erlang user since mochi medium mochiweb etc haskell user since ported exercismio curriculum currently teaching web technology teenager mission bit bit advisinginvesting startup learn haskell learn lot studying new language type supposed help write better software like quickcheck dialyzer good support parallelism concurrency help understand c paper ram footprint per unit concurrency approx haskell threadid mvar ghc kb erlang process kb go goroutine kb c pthread minimum mac o x kb java thread stack minimum kb c pthread default mac o x kb java thread stack default starting intimidated haskell year took class facebook read several book deliberate practice haskell appeal abstraction often used without penalty efficient parallel concurrent programming type system make maintenance easier nice syntax heavy lightweight fantastic community ecosystem haskell haskell b curry early history dozen nonstrict fp language use fcpa meeting peyton jones hudak et al formed fplang committee wanted base language miranda turner declined chose name haskell hudak wadler chosen editor report april haskell report published page ifip working group john hughes quickcheck philip wadler subtyping erlang evolution glasgow haskell compiler ghc haskell monadic io seq strictness annotation haskell commitment stability revised haskell page haskell page domain general purpose effective parsing compilation great dsel domain specific embedded language popular academia time becoming popular industry consumer apps silk platform sharing collection anything chordify chord transcription mass bump google sep send file video everything mobile web mailrank facebook nov email inbox prioritization shuttered postacquisition bazqux r reader show comment post commercial service janrain user management platform spaceport facebook aug mobile game framework using actionscript scrive esigning service nordic market openbrain computing platform scientific business analytics skedgeme enterprise appointment scheduling compiler haskell ghc ajhc haste ghcjs dependently typed agda also interactive proof assistant idris general purpose compile javascript elm functional reactive browser fay haskell subset imperative pug first perl implementation standalone apps pandoc markup swissarmy knife used make slide darcs distributed revision control system like git mercurial xmonad tiling window manager rock gitit wiki backed git darcs mercurial gitannex manage large file git similar dropbox implicitcad programmatic solid cad modeler haskell platform haskell battery included haskell syntax type defines type typeclasses constructor record accessors become value value named binding instance constructor function control flow relative erlang syntax minimal familiar haskell pattern matching clever erlang type kinda like dialyzer every compile although dialyzer really quite different typeclasses nice erlang nt erlang probably much better longrunning system list map f ht f h map f map f isfunction f map map map f x x f x map f x list typed spec map fun fun fun b b term b term map f ht f h map f map f isfunction f map typed map b b map map f x x f x map f x list spec foldr fun list fun fun elem accin accout term term accin term accout term list term foldr f accu hdtail f hd foldr f accu tail foldr f accu isfunction f accu foldr foldr b b b b foldr k z go go z go y k go y sum type sum type possible value type choice definitely possibly noway sum type sum type possible value data choice definitely possibly noway product type product type possible value type choice choice choice product type product type possible value data choice choice choice choice tuple type alias type choice choice choice product type record record syntax record choice fstchoice choice sndchoice choice getters need implemented manually spec fstchoice choice choice fstchoice choice fstchoicesx x spec sndchoice choice choice sndchoice choice sndchoicesx x product type record record syntax defines accessors automatically data choice choice fstchoice choice sndchoice choice getters automatically defined fstchoice choice choice fstchoice choice fstchoice x x sndchoice choice choice sndchoice choice sndchoice x x abstract data type abstract data type list type con nil con con abstract data type abstract data type list data list nil con list type constructor data choice definitely possibly noway data choice choice choice choice mkchoices choice choice choice mkchoices b choice b fstchoice choice choice fstchoice choice type constructor data choice definitely possibly noway data choice choice choice choice mkchoices choice choice choice mkchoices b choice b fstchoice choice choice fstchoice choice using type value annotated inline int binding annotated success maybe constructor value product constructor function success x x constructor pattern matched wildcard case success true true pattern matching spec isjust nothing boolean isjust true isjust nothing false pattern matching isjust maybe bool isjust true isjust nothing false pattern matching erlang pattern matching allows nonlinear pattern spec isequal boolean term isequal true isequal false pattern matching haskell isequal bool isequal b undefined nt even possible constructor pattern matched type builtin equality infix prefix symbolic operator used function erlang module erlang b erlang nt userdefined infix operator infix prefix symbolic operator used prefix parenthesis b named function used infix backticks x elem x infixl infixr define associativity precedence lowest highest infixr append append b b function lambda spec add integer integer integer add x acc x acc spec sumfun integer integer sumfun x list foldl fun x spec sumlambda integer integer sumlambda x list foldl fun x acc x acc end x function lambda add integer integer integer add acc x acc x sumfun integer integer sumfun x foldl add x sumlambda integer integer sumlambda x foldl acc x acc x x function lambda haskell function one argument b c really b c f b really f b let leverage function lambda add integer integer integer add acc x acc x sumfun integer integer sumfun x foldl add x sumlambda integer integer sumlambda x foldl acc x acc x x function lambda add integer integer integer add acc x acc x sumfun integer integer sumfun foldl add sumlambda integer integer sumlambda foldl acc x acc x function lambda add integer integer integer add acc x acc x sumfun integer integer sumfun foldl add sumlambda integer integer sumlambda foldl acc x acc x function lambda add integer integer integer add acc acc sumfun integer integer sumfun foldl add sumlambda integer integer sumlambda foldl acc acc function lambda add integer integer integer add sumfun integer integer sumfun foldl add sumlambda integer integer sumlambda foldl guard spec isnegative number boolean isnegative x x true isnegative false guard isnegative num bool isnegative x x true otherwise false guard isnegative num bool isnegative x x true otherwise false absolutevalue num bool absolutevalue x isnegative x x otherwise x builtin type pronounced unit unit unit char somechar char somechar x instance num typeclass somedouble double somedouble instance fractional typeclass someratio rational someratio list tuples somelist someotherlist sometuple somestring foo list tuples type written prefix somelist someotherlist int somelist someotherlist dontwritethis b written prefix b sometuple someothertuple int char sometuple someothertuple char also known string also see overloadedstrings extension somestring string somestring foo typeclass syntax erlang nt typeclasses elixir protocol closer also typeclasses typeclass syntax class equal isequal bool instance equal choice isequal definitely definitely true isequal possibly possibly true isequal noway noway true isequal false instance equal equal isequal b b isequal b isequal b isequal b null null b typeclass syntax class eq bool instance eq choice definitely definitely true possibly possibly true noway noway true false typeclass syntax data choice definitely possibly noway deriving eq typeclass syntax data choice definitely possibly noway deriving eq ord enum bounded show read quickcheck propitsthere forall int queue tolist queue con queue new quickcheck import datasequence empty import datafoldable tolist propitsthere int bool propitsthere tolist empty quickcheck ghci λ import testquickcheck λ import datafoldable λ import datasequence λ quickcheck int tolist empty ok passed test syntax spec main string ok main args ok secret file readfile etcpasswd file writefile tmppasswd secret ok syntax io main io main secret readfile etcpasswd writefile tmppasswd secret return syntax desugars return desugars return return desugars return syntax io main io main secret readfile etcpasswd writefile tmppasswd secret return syntax io main io main readfile etcpasswd secret writefile tmppasswd secret return syntax io main io main readfile etcpasswd secret writefile tmppasswd secret return syntax io main io main readfile etcpasswd secret writefile tmppasswd secret syntax io main io main readfile etcpasswd writefile tmppasswd syntax spec flatmap fun b b term b term flatmap f x x x f x syntax flatmap b b flatmap f x x x f x syntax flatmap b b flatmap f x x x f x return syntax flatmap b b flatmap f x x x f x syntax flatmap b b flatmap f x x x f x syntax flatmap b b flatmap f x x f syntax flatmap b b flatmap f x flip f x syntax flatmap b b flatmap flip syntax flatmap b b flatmap key feature interactive pure nonstrict lazy evaluation type typeclasses abstraction multiparadigm runhaskell help usage runghc runghc flag ghc flag module program args runghc flag f pathtoghc tell runghc ghc help print usage information version print version number ghci ghci version http wwwhaskellorgghc help loading package ghcprim linking done loading package integergmp linking done loading package base linking done h show type information h map map b b h map map num b b b h monad b b show typeclass info h num class num negate ab signum frominteger integer defined ghcnum instance num integer defined ghcnum instance num int defined ghcnum instance num float defined ghcfloat instance num double defined ghcfloat show value info h info map map b b defined ghcbase h info class monad b b defined ghcbase infixl show type info h info int data int ghcprim ghctypesi ghcprim ghcprimint defined ghcprim ghctypes instance bounded int defined ghcenum instance enum int defined ghcenum instance eq int defined ghcclasses instance integral int defined ghcreal instance num int defined ghcnum instance ord int defined ghcclasses instance read int defined ghcread instance real int defined ghcreal instance show int defined ghcshow l load module r reload h echo hello print hello hellohs h l hello compiling main hellohs interpreted ok module loaded main h hello hello h echo hello print hello hellohs h r compiling main hellohs interpreted ok module loaded main h hello hello main io main input getcontents let wordcount length word input print wordcount main io main getcontents input let wordcount length word input print wordcount main io main getcontents print length word whatthe syntax sugar bind operator io still purely functional building graph action executing inplace starting main haskell runtime evaluate action work much like continuation passing style state variable current world state behind scene way cheat write code pure go way common combinators function composition b c b c f g x f g x function application lower precedence b b f x f x pure haskell purity implies referential transparency mean function invocation freely replaced return value without changing semantics fantastic optimization also enables equational reasoning make easier prove code correct ghc compilation phase parse rename typecheck desugar core optimize code gen llvm optimization common subexpression elimination inlining crossmodule specialize float float inwards demand analysis workerwrapper bind liberate case callpattern specialization specconstr ghc rule term rewriting engine rule pragma allows library defined optimization used great effect short cut fusion example map f map g x map f g x prevent building intermediate data structure commonly used list text bytestring etc great incentive write highlevel code library use rule bytestring specialise break x forall x break x breakbyte x bytestring specialise break x forall x break x breakbyte x ghc rule rule bytestring specialise break x forall x break x breakbyte x bytestring specialise break x forall x break x breakbyte x import bytestring break splitline bytestring bytestring bytestring splitline break n ghc rule rule bytestring specialise break x forall x break x breakbyte x bytestring specialise break x forall x break x breakbyte x import bytestring break splitline bytestring bytestring bytestring splitline breakbyte n lazy call need outside call value inside nonstrict evaluation separate equation execution need special form control flow value restriction enables infinite cyclic data structure skip unused computation better minimum bound lazy call need expression translated graph tree evaluated stg spineless tagless gmachine pattern matching force evaluation nonstrict evaluation infinite list print head map nonstrict evaluation infinite list print head map outside print x putstrln show x putstrln show head map nonstrict evaluation outside print x putstrln show x putstrln show head map head x x map f x x f x map f x desugar syntax putstrln show head map enumfrom nonstrict evaluation desugar syntax putstrln show head map enumfrom enumfrom n n enumfrom succ n putstrln show head map enumfrom succ nonstrict evaluation enumfrom n n enumfrom succ n putstrln show head map enumfrom succ apply map putstrln show head map enumfrom succ nonstrict evaluation apply map putstrln show head apply head putstrln show nonstrict evaluation apply head putstrln show show pattern match argument putstrln show nonstrict evaluation show pattern match argument putstrln show apply show putstrln bool cond b case cond true false b bool bool bool b case true b false false const b const x x fib integer fib zipwith fib tail fib cycle cycle x x cycle x iterate iterate f x x iterate f f x takewhile bool takewhile takewhile p x x p x x takewhile p x otherwise type enforce constraint compile time null parametric polymorphism andor recursion builtin type special syntax typeclasses ad hoc polymorphism overloading h let f x head true interactive could nt match expected type actual type bool first argument head namely true expression head true equation f f x head true h let f x head true interactive scope head perhaps meant one read imported prelude head imported prelude h let x x x infinite recursion fun case deal h case false true exception interactive nonexhaustive pattern case h head exception preludehead empty list h error throw exception exception throw exception h undefined exception preludeundefined polymorphic recursive data list con list nil deriving show data tree leaf branch tree tree deriving show listmap b list list b listmap nil nil listmap f con x x con f x listmap f x treetolist tree list treetolist root go root nil note go return function go leaf x con x go branch l r go l go r typeclasses used many prelude operator numeric literal ad hoc polymorphism overloading many builtin typeclasses automatically derived eq ord enum bounded show read module list data list con list nil instance eq eq list con con b b b b nil nil true false instance functor list fmap nil nil fmap f con x x con f x fmap f x language derivefunctor module list data list con list nil deriving eq functor import datalist sort newtype undown deriving eq instance ord ord compare b case compare b lt gt eq eq gt lt reversesort ord reversesort map undown sort map abstraction monoid identity associative operation functor anything mapped preserving structure applicative functor apply function inside monad applicative return structure monoid class monoid mempty mappend instance monoid mempty mappend infixr monoid mappend functor class functor f fmap b f f b instance functor fmap map instance functor maybe fmap f x f x fmap nothing nothing infixl functor f b f f b fmap applicative class functor f applicative f pure f infixl f b f f b instance applicative pure x x f x concatmap f map f x f instance applicative maybe pure f x f x nothing monad class monad return b b b b mb mb instance monad return pure f concatmap f instance monad maybe return pure x f f x nothing nothing language overloadedstrings module sjson import prelude hiding concat import datatext text concat import dataattoparsectext import controlapplicative data json jarray json jobject text json jtext text deriving show pjson parser json pjson choice ptext pobject parray pstring concat many pstringchunk pstringchunk choice pure elem ptext jtext pstring ppair pstring pjson pobject jobject ppair sepby parray jarray pjson sepby foreign function interface language foreignfunctioninterface import foreignctypes import controlmonad foreign import ccall unsafe stdlibh rand crand io cuint main io main replicatem crand print flipimagehs import systemenvironment import dataword import dataarrayrepa hiding import dataarrayrepaiodevil import dataarrayrepareprforeignptr main io main f getargs rgb v runil readimage f rotated computep v io array f runil writeimage flip f rgb rotated source r e array r e array e g backpermute e flop g e z x extent g flop z j k z x j k import controlconcurrent import networkhttp gethttp string io string gethttp url simplehttp getrequest url getresponsebody url string url map http ifconfigme ip host startrequest string io mvar startrequest url v newemptymvar forkio gethttp url putstr putmvar v return v main io main mvars mapm startrequest url mapm takemvar mvars haskell lot new terminology mutable state take effort laziness change need reason code get used nt problematic monad monoid category endofunctors problem terminology category theory intimidating first return probably nt mean think mean sum num sum sum x x x sum x sum num sum go go acc x x go acc x go x go acc acc sum num sum go go acc seq acc false undefined go acc x x go acc x go x go acc acc language bangpatterns sum num sum go go acc x x go acc x go x go acc acc web framework snap http template extensible snaplets yesod full stack us template haskell happstack full stack rely template haskell happstacklite scotty like ruby sinatra great simple rest apps publishing doc haddock standard library documentation tool haskell project diagram dsl vector graphic hakyll static site generator pandoc markup format swissarmy knife markdown latex epub parser combinators parsec industrial strength monadic parser combinator library haskell attoparsec like parsec make tradeoff performance parallel distributed repa high performance regular multidimensional array multicore accelerate like repa utilize cuda run gpus cloud haskell erlanglike concurrency distribution haskell testing profiling quickcheck property based testing hunit standard unit testing framework hpc haskell program coverage threadscope visualize multicore utilization criterion gold standard performance benchmarking ekg embeds webserver live monitoring metric
508,Lobsters,erlang,Erlang development,The WhatsApp Architecture Facebook Bought For $19 Billion,http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html,whatsapp architecture facebook bought billion,center engagement purpose built apps investment sequoia capital used deal focus messaging privacy facebook chat optimization dark grungy work suitable troll engineer get data need write tool patch tool add knob measure remove bottleneck test repeat erlang rock crack virality code profit value employee count officially divorced something brutal focus user idea limit cause simplicity ok age thing start simply customize keep server count low purposely overprovision hardware growth stall charge money inspiration come strangest place hacker news whatsapp actually worth say facebook zuckerberg internetorg sealed deal,rick reed upcoming talk march titled billion b scaling next level whatsapp reveals eye popping whatsapp stats hundred node thousand core hundred terabyte ram hope serve billion smartphones soon reality around globe erlangfreebsdbased server infrastructure whatsapp faced many challenge meeting evergrowing demand messaging service continue push envelope size core speed erlang message per second serving system since talk yet let take look talk rick reed gave two year ago whatsapp scaling million simultaneous connection built high performance messaging bus c yahoo rick reed new world high scalability architecture founder also exyahoo guy little experience scaling system whatsapp come scaling prowess honestly since big hairy audacious goal every smartphone world could many billion phone year need make experience get fact let digress moment absolutely fascinating conundrum whatsapp possibly worth billion facebook programmer ask whatsapp worth much answer expletive sending stuff network get real also guy thought need blogging platform hard remote login server edit indexhtml file vi write post html taken quite realize code stupid getting user love use product hard part buy love make whatsapp valuable technology ignore people say could write whatsapp week php simply true see pretty cool technology certainly facebook sufficient chop build whatsapp wished let look feature know whatsapp gimmick ad gimmick game product loyal user across world offer free texting cruel world sm charge abusive sheltered american surprised see many real people use whatsapp really stay touch family friend get whatsapp likely people know already since everyone phone mitigates empty social network problem aggressively cross platform everyone know use work work phrase often used full featured shared location video audio picture pushtotalk voicemessages photo read receipt groupchats send message via wifi done regardless whether recipient online handle display native language well using cell number identity contact list social graph diabolically simple email verification username password credit card number required work impressive worth billion product compete feature google wanted possible reason threat cent user facebook desperate phone book metadata even though whatsapp keep none million active user user based growing one million user day potential billion user facebook need whatapp next billion user certainly must part cost user seem unreasonable especially bulk paid stock facebook acquired instagram per user twitter user worth benedict evans make great case mobile trillion dollar business whatsapp disrupting sm part industry globally billion revenue sending billion sm message day global sm system sends billion sm message day fundamental change transition pc nearly universal smartphone adoption size opportunity much larger addressable market facebook normally play facebook promised ad interference win interesting development business use mobile whatsapp used create group conversation project team venture capitalist carry deal flow conversation whatsapp instagram used kuwait sell sheep wechat whatsapp competitor launched taxicab hailing service january first month million cab hailed future ecommerce looking like funneled mobile messaging apps must ecommerce play business using whatsapp application desktop web police officer spain use whatsapp catch criminal people italy use organize basketball game commerce application jumping mobile obvious reason everyone mobile messaging application powerful free cheap use longer need desktop web application get thing done lot functionality overlayed messaging app messaging threat google facebook desktop dead web dying messaging mobile entire ecosystem sidestep channel messaging become center engagement mobile search changing thing found nature application win future prepagerank preweb facebook need get market become irrelevant move mobile seeing deportalization facebook desktop web interface facebook portal style interface providing access feature made available backend big complicated creaky really love facebook ui facebook moved mobile tried portal approach work going strategy smaller focussed purpose built apps mobile first much small screen mobile easier go find special app find menu buried deep within complicated portal style application facebook going one step creating purpose built apps providing multiple competing apps provide similar functionality apps may even share backend infrastructure see messenger whatsapp instagram facebook photo app paper alternate interface facebook provides limited functionality well conway law may operating idea organization design system constrained produce design copy communication structure organization monolithic backend infrastructure get borglike portal design move mobile free organization way thinking apps built provide view slice facebook infrastructure apps built use facebook infrastructure nt need facebook infrastructure free built facebook exactly facebook facebook ceo mark zuckerberg take saying keynote presentation mobile world congress facebook acquisition whatsapp closely related internetorg vision idea develop group basic internet service would free charge use internet could social networking service like facebook messaging service maybe search thing like weather providing bundle free charge user work like gateway drug sort user may able afford data service phone day see point would pay data service would give context important lead paying service like hope go long play game huge reservoir valuable stock allows play reached conclusion think stunning dollar amount tenuous apparent immediate reward long term play explanation actually make sense still early day mobile nobody know future look like pay try force future look like past facebook seems enough support million active user engineer let find source warning know lot whatsapp architecture bit piece gathered various source rick reed main talk optimization process used get million connection server using erlang interesting complete architecture talk stats stats generally current system system talk talk current system include hack data storage messaging metaclustering beamotp patch million active user reached number faster company history engineer one developer support million active user billion message every day across seven platform inbound outbound million people sign every day invested advertising million investment sequoia capital billion amount sequoia make much facebook cash used deal hundred node core hundred terabyte ram erlang message per second whatsapp achieved million established tcp session single machine memory cpu spare pushed million tcp connection whatsapp tweeted dec new record day msg inbound msg outbound billion total message processed one day happy platform backend frontend seven client platform iphone android blackberry nokia symbian nokia window phone sqlite hardware product focus messaging connecting people world regardless world without pay lot money founder jan koum remembers difficult connect family world privacy shaped jan koum experience growing ukraine nothing private message stored server chat history stored goal know little user possible name gender known chat history phone general whatsapp server almost completely implemented erlang server system backend message routing done erlang great achievement number active user managed really small server footprint team consensus largely erlang interesting note facebook chat written erlang went away hard find qualified programmer whatsapp server started ejabberd ejabberd famous open source jabber server written erlang originally chosen open great review developer ease start promise erlang long term suitability large communication system next year spent rewriting modifying quite part ejabberd including switching xmpp internally developed protocol restructuring code base redesigning core component making lot important modification erlang vm optimize server performance handle billion message day focus making reliable system work monetization something look later far far road primary gauge system health message queue length message queue length process node constantly monitored alert sent accumulate backlog beyond preset threshold one process fall behind alerted give pointer next bottleneck attack multimedia message sent uploading image audio video sent http server sending link content along encoded thumbnail applicable code usually pushed every day often multiple time day though general peak traffic time avoided erlang help aggressive getting fix feature production hotloading mean update pushed without restarts traffic shifting mistake usually undone quickly hotloading system tend much looselycoupled make easy roll change incrementally protocol used whatsapp app ssl socket whatsapp server pool message queued server client reconnects retrieve message successful retrieval message sent back whatsapp server forward status back original sender see checkmark icon next message message wiped server memory soon client accepted message registration process work internally whatsapp whatsapp used create usernamepassword based phone imei number changed recently whatsapp us general request app send unique digit pin whatsapp send sm indicated phone number mean whatsapp client longer need run phone based pin number app request unique key whatsapp key used password future call permanent key stored device also mean registering new device invalidate key old device google push service used android user android android enjoyable work developer able prototype feature push hundred million user overnight issue fixed quickly io much quest million connection per server experienced lot user growth good problem also mean spend money buying hardware increased operational complexity managing machine need plan bump traffic example soccer game earthquake spain mexico happen near peak traffic load need enough spare capacity handle peak bump recent soccer match generated spike outbound message rate right daily peak initial server loading simultaneous connection per server extrapolated would mean lot server hoped growth pattern server brittle face burst load network glitch problem would occur needed decouple component thing brittle high capacity goal million connection per server ambitious goal given time running connection running server headroom allow world event hardware failure type glitch would require enough resilience handle high usage level failure tool technique used increase scalability wrote system activity reporter tool wsar record system stats across system including o stats hardware stats beam stats build easy plugin metric system like virtual memory track cpu utilization overall utilization user time system time interrupt time context switch system call trap packet sentreceived total count message queue across process busy port event traffic rate byte inout scheduling stats garbage collection stats word collected etc initially ran minute system driven harder one second polling resolution required event happened space minute invisible really fine grained stats see everything performing hardware performance counter cpu pmcstat dtrace kernel lockcounting fprof dtrace mostly debugging performance patched beam freebsd include cpu time stamp wrote script create aggregated view across process see routine spending time biggest win compiling emulator lock counting turned issue earlier saw time spent garbage collection routine brought saw issue networking stack tuned away issue lock contention emulator show strongly output lock counting measurement result started simultaneous connection per server first bottleneck showed system ran lot contention work stopped instrumented scheduler measure much useful work done sleeping spinning load started hit sleeping lock cpu used across system scheduler utilization first round fix got million connection vm usage cpu beam emulator running utilization match closely user percentage good emulator run user ordinarily cpu utilization good measure busy system scheduler us cpu month later tackling bottleneck million connection per server achieved beam utilization close freebsd might start paging cpu double connection scheduler hitting contention running pretty well seemed like good place stop started profiling erlang code peaked connection per server tried million connection failed see long message queue system trouble either single message queue sum message queue added beam instrumentation message queue stats per process many message sentreceived fast sampling every second could see process message message queue dequeue rate delay second projected drain time second finding erlang beam fix awesome smp scalability nearly linear scalability remarkable box run system cpu utilization keeping running production load run like day testament erlang program model longer server accumulate long running connection mostly idle handle connection connection busy per connection contention biggest issue fix erlang code reduce beam contention issue patched beam partitioning workload work cross processor lot timeofday lock every time message delivered port look update timeofday single lock across scheduler mean cpu hitting one lock optimized use timer wheel removed bif timer check io time table grows arithmetically created vm thrashing hash table would reallocated various point improved use geometric allocation table added write file take port already open reduce port contention mseg allocation single point contention across allocator make per scheduler lot port transaction accepting connection set option reduce expensive port interaction message queue backlog became large garbage collection would destabilize system pause gc queue shrunk avoiding common thing come price backported tse time counter freebsd cheaper read timer fast get time day le expensive going chip backported igp network driver freebsd issue multiple queue nics locking increase number file socket pmcstat showed lot time spent looking pcbs network stack bumped size hash table make lookup faster beam patch previously mentioned instrumentation patch instrument scheduler get utilization information statistic message queue number sleep send rate message count etc done erlang code procinfo million connection slow stats collection efficient gather run production stats kept different decay interval second interval allows seeing issue time make lock counting work larger async thread count added debug option debug lock counter tuning set scheduler wake threshold low scheduler would go sleep would never wake prefer mseg allocator malloc allocator per instance per scheduler configure carrier size start big get bigger cause freebsd use super page reduced tlb thrash rate improves throughput cpu run beam realtime priority thing like cron job interrupt schedule prevents glitch would cause backlog important user traffic patch dial spin count scheduler spin mnesia prefer o timestamp erlang using transaction remote replication ran backlog parallelized replication table increase throughput actually lot change made lesson optimization dark grungy work suitable troll engineer rick going change made get million connection server mind numbing notice immense amount work went writing tool running test backporting code adding gob instrumentation nearly every level stack tuning system looking trace mucking low level detail trying understand everything take remove bottleneck order increase performance scalability extreme level get data need write tool patch tool add knob ken relentless extending system get data needed constantly writing tool script data needed manage optimize system whatever take measure remove bottleneck test repeat erlang rock erlang continues prove capability versatile reliable highperformance platform though personally tuning patching required cast doubt claim crack virality code profit virality allusive quality whatsapp show figure man worth lot money value employee count officially divorced lot forcemultipliers world today advanced global telecom infrastructure make apps like whatsapp possible whatsapp make network phone etc would never happen powerful cheap hardware open source software availability course another multiplier right place right time right product front right buyer something brutal focus user idea whatsapp focussed simple messaging app gaming network advertising network disappearing photo network worked guided ad stance ability keep app simple adding feature overall brainer work philosohpy phone limit cause simplicity ok identity tied phone number change phone number identity gone uncomputer like make entire system much simpler design age thing age discrimination prevented whatsapp cofounder brian acton getting job twitter facebook shame shame shame start simply customize chat launched initially server side based ejabberd since completely rewritten initial step erlang direction experience scalability reliability operability erlang initial use case led broader broader use keep server count low constantly work keep server count low possible leaving enough headroom event create shortterm spike usage analyze optimize point diminishing return hit effort deploy hardware purposely overprovision hardware ensures user uninterrupted service festivity employee able enjoy holiday without spending whole time fixing overload issue growth stall charge money growth super fast whatsapp free downloads day early day switching paid declined day end year adding picture messaging settled charging onetime download fee later modified annual payment inspiration come strangest place experience forgetting username password skype account drove passion making app work related article hacker news keynote benedict evans incontext related slide whatsapp benedict evans whatsapp blog telling diary billion dollar startup nice timeline event andre bourque rick change erlang github whatsapp blog whatsapp inside story open source project used whatsapp whatsapp facebook erlang realtime messaging started ejabberd quora whatsapp work whatsapp work mobile network whatsapp grow big whatsapp broken really broken early security problem whatsapp ceo jan koum hate advertising tech rumor mill full dive video singapore progressively business whatsapp four number explain facebook acquired whatsapp announcement mark zuckerberg millionuser comet application mochiweb part inside erlang rare programming language behind whatsapp success whatsapp actually worth say facebook zuckerberg internetorg sealed deal facebook buy whatsapp billion value pricing perspective facebook billion craving explained mark zuckerberg imho lesson learned whatsapp may use whatsapp rest world sure whatsapp story challenge valley conventional wisdom whatsapp right according jan koum video facebook buy whatsapp someone explain whatsapp valuation google unusual offer whatsapp
509,Lobsters,erlang,Erlang development,Why You Should Learn Erlang,http://videlalvaro.github.io/2014/02/why-you-should-learn-erlang.html,learn erlang,learn erlang whatsapp acquisition facebook recruiter reason single assignment variable pattern matching actor model universal modular actor formalism artificial intelligence syntax book programming erlang software concurrent world otp design principle mnesia user guide erlang otp action conclusion,learn erlang february rage whatsapp acquisition facebook people going crazy erlang even recruiter using weapon lure engineer said write blogpost consider people learn erlang keep mind blog post program erlang fanboy attempt say erlang better language x please refrain language flamewars also think provide many code example since think matter particular kind discussion reason writing blog post question might need code erlang day job still anything could learn erlang make better programmer without much ado reason learn erlang single assignment variable first thing remarkable erlang variable vary erlang assign value variable changed come imperative programming world java php net python etc learning live lot program making assignment mutating variable time cool feature erlang actually prevents thing remember time track lifecycle one variable try debug production pm sharp request served variable become true instead false enjoy wasting time reproducing bug able track neither erlang becomes quite easy avoid problem simply change variable assigned value little little brain start learn live see algorithm implemented without mutable variable problem solved way start learn actually need many variable le one go back day day job start coding imperative language il start seeing perhaps variable change actually needed modifying object particular place make code hard reason encapsulation brag got completely destroyed passed object method method mutated object way happened well experience erlang train coder instinct detect place modifying object variable state dangerous best thing learnt single assignment variable please arguing algorithm implemented imperative language due performance reason implemented mutation saying coding erlang let easily detect part code might present problem later pattern matching pattern matching part erlang set apart language example erlang loop implement similar behaviour like f n f n f n n acc acc f count n acc f n f count acc first function definition f n usable interface function take four argument pas anonymous function f number n indicating many time want call function function would call like example f telling start counting stop counter reach second part recursive function two header two function definition would called depending value argument every time function called count variable increased second part function called see statement checking counter ever becomes first header function written like f n n acc execute body function argument function called first argument whatever passed second one example unless counter becomes point body function never called simplicity construct alone make learning program erlang valuable see feature real world example rabbitmq apart erlang pattern matching come destructuring another cool feature drive mad next time need access deeply nested data structure non erlang language learn use probably open online petition day day programing language get feature soon actor model whole concept million tiny process composing system working harmony reach solution sound cool enough start learning erlang already mode computation called actor model introduced carl hewitt famous paper universal modular actor formalism artificial intelligence concept process supervising others process automatically shut neighbor process died process isolated corrupt others state quite interesting reason dive erlang see learn way oop perhaps way erlang completely isolated object communicate others mean message passing learning actor model let improve way understand oop syntax lot complaining erlang syntax well yes come algol family language course weird grant want learn something new think erlang syntax remind hey think thing mean think mean time language come complete new paradigm like concurrent programming think rather different syntax also interesting book resource learning erlang learnt erlang book programming erlang software concurrent world book went directly guide official doc otp design principle learnt mnesia erlang database mnesia user guide book erlang otp action teach lot building reliable apps erlang project learn erlang tried create redis clone erlang never published project learnt lot finally got hooked rabbitmq time time would read source code learn erlang read adventure slide conclusion sum learn erlang make aware place code modifying state perhaps cleaner implementation need keep mind write pure function function always return value argument easier become prove code correct example writing unit test erlang notion pattern matching literally change way see code make wonder language choice support feature actor model give new perspective word encapsulation probably make think oop far putting namespaces around collection related function finally syntax help navigate moody water new concept reminding look like actually hope helpful making decide learn erlang want write tutorial erlang highlight salient feature make worth time learning new language like erlang sure new perspective programming benefit day day job long run
510,Lobsters,erlang,Erlang development,Scaling WhatsApp to Millions of Simultaneous Connections,http://www.erlang-factory.com/upload/presentations/558/efsf2012-whatsapp-scaling.pdf,scaling whatsapp million simultaneous connection,,äüöß obj stream 糴 endstream endobj obj endobj obj stream z u g qn v ŵ j p ta du b p c c h l z y qj ħ cpe n f tcu 裍 u z g l ʮ w x g x 횻 zg ard x x x mr f f nt j il b kl v g c rrj uf g k yu
511,Lobsters,erlang,Erlang development,Naive Parallel Prime Numbers Sieve,https://github.com/videlalvaro/erlang-prime-sieve,naive parallel prime number sieve,naive parallel prime number sieve chemical computing sieve method algorithm example new,naive parallel prime number sieve program calculates prime number using new method building sieve usage example sieve prime number run max primessieve start idea behind program number running erlang process know eliminate sieve erlang process cooperate creating sieve together arrive solution got inspired paper chemical computing tho necessarily claiming implementing yes know one probably nt using erlang anyway sieve method sieve method us following property prime n ca nt congruent modulo k k n specifically n k sqrt n k stand modulus operation n kj k divide j replacing n kj get kj k k k qed number pas test kept sieve returned collect called multiplying adding since professional mathematician wary method since far nt seen sieve produced using property number algorithm algorithm check n would candidate making n p stand prime number us algorithm notation introduced knuth taocp initialize set k re n lesser k k terminate n candidate k greater sqrt k sqrt terminate n candidate congruent re k re terminate n candidate recycle set k k re re go back another notation presented knuth taocp n number want test n k r return value n n candidate n f n n f n k r n n k n k r otherwise f n k r n k sqrt n k r otherwise f n k r n k r n k r otherwise f n k r n example write number scratch n satisfy n greater removed add getting add getting mean scratch n satisfy n n satisfy n remaining number multiplied adding result give prime number sequence call method new far nt seen various math book consulting new mean mathematical property outlined one process per number part claiming advanced number theory result anything like seen method please let know opening issue
512,Lobsters,erlang,Erlang development,Erlang library for creating and parsing JWT tokens,https://github.com/kato-im/ejwt,erlang library creating parsing jwt token,erlang jwt library format peter hizalev katoim smoke test example,erlang jwt library jwt simple authorization token format based json peter hizalev wrote library katoim opensourcing case someone else need create parse jwt token erlang smoke test example install git clone git githubcom katoimejwtgit cd ejwt rebar getdeps erl erlang shell create jwt token application start crypto key claim userid username bob expirationseconds token ejwt jwt claim expirationseconds key parse jwt token ejwt parsejwt token key get back original claim jterm plus expiration claim exp userid username bob
515,Lobsters,erlang,Erlang development,Erlang Binary Garbage Collection: A love/hate relationship,http://blog.bugsense.com/post/74179424069/erlang-binary-garbage-collection-a-love-hate,erlang binary garbage collection lovehate relationship,well known fact giant little background tampering beast wrk kvetch solution priestjim,well known fact erlang vm generational gc well trying garbage collect nonheap binary splunk building brand new technology standing shoulder giant course run weakness multiple time chronicle adventurea little backgrounderlang binary certain size byte precise get stored process heap space garbage collected along state variable tuples list etc larger one however get stored separate shared memory space called procbin pointer one stored manipulating process heap space instead large binary garbage collected erlang conventional way perprocess gc since accounted process memory usage reference counted different gc pattern collection interval turn intuitive even finetuned allow application selfdestruct handle sufficiently large number binary number memory size architecture large number binary data coming system cowboy web server instance packet kb size also touched different longlive dgenserver process way purposewhat observed even though point lifetime binary datum datum released process touched served request sent erlang node datum space still remain allocated memory returned o indefinite amount time indefinite explained erlang documentation memory pressure kicksin old generation gc occurs best blurry memory pressure really mean measured importantly memory pressure usually pertains process erlang vm whole large binary stored tampering beastto test speed effectiveness erlang binary gc used wrk simple lua script kb json eventjson file fill erlang application data via cowboy wrk command used iswhich testbed virtualized server gb memory swap fill internal data structure mb memory exactly secondsthe test procedure followed described start application serverfill gb data wrk scriptfetch data serially batch mb event previous operation leaf application server without meaningful binary data stored process staterun wrk script populate data structure againcrash time repeat step manual erlang garbagecollect pid pid erlang process step observed erlang garbage collect shared binary space actual memory pressure translates system memory full without significant competition system processeseven run full sweep clean entire unused binary data set start cleaning progressively reclaiming much space needed order operate correctly allocating outgoing buffer memory cowboy handler standard behaviour incremental generational gc system erlang reality always occur fast enough timely manner save vm crashing oom conditionssometimes misestimate remaining system memory fail adequately prioritize gc mechanism result much needed memory freed time whole vm crash oom condition erlang fanboys say logic may align erlang philosophy let crash believe concept apply erlang controlled environment process function port etc vm wholeforcing old generation sweep lower number minor sweep like even via spawnopt fullsweepafter genserver absolutely nothing since order run minor collection memory pressure occur thing happening process long lightweight enough term process state remember binary stored procbin process heap forcing garbage collection erlang garbagecollect whereis namedprocess job cleanup entire stale binary data set shared heap fast enough notice cpu usagesolution unfortunately elegant solution even official erlangotp documentation state heap grow likely garbage collection may cause binary hang around longer expected strategicallyplaced call erlang garbagecollect help could done implementing sort selfscrubbing otp design use genserver gen pattern like inelegant get better solution include measuring general binary memory usage process bound createmanipulatehandle large binary run selfscrubbing like sending gc signal offending process right handling large binary transactionhopefully situation improve workarounds implemented ensure proper application operationpanagiotis papadomitsos priestjim
516,Lobsters,erlang,Erlang development,What I Did on My Winter Vacation,http://www.c800colon5.com/blog/2014/01/19/what-i-did-on-my-winter-vacation/,winter vacation,webmachine,recently took position new company big deal since changed job couple time good chunk last job spent amassing institutional knowledge hoped maturing programmer always dubious latter new job exciting knew working new language good chance erlang virtually work experience functional language despite find fascinating spent hundred hour toying around various lisp mutant haskell language always seem vastly removed kind professional work done hacking small medium sized server written c c every language used tacit acknowledgment concurrent programming hopelessly fucked even though really need maybe think probably use unless insane even look forward undebuggable nightmare code may may actually one thing time anyway really understand erlang functional nature contributed ability found mindblowing hot code swapping concurrency ability think ever really bad thread cc idea concurrency mundane topic language kind exciting already obvious computer scientist ashamed interviewer elect grill theoryofcomputation stuff disappointed understand stuff find theoretical part computer science interesting encounter real world problem stop thinking erlang therefore perfect conundrum language let run reliable concurrent program need restarting deployed hey extensive networking library run switching equipment getting tiny digital erection problem lisp ability rival fouryearold terrible programming recursion barely able understand xmonad h file year hacking one thing certain life difficult predict able learn thing seem like hard found absolutely fucking possible namely ice skating time write post thing seemed nightmarishly difficult like driving stick shift learning corner motorcycle correctly turn pretty easy somebody tell think especially somebody pay hour week immersion repetition key believe effective way learn programming language volunteer opportunity get thrown working somebody else code language know trying find right spot slotin stuff tasked adding best situation existing code suck code becomes conversation partner talk fast use many vapid colloquialism anyway honest expectation going totally blow erlang way usually totally blow project euler problem people solve three byte haskell take many hundred line c go solve pictured becoming embittered struggling purist elitist functional bullshit stupid variable reassigned tearing hair thinking wish stupid template stl back fantasizing serially murdering mathematician rage shortcoming functionista turn worried course load annoying jackass bloviating abandon everything eat brown rice read latest blog entry actuality one program universe gigantic haskell monad released github like java came need publisher contrary doubt switch erlang exciting refreshing pattern seen growing frequency near compulsive use map filter growing disdain incomprehensible class megalith tuples would ordinary way stuff erlang instead trying figure make code look good spent mine time tearing problem little piece way figure structure program found wind writing code concise readable would work however think would impossible written program erlang scratch least one happy fortunate maintenance existing program good size quality greater complexity dorky todolist application book surprisingly little reading required excellent emacs erlangmode powerful tutor refusing indent thing got semicolon comma period right spot main thing like erlang though clearly industrial tool although writing factorial function replaced hello world functional programming book erlang language seen writing factorial socket server instead library reminds go heavy bitpushing stuff documentation look like something would come crate gray threering binder part number dizzying price thing may modern research project anyway point site offer whatever assurance via blogging plenty room world u nonhipster programmer worth think safe bestow seal approval erlang tool working like basho asskicking webmachine coming procedural background like fancy get mired bunch esoteric crap pas opportunity hack erlang
518,Lobsters,erlang,Erlang development,RWLocks in Erlang/OTP (2010),http://www.erlang-factory.com/upload/presentations/303/rickard-green-euc2010.pdf,rwlocks erlangotp,,äüöß obj stream wyr esu dk l vӣ endstream endobj obj endobj obj stream c dff qq l n r dlc v ybл 멽 c l c r f j e ʠ p x z l e w e zo b j ɣz qd vߤ qmب l f rv g q cf n q u z 専 l h ƚ rbft yrԫ ee қ h endstream endobj obj endobj obj stream endstream endobj obj endobj obj stream yоf daai ڮ p endstream endobj obj endobj obj stream l endstream endobj obj endobj obj stream k dx r u v n ĕf iί lm v endstream endobj obj endobj obj stream l endstream endobj obj endobj obj stream ri uh r e x endstream endobj obj endobj obj stream l endstream endobj obj endobj obj stream ɋ p ug ؠ h
520,Lobsters,erlang,Erlang development,3 part series on testing with quickcheck,http://erlcode.wordpress.com/tag/quickcheck/,part series testing quickcheck,eqc implementation module clockerl zenon zenhome zenon zenhome test module clockeqcerl zenon zenhome zenon zenhome next time like,continuation tdd quickcheck last time following method implemented tested clock library export missing implementation submin subhour always wise pick low hanging fruit first enter test propsubtracthoursfromtime forall h nat nat nat nat implies implies implies h implies h begin clock subhour h end needle say testcode trivial test fail precondition many time therefore wise crank amount time test run using eqc first argument integer amount test second argument property modified code becomes propsubtracthoursfromtime eqc numtests forall h nat nat nat nat implies h andalso h implies implies begin clock subhour h end invite run modified version slightly complicated function test found bug old implementation error produced running test zen qcmini zenon make test propsubtractminutesfromtime failed reason exit badarith clock clockeqc eqc eqc eqcgen eqcgen eqcgen eqc test reason produced float value float value work div needed either round return value make return rounded value clock library intended work natural number best make function return rounded whole value changing function require changing test kind point test first place changing implementation alert programmer behaviour changed test look like propsubtractminutesfromtime forall h nat nat nat nat implies h implies implies implies h begin h clock subminute clock clock end test continues fail zen qcmini zenon make test propsubtractminutesfromtime failed test shrinking time time due fact model quickcheck test round right hand side rh calculate lh without rounding clearly use test solution go smallest possible unit second clock subminute clock clock voila zen qcmini zenon make test propsubtractminutesfromtime x xxx x x x xx x xxx ok passed test course made proper change test order keep function returning whole integer value using round left exercise left write test function add function allow u add two time value together wrapping added value bound time well due intended cyclic behaviour make adjustment function first making sure everything working within bound hour system minor modification mean adding rem function changing test first test propaddtime forall h nat nat nat nat nat nat implies h implies implies implies implies implies begin h hres mres sres clock add hres andalso mres andalso sres andalso hres mres sres clock clock clock end proof implementation add h sp sp rem sp div mp mp rem h mp div rem working zen qcmini zenon make test propaddtime x xxxx xxxxxxxxxxxxxx ok passed test great last api function left somewhat similar test first propsubtime forall h nat nat nat nat nat nat implies h implies implies implies implies implies implies h begin h hres mres sres clock sub hres andalso mres andalso sres andalso hres mres sres clock clock clock end fret ugly next post topic show fix good way sub h sres rem mres div hres h div case sres mres mres false false false hres sres true true hres mres sres true false hres mres sres hres mres sres end voila running test like run make pas zen qcmini zenon make test propsubtime x xx xxxx xxxxx xx x x xxxxxx x xxx x xxxxxxx xx xxxxx xxxx xxx xxxxxxxxxx xx xx xxxxxxxxx xxxxxxxxxx xxx xxxxxxxxxxxxxxxxxxxxxxxxxxx removed line ok passed test end story clock lib working time value follows full code next time start refactoring tidying clock lib also testfile write generator make clockeqcerl look better implementation module clockerl author gianfranco zenon zenhome copyright c gianfranco created nov gianfranco zenon zenhome module clock export type nat nonneginteger type time nat nat nat spec time nat h h spec time nat h h div spec time nat h h div div spec nat time div div rem div rem rem spec nat time div rem rem spec nat time h h rem spec subsec time nat time subsec h sres rem mres div hres h div case sres mres mres false false false hres sres true true hres mres sres true false hres mres sres hres mres sres end spec subhour time nat time subhour h spec subminute time nat time subminute h case true false h end spec add time time time add h sp sp rem sp div mp mp rem h mp div rem spec sub time time time sub h sres rem mres div hres h div case sres mres mres false false false hres sres true true hres mres sres true false hres mres sres hres mres sres end test module clockeqcerl author gianfranco zenon zenhome copyright c gianfranco created nov gianfranco zenon zenhome module clockeqc includelib eqcincludeeqchrl compile exportall proptimetoseconds forall h nat nat nat implies h implies implies clock h h proptimetominutes forall h nat nat nat implies h implies implies clock h h m div proptimetohours forall h nat nat nat implies h implies implies clock h h div div propsecondstotime forall nat begin rem div rem h div div rem clock h end propminutestotime forall nat begin h div rem rem clock h end prophourstotime forall h nat clock h h rem propsubtractsecondsfromtime forall h nat nat nat nat implies implies implies h implies h begin h clock subsec clock clock end propsubtracthoursfromtime eqc numtests forall h nat nat nat nat implies h andalso h implies implies begin clock subhour h end propsubtractminutesfromtime forall h nat nat nat nat implies h implies implies implies h begin h clock subminute clock clock end propaddtime forall h nat nat nat nat nat nat implies h implies implies implies implies implies begin h hres mres sres clock add hres andalso mres andalso sres andalso hres mres sres clock clock clock end propsubtime eqc numtests forall h nat nat nat nat nat nat implies h implies implies implies implies implies implies h begin h hres mres sres clock sub hres andalso mres andalso sres andalso hres mres sres clock clock clock end next time cleaning refactoring module generator case extra material quickcheck cheer g like like loading
521,Lobsters,erlang,Erlang development,Erlang implementation of Raft consensus protocol,https://github.com/andrewjstone/rafter,erlang implementation raft consensus protocol,warning introduction raft consensus protocol libpaxosdll distributed consensus replicated log correct compaction development environment quick start clone build launch node raftererl set initial configuration cluster write operation read operation show current state log peer running test erlang quickcheck todo license http,warning rafter production ready nt tested run production environment furthermore log entirely creation possible nt safe efficient many log structured backends like leveldb rocksdb protocol solid well tested work expected case however support fully guaranteed nt current use case rafter actively developing however best respond report fix bug efficient manner introduction rafter erlang implementation raft consensus protocol aim take pain away building consistent cp distributed system well act library leader election routing main goal keep small user api automatically handle problem everyday erlang distributed system developer hopefully libpaxosdll erlang rafter meant used library application already created erlang cluster node rafter peer uniquely identified atom local setup name node tuples using distributed erlang configuration dynamic reconfiguration achieved without taking system distributed consensus replicated log use case implementing distributed database replicated log used internally provide strong consistency operation serialized written log file order node operation committed node applied state machine backend case distributed database operation would probably create update item database leader return success client operation safely replicated clear applying type deterministic operation order produce output time hence one machine crash others still accessed without data loss serialized operation continue long majority node communicate majority node agree system reject request read writes mathematical term cluster node handle f failure common cluster size node handle failure still work handle two failure important note operation logged executed state machine allowed fail arbitrarily without bringing peer exhibit nondeterministic behavior executed state machine allowed would way guarantee replica state state machine transformation could tell replica correct data word state machine operation pure function state machine must deterministic replay inorder operation node must result exact output state else use safety property given replicated log note lastly operation base output state current time day inherently nondeterministic distributed system allowed state machine additional benefit deterministic state machine allows snapshotting current state disk truncating already applied operation log state machine output successfully snapshotted known compaction provides output durability state machine allows faster restarts failed node since entire log longer need replayed read compaction development environment quick start rafter currently development quite ready production use however easy get started playing rafter local machine following describe easiest way get development cluster node running note must version erlang order rafter work since consensus really important across node previous description running single node removed furthermore implementation detail ets backend allow run one instance rafter vm time changed future release clone build git clone git githubcom andrewjstoneraftergit cd rafter make deps make mkdir data directory store rafter log metadata node launch node open three new terminal machine following terminal run following cd rafter binstartnode peerx start erlang vm appropriate cookie code path start rafter peer utilizing rafteretsbackend node name case peerx unique node three node operated rafter client api empty log point configuration note operation rafter performed via client api raftererl set initial configuration cluster rafter cluster support reconfiguration system running however start blank first entry log must configuration entry set initial cluster start time note operation fail timeout majority node reachable however peer become reachable command replicated cluster configured go first erlang shell running arbitrarily choosing node first leader ensure running sys getstate see something similar following state rafterconsensusfsm rr rafterconsensusfsm appendentries appendentriesrpy clientreq config meta rafterentry rafteropts requestvote state vote sys getstate follower state leader undefined term votedfor undefined commitindex initconfig undefined timer ref follower response sendclock sendclockresponses clientreqs readreqs config config state blank oldservers newservers statemachine rafterbackendets backendstate state set config cluster note talking process registered locally node nt need use fully qualified name talking via shell peer rafter setconfig peer write operation write operation written log fed backend state machine general multiple statemachine backends implement backend protocol operation opaque rafter depend provided backend state machine following operation available ets backend use anticipated api grow include multikey potentially global transaction create new ets table rafter op new sometable store erlang term table rafter op put sometable somekey someval delete term table rafter op delete sometable somekey delete table rafter op delete sometable read operation read operation nt need written persistent log however still need get quorum peer still need read rafter backend ets backend provides following read operation read erlang term rafter readop get table key list table rafter readop listtables list key rafter readop listkeys table show current state log peer rr rafterlog sys getstate running test test require erlang quickcheck currently unfortunately free trial version may may supported version make test todo automatically forward request leader instead returning redirect add transaction ets backend add multikey multitable query support ets backend compaction start snapshotting assuming data small described section client interface client sequence number idempotent counter redis like textbased interface http parallel eqc test antientropy write aae info snapshot file snapshotting license apache http
522,Lobsters,erlang,Erlang development,Erlang library for parsing and composing JSON terms,https://github.com/seth/ej,erlang library parsing composing json term,ej help work erlang term representing json json jiffy ejson ej example ej example http wwwjsonorgexamplehtml thread erlang question sticky note example application thanks build status license,ej help work erlang term representing json ej module make easier work erlang term representing json format returned jiffy ejson use ej walk object return particular value ej update value within object ej remove value object ej path json object expressed using tuple key like javascriptej objauthornamefirstej get author name first obj get started using ej see ej example ej also provides mean validating json object according specification provide feature useful need process json request body brief example specification json object describing person favorite food name stringmatch regexfor name opt nickname stringmatch regexfor name food arraymap string ej independent library used json serialization dependency ej example ej best explained example consider following json data borrowed http wwwjsonorgexamplehtml menu id file value file popup menuitem value new onclick createnewdoc value open onclick opendoc value close onclick closedoc translates json erlang term like struct menu struct id file value file popup struct menuitem struct value new onclick createnewdoc struct value open onclick opendoc struct value close onclick closedoc ej action specify path want access tuple key use string binary ej get menu value obj file access list element index ej get menu popup menuitem onclick obj opendoc atom first last used list well ej get menu popup menuitem first value obj new filter list object specifying property keyvalue pair match ej get menu popup menuitem select value new obj set value ej set menu id obj add value ej set menu newkey obj something add value list newitem struct value save onclick savedoc ej set menu popup menuitem new obj newitem idea helper module inspired thread erlang question mailing list particular reply richard keefe additional motivation similar helper module struct included sticky note example application folk beebole thanks christopher brown christopher maier john keiser sebastian probst eide build status license ej available apache license version licensed apache license version license may use file except compliance license may obtain copy license http unless required applicable law agreed writing software distributed license distributed basis without warranty condition kind either express implied see license specific language governing permission limitation license
523,Lobsters,erlang,Erlang development,Webmachine Tutorial,http://christophermeiklejohn.com/erlang/webmachine/2013/07/11/lambdajam-2013-webmachine-tutorial.html,webmachine tutorial,lambdajam sean cribbs webmachine slide code,yesterday part lambdajam conference sean cribbs presented workshop building functional web application webmachine toolkit building correct wellbehaved http application able make slide code available follow along home tutorial start basic hello world application walk though building upon create twitter clone feature csrf token protection streaming response conditional request templating visual debugger try let know think
524,Lobsters,erlang,Erlang development,Haskell vs. Erlang for bittorent clients,http://jlouisramblings.blogspot.ca/2010/04/haskell-vs-erlang-for-bittorent-clients.html,haskell v erlang bittorent client,,
526,Lobsters,erlang,Erlang development,Lergic: An embedded datalog-like logic programming DSL for Erlang.,https://github.com/JoeOsborn/lergic,lergic embedded dataloglike logic programming dsl erlang,,lergic embedded dsl logic programming erlang intended replace deep lookup update state object lot list data nicer syntax qlc join easily use arbitrary function relation query see testlergictestserl also transform called lergickv treat query logical function rather relation basically blessing certain slot key others value returning value course return value matched see testlergickvtestserl negationasfailure implemented simplest possible way lergic none query inside another query take value variable bound far variable bound within none leak enclosing query lergic also seen reincarnation mnemosyne intend steal rule syntax relation definition near future relation backed kind store simply userdefined function composed via parse transform turn query list comprehension worried nested loop careful write query fewer search update parse transform spit qlc query handle rather list comprehension send pull request performance likely bad relation defined term relation currently implemented naively simply query optimization current bugspending feature relation defined hand handle sigils would better option automatically produce syntax probably different parse transform builtin relation defined arithmetic operator c nt hard nt needed yet need handle ungrounded term specially course since nt plan implement constraint solver query planner would nice work involved probably nontrivial
527,Lobsters,erlang,Erlang development,ZMTP protocol in pure Erlang.,https://github.com/a13x/ezmtp,zmtp protocol pure erlang,join github today sign file permalink ezmtp usage todo resource reload reload,zmtp protocol pure erlang dismiss join github today github home million developer working together host review code manage project build software together sign file permalink failed load latest commit information type name latest commit message commit time ezmtp zmtp protocol pure erlang us ranch socket management implementing protocol version usage check testhandlererl implement simple ezmtphandler behavior single handle function todo add documentation example zmtp protocol pure erlang resource perform action time signed another tab window reload refresh session signed another tab window reload refresh session
528,Lobsters,erlang,Erlang development,Erlang Style Actors Are All About Shared State (2009),http://james-iry.blogspot.com/2009/04/erlang-style-actors-are-all-about.html,erlang style actor shared state,last week exciting episode situation finally damn code last note postscript,actor become quite popular topic besides erlang famous library implementation scala least java shared state propaganda setting people failure last week exciting episode defined state nt fact something responds differently input time detail represented based show saying erlang style actor nt share state totally wrong headed fact nt want share state actor model clunky way thingsbefore go let emphasize like erlang like actor nifty model stateless model let show ranting problem erlang style actor shared mutable changeable state model shared state nt need share mutable state better alternative actor importantly even using actor well must think problem shared mutable state people believe propaganda rude shocksthe situationlast time described simple sock tube dispensing machine insert two coin press button get tube sock insert many coin get extra coin returned push button inserted enough coin get nothing diagramimagine alice bob work crap corp making high quality crap since day like saunter break room purchase nice warm tube sock crap corp machine nt take regular coin crap corp coin instead ccc weighs pound roughly kilogram naturally alice bob nt want carry pound crappy token around laboriously drag token machine insert walk back cubicle grab another repeat alice bob take sock break different time probably going work fine tend overlap bad thing happen possible alice insert first coin bob insert first coin alice insert second coin get coin back bonus cry happily experiencing greatest joy ever experienced crap corp alice push button get tube sock merrily skip back cube well maybe skip exactly whatever ecstatically happy carrying pound crapthen bob show insert second coin eagerly smash button get well deserved tube sock get nothing feeling cheated pound machine kick shake rock back forth inevitably machine tip fall bob crush ton crap corp coin inserted week tragic ending somebody wanted socksnow outcome nt guaranteed even bob alice start time way inserting first coin alice could waylaid bos looking tps report alice patiently explains tps report never job b discontinued three year ago c eye face chest bob could merrily taken two coin trip safely received tube sock without ever knowing mortal injury narrowly avoidedfinally damn codeany time something unwanted happen result unpredictable delay scheduler priority workload etc race condition could unwanted crushed vending machine could unpredictable pointy haired bos write exactly erlangin file called sockmachineerl first little standard module definition export business module sockmachine export gut machine zerocoins onecoin twocoins state machine one called block waiting message inbox based message get responds nothing nothing happens coin need return coin tubeofsocks win also call appropriate function next state might state private function exported module note clever way write explanatory purpose like thiszerocoins receive coin nothing onecoin button nothing zerocoins end onecoin receive coin nothing twocoins button nothing onecoin end twocoins receive coin coin twocoins button tubeofsocks zerocoins end start spawn new sock machine actor zerocoins statestart spawn fun zerocoins end insertcoin pushbutton rpc style convenience function insert coin push button get backwards well whichever return whatever recieve message back machineinsertcoin machine machine coin self receive x x end pushbutton machine machine button self receive x x endtest spawn many concurrent test loop requested simultaneously pound one machinetest machine process process spawn fun testloop machine end test machine process true io format test process launchedn end testloop repeatedly walk cycle inserting coin pushing button call helper function mirror state sock machine show expects happen step complaining thing nt go well testloop process machine count count testzerocoins process machine count true io format w testing completedn process end testzerocoins process machine count case insertcoin machine nothing testonecoin process machine count coin io format w bonus coin n process testtwocoins process machine count end testonecoin process machine count case insertcoin machine nothing testtwocoins process machine count coin io format w bonus coin n process testtwocoins process machine count end testtwocoins process machine count case pushbutton machine tubeofsocks io format w got socksn process nothing io format w blasted machine ate money give rattle rattle arrrgghghhrhrhghn process end testloop process machine count fire erl compile start machine test running test c sockmachine ok sockmachine machine sockmachine start sockmachine test test process launched ok got sock got sock got sock got sock got sock got sock got sock got sock got sock got sock testing completed ah sweet sweet success run another test concurrent test loop bob alice way around sockmachine test test process launched bonus coin bonus coin ok got sock blasted machine ate money give rattle rattle arrrgghghhrhrhgh bonus coin bonus coin got sock blasted machine ate money give rattle rattle arrrgghghhrhrhgh bonus coin bonus coin got sock blasted machine ate money give rattle rattle arrrgghghhrhrhgh bonus coin bonus coin got sock blasted machine ate money give rattle rattle arrrgghghhrhrhgh bonus coin bonus coin got sock blasted machine ate money give rattle rattle arrrgghghhrhrhgh bonus coin bonus coin got sock blasted machine ate money give rattle rattle arrrgghghhrhrhgh bonus coin bonus coin got sock blasted machine ate money give rattle rattle arrrgghghhrhrhgh bonus coin bonus coin got sock blasted machine ate money give rattle rattle arrrgghghhrhrhgh bonus coin bonus coin got sock blasted machine ate money give rattle rattle arrrgghghhrhrhgh bonus coin bonus coin got sock blasted machine ate money give rattle rattle arrrgghghhrhrhgh testing completed testing completed litany sock bonus coin crushed intestine machine oddly predictable litany real distributed erlang app would much interesting random litany network delay would emulate pointy haired boss even better erlang schedulersome last noteswith erlang style programming actor central unit statefulness multiple actor share access one stateful actor hence shared state race condition ruptured spleen saying erlang actor bad fact quite like erlang model nicely separate must stateful concurrent pure computation making state much painful write foox foox actor model encourages think consequence sharing also cleanly mirror mechanic distributed computing asynchronous io nice statelessone last note started actor shared state naturally one might ask well stateless actor actor nt change state depend state via io certainly viable us actor longer concurrency parallelism imho future data flow variable haskell data parallelism cleaner way deal parallelism someday soon hope write meantime whole point complexity message passing instead simpler mechanism precisely deal complexity concurrent stateone really last note sadly simple straight actor nt automatically compose well design set actor interact correctly one use case nt interact well plugged different system another aspect actor share traditional manual lock shared mutable memory date best known way deal composable state transaction optimistic pessimistic distributed compensating software hardware database whatever nice transactional capability available erlang yet another area shared state mantra lead people think actor entire answer without needing anything elsetry get crushed good luck sock postscriptit suggested comment people say erlang style actor nt share state mean nt share memory first clearly defined state previous article different representation importantly think saying nt share memory distinction without much relevance mostly implementor point view nt reflect user must think actorshere erlang code simple shared mutable variable nt recommended erlang usage nt break model waymodule variable export malloc spawn fun loop end loop value receive fetch value loop value store newvalue loop newvalue end fetch variable variable fetch self receive x x end store variable value variable store value using c variable ok variable x variable malloc variable store variable fetch x variable store x variable fetch x variable fetch x since variable actor easy share sock machine example
529,Lobsters,erlang,Erlang development,Resources for learning Erlang,https://github.com/0xAX/erlang-bookmarks/blob/master/ErlangBookmarks.md,resource learning erlang,join github today sign,dismiss join github today github home million developer working together host review code manage project build software together sign
532,Lobsters,erlang,Erlang development,Systems that Run Forever Self-heal and Scale,http://www.infoq.com/presentations/self-heal-scalable-system,system run forever selfheal scale,infoq homepage presentation system run forever selfheal scale summary bio conference related sponsored content,infoq homepage presentation system run forever selfheal scale system run forever selfheal scale summary joe armstrong outline architectural principle needed building scalable faulttolerant system built small isolated parallel component communicate though welldefined protocol bio joe armstrong principal inventor erlang coined term concurrency oriented programming ericsson developed erlang chief architect erlangotp system formed bluetail developed product erlang obtain phd royal institute technology stockholm author book software concurrent world conference lambda jam new conference take skill next level traditional conference sitting listening significant portion day devoted handson practice workshop aim stretch skill teach something new recorded aug related sponsored content
533,Lobsters,erlang,Erlang development,Bringing Erlang's Fault Tolerance and Distribution to Java with Akka and Erjang,http://www.infoq.com/interviews/jonasboner-krestenkrabthorup-erlang-jvm,bringing erlang fault tolerance distribution java akka erjang,erlang factory london sitting jonas boner kresten krabthorup jonas bringing otp erlang jvm via scala route kresten creator erjang jvm port erlang also bringing erlang otp jvm choose way think scala instance would easier take shortcut mutable state scala story regard essentially supervision tree one idea brought fallacy latency actually visible inside data center smalltalk away original idea smalltalk really message passing,erlang factory london sitting jonas boner kresten krabthorup jonas jonas boner swedish cto typesafe company launched publicly month ago building stack top scala middleware stack developer tool support service also product around scala ecosystem contribution may akka akka middleware sort product heavily influenced erlang long story short erlang otp product inspired start akka writing middleware system server system career mainly living jvm got really excited got erlang learned wanted get others excited lot people customer colleague jvm hard time convincing move erlang runtime felt ok thing implemented concept really sound around year really alien java developer see use thing good left erlang geek excellent community felt need urge move idea onto jvm started akka attempt took lot best idea otp also idea language like language oz data flow concurrency borrowed haskell clojure stuff like put together mix try address like scaling vertically well scaling horizontally unified platform programming model say short akka bringing otp erlang jvm via scala route jonas boner exactly akka implemented scala scala compiler emits jvm bytecode run jvm akka scala interface scala api well java api use also people used groovy jruby runtime language onto jvm implemented scala solely scala scala product kresten creator erjang jvm port erlang also bringing erlang otp jvm choose way kresten krabthorup really think new concept jonas saying hard grasp java developer need full opinion like whole isolation mechanism instance really core erlang used aspect erlang erlang many thing functional program language concurrent think important big stumbling block think big stumbling block really much practical java used strict state management maybe ten year ago proposal isolates java kind like little island mutable state touch core concept beautifully encapsulated erlang language using erlang language program kind way good way could many language kind pipe dream mine might even imagine new language kind adopts model strict isolation opinion important profound garbage collection imagine looking language garbage collection really like cool stuff implement garbage collector still use stuff lot boundary condition difficult manage course also practical pragmatic thing objectivec thing object really nice still able use c c integrate really nicely also kind bastard language mix different world ended pretty successful hope mixture successful would like force say box state management properly language see appeal scala akka concept obviously idea pushing erlang erjang afraid novice programmer come project maintenance mode find easy like quick hack circumvent thing probably one part equation course many thing depends coming think scala instance would easier take shortcut mutable state scala story regard jonas boner scala favor immutability way default collection immutable ask mutable want also make distinction syntactic distinction variable value scala code always use value mean final variable java stack allocated variable really try make easy right thing come state management scala functional story mix two different paradigm oo object orientation common idiom using mutable state functional side scala heavily favor immutability use combinators transformation state without mutable state akka also try favor immutability problem running jvm one single shared heap like erlang every process heap start tampering state currently scala think jvm language state management need either convention somehow enforced runtime tool however research scala community right martin odersky team enforce type system way guaranteeing immutable state used also guarantee uniqueness one component access component state nothing gone scala compiler scala type system yet think interesting research might see ending scala within year something would love cause would get compile time enforcement even though get inside jvm least catch immediately kresten krabthorup always problem also ten year ago working ejb container also one problem ejb trying resource container would declare dependency also managed resource could open file would closed ejb way manage jvm environment unless want analyze code would potentially call way proper resource management way aspect something different mindset think huge value actually enforce scala obviously lends people like type feel relieved know system typesafe actually kind thing state management know world like easy worry affect thing system get original oo world always talked encapsulation object encapsulate big fake never really encapsulated kind relief get start studying oo really nice think encapsulation year later realized encapsulation actually thing jonas boner actually massive test suit oo system never really sure refactoring bug emerges fix break every state entangled place really idea going use functional approach state change local least pure functional approach get referentially transparent code swap value actual function value knowing affecting state locally sure break place make sleep better night kresten krabthorup relief make thing easy kind feeling jonas boner actor mutable state completely isolated still relief completely enforced way especially going go top concurrency erlang shine erjang shine akka also try pull thing table raise abstraction level like plumbing management state basically singlethreaded system system sort deterministic idea going soon starting adding thread system everything becomes completely indeterministic idea going thread obey nice encapsulation rule set typesystem compose run corrupt extremely hard handle use something like actor model plumbing becomes workflow instead think term message flow system guard state others make much easier reason code understand going kresten krabthorup micro level make code manageable understandable think using actor way encapsulate nice think higher level superstructure system really interesting part akka erlang build system reliable think something appreciated valued enough obviously customer buy system expect reliable never really much topic except distinct area close hardware management like instance telephony system robotics kind world never mainstream information system another reason thing interesting building system composing web service like one healthcare project working system integrated rely behaving correctly time stuff like also depend becomes much important valuable work always work computer system getting interconnected dependent sudden raise value availability business level value really scala akkastyle system erlangbased system design pattern system design pattern architecture pattern make thing really work really stable starting see lot interest think interesting angle push new cool technology reason availability pattern building reliable system reason start paying attention jonas boner absolutely kind approach really shine distributed system build reliable system one node get hardware failure memory game way normally traditionally make system like world jvm also clr whatever case emulate shared state way familiar world even think fundamentally broken even single system people comfort zone system try give distributed computing distributed store try stretch sort thinking across many machine problem get extremely leaky abstraction network two machine nothing like shared state underneath message passing think instead seeing embracing limitation distributed computing network seeing everything message passing share nothing make lot easier think program kresten krabthorup make composable subsystem general leaky abstraction make subsystem component able compose interact jonas boner also got much interested erlang fault model embracing failure natural state lifecycle application something hope happen try guard prevent instead natural thing especially write distributed system go better good way dealing think erlang story extremely appealing trying lie fake something instead embracing core whole make best instead lot thing trying port especially system integration like kresten say never trust another guy system trouble trusting would bet money someone else essentially supervision tree one idea brought kresten krabthorup honest failure happen talk goto copenhagen time ago quote said defensive coding sign weak system weak platform quoted tweeted way handle error fault kind system try handle upfront write code much simpler put assertion let fail fault handling meta level level fault handling fact instead trying prevent everything make code much simpler coding spec protecting everything around spec course handle boundary condition information get system tcp socket level course check protocol data inside system client behave properly towards service use check everything make code much simpler assume something fails take everything notion already desktop operating system word fails bring powerpoint micro level inside program think component fails really hard thing get used took kind get brain comfortable part program fail mean everything failed hear people say many time feel body comfortable jonas boner right never completely shared state everything entangled need separation level indirection kresten say one really nice thing nice separation concern give way almost declaratively configure system react upon failure rather program entangle code deeply involved aspect oriented programming aop community long time trying separation concern thing belongs thing belongs feel thing using erlang sense well nice separation almost declarative way put thing work well practice theoretical exercise kresten krabthorup definitely something get used whole generation javascript c programmer used point view interesting observe different business adopt like started business basically go know thinking trying within business easy either bring erlang established java c consulting business good easy continue jonas boner much harder easier start thing start influence people want listen need influence press people even want listen least initially kresten krabthorup going interesting see kind thing probably happening java became obvious java next big thing could really raise bar make much easier build system many business went c c odd new language called java really fast kind new weird concept jonas boner right education process think easier sell ten year ago remember started working terracotta java clustering company came customer even know scalability problem fault tolerant problem whatever confusing performance scalability go start ground level computer science really kind problem nowadays people used nosql database used using kind stuff scale used writing distributed system using rest stuff like people becoming aware kind thing feel much easier almost many way thing instead kresten krabthorup definitely need kind convergence phase educational phase concept obviously need materialize broader developer community kind thing come hardware fail might well message passing fail fact shared memory model work materialize term thinking saying deep riak kind thing say write conflict happen different place world two different people write two set key two different value later point deal core concept fact nature almost like cheating jonas boner like lift fundamental property hand programmer lot responsibility hand trying lie need fake anything really like approach le magic better also something really try embrace akka well example software transaction memory really bad reputation magic implementation try bless whatever mess user make instead taken approach extremely explicit almost bit ugly need wrap state want transaction magical reference much eye think really good thing know exactly pay price kind semantics see nosql also embracing concept like dynamo paper thing better lift shield away make simple nt even think never simple kresten krabthorup fallacy distributed computing around last year year pc bad shared memory bad fail living world net remoting rmi trying make everything like terracotta trying make thing look like shared memory able push good enough system become integrated cloud widely used people run thing infrastructure service hosting provider get latency network effect exposed even fallacy come back hit think time definitely fallacy latency actually visible inside data center kresten krabthorup virtualization stuff one branch really trying make old software continue run old window apps want rewrite like put virtualized hardware make environment like putting artificial life old system run cloud stuff good business case integration happens everywhere across system need integration inevitably kind expose failure happen easily propagate thing fail need expose completely agree smalltalk away original idea smalltalk really message passing jonas boner even asynchronous message passing talking erlang akka actor message passing active object try talk object encapsulate state behavior message passing way implemented akka scala polymorphism inheritance think essence view kresten krabthorup many definition object oriented people saying word matter say response question people completely agree jonas describe actor programming talk object come naturally lot technique developed object oriented programming applies really well model like crc card people playing role different class much better actor programming natural people talking activity kind thing many intersecting concept usable context jonas boner think useful think regardless definition think useful think actor object model object important least
534,Lobsters,erlang,Erlang development,zog_web is a web serving and domain/page routing platform for erlang applications,https://github.com/mattsta/zog_web,zogweb web serving domainpage routing platform erlang application,zogweb erlangbased web serving using domain route usage basic usage ultraquickstart example application http githubcommattstahnf building testing next step use zogweb background thanks,zogweb erlangbased web serving using domain route usage basic usage ultraquickstart include zogweb rebar dependency start erlang node config myconfig wherein define webip webport routedirs see hnf example application start zogweb webserver running serving traffic route listed configs routedirs example application complete application using zogweb available http githubcommattstahnf building download deps rebar getdeps build rebar compile testing egad need test next step specific order actual documentation domain route work path route work send page stall page redirect page deal parameter test continual synchronization feature upcoming zog component use zogweb use zogweb need simple way expose erlang code internet series url use zogweb want entire web stack embedded one application zogweb provides web server domain routing url routing paired zoguser zogweb automatically provide authentication authorization predefined path background zog project result experience deploying dozen website using yaw past year zog provides everyone low latency scalable minimal nomagic web framework get way focus getting content user zog consists zogweb zoguser zogtemplate application yet named hint zog right zogweb available completely usable isolated application remaining application polishedfinishedintegrated released soon thanks mochiweb providing battletested web serving component chicagoboss stole idea path routing method argument lfe shoving lisp macro erlang
535,Lobsters,erlang,Erlang development,Jobs is a job scheduler for load regulation of Erlang applications.,https://github.com/esl/jobs,job job scheduler load regulation erlang application,job job scheduler load regulation version job example prerequisite http githubcomeslparsetrans contribute http githubcomesljobsissues module,job job scheduler load regulation copyright c erlang solution ltd version job job job scheduler load regulation erlang application provides queueing framework queue configured throughput rate credit pool feedback compensation queue added modified runtime customizable sampler propagate load status across node system specifically job provides three feature job scheduling job scheduled according certain constraint instance may want define job certain type execute simultaneously maximal rate start job per second job queueing load higher scheduling limit additional job queued system run later load clear certain rule govern queue dequeued fifo lifo order many job queue take full deadline job rejected hit queue limit reject job provides feedback mechanism client queue take action sampling dampening periodic sample erlang vm provide information health system general high cpu load high memory usage apply dampening scheduling rule may lower concurrency count rate execute job health problem clear remove dampener run full speed example done prerequisite application requires exprecs exprecs module part http githubcomeslparsetrans contribute issue comment feedback please create issue http githubcomesljobsissues job issue module
536,Lobsters,erlang,Erlang development,A Visual Tour of Erlang,https://www.youtube.com/watch?v=lHoWfeNuAN8&feature=youtu.be,visual tour erlang,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature visual tour erlang youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature visual tour erlang youtube
537,Lobsters,erlang,Erlang development,Making reliable distributed systems in the presence of software errors,http://www.erlang.org/download/armstrong_thesis_2003.pdf,making reliable distributed system presence software error,,obj length filter flatedecode stream b e sa n endobj obj type page content r resource r mediabox parent r endobj obj type xobject subtype form formtype matrix bbox resource procset pdf extgstate r r length r filter flatedecode stream 玚 f n qk zfd ob u l k x
538,Lobsters,erlang,Erlang development,Erlang's Open Telecom Platform (OTP) Framework,http://www.infoq.com/presentations/Erlang-OTP-Behaviors,erlang open telecom platform otp framework,infoq homepage presentation erlang open telecom platform otp framework summary bio conference related sponsored content,infoq homepage presentation erlang open telecom platform otp framework erlang open telecom platform otp framework summary steve vinoski introduces erlang otp frmework outlining main feature including several behavior implementation common pattern useful concurrent faulttolerant application bio steve vinoski author toward integration ieee internet computing written magazine cc user journal c report coauthor advanced corba programming c apc michi henning currently architect basho technology previously worked chief architect iona technology hp apollo computer texas instrument conference software changing world qcon aim empower software development facilitating spread knowledge innovation enterprise software development community achieve qcon organized practitionerdriven conference designed people influencing innovation team team lead architect project manager engineering director recorded aug related sponsored content
539,Lobsters,erlang,Erlang development,Building Highly Available Systems in Erlang,http://www.infoq.com/presentations/Building-Highly-Available-Systems-in-Erlang#.UUUKT7OwH5g.twitter,building highly available system erlang,infoq homepage presentation building highly available system erlang summary bio conference related sponsored content,infoq homepage presentation building highly available system erlang building highly available system erlang summary joe armstrong discus highly available ha system introducing different type ha system data ha architecture algorithm rule ha ha done erlang bio joe armstrong principal inventor erlang coined term concurrency oriented programming ericsson developed erlang chief architect erlangotp system formed bluetail developed product erlang obtain phd royal institute technology stockholm author book software concurrent world conference software changing world qcon aim empower software development facilitating spread knowledge innovation enterprise software development community achieve qcon organized practitionerdriven conference designed people influencing innovation team team lead architect project manager engineering director recorded apr related sponsored content
544,Lobsters,erlang,Erlang development,Using Unicode to play chess over SMS,http://www.twilio.com/engineering/2012/11/08/adventures-in-unicode-sms,using unicode play chess sm,unicode chess piece sm character encoding background byte gsm character encoding option smpp basic multilingual plane emoji combining character fixing api type collection byte must know encoding order understand string text long algebraic notation encoding chessboard display problem fitting board modeling chess service erlangotp erlangotp communicating chess engine xboard xboard winboard uci universal chess interface port stockfish representing game final thought fork source,remember one first week engineer twilio tried send unicode chess piece phone disappointed see character come handset perhaps bad sending chess piece twilio phone sent twiml endpoint incorrectly encoded one first major project messaging team twilio bring international sm beta requirement sending message internationally support character language country learning character encoding sm network protocol proved extremely educational interesting task sm character encoding background historically sm api claimed support ascii character turned oversimplified two way size limitation actually complicated ascii encoding interest actually fit single sm least gsm network limited byte maximum actually come fact encode character byte even character ascii guaranteed fit character character encoding used sm ascii gsm consequently certain character gsm require escape character mean take character bit encode character include short sm escape character character instead perhaps devastating message truncated exactly wo nt fit single sm single one character every ascii character encodable gsm example missing tab character encoding option sm gateway protocol tend support character encoding gsm bad news encoding actually matter depends carrier network handset phone especially internationally receive message either gsm character encoding mean even though example smpp support character encoding like iso iso iso mysterious unspecified pictogram encoding message probably going get converted gsm anyway character encoding missing gsm lost conversion thus message encoded gsm reliable option encode using defunct character encoding since replaced two main difference encoding nt use byte order mark always big endian explicit support surrogate pair meaning limited always byte per character whereas byte per character mean encode character outside basic multilingual plane nonbmp character difference turn matter practice due lack support encoding modern programming language smartphones tend decode message big endian good news mean practice send nonbmp character emoji character sm despite fact spec nt strictly allow drawback message since character byte maximum fit byte sm message even true one character nt gsm since encoding applies every character message note sending emoji nonbmp character limitation actually ignoring combining character eg diacritic mark could bring count depending count length text fixing api knew possible clear api limitation time start correcting issue bug fell category avoid mistake following concept important keep kind make sure language framework interpreting percent encoded http parameter make sure database connection set mysql better make sure column type latter support nonbmp character maximum byte per character mysql ca nt upgrade going need find solution nonbmp character option include using blob type handling encodingdecoding escaping nonbmp character whatever scheme come must sure produce valid general confuse string byte collection byte must know encoding order understand string text unicode sm international character sm api robust character encoding support opportunity fully realize vision chess game played entirely sm using unicode character model piece chess board build chess sm chessms game move made using long algebraic notation eg opponent currently limited chess engine encoding chessboard send chessboard phone basically two challenge getting piece line getting whole board fit one sm message display problem tricky thing displaying chessboard using text searching unicode codepoints would make good empty black white square hoping find character close width chess piece character possible general phone use fixedwidth font worse since phone use different font may prove difficult impossible find black white square character make board align nicely across handset fact many font chess piece nt even width course assumes phone font even character chess piece nt likely see substitute character like unicode block luckily iphone android window phone use font chess piece phone fall back alphabetical character trial error found unicode shaded block character fixedwidth whitespace character worked pretty well iphone helevetica neue font since ca nt tell kind phone sending sm end user change setting character us render board general due problem rendering board much best effort render io since using whitespace character white square ran problem top left square empty top left happens white square playing white first character message whitespace turned api actually strip leading whitespace stripping square perhaps literal corner case history software changed api strip standard type whitespace assumption anyone using special whitespace character probably purpose fitting board recall character encoding background section allowed byte sm message luckily chess piece basic multilingual plane bmp take byte thus message send character chessboard character used board need split rank need newlines one rank except last need one many character close happen footage exact moment grand master garry kasparov read sm specification solution fitting board omit final whitespace rank empty white space end work rank piece sitting position nt come workaround board sent two message modeling chess service erlangotp implementing chessms chose erlangotp knew requirement chessms would expose several feature erlang nt gotten play yet knew service mission critical chess sm system could give reliability scalability needed well actually despite great reason choose erlang end excellent fun choice explain without getting detailed architecture communicating chess engine developing chess engine outside scope project luckily dozen great open source chess engine two main protocol communicating engine interface xboard protocol gradually evolved xboard winboard user interface there uci universal chess interface designed scratch engine author uci much simpler interface put complexity ui side chose implement uci stateless design simpler command list chess engine ui communicate stdinstdout great match erlang port feature port executable program program fork send receive message another erlang actor made extremely simple command chess engine erlang since want give engine second decide move spawn engine default course configurable add common resource pool manages pool engine currently using stockfish chess engine theory uci engine plug work representing game implementing chessboard state updating board move surprisingly good fit erlang pattern matching erlang particular made part code readable would otherwise nasty specialkind pawn undefined enpassantsquare enpassantsquare enpassant specialkind pawn promoted promoted undefined promotion specialkind white king undefined castle specialkind white king undefined castle specialkind black king undefined castle specialkind black king undefined castle specialkind undefined normal code defines function called specialkind determines move special move take tuple color piecetype square square promotion square enpassant square return either castle normal enpassant promotion chess game running erlang process operating system process inside erlang vm use mnesia database store mapping player pid process id web interface implemented cowboy http framework receives sm command twilio look game process phone number currently involved sends move message process since erlang process could running locally another erlang node without change code move valid process make change local state asks chess engine pool response move serializes chessboard sends back actor return twiml final thought chessms nice workrelated side project term learning erlangotp dogfooding api neat demo unicode support besides sending international character think erlang great choice building sm application twilio play chessms texting play fork source github
545,Lobsters,erlang,Erlang development,Why I Program In Erlang,http://www.evanmiller.org/why-i-program-in-erlang.html,program erlang,program erlang evan miller russian erlang benchmark talk nif opencl directly erlang code change evanmillerorg twitter r wizard data le time communicate discovery visually back evan home page subscribe r twitter youtube,program erlang evan miller october translation russian erlang twentyfiveyearold programming language yet win popularity contest almost certainly never win medal speed let alone tiara syntactic beauty language slow awkward ugly refactoring erlang code pain yet almost five year spent large chunk free time programming erlang point spent well thousand hour language used language write rough chronological order csv parser nt laugh said chronological order template compiler objectrelational mapper richtext parser image resizer language preprocessor web framework distributed message queue follows impression language compared language used professionally c java perl php ruby objectivec javascript good news erlang summed erlang culmination twentyfive year correct design decision language platform whenever wondered something erlang work never disappointed answer almost always leave impression designer suppose contrast java pedantic thing perl kludgy thing ruby two independent implementation wrong thing c nt anything take garbage collection time collect garbage language entire system stop garbage collector run approach perfectly fine computer program supposed run write output quit longrunning application desktop mobile server program strategy result occasionally frozen uis slow response time erlang program hand thousand independent heap garbagecollected separately way performance penalty garbage collection spread time longrunning application mysteriously stop responding time time garbage collector run take string concatenation pop open implementation string concatenation perl ruby javascript certain find statement realloc memcpy concatenate two string first string grown make room second second copied first approach worked decade thing erlang approach nonobvious believe correct usual case erlang use contiguous chunk memory represent sequence byte instead something called nested list noncontiguous chunk memory result concatenating two string io list take time erlang compared n time language template rendering ruby python etc slow fast erlang matter blocking concurrent application logic impossible make blocking network call erlang spawn multiple o process design decision make erlang server never crash operating system lost many night sleep overloaded operating system previous job believe erlang concurrency design correct mentioned refactoring erlang code pain fortunately experience rarely necessary refactor erlang code way objectoriented code need refactoring time time erlang function passed information need get compiler warning passed information nt need sense refactoring integrated development distinct activity requiring bountiful test coverage several pot coffee refactoring java objectivec code usually becomes necessary many instance method added class developer must spend time figuring method require instance variable best cut carriage half simply concern functional programming moving function different module requires little handwringing virtually effort erlang usually consists breaking large function smaller function much mental effort involved however due erlang syntactic peculiarity tedious converting anonymous function named function perhaps clever ide eliminate tedium one day data structure erlang completely transparent knowing nothing library using always inspect content data structure runtime feature greatly aid debugging boon oldfashioned hacking easy manipulate undocumented data structure order implement functionality original library author intend unlike objectoriented programming never need worry original author renaming variable breaking subclass code long underlying data structure remains modification continue work erlang find transparency data structure erlang make programming much easier objectoriented programming always worrying name thing erlang usually nt matter data structure half interface never programmed erlang probably idea talking come bad news erlang language benefit backloaded language benefit appreciated several year language followed several year erlang certainly language beginner syntax strange programmer hailing c diaspora functional programming tough erlang nt put sugar pill graphic toolkits primitive fillinthecode computer game found introductory java course reading nontrivial erlang code requires firm understanding recursion kind abstract thinking many people find difficult erlang also lacking library compared language experience given task zero one two erlang library available job perhaps alone say actually like fact many erlang library available need something done excuse often make discovery would made otherwise sound dumb true feel productive something one done yet along way freedom try new approach make real innovation learned course developing erlang library ever learned stitching together people ruby c code program erlang purely enjoyment solving problem sharing discovery wellengineered application seasoned hobbyist programmer like truly bad news erlang slow server application written speed language issue extra cost cpu made erlang correct handling garbage collection network io string concatenation concurrent environment language complexity analysis erlang program tend large constant front excellent asymptotic property programmer wish write fast program using erlang sort program start run write output exit hope several front nativecode compiler available according numerical benchmark make erlang program faster ruby perl php albeit slower java javascript talk justintime nativecode compiler might provide improvement execution time gleaning information code execution making appropriate optimization finally brave soul write computationally intensive code c via nif important caveat c code block erlang scheduler potentially negating erlang concurrency capability parallel c code famously difficult write choice writing fast program erlang alternative technology affords benefit c code without compromising integrity erlang runtime opencl clike language introduced apple like erlang opencl easily take advantage processor core given machine unlike erlang opencl program fast fact opencl program usually faster c program opencl program take advantage processor vector capability way normally requires handtuned assembler code opencl program compiled executed directly erlang code view perfect technology performing computationally intensive task running inner loop inside larger erlang program way disclaimer actually used opencl inside erlang program said speed problem erlang program written firsthand experience opencl quite pleased wrote map projection library opencl time faster stateoftheart library written c also wrote opencl library multivariate statistic nt benchmarked existing library suspect faster similar margin peculiarity writing opencl code hope one day world tight loop rewritten opencl invoked large program written erlang change minor clarification correction reading evanmillerorg random collection math tech musing liked might also enjoy get new article published via twitter r want look statistical pattern mysql postgresql sqlite database desktop statistic software wizard help analyze data le time communicate discovery visually without spending day struggling pointless command syntax check back evan home page subscribe r twitter youtube
546,Lobsters,erlang,Erlang development,A Tale of Two Concurrency Models: Comparing the Go and Erlang Programming Languages,http://www.informit.com/articles/article.aspx?p=1768317,tale two concurrency model comparing go erlang programming language,json json string cay horstmann blockchain ultimate serverless platform michael juntao yuan new io programming big nerd ranch guide edition christian keur ram scott mueller infectious disease spread david clark service worker progressive web apps pwa john wargo top cybersecurity threat sherri davidoff distributed service platform introduction silvano gai create gui java rogers cadenhead bpf io stack brendan gregg online privacy threat requirement william stalling calculate risk project juval lowy c packaging design rule john lakos javascript value variable kirupa chinnathambi new standard software design juval löwy software system decomposition juval löwy customizing iphone look brad miser personalize ipad michael miller program design highlight greg perry dean miller ethereum node michael juntao yuan,json json string cay horstmannjun javascript object notation usedblockchain ultimate serverless platform michael juntao yuanjun using blockchain cloud computing platformwhat new io programming big nerd ranch guide edition christian keurmay nerd ranch released edition io programming guide find new changed latest editionwhat ram scott muellerapr mueller outline ram explains difference computer memory disk storagehow infectious disease spread david clarkapr prevalence infectious disease history fluctuated wildly david clark outline different way disease spread examines many disease become milder timeservice worker progressive web apps pwa john wargomar introduction service worker use enable cool background processing web apptop cybersecurity threat sherri davidofffeb new year brings new threat discover top cybersecurity threat company face based latest case trend observed data breach expertsdistributed service platform introduction silvano gaijan need distributed service platform cloud infrastructure offer superior security cloudlike scale hardware performance low latency yet software programmablecreate gui java rogers cadenheadjan use swing create application feature key gui componentsbpf io stack brendan greggjan bpf trace layer storage io stack tool traced block io layer io scheduler scsi nvme example driveronline privacy threat requirement william stallingsjan survey threat requirement approach online privacyhow calculate risk project juval lowyjan calculate quantified risk software architecture project use calculation evaluate option planning toolc packaging design rule john lakosjan organize package componentbased software uniform domainindependent manner chapter also provides fundamental c design rule govern develop modular software hierarchically term component package package groupsjavascript value variable kirupa chinnathambidec use javascript value variable store data organize codethe new standard software design juval löwydec software architect juval lowy present simple design standard software engineering facilitate absorbing adhering correct design directive guidelinessoftware system decomposition juval löwydec common way decomposition flawed core learn powerful helpful technique leverage designing software systemcustomizing iphone look brad miserdec lot way customize way iphone look design organize home screen choose dark light mode set screen brightness text size wallpaperpersonalize ipad michael millerdec guidance personalizing way ipad look worksprogram design highlight greg perry dean millerdec productive computer programmer go writing programsethereum node michael juntao yuandec run interact ethereum node
