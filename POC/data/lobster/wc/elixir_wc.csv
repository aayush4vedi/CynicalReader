ID,Source,Tag_Code,Tag_Name,Title,Url,ProcessdedTitle,WeightedContent,Content
1,Lobsters,elixir,Elixir programming,The BEAM Has Spoiled Me,https://gvaughn.github.io/2020/08/08/beam_spoiled_me.html,beam spoiled,beam spoiled began fault tolerance let crash freedom bigger thought game changer,august beam spoiled greg vaughn noticed change prefer develop software since focusing career elixir allows think bigger thought develop lower friction le fear want go back began fault tolerance many people introduced elixir focus concurrency joe armstrong even called erlang concurrency oriented language note point generic beam language experience come elixir perspective please excuse bias terminology find helpful consider concurrency logical consequence primeval concern fault tolerance achieving beamstyle fault tolerance come isolated process affect crash plus supervisory process informed another process dy core point process contain blast radius damage caused error happens isolation quality enable also make great candidate concurrency let crash first heard let crash mantra erlang community sounded crazy based prior development exerience important understand license irresponsibility care system crashing core recognition system error even write bugfree code hardware bug u eventually architecture managing blast radius damage little part system crashing longer scary thing le fear yes please learned write elixir code focus blast radius driver reach process even case need concurrency use process enclose damage error might cause use supervision tree durable work queue recover minor crash process learned prefer upserts insert allow logic retried safely greater idempotency two idea process enclose possible error plus idempotency become second nature elixir code write freedom automatic ability recover error change complexion topic like test coverage enforcement static type extensive code review etc heart preventing error introduced first place yes recognize secondary benefit still good thing advocating irresponsibility solid safety net fault tolerance beam able look different perspective see add friction inertia delivering software perhaps temper reliance upon favor greater delivery speed circumstance le fear mean freedom choose bigger thought elixir reignited intellectual interest software development found via erlang beam history general huge body wisdom distributed system learn new tool toolbox think software process lightweight pervasive offering freedom fear crashing perspective shifted exciting way think writing web application thought immediately limited think building system think bigger thought better abstraction build upon team happy use elixir write web application fit preexisting microservice deployment model urge developer reach bigger thought fault tolerant lighweight process enable consider process logical microservice need friction deploying separately serializing tofrom json container orchestration distributed logging etal deploy entire system million interacting logical microservices single beam release game changer elixir beam certainly game changer fearless build system hope share freedom others beam spoiled good way tag beam elixir introspection
2,Lobsters,elixir,Elixir programming,"Parse, don't validate — Elixir edition, Part Two",https://well-ironed.com/articles/parse-dont-validate-elixir-edition-part-two/,parse nt validate elixir edition part two,previous bottomup lot written resultt simple parser railwayoriented programming result module breaking specific part dataparser leveraging builtin builtin summing,couple month since published previous post topic parsing validation sketched proposal truly smart constructor could look like elixir took approach separating deserialization data onthewire happen anywhere like protocolspecific controller construction domain object crucially wanted make sure object construct semantically valid completely obviating need function validate valid smart constructor function take primitive data type return either ok thevalidobject object constructed input error thereasonfortheerror input specify valid object wait type parser bottomup lot written topic parsing computer science going take approach say parser simply function take unstructured input either produce structured output fails capture fact using following type definition type parser resultt parser function accepts conceivable input return either successfullyparsed type kind error going dwell error type interesting thing could shipped error type make descriptive string resultt defined type b ok error b simple parser following function meet criterion parser def id input resultok input end given input simply return input valid parse result one immediately useful let look practical parser def number input case isnumber input true resultok input false resulterror number inspect input end end let try integer float input satisfy parser iex number ok iex number ok sure enough elixir data type iex number hello world error number hello world iex number ok error number ok iex number error number let extend parser accept nonnegative number def nonnegnumber input case isnumber input input true resultok input false resulterror nonnegative number inspect input end end parser strictly useful detecting type u also constraining value particular range iex nonnegnumber ok iex nonnegnumber error nonnegative number iex nonnegnumber mary little lamb error nonnegative number mary little lamb completeness let clamp number interval def input case isnumber input input input true resultok input false resulterror number range inspect input end end parser succeed passed narrow range numeric input iex ok iex error number range iex ok iex list error number range list said parser getting weirdly specific slightly unwieldy right think still looking quite readable let say need parse number range string parse number range implement piling even functionality onto single specific parser def input case isnumber input input input true resultok input false case isbinary input floatparse input num num num resultok num resulterror numberlike range inspect input end end end sure enough expect iex ok iex ok iex error numberlike range iex error numberlike range iex ok iex foo error numberlike range foo however code particularly satisfying look work additionally parse number float avoid yet another nested case expression cartesian case pattern matching promise functional programming use composition extension create bigger program would nice could compose many small generic parser larger specific turn apply railwayoriented programming result module several interesting function take advantage one help u write code happy path parser passing result successful parse next parser bailing first error let see help u refactor function breaking specific decompose requirement regarding input must number string parseable number nonnegative smaller keep thing simple let first ignore string parseable number requirement simply line numeric specification like def anumber input isnumber input resultok input def anumber input resulterror number input def nonnegative input input resultok input def nonnegative input resulterror input def input input resultok input def input resulterror input def numberinrange input anumber input resultandthen resultandthen end let try use parser iex numberinrange ok iex numberinrange atom error number atom iex numberinrange error iex numberinrange error see chain parser return ok value numberinrange exit successful parse final result parser fail bail return failed parser error message caller let tackle hardest requirement input either number stringthatcanbereadasanumber conceptually like parser whose input represent set union number parser stringtonumberparser would look like first need aware elixir separate function parsing integer float stringtonumberparser need union stringtofloat parser stringtointeger parser let write basic building block first def floatstring input case isbinary input floatparse input n resultok n resulterror string representation float inspect input end end iex floatstring ok iex floatstring ok iex floatstring ok iex floatstring error string representation float iex floatstring foo bar error string representation float foo bar let write analogous parser integer def integerstring input case isbinary input integerparse input n resultok n resulterror string representation integer inspect input end end iex integerstring ok iex integerstring error string representation integer iex integerstring error string representation integer okay building block need let create parser represents union three requirement let see remember based code def numericstring input unionparser union unionparser input end union come easy part dataparser module exactly need try apply parser received order us first successful result bail appropriate message take look entire parsing program defmodule alias feresult import dataparser union def new input numericstring input resultandthen resultandthen end defp numericstring input unionparser union unionparser input end defp integerstring input case isbinary input integerparse input n resultok n resulterror string representation integer inspect input end end defp floatstring input case isbinary input floatparse input n resultok n resulterror string representation float inspect input end end defp anumber input isnumber input resultok input defp anumber input resulterror number input defp nonnegative input input resultok input defp nonnegative input resulterror input defp input input resultok input defp input resulterror input end function public function main workhorse contains result pipe railwayoriented program first step pipe say apply parser union anumber integerstring floatstring one parse successfully pas input nonnegative successful pas result returning whatever come last step presto module encapsulates parsing rule built rather verbosely hand sake learning expose one function precisely smart constructor certain every value created exactly claim validation work iex ok iex ok iex error try parse input satisfy union parser get swanky detailed domainerror structure iex hello error errordomainerror causedby nothing detail input hello parser function function function reason noparserapplies leveraging builtin dataparsers lot work building smart constructor hand save lot time using parser bundled data package particular parser generator function take predicate function map onto parser semantics first argument predicate function second either default error function receives bad input leverage second argument retain nice error message time form tagged tuples module golfed like defmodule alias feresult import dataparser union predicate def new input union predicate notanumber input resultandthen predicate isnegative resultandthen predicate end defp integerstring input case isbinary input integerparse input n resultok n resulterror string representation integer inspect input end end defp floatstring input case isbinary input floatparse input n resultok n resulterror string representation float inspect input end end end iex error iex ok iex error isnegative look pretty good still repetitive floatstring integerstring function differ elixir module used call let convert new style parser interface quite simple return function take single argument return resultt def stringreprof mod mod integer float fn input case isbinary input modparse input n resultok n resulterror string representation inspect mod inspect input end end end partially apply function module name receive nice parser work like iex stringreprof float ok iex stringreprof float foo error string representation float foo iex stringreprof integer error string representation integer iex stringreprof integer ok turn stringreprof parserbuilder part builtin suite parser come dataparser called stringof return detailed error struct failure work principle compose parser together arrive rather succinct smart constructor defmodule alias feresult import dataparser union predicate import dataparserbuiltin stringof def new input union predicate notanumber stringof integer stringof float input resultandthen predicate isnegative resultandthen predicate end end summing gone manually specifying railwayoriented parsing function special numeric data point leveraging power parser combinators specifying data point declarative fashion might rightly complain original code shorter le dependency job faster declarative smart constructor artificial scenario might indeed prudent go straightforward approach overengineered numeric bracket function quite bit indeed however hope show next installment declarative method really shine data parse becomes complex exhibit internal dependency stay tuned turn parse validate gnarly json payload correctbyconstruction elixir structs
3,Lobsters,elixir,Elixir programming,Elixir RAM and the Template of Doom,https://www.evanmiller.org/elixir-ram-and-the-template-of-doom.html,elixir ram template doom,elixir ram template doom evan miller gather script tracing limit le costly phoenix request request template doom parting wisdom phoenix chicago bos dtrace note evanmillerorg twitter r wizard data le time communicate discovery visually back evan home page subscribe r twitter youtube,elixir ram template doom evan miller april attempt convince two line code elixir interesting programming language ever used ready worry code involve quicksort metaprogramming anything like go ok file fileopen tmpsomethingtxt write raw filewrite file rereplace hello goodbye amp code nothing special open file writes short string replacing ampersand hardcoded string html entity amp probably sharp enough write equivalent code favorite language couple minute le code entirely equivalent elixir code least perspective run tracing program like strace dtruss nonelixir code probably see something like write hello usual syscall expect trace elixir program instead see something like writev give strange hexadecimal number point good old write good enough mr fancy pant elixir answer immediately obvious code sample go long way towards explaining unique performance characteristic well anomaly might encounter ever try benchmarking erlang elixirâ html template read tale technical subtlety engineering culminates inmemory rendering template doom gigabyte monster bottom sea end post promise look web server way anyway enough gabbing dive gather get handle thing first revisit stringreplacement code rereplace hello goodbye amp paste code elixir shell see something slightly unexpected hello amp goodbye instead flat string erlang oops say erlang meant elixir creates nested list containing four leaf element add string expect hello amp goodbye first glance may seem like pointless complication see computer think situation look man page writev see mean writes data multiple memory location single system call wrote little dtrace script unpack writev call saw earlier peek elixir code actually system call log script writev return writev data byte hello writev return writev data byte writev return writev data byte amp writev return writev data byte goodbye original hexademical number writev call introduction memory address vector vector contains memory address four memory address represented big hexadecimal number next string address see log elixir writing element nested list separately hello amp goodbye notice anything peculiar memory location one perhaps look like others hello amp goodbye good hexadecimal lay character stated memory address simply rearranging expanding data log boldfacing start address clarity p h e l l g b e see yet nested list string fragment list make new string start make sense three pointer original string plus outoforder pointer replacement string word set modification old string also see extra tiny optimization performed regex engine notice final string us ampersand original string rather replacement string data structure called io list designed leverage writev thus minimize data copy writing disk network language wipe original string copy whole thing missing whole class nocopy latecopy performance optimization course pointer panacea sometimes data copying cheaper pointer juggling use dtrace explore erlang vm implementation see system draw various line attempt balance engineering consideration tracing limit try tracing two line code filewrite file enummap fn foobar end filewrite file enummap fn foobar end attempt write io list file first one foobar repeated time second foobar repeated time might think task result syscalls reality first line code call writev vector element second one flattens io list single blob memory call write concatenated data much language try string slightly longer shorter foobar see trigger simply number element list rather total size resulting string hit element list erlang switch concatenating data contiguous chunk memory poke around vm code see triggered constant smallwritevec dtrace log vector reveals something else writev something might surprise take look writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar notice anything memory address well strain eye mean point different address copy foobar lying around memory interestingly case move foobar literal outside closure elixir code trace code instead foobar foobar filewrite file enummap fn foobar end see end result get rather different trace writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar time memory address work hood small string elixir instantiated wherever literal appears code foobar inside closure new string created whenever closure executed foobar outside closure execution closure result new reference string coming say javascript point might seem obvious remember string elixir immutable necessarily expect new instantiation execution code fact rule change string defined byte larger second magic number erlonheapbinlimit vm code big literal appear compiled module allocated shared heap refcounted see memory address trace regardless literal appears code worth noting string literal elixir shell always use smallstring rule complicated might thinking great care foobar got le costly show benchmark going blow mind make question everything thought knew web server performance well everything except great stuff learned article far ready going back something like scene raider lost ark one face melt head explodes simply unsee two elixir template wired excellent phoenix web framework template first iters blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah end template second iters blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah end template produce identical output lot blahblahblahblah difference second template insert string length zero middle iteration going believe one template greater throughput get excited caching computed template fragment better close look benchmark output benchmark first template without empty string running test http thread connection thread stats avg stdev max stdev latency reqsec request read socket error connect read write timeout requestssec transfersec benchmark second template empty string running test http thread connection thread stats avg stdev max stdev latency reqsec request read socket error connect read write timeout requestssec transfersec ruhroh inserting empty string template increase performance could learned anything far syscalls matter strace dtrace friend use look template perspective first template produce lot output like writev return writev data byte nblahblahblahblah second template produce output like writev return writev data byte ok first template delivered client tiny byte chunk empty string included second template along http response header flattened one big kilobyte string instead verrrrrrrry interesting tell least little curious going discrepancy traced another compiletime constant erlang vm one known erlsmalliobinlimit determines maximum string size consolidated one big string hardcoded four time value erlonheapbinlimit byte exact string smaller equal limit consolidated larger string preserved writev vector notice template example deliberately contrived byte chunk blahblahblahblah exceed limit get entry writev vector split chunk half true nefarious purpose mysterious empty string resulting chunk limit get consolidated happens computer consolidation greater throughput particular template come cost higher ram usage brings template doom enough information render template doom recently recovered sunken spanish galleon doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom end template produce file word doom repeated billion time totaling gb size template consists entirely chunk larger byte chunk compiled refer memory address know server storing million boxed pointer order magnitude gb machine vm topped gb ram usage serving single copy template doom best part make template doom crash server inserting empty string template dare try rather secondbest part best part understand crash email implemented template doom assembly using five molecule ram remember silly benchmark underpowered macbook point exercise empty string template string million time order save help give tool understand going hood system engineering situation call small memory footprint tinychunk writev strategy may better others great cpu caching slabofram may fine exercise starting point exploration parting wisdom memory architecture fit neatly onto problem dynamic template rendering rendering speed killing productivity making customer swim black pool pageload depression take look phoenix chicago bos framework work writev io list well kqueueepoll slash cpu ram usage compared nonerlang system many case obviate need serverside erlang vm clever produce oddity highly informal testing look like erlsmalliobinlimit particular cranked bit perhaps byte guardian vm might consider making tunable compiletime parameter using erlang elixir might want poke around favorite template implementation see using writev hood tracer make quick work task strace linux dtruss o x good start absolutely nothing beat dtrace power see writev trace log might opportunity improving memory architecture keep eye memory location trace output little string reuse go long way finally enjoyed using elixir code example found library could make better use io list particularly regex string module well html entityescaping without io list elixir eagercopying memory like everybody else missing one feature make erlang vm technically interesting note reading evanmillerorg random collection math tech musing liked might also enjoy get new article published via twitter r want look statistical pattern mysql postgresql sqlite database desktop statistic software wizard help analyze data le time communicate discovery visually without spending day struggling pointless command syntax check back evan home page subscribe r twitter youtube
4,Lobsters,elixir,Elixir programming,Minimum Viable Phoenix,http://www.petecorey.com/blog/2019/05/20/minimum-viable-phoenix/,minimum viable phoenix,minimum viable phoenix application confused first compilation also evaluation mix build tool cowboy plug macro initial configuration plug pipeline defines helper function hood generates handful helpful macro modulebased plug establishes plug automatic layout view module detection view controller module configuration option final thought phoenix codebase elixir metaprogramming plug,phoenix ship quite bell whistle whenever fire mix phxnew create new web application forty six file created spread across thirty directory overwhelming developer new phoenix build better understanding framework moving piece interact let strip phoenix bare bone let start zero slowly build minimum viable phoenix application starting beginning need recognize phoenix application elixir application first step process building minimum viable phoenix application really build minimum viable elixir application interestingly simplest possible elixir application simply ex file contains source code set success later let place code libminimalapplicationex start simply printing hello console ioputs hello surprisingly execute newly written elixir application compiling elixirc libminimalapplicationex hello confused first explained elixir world compilation also evaluation libminimalapplicationex ioputs hello executionbycompilation work really nothing onthefly evaluation generating compilation artifact reused later deployed elsewhere fix moving code module compile newly modularized applicationex new elixirminimalapplicationbeam file appear root project run compiled elixir program running elixir directory contains beam file specifying expression evaluate using e flag elixir e minimalapplicationstart hello similarly could spin interactive shell iex directory evaluate expression iex minimalapplicationstart hello gitignore beam dsstore libminimalapplicationex ioputs hello defmodule minimalapplication def start ioputs hello end end great manually managing beam file bootstrap expression little cumbersome mention fact even started working dependency yet let make life easier incorporating mix build tool application development process creating mixexs elixir script file root project defines module us mixproject describes application write callback new mixproject module requirement return application name minimal version def project app minimal version end mix requires return app version configuration value worth taking look configuration option available u especially elixir startpermanent buildpath elixircpaths others next need specify callback mixproject module tell mix module want run application fire def application mod minimalapplication end pointing minimalapplication module wrote previously normal application startup process elixir call function module specify normal first argument whatever specify case second mind let modify function accept parameter def start normal ioputs hello ok self end notice also changed return value ok tuple whose second value pid normally application would spin supervisor process first act life return pid yet simply return current process pid change done run application mix mix run fire interactive elixir shell iex mix bootstrap expression required gitignore beam dsstore dsstore build libminimalapplicationex defmodule minimalapplication def start def start normal ioputs hello ok self end mixexs defmodule minimalmixproject use mixproject def project app minimal version end def application mod minimalapplication end end built minimum viable elixir project let turn attention phoenix framework first thing need incorporate phoenix elixir project install dependency start adding deps array callback mixexs file deps list phoenix plugcowboy jason dependency default mix store downloaded dependency deps folder root project let sure add folder gitignore done install dependency mix depsget reliance phoenix make sense already pulling plugcowboy jason hood phoenix us cowboy web server plug compose functionality top web server would make sense phoenix relies plugcowboy bring two component application try go building application without installing plugcowboy greeted following error undefinedfunctionerror function undefined module plugcowboy available plugcowboychildspec scheme http plug minimalwebendpoint similarly phoenix relies json serialization library installed configured without either jason poison installed receive following warning trying run application warning failed load jason phoenix json encoding module jason available ensure jason exists deps mixexs configured phoenix use json encoding verifying following exists configconfigexs config phoenix jsonlibrary jason heeding advice install jason add configuration line new file project configconfigexs gitignore build deps configconfigexs use mixconfig config phoenix jsonlibrary jason mixexs app minimal version version deps jason phoenix plugcowboy installed dependency phoenix framework web server us hood time define web server incorporates application defining endpoint application interface underlying http web server client interface web application following phoenix convention define endpoint creating minimalwebendpoint module us phoenixendpoint specifies name otp application minimal defmodule minimalwebendpoint use phoenixendpoint otpapp minimal end macro phoenixendpoint quite bit heaving lifting among many thing load endpoint initial configuration set plug pipeline using plugbuilder defines helper function describe endpoint otp process curious phoenix work low level start search phoenixendpoint us value provide otpapp look configuration value application phoenix complain provide bare minimum configuration entry endpoint add configconfigexs file config minimal minimalwebendpoint configuration value want pas endpoint like host port want serve value usually environmentdependent add line bottom configconfigexs load another configuration file based current environment importconfig mixenv ex next create new configdevexs file specifies host port serve development use mixconfig config minimal minimalwebendpoint url host localhost http port start application point still greeted hello printed console rather running phoenix server still need incorporate phoenix endpoint application turning minimalapplication proper supervisor instructing load endpoint supervised child use application def start normal supervisorstartlink minimalwebendpoint strategy oneforone end done fire application using mix phxserver iex mix phxserver see endpoint listening localhost port alternatively want use old standby mix run either configure phoenix serve endpoint startup mix phxserver hood config phoenix serveendpoints true configure application endpoint specifically config minimal minimalwebendpoint server true configconfigexs config minimal minimalwebendpoint config phoenix jsonlibrary jason importconfig mixenv ex configdevexs use mixconfig config minimal minimalwebendpoint url host localhost http port libminimalapplicationex defmodule minimalapplication use application def start normal ioputs hello ok self supervisorstartlink minimalwebendpoint strategy oneforone end libminimalwebendpointex defmodule minimalwebendpoint use phoenixendpoint otpapp minimal end phoenix endpoint listening inbound http request u much good serving content first step serving content phoenix application configure router router map request sent route path web server specific module function function job handle request return response add route application making new module minimalwebrouter us phoenixrouter defmodule minimalwebrouter use phoenixrouter end instruct minimalwebendpoint use new router plug minimalwebrouter phoenixrouter module generates handful helpful macro like match get post configures modulebased plug reason seamlessly incorporate endpoint using plug macro router wired endpoint let add route application get minimalwebhomecontroller index instructing phoenix send http get request function minimalwebhomecontroller controller module minimalwebhomecontroller module need use phoenixcontroller provide minimalweb module namespace configuration option defmodule minimalwebhomecontroller use phoenixcontroller namespace minimalweb end phoenixcontroller like phoenixendpoint phoenixrouter quite bit establishes plug using phoenixcontrollerpipeline us namespace module provide automatic layout view module detection controller module essentially glorified plug expect phoenix pas conn first argument specified controller function userprovided parameter second argument like plug function return potentially modified conn def index conn params conn end returning unmodified conn like essentially noop let spice thing bit return simple html response requester simplest way use phoenix builtin function take conn first argument html want send back client second phoenixcontrollerhtml conn hello dig find using plug builtin function plugconnsendresp conn hello ultimately modifying conn structure directly conn status respbody hello state set three expression identical use whichever one choose return html fragment controller follow best practice stick phoenix helper function libminimalwebcontrollershomecontrollerex defmodule minimalwebhomecontroller use phoenixcontroller namespace minimalweb def index conn params phoenixcontrollerhtml conn hello end end libminimalwebendpointex use phoenixendpoint otpapp minimal plug minimalwebrouter end libminimalwebrouterex defmodule minimalwebrouter use phoenixrouter get minimalwebhomecontroller index end phoenixbased web application successfully serving content route navigate http greeted friendly homecontroller behind scene issue browser automatically request faciconico asset server idea respond request asset exist phoenix kill request process automatically return http status code need way handing request missing content thankfully stack trace phoenix gave u killed request process give u hint request get faviconico exit exception raised undefinedfunctionerror function undefined module minimalweberrorview available minimalweberrorviewrender conn phoenix attempting call first argument request conn second finding module function exist let fix defmodule minimalweberrorview def render assigns found end end function view controller return content want render response conn said distinction view controller may outside scope building minimum viable phoenix application skim sure read move errorview module incorporates application endpoint also note module called render error customizable rendererrors configuration option libminimalwebviewserrorviewex defmodule minimalweberrorview def render assigns found end end final thought minimum viable phoenix application probably worth pointing using phrase minimum viable loosely sure people come minimal phoenix application similarly sure concept tool left like view template would cause people argue example minimal idea explore phoenix framework ground building requisite component without relying automatically generated boilerplate like think accomplished goal certainly learned thing two one thing taken away process magic behind phoenix everything understood little familiarity phoenix codebase healthy understanding elixir metaprogramming little knowledge plug
5,Lobsters,elixir,Elixir programming,"Hacking the Pleroma: Elixir, Phoenix and a bit of ActivityPub",https://wimvanderbauwhede.github.io/articles/hacking-pleroma/,hacking pleroma elixir phoenix bit activitypub,pleroma stolen lain blog post elixir phoenix elixir elixir documentation guide erlang phoenix phoenix endpoint endpoint plug phoenixcodereloader router router controller controller activitypubcontroller view view template template ecto ecto genserver genserver application worker supervisor application supervisor supervisorspec mix mix hacking pleroma fork pleroma adding worker main pleroma application bit activitypub activitypub getting message processing message posting reply pleroma source tree pleroma source tree,pleroma microblogging server software federate exchange message server support federation standard ostatus activitypub mean host server friend stay control online identity still exchange message people larger server pleroma federate server implement either ostatus activitypub like gnu social friendica hubzilla mastodon stolen lain blog post recently modified pleroma instance support bot service parse posted message take action post result get learn elixir language pleroma written well phoenix web framework elixir us little bit activitypub protocol exchanging message want explain particular architecture pleroma hack easily fun want participate development elixir pleroma written elixir need learn language extent familiar ruby perl matter idea functional programming everything function quite easy learn understand documentation guide good never hear functional programming main difference eg ruby java elixir use objectoriented programming model instead function manipulate data structure function particular consequence functional model whileloops instead called higherorder function eg apply another function list elixir program also make lot use recursion another point elixir web programming language built system process communicate passing message one another built way process dy normally restarted automatically approach make easy offload work separate worker process etc come courtesy erlang language elixir built powerfull otp framework building application beam virtual machine manages process phoenix lot groundwork pleroma done phoenix easytouse web server framework essentially happens end user access application using specific url typically via web browser based url application performs number action end result change state application usually shown browser window phoenix five stage component connection resulting action application endpoint endpoint boundary request web application start also interface application provides underlying web server pleroma endpoint webendpointex look source see several occurrence plug plug plug specification composable module web application heavily used pleroma example serve specific static filesfolders privstatic plug plugstatic pleroma w indexhtml static finmoji emoji pack sound image instance swjs another nice feature phoenis edit code server running get automatically recompiled affected process automatically restarted courtesy phoenixcodereloader code reloading explicitly enabled codereloader configuration endpoint codereloading plug phoenixcodereloader end router router main hub phoenix application match http request controller action wire realtime channel handler define series pipeline transformation scoping middleware set route pleroma router webrouterex key function router pipeline let create pipeline plug function scope get post pipethrough let match url whether dealing get post request define appropriate pipeline action example federated activitypub request handled follows scope pleromawebactivitypub pipethrough activitypub post user nicknameinbox activitypubcontroller inbox post inbox activitypubcontroller inbox end pipethrough activitypub call used insert custom pipeline pipeline activitypub plug accepts activityjson plug pleromawebplugshttpsignatureplug end controller controller used group common functionality pluggable module pleroma make heavy use controller almost every request handled specific controller given protocol eg mastodonapicontroller activitypubcontroller make easy identify file work need make change code given protocol example activitypub post request router handled inbox function activitypubcontroller def inbox assigns validsignature true conn params federatorenqueue incomingapdoc params json conn ok end view view used control rendering template create view module template set assigns basically keyvalue pair pleroma us view rendering json object example webactivitypubactivitypubcontrollerex line like json userviewrender userjson user user userviewrender defined webactivitypubviewsuserviewex number different json string really template simply used pattern match function definition conventional usage create html also used eg template webtemplatesmastodonapimastodonindexhtmleex used webmastodonapimastodonapicontrollerex via view webmastodonapiviewsmastodonviewex render mastodonview indexhtml initialstate initialstate template template text file typically html page elixir code generate specific value based assigns included example pleroma mastodon frontend us template indexhtml file code applicationgetenv pleroma instance name show name instance ecto ecto part phoenix integral part web application ecto elixir main library working database provides tool interact database common api ecto split main component ectorepo repository wrapper around data store via repository create update destroy query existing entry repository need adapter credential communicate database pleroma us postgresql database ectoschema schema used mainly map table elixir data use case ectochangeset changesets provide way developer filter cast external parameter well mechanism track validate change applied data ectoquery written elixir syntax query used retrieve information database genserver elixir like erlang us processeswithmessagepassing paradigm clientserver relationship common abstracted behaviour elixir specification composable module implement specified public function bit like interface java typeclass haskell look federatorenqueue function implementation actually reduces single line genservercast module enqueue type payload priority genserver elixir behaviour module implementing server clientserver relation cast call sends asynchronous request server synchronous request use call server behaviour implemented using handlecast callback handle cast call pleromafederator implemented module enqueue function hence use module rather hardcoded module name application worker supervisor elixir borrows concept supervision tree erlangotp application consists tree process either supervisor worker task supervisor ensure worker process work including distributing work restarting worker process die supervisor supervise either worker supervisor build supervision tree elixir provides application behaviour module supervisor module make easy application module requires start function entry point typical code create supervision tree supervisorstartlink child opts startlink spawn top process tree spawn child process list child pleroma us convenient deprecated module called supervisorspec provides worker supervisor function example child supervisor pleromarepo supervisor pleromawebendpoint worker pleromawebfederator every worker startlink function eg webfederatorfederatorex find def startlink genserverstartlink module end mean federator module borrows startlink genserver module common way create worker mix mix build tool elixir main advantage build script also written elixir key mix action provided phoenix example build run final pleroma application action mix phxserver hacking pleroma brief tour elixir phoenix want give example adding simple bot functionality pleroma see fork pleroma code bot par incoming message pixelbot extract list pixel message modifies canvas new pixel creates png image result post link png image adding worker updating canvas creating png image could timeconsuming especially canvas large put functionality separate server module added list worker main pleroma application child botenabled else worker pleromabotspixelbot getcanvassize id pixelbot bot take size canvas configexs using helper function getcanvassize id pixelbot allows access worker name application start launch pixelbot worker botspixelbotex worker call init function part genserver behaviour load last canvas file bit activitypub one protocol used federation activitypub specification long easy read however purpose hacking pleroma mainly help understand structure activitypub action case post activity actor userurl data actor userurl cc userurl follower context instanceurl context contextid id instanceurl activity activityid object actor userurl attachment name imagefilename type image url href instanceurl medium uuid imagefilename mediatype imagepng type link uuid uuid cc userurl follower content contentstr context instanceurl context contextid emoji id instanceurl object objectid published summary tag http public type note published http public type create id id insertedat ndt local true recipient http public userurl follower updatedat ndt case instanceurl http pynqlimitedsystems userurl userurl userspixelbot imagefilename canvaspng contentstr canvas br href instanceurl medium uuid imagefilename classattachment imagefilename pleroma activity linked ecto repository pleromarepo repoex module pleromaactivity activityex defines schema getting message bot support activitypub seen pleroma incoming message handled inbox function activitypubcontroller webactivitypubactivitypubcontrollerex put little hook detect message pixelbot actual message body content def inbox assigns validsignature true conn params header enuminto connreqheaders ismap params maphaskey params nickname maphaskey params object params nickname pixelbot ismap params object maphaskey params object content content params object content genservercast pleromabotspixelbot content ok else nok end else nok end see content message pixelbot passed pixelbot worker processing using genservercast pleromabotspixelbot content call processing message pixelbot worker par message extract pixel botspixelbotparsemessagesex update canvas list list writes content file call external program create final image posting reply finally bot post status public timeline botspixelbotpixelbotpoststatusex status contains current time link latest canvas function pixelbotpoststatus creates status wrap correct structure required activitypub also get user object based nickname via pleromausergetcachedbynickname nickname like activity user object defined via schema linked ecto repository userex user code complicated object url nickname finally function call activitypubcreate creates activity case mean post status def pixelbotpoststatus datetimetostring datetimeutcnow nickname pixelbot user pleromausergetcachedbynickname nickname visibility public getvisibility data instanceurl http pynqlimitedsystems userurl userurl userspixelbot imagefilename http public cc userurl follower context instanceurl contextspixelbotdummycontext object actor userurl attachment name imagefilename type image url href instanceurl pixelbot imagefilename mediatype imagepng type link uuid pixelbotdummyuuid cc userurl follower content canvas br href instanceurl pixelbot imagefilename classattachment imagefilename context context emoji summary nil tag http public type note re pleromawebactivitypubactivitypubcreate actor user context context object object additional cc cc pleromauserincreasenotecount user re end pleroma source tree part pleroma source tree show file mentioned libpleroma activityex applicationex notificationex objectex plug authenticationplugex httpsignatureex oauthplugex repoex userex web activitypub activitypubex activitypubcontrollerex transmogrifierex utilsex view objectviewex userviewex commonapi commonapiex utilsex endpointex federator federatorex mastodonapi mastodonapiex mastodonapicontrollerex mastodonsocketex view mastodonviewex routerex template mastodonapi mastodon indexhtmleex webex webfinger webfingerex webfingercontrollerex
6,Lobsters,elixir,Elixir programming,Homemade analytics with Ecto and Elixir,https://dashbit.co/blog/homemade-analytics-with-ecto-and-elixir,homemade analytics ecto elixir,homemade analytics ecto elixir tracking upserts async batched writes process dynamic process elixir registry elixir plug summary,homemade analytics ecto elixir dashbit website wanted avoid tracking user much possible mean cooky unfortunately analytics use cooky tracking andor fingerprinting however still want see page website frequently accessed purpose decided roll analytics system article cover implemented analytics system ecto upserts used elixir registry elixir process reduce pressure database tracking upserts idea simple every time someone access page store information database however need track access instant happen u tracking many access page day completely fine therefore every time page accessed given date attempt insert entry database entry already exists update counter instead luckily done upsert ecto let first define schema database resource defmodule myappmetricsmetric use ectoschema primarykey false schema metric field date date primarykey true field path string primarykey true field counter integer default end end three field date page path counter number access date path make composite primary key migration look like defmodule dashbitrepomigrationscreatemetrics use ectomigration def change create table metric primarykey false add date date primarykey true add path string primarykey true add counter integer default end end end execute following command whenever want count one page access defp upsert path counter import ectoquery date dateutctoday query dashbitmetricsmetric update inc counter counter dashbitrepoinsert dashbitmetricsmetric date date path path counter counter onconflict query conflicttarget date path end code performs upsert incrementing number access page value counter typically entry exist one immediately created core analytics straightforward solution strong requirement database accepting writes application heavily rely database analytics system place website us database believe important show article blog post even error talking storage layer address decided move upserts separate process async batched writes process laid previous section want move database writes done analytics code separate process another concern solution far handle overload huge spike traffic could end putting much pressure database sense would good idea batch writes honest application fine spike page load within hundred microsecond thanks phoenix database usage minimal hand small project perfect opportunity experiment decided explore analytics solution would look like performed writes asynchronously batch came every time user access page spawn elixir process track access page process already exists said page message existing process instead goal process collect access within time interval writing database x second going call worker process start like defmodule dashbitmetricsworker use genserver restart temporary define module process declare genserver also say process temporary ie dy want supervisor restart assuming process dy logic dynamically spawn process page eventually start new one anyway next define init callback process impl true def init path processflag trapexit true ok path counter end init callback trap exit set process state path first element page path second element number page visit process able receive bump message message sent whenever need bump counter handled handleinfo callback impl true def handleinfo bump path scheduleupsert noreply path end impl true def handleinfo bump path counter noreply path counter end receive bump page access ie counter zero bump counter also schedule upsert event eventually write access database counter simply bump return updated state scheduling upsert code look like defp scheduleupsert processsendafter self upsert enumrandom end impl true def handleinfo upsert path counter upsert path counter noreply path end defp upsert path counter function previous section end scheduleupsert function schedule message current process self message named upsert delivered random value reason picked random value avoid scenario multiple process different page spawned time write database time next define another handleinfo clause time handle scheduled upsert message clause simply invokes upsert function defined previous section reset state back path make new bump schedule new upsert finally implement terminate callback invoked whenever application shutting impl true def terminate path ok def terminate path counter upsert path counter end application shutting may pending writes worker want send database part termination logic one important thing remember terminate callback called default shutting unless trapping exit called processflag trapexit true init function process implemented delivers requirement far writes asynchronous happen separate process also batched using interval last step need implement actually spawn process fly user navigate website dynamic process elixir registry order spawn find process page going use elixir registry also need dynamic supervisor going parent worker process let implement logic overaching metric module alongside bump page function let get started basic defmodule dashbitmetrics use supervisor worker dashbitmetricsworker registry dashbitmetricsregistry supervisor dashbitmetricsworkersupervisor dashbitmetrics module supervisor two child registry supervisor worker since worker started dynamically request come use dynamicsupervisor store name worker registry dynamic supervisor process module attribute convenience next define supervisor started init callback def startlink opts supervisorstartlink module ok name module end impl true def init ok child registry key unique name registry dynamicsupervisor name supervisor strategy oneforone supervisorinit child strategy oneforall end registry dynamic supervisor place write bump function def bump path isbinary path pid case registrylookup registry path pid pid case dynamicsupervisorstartchild supervisor worker path ok pid pid error alreadystarted pid pid end end send pid bump end end bump function look registry process given path return process identifier pid one exist ask worker supervisor start worker dynamically expect two possible outcome startchild ok pid worker started error alreadystarted pid worker given path already exists need second branch address potential race condition two user may access page first time time scenario fail attempt spawn worker one succeed return already started error find pid send bump message almost two step left first need configure worker register whenever started done via startlink function let go back worker add registry dashbitmetricsregistry def startlink path genserverstartlink module path name via registry registry path end need start dashbitmetrics supervision tree typically done application supervision tree typically located libmyappapplicationex child dashbitrepo dashbitmetrics dashbitendpoint whenever user access page need call dashbitmetricsbump path path current page address case store path without host without query string using plug built connpathinfo field also perform writes page successfully rendered status overall bumping code look like plug bumpmetric defp bumpmetric conn opts registerbeforesend conn fn conn connstatus path enumjoin connpathinfo dashbitmetricsbump path end conn end end summary article covered minimal analytics system using ecto genserver elixir registry performs writes asynchronously batch usage registry dynamically spawn process map different resource lifecycle used many different scenario one important aspect solution process page created stay alive new deployment work u le page know maximum number process bound low value although elixir process lightweight thanks erlang vm large number page million page could potentially endup hundred thousand unused process case would slightly change solution terminate process every upsert something along line impl true def handleinfo upsert path counter first unregister stop receiving new message registryunregister registry path schedule stop second give u time process late message processsendafter self stop noreply path counter end impl true def handleinfo stop path counter stop terminate callback write pending writes stop shutdown path counter end hope enjoyed article learned thing two could useful next project
7,Lobsters,elixir,Elixir programming,sorentwo/oban - Robust job processing in Elixir,https://github.com/sorentwo/oban,sorentwooban robust job processing elixir,enterprise grade feature table content official documentation hexdocs feature reliability consistency observability advantage tool fewer dependency rdbms transactional control database backup advanced feature isolated queue queue control resilient queue job canceling triggered execution unique job scheduled job periodic cron job job priority historic metric node metric queue draining telemetry integration telemetry requirement oban webpro getobanpro installation hex ecto jason postgrex usage note release usage configuring queue caveat guideline defining worker enqueueing job pruning historic job caveat guideline unique job strong guarantee performance note periodic job standard rule cron expression crontab guru caveat guideline prioritizing job testing caveat guideline usage integration testing error handling error detail instrumentation limiting retries limiting execution time instrumentation logging telemetry reporting error sentry isolation supervisor isolation community contributing,robust job processing elixir backed modern postgresql reliable observable loaded enterprise grade feature table content note readme unreleased master branch please reference official documentation hexdocs latest stable release feature oban primary goal reliability consistency observability fundamentally different background job processing tool retains job data historic metric inspection leave application running indefinitely without worrying job lost orphaned due crash advantage tool fewer dependency running web app good chance running top rdbms running job queue within postgresql minimizes system dependency simplifies data backup transactional control enqueue job along database change ensuring everything committed rolled back atomically database backup job stored inside primary database mean backed together data relate advanced feature isolated queue job stored single table executed distinct queue queue run isolation ensuring job single slow queue ca nt back faster queue queue control queue started stopped paused resumed scaled independently runtime locally across running node even environment like heroku without distributed erlang resilient queue failing query wo nt crash entire supervision tree instead trip circuit breaker retried future job canceling job canceled middle execution regardless node running stop job flag discarded triggered execution database trigger ensure job dispatched soon inserted database unique job duplicate work avoided unique job control uniqueness enforced argument queue worker even subargument level period time scheduled job job scheduled time future second periodic cron job automatically enqueue job cronlike schedule duplicate job never enqueued matter many node running job priority prioritize job within queue run ahead others historic metric job processed row nt deleted instead job retained database provide metric allows user inspect historic job see aggregate data job queue argument level node metric every queue record metric database runtime used monitor queue health across node may used analytics queue draining queue shutdown delayed slow job finish executing shutdown shutdown start queue paused stop executing new job job left running shutdown grace period may rescued later telemetry integration job lifecycle event emitted via telemetry integration enables simple logging error reporting health checkup without plugins requirement oban developed actively tested elixir erlangotp postgresql running oban currently requires elixir erlang postgresql oban webpro webbased user interface managing oban along official set plugins worker available private package learn oban webpro getobanpro installation oban published hex add list dependency mixexs def deps oban end run mix depsget install oban dependency including ecto jason postgrex package installed must create database migration add obanjobs table database mix ectogenmigration addobanjobstable open generated migration editor call function obanmigrations defmodule myapprepomigrationsaddobanjobstable use ectomigration def obanmigrationsup end specify version ensuring roll way back necessary regardless version migrated def obanmigrationsdown version end end run oban versioned migration database migration version idempotent never change release new version released may need run additional migration run migration create table next see usage integrate oban application start defining job note release using release may see postgrex error logged initial deploy deploy requiring oban migration error temporary migration completed queue start producing job normally usage oban robust job processing library us postgresql storage coordination oban instance supervision tree application mean wo nt started automatically must included application supervision tree configuration passed supervisor allowing configure oban like rest application configconfigexs config myapp oban repo myapprepo plugins obanpluginspruner queue default event medium libmyappapplicationex defmodule myappapplication moduledoc false use application alias myapprepo alias myappwebendpoint def start type args child repo endpoint oban obanconfig supervisorstartlink child strategy oneforone name myappsupervisor end conditionally disable crontab queue plugins defp obanconfig applicationgetenv myapp oban end end running test want disable plugins enqueuing scheduled job job dispatching altogether testing configtestexs config myapp oban crontab false queue false plugins false see installation instruction readme hexdocs guide detail migrate database configuring queue queue specified keyword list key name queue value maximum number concurrent job following configuration would start four queue concurrency ranging queue default mailer event medium may also use expanded form configure queue individual override queue default mailer limit pollinterval timerseconds event limit paused true declared mailer limit poll deschedule job every second event queue start paused state mean wo nt process anything called start nt limit number queue many job may execute concurrently queue additional guideline caveat guideline queue run many job possible concurrently configured limit make sure system enough resource ie database connection handle concurrent load queue limit local pernode global percluster example running queue local limit one three separate node effectively global limit three require global limit must restrict number node running particular queue job configured queue execute job queue stay database untouched careful many concurrent job make expensive system call ie ffmpeg imagemagick beam ensures system stay responsive load guarantee nt apply using port shelling command defining worker worker module work processing job minimum must define function called obanjob struct note args field job struct always string key regardless key type job enqueued args stored jsonb postgresql serialization process automatically stringifies key define worker process job event queue defmodule myappbusiness use obanworker queue event impl obanworker def perform obanjob args id id model myapprepoget myappbusinessman id case args inthe business ioinspect model votefor vote ioinspect vote model ioinspect model end ok end end use macro also accepts option customize max attempt priority tag uniqueness defmodule myapplazybusiness use obanworker queue event priority maxattempts tag business unique period impl obanworker def perform job business slowly ok end end successful job return ok ok value tuple value returned used control whether job treated success failure discarded completely deferred later see obanworker doc detail failure condition obantelemetry detail job reporting enqueueing job job simply ecto structs enqueued inserting database convenience consistency worker provide function convert args map job changeset suitable insertion id inthe business ofdoing business myappbusinessnew obaninsert worker default may overridden passing option id votefor none myappbusinessnew queue special maxattempts obaninsert job may scheduled specific datetime future id myappbusinessnew scheduledat u obaninsert job may also scheduled second time future id myappbusinessnew schedulein obaninsert unique job configured worker job built email brewster examplecom myappmailernew unique period field queue worker obaninsert job priority specified using integer default highest priority id myappbackfillernew priority obaninsert number tag added job dynamically time inserted id id id myapponboardmailernew tag mailer record id obaninsert multiple job inserted single transaction ectomultinew obaninsert bjob myappbusinessnew id obaninsert mjob myappmailernew email brewser examplecom repotransaction occasionally may need insert job worker exists another application case use build changeset manually id userid obanjobnew queue default worker otherappworker obaninsert preferred way inserting job provides oban advanced feature ie unique job however use application function necessary see full list job option pruning historic job job stats queue introspection built keeping job row database completed allows administrator review completed job build informative aggregate expense storage unbounded table size prevent obanjobs table growing indefinitely oban provides active pruning completed discarded job default pruning retains job second configure longer retention period providing maxage second pruner plugin set maxage minute config myapp oban plugins obanpluginspruner maxage caveat guideline pruning besteffort performed outofband mean limit soft job beyond specified age may pruned immediately job complete pruning applied job completed discarded reached maximum number retries manually killed never delete new job scheduled job job failed retried unique job unique job feature let specify constraint prevent enqueuing duplicate job uniqueness based combination args queue worker state insertion time configured worker job level using following option period number second job longer considered duplicate always specify period infinity used indicate job considered duplicate long job retained field field compare evaluating uniqueness available field args queue worker default three used key specific subset args consider comparing historic job allows job multiple keyvalue pair args compared using subset state job state checked duplicate available state available scheduled executing retryable completed discarded default state except discarded checked prevents duplicate even previous job completed example configure worker unique across field state second use obanworker unique period configure worker unique worker queue use obanworker unique field queue worker period configure worker unique executed use obanworker unique period state available scheduled executing consider url key rather entire args use obanworker unique field args worker key url use specify uniqueness across state including discarded use obanworker unique period state obanjobstates strong guarantee unique job guaranteed transactional lock database query rely unique constraint database make uniqueness entirely configurable application code without need database migration performance note application make heavy use unique job may want add index args column obanjobs table column considered uniqueness already covered index periodic job oban allows job registered cronlike schedule enqueued automatically periodic job registered list cron worker cron worker option tuples config myapp oban repo myapprepo crontab myappminuteworker myapphourlyworker args custom arg myappdailyworker maxattempts mon myappmondayworker queue scheduled tag monday daily myappanotherdailyworker job would executed follows myappminuteworker executed every minute myapphourlyworker executed first minute every hour custom args myappdailyworker executed midnight every day retries myappmondayworker executed noon every monday scheduled queue crontab format respect standard rule one minute resolution job considered unique minute prevents duplicate job multiple node across node restarts like job recurring job use queue specified worker module default one specified cron expression standard cron expression composed rule specifying minute hour day month weekday rule field comprised literal value wildcards step value range wildcard match value literal match step match value multiple range match value within range step value used conjunction range part may multiple rule rule separated comma allowed value field follows minute hour day month alias jan feb mar etc weekday alias sun mon tue etc following cron extension supported hourly daily well midnight weekly monthly yearly well annually reboot run boot across entire cluster specific example demonstrate full range expression first minute every hour every fifteen minute standard business hour dec day midnight december fri hour rush hour friday depth information see man documentation cron crontab system alternatively experiment various expression online crontab guru caveat guideline schedule evaluated utc unless different timezone configured see information configuring timezone worker used regular scheduled job long accept different argument duplicate job prevented transactional lock unique constraint worker used regular scheduled job must specify unique option le long running job may execute simultaneously scheduling interval shorter take execute job prevent overlap passing custom unique opts crontab config customargs scheduled true uniqueopts period state available scheduled executing config myapp oban repo myapprepo crontab myappslowworker args customargs unique uniqueopts prioritizing job normally available job within queue executed order scheduled override normal behavior prioritize deprioritize job assigning numerical priority priority allowed highest priority lowest default priority unless specified job equally high priority job higher priority execute job lower priority within particular priority job executed scheduled order testing oban provides helper facilitate testing helper handle boilerplate making assertion job enqueued use helper test must include testing module specify app ecto repo use obantesting repo myapprepo assert refute list job enqueued within integration test assertenqueued worker myworker args id refuteenqueued queue special args id assert args id allenqueued worker myworker also easily unit test worker function automates validating job args option worker result single function call assert ok performjob myworker id assert ok performjob myworker id attempt maxattempts assert error performjob myworker bad arg see obantesting module detail caveat guideline noted usage guideline running test disable job dispatching setting queue false queue nil testexs config keyword configuration deep merged setting queue wo nt effect disable plugins via plugins false default plugins fixed pruner nt necessary testing mode job created within sandbox rolled back end test additionally periodic pruning query raise dbconnectionownershiperror application boot disable cron job via crontab false periodic job nt useful testing scheduling lead random ownership issue sure use ecto sandbox testing oban make use database pubsub event dispatch job pubsub event never fire within transaction since sandbox test run within transaction event fire job wo nt dispatched config myapp myapprepo pool ectoadapterssqlsandbox integration testing integration testing may necessary run job work essential test complete ie sending email processing medium etc execute available job particular queue calling directly test example process pending job mailer queue testing business logic defmodule myappbusinesstest use myappdatacase async true alias myapp business worker test stay business business ok businessscheduleameeting email monty brewstercom assert success failure obandrainqueue queue mailer make assertion email delivery end end see additional detail error handling job return error value raise error exit execution detail recorded within error array job number execution attempt configured maxattempts limit job automatically retried future retry delay exponential backoff meaning job second attempt third fourth etc see obanworker documentation customizing backoff alternative backoff strategy error detail execution error stored formatted exception along metadata failure occurred attempt caused error stored following key utc timestamp error occurred attempt attempt number error occurred error formatted error message stacktrace see instrumentation doc example integrating external error reporting system limiting retries default job retried time number retries controlled maxattempts value set worker job level example instruct worker discard job three failure use obanworker queue limited maxattempts limiting execution time default individual job may execute indefinitely undesirable may define timeout millisecond callback worker module example limit worker execution time second def myappworker use obanworker impl obanworker def perform job somethingthatmaytakealongtime ok end impl obanworker def timeout job timerseconds end function accepts obanjob struct customize timeout using job attribute define timeout value job args def timeout args timeout timeout timeout define timeout based number attempt def timeout attempt attempt attempt timerseconds instrumentation logging oban provides integration telemetry dispatching library metric easy report oban metric backend attaching oban event example sample unstructured log handler defmodule myappobanlogger require logger def handleevent oban job start measure meta loggerwarn oban started metaworker measuresystemtime end def handleevent oban job event measure meta loggerwarn oban event metaworker ran measureduration end end attach handler success failure event applicationex event oban job start oban job stop oban job exception telemetryattachmany obanlogger event obantelemetry module provides robust structured logger handle oban telemetry event example attach within applicationex module ok obantelemetryattachdefaultlogger detail default structured logger information event metadata see doc obantelemetry module reporting error another great use execution data error reporting example integrating sentry report job failure defmodule errorreporter def handleevent oban job exception measure meta extra meta maptake id args queue worker mapmerge measure sentrycaptureexception metaerror stracktrace metastacktrace extra extra end def handleevent oban circuit trip measure meta sentrycaptureexception metaerror stacktrace metastacktrace extra meta end end telemetryattachmany obanerrors oban job exception oban circuit trip use exception event send error report honeybadger rollbar appsignal application monitoring platform isolation oban support namespacing postgresql schema also called prefix ecto prefix job table reside outside primary schema usually public multiple separate job table use prefix first specify within migration defmodule myapprepomigrationsaddprefixedobanjobstable use ectomigration def obanmigrationsup prefix private end def obanmigrationsdown prefix private end end migration create private schema table function trigger within schema database migrated specify prefix configuration config myapp oban prefix private repo myapprepo queue default job inserted executed using privateobanjobs table note write job privateobanjobs table need specify prefix manually insert job directly repo supervisor isolation obanjobs table isolated within schema notification event also isolated mean insertupdate event dispatch new job prefix run multiple oban instance different prefix system entirely isolated provided give supervisor distinct id configure application start three oban supervisor using public special private prefix respectively def start type args child repo endpoint supervisorchildspec oban name obana repo repo id obana supervisorchildspec oban name obanb repo repo prefix special id obanb supervisorchildspec oban name obanc repo repo prefix private id obanc supervisorstartlink child strategy oneforone name myappsupervisor end community place connect communicate oban user contributing run oban test suite must postgresql running locally database named obantest follow step create database create database run migration ensure commit pass ci run mix ci locally executes following command check formatting mix format checkformatted lint credo mix credo strict run test mix test raise run dialyzer mix dialyzer
8,Lobsters,elixir,Elixir programming,Assorted IEx tricks,http://blog.tap349.com/elixir/iex/2017/05/21/elixir-iex/#suppress-long-output---in-pry,assorted iex trick,elixir iex http hexdocspmiexiexhtml http hexdocspmiexiexhelpershtml http http iexexs alias quickalias quit iex http shell history http nithinbekalcompostselixirshellhistory http hexdocspmiexiexhtml moduleshellhistory http githubcomferderlanghistory get result last evaluated expression pry http hexdocspmiexiexhelpershtml cancel multiline command http http cancel reverse search http readlinekablamoorgemacshtml recompile current mix application pry http suppress long output pry http truncate long list string http http hexdocspmelixirinspectoptshtml force display list integer http githubcomelixirlangelixirwikifaq http wwwtheguildnlprintlistofintegersasintegersiniex elixir set option http hexdocspmelixirinspectoptshtml set inspect option used iex http hexdocspmiexiexhtml add nonprintable character,elixir iex may erlang shell eshell erl elixir shell iex iex unix shell bash etc http hexdocspmiexiexhtml http hexdocspmiexiexhelpershtml http closed http iexexs iex load file find project iexexs local alias pollute global namespace iex configs merged current project iexexs userwide config iexexs read alias content iexexs evaluated shell context used alias popular module cut typing alias neko achievement userrate else try use quickalias package though working tried quit iex http cc cr graceful cg q cr graceful cc cc graceful c graceful graceful way quit iex save shell history using erlanghistory update since erlangotp shell history supported box using instead erlanghistory patch way quit iex allow save shell history except last one c shell history http nithinbekalcompostselixirshellhistory git clone http githubcomferderlanghistorygit cd erlanghistory sudo make install shell history since stored erlanghistnonode nohost binary file plain text update shell history stored erlanghistory might need remove erlanghistnonode nohost work shell history saved quit iex gracefully using either cc cr cg q cr command erlanghistory must compiled new version erlangotp kernel get current version kernel library erl application whichapplications stdlib ert cxc kernel ert cxc current version update erlanghistory repo cd erlanghistory git make install cd erlanghistory sudo make install password erl make recompile recompile file copied make sure file copied file copied mean current version kernel library supported probably update erlanghistory repo update http hexdocspmiexiexhtml moduleshellhistory erlangotp possible get shell history passing flag enable vm http githubcomferderlanghistory since shell history supported box although initially disabled default port library erlangotp code base enable shell version setting shellhistory kernel environment variable enabled export erlaflags kernel shellhistory enabled added environment variable zshenv export erlaflags kernel shellhistory enabled using erlanghistory longer required though found easy way uninstall get result last evaluated expression pry http hexdocspmiexiexhelpershtml iex iex v optional argument passed return nth expression current iex session positive number indicates absolute position negative number indicates relative one say v v cancel multiline command http http iex foo iex break cancel reverse search http readlinekablamoorgemacshtml cu cu first cu cancel reverse search leaf found command cursor located end line second cu deletes line current cursor position backwards start line mbackspace standard hotkey delete previous word first mbackspace cancel reverse search leaf found command like cu subsequent press delete previous word one one recompile current mix application reload pry http also possible recompile specific module suppress long output pry http add another expression end line semicolon truncate long list string http http hexdocspmelixirinspectoptshtml collection default item iex ioinspect list limit infinity string charlists default byte iex ioinspect list printablelimit infinity force display list integer http githubcomelixirlangelixirwikifaq http wwwtheguildnlprintlistofintegersasintegersiniex see also elixir post character list section way print charlist collection codepoints set charlists option http hexdocspmelixirinspectoptshtml note always return string fact value passed charlists option except ascharlists act aslists iex inspect charlists aslists iex inspect charlists ascharlists e set charlists inspect option used iex http hexdocspmiexiexhtml iex iexconfigure inspect charlists aslists iex else set iex config file iexexs iexconfigure inspect charlists aslists option respected shell printing result expression evaluation add nonprintable character usually added iex
9,Lobsters,elixir,Elixir programming,Ecto Associations in Phoenix LiveView: One to Many,https://dennisbeatty.com/2019/08/20/ecto-associations-in-phoenix-liveview-one-to-many.html,ecto association phoenix liveview one many,ecto association relationship three type relationship example liveview github page one many relationship let know twitter database migration schema live view http template http phoenixhtml creating user listing role saving role user list http http make work realtime http http let know went let know twitter video youtube retweet others find youtube channel,video part series working ecto association phoenix liveview get update release next part please subscribe channel youtube enter email bottom post subscribe email update start want apologize mia past couple month got married end july quite bit past month still reception coming washington state weekend able get back regular cadence thanks understanding said start new series almost year half ago gave talk ecto lonestar elixirconf originally planned speak mostly model ecto association ended speaking upserting data got comment last post asking talk ecto association decided want next series cover let get started ecto association one important underlying principle relational database made table related relationship allow easily manage data keeping separate table ecto relationship often called association basically row one table associated one many type data table three main type association work one one one many many many go detail super familiar relational database design databaseguide pretty good article relationship three type relationship post series cover one three type assocations use database manage phoenix liveview example three part series working example admin panel user administration liveview would helpful case would able automatically update admin panel user case multiple admins making modification time normally use case probably worth effort required set realtime functionality phoenix liveview make simple definitely worth including begin want set application phoenix liveview make sure running latest version elixir erlang writing post using elixir erlang get latest version phoenix generator mix archiveinstall hex phxnew want create project call useradmin let cd useradmin directory get work post step get started phoenix liveview keep tutorial going obsolete little longer follow liveview github page follow along youtube video top post one many relationship post talking onetomany relationship tend common type relationship model useful maintaining data integrity example modeling user role many application user role administrator editor subscriber etc typically one role role given many different user user role would best defined onetomany relationship mean one role associated many user also see way around many different user one role data model example look something like question please let know twitter hopefully clarify better otherwise let go ahead set database database migration set onetomany relationship database typically adding foreign key id corresponds id row different table table make many relationship refer diagram case roleid field user table refers id field role table order properly set foreign key postgres requires u one table case role created create foreign key many table let start creating role table recommend leveraging ecto generator mix ectogenmigration createroles create migration file privrepomigrations directory let open migration file create table ecto automatically generate id column u need add name column defmodule useradminrepomigrationscreateroles use ectomigration def change create table role add name string end end end saving go ahead run mix ectomigrate make sure role table created correctly ready add user table let use generator mix ectogenmigration createusers open newly generated migration file want create table give user name also add roleid column reference role user tell ecto want create foreign key constraint database make sure user role always valid role exist role table defmodule useradminrepomigrationscreateusers use ectomigration def change create table user add name string add roleid reference role end end end go ahead run migration database everything need let set ecto schema handling data elixir schema let work context pattern create context libuseradminusersex create empty module defmodule useradminusers end nest schema create two new file libuseradminusersroleex libuseradminusersuserex let start roleex use ectoschema macro create ecto schema mirror migration defmodule useradminusersrole use ectoschema schema role field name string end end user schema time making small change rather directly reference roleid field let ecto manage association using belongsto defmodule useradminusersuser use ectoschema alias useradminusersrole schema user field name string belongsto role role end end basic code set work data let get started actual liveview work live view worked ecto database thing start get little interesting let start creating basic liveview boilerplate libuseradminwebliveuserlivenewex defmodule useradminwebuserlivenew use phoenixliveview def mount session socket ok socket end def render assigns l end end let hook libuseradminwebrouterex phoenix know use live view defmodule useradminwebrouter scope useradminweb pipethrough browser live usersnew userlivenew end end able start server mix phxserver visit http browser view new live view notice empty template far added content yet let go ahead create template template let start creating view module delegate template libuseradminwebviewsuserviewex let add following boilerplate defmodule useradminwebuserview use useradminweb view end let create actual template libuseradminwebtemplatesusernewhtmlleex start basic html replace phoenixhtml nicety new user form fieldset label namefield name label input type text id namefield label rolefield role label select id rolefield option value admin administrator option option value mod moderator option option value user user option option value guest guest option select div input type submit value create div fieldset form let get actually displaying modifying userlivenew module render template instead empty one defmodule useradminwebuserlivenew use phoenixliveview alias useradminwebuserview def render assigns userviewrender newhtml assigns end end go http see something look like phoenixhtml phoenix includes really nice helper method make html form little cleaner let take advantage start want create changeset form operate start let add function useradminusersuser allow u get changeset user defmodule useradminusersuser import ectochangeset def changeset user change user cast change name validaterequired name end end may notice casting validating name user get save role little bit let create function useradminusers allow u get changeset without calling schema module directly defmodule useradminusers alias useradminusersuser doc create changeset change user spec changeuser usert map ectochangesett def changeuser user change userchangeset user change end end let use useradminwebuserlivenew want create changeset admin first load live view let set mount function like defmodule useradminwebuserlivenew alias useradminusers alias useradminusersuser def mount session socket changeset userschangeuser user ok assign socket changeset changeset end end actually modify template use replace form label input element let hook form live view add phxsubmit attribute form tell submit using liveview use phxdisablewith submit button prevent admins trying create user multiple time new user f formfor changeset phxsubmit create fieldset label f name namefield textinput f name id namefield label rolefield role label select id rolefield option value admin administrator option option value mod moderator option option value user user option option value guest guest option select div submit create phxdisablewith creating div fieldset form reload browser form look exactly submit form turn red show spinner check app see undefinedfunctionerror say undefined private let set actually create user creating user let start creating function context actually save user useradminusers go ahead add defmodule useradminusers alias useradminrepo doc create user spec createuser map ok usert error ectochangesett def createuser attrs user userchangeset attrs repoinsert end end let hook live view need add function app looking submitted form want call new function clear form display message creation successful error want display error message defmodule useradminwebuserlivenew alias useradminwebrouterhelpers route def handleevent create user attrs socket case userscreateuser attrs ok user socket socket putflash info user successfully created redirect routeslivepath socket module noreply socket error changeset noreply assign socket changeset changeset end end end assigning error changeset socket need actually display error let modify template add errortag textinput displayed error changeset textinput f name id namefield errortag f name refresh browser able submit form try submitting empty name field make sure error show something name field make sure success message show successfully built user creation form look running application see insert database also notice sends user name selected role let change working role listing role role probably change often let put directly database privreposeedsexs file alias useradminrepo alias useradminusersrole role w administrator moderator editor user guest enumeach role fn name repoinsert role name name end go ahead run seed mix run privreposeedsexs database five different role feel free add wish one role put html template let go ahead get template displaying role database instead first let make function user context let u get role defmodule useradminusers alias useradminrepo alias useradminusers role user doc list role database spec listroles list rolet def listroles repoall role end end let set live view use new function pas template defmodule useradminwebuserlivenew def mount session socket changeset userschangeuser user role userslistroles ok assign socket changeset changeset role role end end finally let tell swap last label select element template using phoenixhtml helper select function expects keyword list list twoitem tuples item display key sent backend need use enummap convert list role structs tuples well let add errortag case error need displayed role oh one last thing add html using roleid determine role rather using role name everything want use id key new user f formfor changeset phxsubmit create fieldset label f name namefield textinput f name id namefield errortag f name label f roleid rolefield select f roleid enummap role id rolefield errortag f roleid div submit create phxdisablewith creating div fieldset form refresh browser open dropdown see option instead try saving another user look database see role id nil let get saving saving role simplest step need change changeset function user schema accept roleid let libuseradminusersuserex defmodule useradminusersuser def changeset user change user cast change name roleid validaterequired name roleid end end successfully saving user name role effectively making use onetomany relationship finally let make user list watch new user created display role chosen user list order get list user let start adding new function user context allow u get list user defmodule useradminusers doc list user database spec listusers list usert def listusers repoall user end end let add new live view libuseradminwebliveuserliveindexex use new listusers function get user live view mounted defmodule useradminwebuserliveindex use phoenixliveview alias useradminusers def mount session socket user userslistusers ok assign socket user user end def render assigns l end end hook libuseradminwebrouterex defmodule useradminwebrouter scope useradminweb pipethrough browser live user userliveindex live usersnew userlivenew end end let go ahead create template libuseradminwebtemplatesuserindexhtmlleex want use comprehension loop user add table user table thead th name th th role th thead tbody user user tr td username td td userrolename td tr end tbody table let hook live view defmodule useradminwebuserliveindex alias useradminwebuserview def render assigns userviewrender indexhtml assigns end end point navigate browser http would expect see table user instead get nice error saying role loaded listusers function pulling user role need using repopreload user context defmodule useradminusers def listusers user repoall repopreload role end end refresh work user role added roleid validaterequired changeset function user added without role rather trying change code accomodate case let reset database start clean get rid bad record refresh page see empty user table go back http add user two come back table couple user role showing preloading role work pretty well currently hit database get user get role make little bit performant join defmodule useradminusers import ectoquery def listusers user join inner u r assoc u role preload r role r repoall end end want look performance cost join case particular case save round trip database improve performance tiny bit make work realtime point using phoenix liveview really taking advantage realtime capability websockets channel let use phoenixpubsub user list subscribe list user automatically update new user created used phoenix generator set app initially already set useradminpubsub u use start adding subscribe function user context allow u subscribe event context publish event whenever new user created defmodule useradminusers topic inspect module def createuser attrs user userchangeset attrs repoinsert broadcastchange user created end doc subscribe update user list spec subscribe ok error term def subscribe phoenixpubsubsubscribe useradminpubsub topic end spec broadcastchange ok usert list atom ok result defp broadcastchange ok result event phoenixpubsubbroadcast useradminpubsub topic module event result ok result end end event published need tell live view subscribe update template whenever subscribing pretty easy need add handleinfo function handle pubsub message whenever received defmodule useradminwebuserliveindex def mount session socket userssubscribe end def handleinfo user user socket user userslistusers noreply assign socket user user end end try opening one browser window http window open http try creating couple user see show immediately list working onetomany association realtime keep code machine continue building part go manytomany relationship one little difficult prefer already boilerplate way focus making manytomany relationship work like exercise meantime recommend making another live view add new role use useradminpubsub make new role show automatically dropdown created without refresh page let know went always love hear tutorial went get stuck anywhere question anything said wish would writemake video different topic let know twitter prefer leave comment video youtube either way try get back quickly thanks reading andor watching liked post please retweet others find also subscribe email list youtube channel see new video right away
10,Lobsters,elixir,Elixir programming,Using Benchee for Elixir Performance Tests,http://prying.io/technical/2019/07/21/using-benchee-for-elixir-performance-tests.html,using benchee elixir performance test,github page elixir school testing limit system defining performance different condition automating benchee test basic unit test case integration test gotchas,benchee useful tool find situation need test limit system need define behavior specific environment seems primarily designed development debugging also used test well github page useful tool information setup configuration information elixir school site well doc cover use benchee post focus use note experience implementing benchmarking test suite benchee useful testing limitation system defining time constrains memory impact critical process aid development write performant code article let set aside benchee dev tool focus use case involve exunit testing limit system system handle today average load system processing power handle load impact long take system process login request comment compare processing request answering question help team spend time wisely identify problem spot code using data let drive development company growth target write test assert minimum met different hardware adverse scenario without live nightmare automating test stretching system prevents regression also ensures code bottleneck growth company defining performance different condition given situation system respond within specified time given hardware b system still able handle load enough memory allocated critical situation exactly would system long would take automating benchee test benchee test play nicely test exunit tag easily avoided would recommend creating test suite dedicated benchmarking function use test suite gate release depending need test setup simple complex simple case testing standalone function asserting output moving next test benchee meant need integration test benchee still useful integration case difficult reason covered later post basic unit test case usage example documentation usage example unit test since discovering benchee workflow io install basic happy path benchee test around given function function pass test around functionality tinker crucial aspect logic might slowing processing example might change enumeach enummap single enumreduce integration test case metric like deviation percentile case valuable well since show exunit integration doc benchee exunit test would look like defmodule applicationbencheeunittest alias applicationhelpermodule alias applicationtesthelper tag benchmark test benchmark function setting output aside make assertion output output bencheerun casea fn input resource ok result helpermoduledosomething casea returning value used aftereach possible best move assertion aftereach avoid impacting test result end caseb fn input resource ok result helpermoduledosomething caseb result end beforeeach fn input test setup return input test resource iteration ok resource testhelpergetresources input return tuple input test resource input resource end aftereach fn result make assertion output iteration end iterates input scenario input firstscenario enumat outputscenarios secondscenario enumat outputscenarios make assertion performance micro second assert firstscenarioruntimedatastatisticsaverage end end integration test one strength elixir ability build application tree using genservers unfortunately case often challenging test require processing message queue aim test one module time certain case end end test genserver b processed message genserver worse still benchee scoping inherited test module setup must happen inside beforeeach inside benchee run use case found helpful create module handle event test eventbased system might right approach point way asserting process path completed moment completes assertion add time test run long apple apple comparing past performance still get value test example would look beforeeach fn input inside beforeeach start mock handle event passing test pid callback mock event handler logic pass along message mockeventhandlerstartlink callbackpid self eventhelpersubscribetoevents mockeventhandler eventa eventacompleted assert event received indicate process completed inside scenario casea fn input resource payload struct would defined mock example assertreceive event eventa match exactly pas value aftereach make assertion payload payload assertreceive event eventacomplete payload completepayload end gotchas inside benchmark run access file within application example imagine imported mock test benchee scoping inherit exunit case currently test require great deal setup tear hindsight seems obvious initially understand benchee run ran many time given chunk code possible beforeeach aftereach parameter refer iteration scenario given input cycled iteration process input beforeeach method test scenario given chunk code
11,Lobsters,elixir,Elixir programming,Why functional?,https://blog.testdouble.com/posts/2020-06-30-why-functional/,functional,functional scary think todo app taming uncertain future one elixir elm intent avoiding backwash time state please functional core imperative shell cqrs elixir elm ramda thinker,internet full information mostly related learning something come software development feel bigger question learn something imagine explaining friend confronted bear stand ground make lot noise try look big scary possible trying intimidate animal could brush aside flick claw seems ridiculous friend might decide better stick knee strategy might take advice use wrong time like mother bear cub knowing certain thing allows u trust worth importantly context know appropriate functional scary think point may looked example todo app written functionally decided maybe gave try turned unmaintainable mess without understanding goal functional programming hard receive benefit like focus developer would choose learn think functional way say need switch using functional language immediately programming functional use pattern architecture embraced functional give many benefit worth time change entire process carrying fine well one functional codebase generally lot enjoyable live work may surprise time told functional programming confusing academic hard read etc true staring blank page producing functional code may require bit upfront thought programming paradigm generally result much enjoyable read maintain think important differentiate something versus something example could use basic word say sad could say even word slightly advanced better understand feeling word choice accurate nuanced description emotion similarly functional programming concept slightly advanced accurate description kind problem trying solve program taming uncertain future generally write code solve problem automate task going happen future write code read present tense future tense may slightly complex language construct present tense future complicated future tense accurate representation situation consider two way giving driving direction left turn right go straight past blue turn left turn right keep driving straight go past blue house struggling give first scenario written present tense make assumption road closed blue house painted white work fine lot time give u false sense security sitting front sign freshly painted white house idea second scenario beginning similar writing future tense reminds u describing one possible future thing future uncertain actually many possible future therefore end direction acknowledging offering alternative course action calling help something fit expected future concept uncertain future nothing functional programming universe work choose ignore fact traditional programming risk buggy confusing code result functional programming need handle many possible future depends type problem solving case driving direction provide instruction expected case case simply reach help case self driving car say intersection light also need explicitly handle case light red person walking stop approach taken defining future depends lot use case language like elixir tend embrace style first example define case expect happen case allow erlang runtime fail immediately report problem perfect backend system monitor log fix unexpected behavior elm hand favor latter example frontend language priority seamless user experience forced always handle possible case even unlikely error handling well serf purpose word error suggests something unexpected happened thinking uncertain future nothing unexpected subtle difference point trying make future complicated rather trying describe basic language describe appropriate grammar readable code using simple language construct clearly modelling intent avoiding backwash time move completely idea want note functional pattern provide better language construct also allow u form code easily defined sequential flow time always move forward control flow logic one two way funnel one possible future result fan many possible future based result main two construct functional programming conditionals used define possible future function used describe happens one future make concrete conditionals take one input define many output function take many input produce one output define chain condition function scope possible future expands contract always moving forward time never think changing something already happened state please hold sound like saying way keep track state well hold thought first talk benefit worry state within flow logic look another example two version recipe egg stir cup flour place egg cup flour oven preheated degree whisk egg stir flour place oven produce first example look easier first glance think assumption make happens whisked egg realize flour finished combining ingredient realize oven needed preheated instruction could made little clear saying oven degree whisk two egg refrigerator stir cup flour pantry place little better still assumption state world assumes ingredient pantry oven actually work second example state front required complete recipe state produced following recipe nothing assumed ingredient working preheated oven know even start recipe consider real code example eventsbylocation const event jsonparse localstorageevents let group const event event const group group eventlocation grouppush event group eventlocation group return group got two concerning thing going right first referencing localstorage making assumption state world within function always trust function work function deterministic result input known function functional language enforce common best practice follow pattern much possible second built lot local state along way group variable mutated looping event started blur intent function simply giving linear direction keeping track thing happened past let try instead eventsbylocation event eventsreduce acc event const group acc eventlocation return acc eventlocation group event see function pure pas everything need mutable internal state everything flow beginning end elegant way using modern javascript functional language library could one liner state somewhere yes never eliminate state completely system keep seeping every part application constantly managing pattern called functional core imperative shell idea core business logic application written pure function future tense wrapped thin layer code interacts outside world deal state written state useful want stay way one way elixir lean heavily erlang otp process state maintained modifying data recursive loop elm deal state using internal architecture modify directly send message instruct internal state would like change implementation cqrs pattern redux common state management library javascript often used react regardless library architecture choose main point state business logic stay separate deal complexity uncertain state language like elixir elm suggest enforce functional pattern varying degree great thing start wherever functional way thinking language instance react helped start thinking functional way idea ui simply function state incredibly powerful redux top helped decouple state business logic even got excited pattern started using ramda library allows writing functional code fluently javascript using function composition piping currying finally started working language designed functional honestly point become functional thinker big jump hope journey encourage thoughtfulness way define problem way communicate intent
12,Lobsters,elixir,Elixir programming,Operating via development,https://www.theerlangelist.com/article/operating_via_development,operating via development,certbot siteencrypt instruction start system locally phoenix live dashboard soul erlang elixir certification acme automatic certificate management environment protocol siteencrypt make task straightforward midlevel module lowerlevel module reducing devproduction mismatch testability automation tight integration operation final thought,two year ago decided add http support site using automatic certification via let encrypt article subject relied tool called certbot couple variation mentioned requiring tool run site others using nginx certbot combination seemed installing running additional external tool production mandatory point erlangelist standalone elixirpowered system required external program seemed start worrying setting additional service interact using custom dsl would complicate operation create disconnect production development change certification configuration would need tested directly production alternatively setup staging server either way testing certification would done manually unhappy state started work siteencrypt library take different approach automatic certification siteencrypt library dependency external tool required install oslevel package use certification process periodical renewal running o process rest system o process need started everything configured project system implemented interaction siteencrypt done via elixir function data yaml ini json kind dsl required trivial run certification locally reduces difference prod local dev support automatic testing certification provided need setup staging machine make change directly production system example call integrated operation instead spread across bunch yamls inis jsons bash script somehow glued together oslevel operation done development ie place rest system implemented using language approach significantly reduces technical complexity system erlangelist mostly implemented elixir administrative task installation o package user creation port forwarding rule similar provisioning task done outside elixir also simplifies local development instruction start system locally simple install build tool elixir erlang nodejs fetch dependency invoke single command start system locally started system extremely close production version almost nothing significance running production running locally two difference note think port forwarded prod prod version us let encrypt certification local version us local ca server later may sound like much simple blog host behind scene erlangelist bit simple request responder erlangelist system run two separate web server public facing server one use read article another internal server us phoenix live dashboard expose metric small handmade database running collect aggregate persists reading stats periodically removing older stats disk system periodically renews certificate locally ci another web server act local certificate authority ca running word erlangelist blog site server app system consisting multiple activity collectively work together support full enduser service well operational aspect system activity running concurrently block crash system utilizes cpu core host machine detail work take look talk soul erlang elixir let take closer look siteencrypt certification let encrypt support automatic certification via acme automatic certificate management environment protocol protocol describes conversation client system wanting obtain certificate domain server certificate authority ca create certificate acme conversation system asks ca provide certificate domain ca asks u prove owner domain ca give u random byte make request domain expecting get byte return also called challenge successfully respond challenge ca create certificate u real story course involved simplified version hopefully give basic idea conversation activity system job need occasionally done allow system provide full service certification valid certificate people use site likewise decide shut site certification serf purpose anymore situation preferred approach run activity together rest system le fragmented system easier manage running part system externally fine stronger reason see reason simple scenario siteencrypt make task straightforward add library dep fill blank good go certification configuration provided defining certification function def certification siteencryptconfigure client native domain mysitecom wwwmysitecom email contact mysitecom anothercontact mysitecom dbfolder folderwheresiteencryptstoresfiles directoryurl directoryurl end code look pretty declarative executable code collection fact mean lot flexibility shape configuration data however want example want make certification parameter configurable system operator say via yaml file nothing stop u invoking loadconfigurationfromyaml instead hardcoding data say want make parameter configurable eg domain email leaving rest hardcoded simply keywordmerge loadsomeparamsfromyaml hardcodeddata supporting kind config source like etcd database equally straightforward always build declarative top imperative opposite require imagination trickery running external configuration generator good luck managing production also worth mentioning siteencrypt internally ship two lowerlevel module sort plumbing porcelain midlevel module provides workflowrelated operation create account perform certification lowerlevel module provides basic acme client operation module used want finer grained control certification process reducing devproduction mismatch one interesting thing happening configuration presented earlier def certification siteencryptconfigure directoryurl directoryurl end directoryurl property defines ca siteencrypt obtain certificate instead hardcoding url invoking function compute happens need use different url production v staging v local development let take look defp directoryurl case systemgetenv mode local production http staging http local internal port end end distinguishing production staging development based mode o env easily replaceable source owing programmable api env provided assume system running locally production machine go real ca staging use let encrypt staging site internal port thing use local development pas particular shape data siteencrypt internal acme server started given port sort local mock let encrypt server running inside o process rest system locally siteencrypt start mock let encrypt use mock obtain certificate word locally system certify example action local version erlangelist iex mix phxserver info running erlangelistwebblogendpoint http info running erlangelistwebblogendpoint http info running local acme server port info creating new acme account domain theerlangelistcom info ordering new certificate domain theerlangelistcom info new certificate domain theerlangelistcom obtained info certificate successfully obtained testability since local erlangelist behaves exactly real one test system behaviour example even local version http request redirected http test verifying test http request redirected http assert redirectedto clientget http localhost http localhost end likewise redirection www also tested test theerlangelistcom redirected wwwtheerlangelistcom assert redirectedto clientget http theerlangelistcom http wwwtheerlangelistcom end contrast external proxy rule defined nginx configuration typically tested mean change configuration might break something else way obvious operator addition siteencrypt ship small helper testing certification relevant test test certification cleanrestart erlangelistwebblogendpoint cert getcert erlangelistwebblogendpoint assert certdomains wtheerlangelistcom wwwtheerlangelistcom end test blog endpoint ie blog web server restarted previously existing certificate removed restart endpoint certified via local acme server certification go whole process mocking save fact local ca used http request made key generated system call ca concurrently make request system ultimately certificate obtained finished invocation getcert establish ssl connection blog server fetch certificate peer assert expected property certificate test significantly increase confidence system course always chance something going wrong production eg dns correctly configured let encrypt reach site possibility error reduced test also compiled language used example make syntax error changing configuration code even compile let alone make production make typo eg specifying theerlangelistorg instead theerlangelistcom certification test fail contrast external configuration much harder test typically end manually verified staging case production automation beyond obtaining certificate siteencrypt periodically renew periodic job executed three time day job check expiry date certificate start renewal process certificate expire day addition every time certificate obtained siteencrypt optionally generate backup data system starting siteencrypt database folder present backup file exists siteencrypt automatically restore database backup user siteencrypt zero work make happen significantly reduces amount operational work required bringing bulk regular development elaborate backup scenario siteencrypt provides callback hook endpoint module define function invoked certificate obtained use function eg store cert arbitrary secure storage choice notice becomes part regular system codebase convenient logical place express task fact running together rest system also mean testable testing new certificate correctly stored desired storage straightforward tight integration since run o process powered language siteencrypt integrate much better client lead nice benefit mentioned earlier certification conversation system ca server using certbot tool dialogue turn threeparty conversation instead system asking certificate ask certbot behalf however ca verification request aka challenge need served site since certbot external tool treat site opaque box result certbot know responded ca challenge bit conservative namely certbot sleep three second start polling ca see challenge answered native elixir acme client run o process integrate much better acme client informed challenge handler challenge fulfilled use much shorter delay start polling ca production optimization particularly relevant local dev especially test difference becomes significant certification test via certbot take second machine test via native client tight integration offer interesting possibility bit change api siteencrypt could support arbitrary storage database could also support coordination multiple node making possible implement distributed certification arbitrary node cluster initiate certification node successfully respond challenge including even node came online challenge started operation bulk system behaviour described elixir code remaining operational task done outside elixir exclusively related preparing machine run erlangelist task involve creating necessary account creating folder structure installing required o package essentially docker needed setting single systemd unit starting container production dockerized production docker image lightweight site run apk nocache upgrade apk add nocache ncurses copy frombuilder optappsitebuildprodrelerlangelist erlangelist volume volume workdir erlangelist entrypoint erlangelistbinerlangelist key part copy instruction add built release system image release contain compiled binary well minimal erlang runtime system therefore pretty much selfcontained requiring one small oslevel package installed final thought might argue using certbot optionally nginx caddy simple enough completely disagree perfectly valid reach external product solve technical challenge related business domain product help u solve problem quickly focus core challenge hand feel critical problem introduced product tried show simple example integrated operation approach reduces amount moving part technology used bridge gap production development improves testability system implementation simpler time flexible since tool driven function data approach work need runtime support managing multiple system activity beam runtime erlang elixir make possible example many case serving traffic directly phoenix without reverse proxy front work fine feature ets table genserver reduce need tool like redis running periodic job regulating load ratelimiting pipeline processing done directly elixir without requiring external product course always case external tool make sense also many case integrated approach work fine especially smaller system operating level scale complexity netflix twitter facebook similar option available would allow u start simple move external tool complicated scenario reason started work siteencrypt library still incomplete probably buggy issue fixed time effort believe benefit approach worth effort continue work library like see library appearing giving u simpler option challenge load balancing proxying persistence long technical challenge running external product option opportunity simplification u developer make happen
13,Lobsters,elixir,Elixir programming,Introducing Lean Server for Midas (HTTP server in Gleam),https://crowdhailer.me/2020-06-23/introducing-lean-server-for-midas/,introducing lean server midas http server gleam,introducing lean server midas midas web framework lean ace raxx gleam using lean server,introducing lean server midas lean server http server written gleam gleam new type safe language erlang virtual machine beam lean builtin server midas web framework import midaslean maxconcurrency import gleamhttp fn handle request httpresponse httpsetbody hello world fn startlink leanstartlink handle maxconcurrency lean simple use simple maintain fast hopefully lean incorperates lesson learnt developing ace raxx ace http server written elixir aimed abstract away difference ace also supported http long lived connection streaming requestsresponses opinion ace successful goal however feature one server increased implementation complexity since starting ace written several service use narrow subset feature application mostly json api service streaming deployed behind load balancer needed neither http lean aim focus api application sizeable list nongoals ssl streaming http pipelining websockets tackling nongoals lean simpler therefore easier maintain make easier address feature bug well easier contribute also faster though yet test course feature listed important framework writing adapter server ace cowboy midas framework able support feature gleam gleam feel like promising approach getting benefit type beam something several people wish list including mine quite long time gleam compiles readable erlang readable erlang nt controversial statement also great interop erlang elixir feature would argue considered production ready part application part application benefit type safety others write topic later time using lean server lean sever bundled part midas currently midas using feature yet part gleam stable release therefore need use git dependency midasframeworkmidas
14,Lobsters,elixir,Elixir programming,Using Mnesia in an Elixir Application,https://blog.appsignal.com/2020/05/19/using-mnesia-in-an-elixir-application.html,using mnesia elixir application,introduction mnesia check research paper detail query list comprehension match specification mnesia cap theorem use mnesia postgresql database looking mnesia doc handson project mnesia amnesia library conclusion alex koutmos p like read elixir alchemy post soon get press subscribe elixir alchemy newsletter never miss single post,today post learn mnesia see would use tool take look pro con using covering fundamental mnesia dive right sample application build elixir application us mnesia database let jump right introduction mnesia high level mnesia database management system dbms baked otp thus using elixir erlang ability leverage mnesia outofthebox additional dependency need installed separate system need running considering migrating everything existing database mnesia let discus mnesia designed problem aim solve mnesia largely designed solve problem existed telecommunication problem space specifically following requirement needed fulfilled check research paper detail fast keyvalue lookup time need soft realtime latency guarantee soft realtime system one system able service majority request within given time frame failure generally mean degradation service ie data longer useful time frame passed hard realtime system hand system must respond within given time frame else considered system failure ability perform complex query like would sql example without soft realtime latency guarantee high level fault tolerance typical dbms application would need either make network call separate machine database running would connect database process running machine either way data contained within database resides entirely separate memory space application therefore inescapable amount latency overhead hand mnesia run within memory space application result baked language runtime able fetch data mnesia soft realtime speed word application database running sidebyside little communication overhead two another important thing note mnesia store erlang data type natively need marshallunmarshall data readwrite mnesia marshalling process converting data one format another purpose storing transmitting performing complex query mnesia database either leverage query list comprehension qlc write match specification addition also add index mnesia table field know querying often using tool perform arbitrary query table extract relevant data primary requirement telecommunication system must running nonstop downtime mean missed dropped call mnesia address allowing table replicated across various node cluster running within transaction data need committed must written configured table replica node unavailable write transaction update available node replica update unavailable node replica come back online replication mechanism mnesia able provide high level fault tolerance mnesia cap theorem may wondering exactly fall regard cap theorem unfamiliar cap theorem basically state dealing distributed system three characteristic play guarantee two given time three characteristic consistency whenever read made database database respond recently updated data availability whenever request made database database respond data even date ie newer data committed propagated node partition tolerance whenever request made database able respond regardless node unavailable network partition occur ie database node unavailable system must make tradeoff favor consistency error request node unavailable favor availability servicing request understanding may data inconsistency missing node come back online given mnesia propagate transaction commits across table replica support kind eventual consistency cp style database case network partition separate partition handling request application need deal reconciliation data use mnesia postgresql database like many thing software engineering system design making correct tradeoff whether mnesia right application largely depends requirement personally used mnesia production primarily support soft realtime use case good result data stored mnesia needed duration user session would get cleared user interaction system ceased thus lot pressure system resource ram specifically table need fit ram size table would reflect number user actively using system situation need store large amount data require soft realtime response time traditional dbms mysql postgres may better choice situation see reaching redis memcached may want consider looking mnesia given fill similar need built otp information regarding topic would suggest looking mnesia doc handson project mnesia order get familiar mnesia creating simple banking application leverage mnesia database could leverage mnesia api directly via mnesia instead opt use amnesia library provides nice elixir wrapper around mnesia api banking application support following operation create new account transfer money account fetch account detail deposit fund account withdraw fund account search account low balance begin let create new elixir project using following terminal command mix new fortknox sup creating elixir project open mixexs file make sure function look like following deps amnesia end done run mix depsget fetch amnesia dependency next want create module defines table schema mnesia database sample application one table defined bank account add following content libdatabaseex amnesia defdatabase database deftable account id autoincrement firstname lastname balance type orderedset index balance end database contains account table specifies field along autoincrementing id field database definition place let go back terminal run following command mix amnesiacreate database disk executing command notice new directory mnesianonode nohost created u root project directory contains disk persisted data data maintained across application restarts delete persisted database data either rm rf mnesianonode nohost run mix amnesiadrop database schema place time work business logic let create file libfortknoxaccountsex start creating function create new account fetch existing account fortknoxaccounts require amnesia require amnesiahelper require exquisite require databaseaccount alias databaseaccount def createaccount firstname lastname startingbalance amnesiatransaction account firstname firstname lastname lastname balance startingbalance accountwrite end end def getaccount accountid amnesiatransaction accountread accountid end case account account account error notfound end end end module begin require statement pull amnesia functionality leverage account struct conveniently interact account table mnesia create new account entry table create struct call accountwrite within transaction want perform database action within transaction also leverage dirty readwrite api call recommended looking existing account id leverage transaction match account struct account found let go ahead add remainder functionality libfortknoxaccountsex fortknoxaccounts def transferfunds sourceaccountid destinationaccountid amount amnesiatransaction account accountread sourceaccountid accountread destinationaccountid case account account sourceaccount account destinationaccount amount sourceaccountbalance adjustaccountbalance destinationaccount amount adjustaccountbalance sourceaccount amount ok else error insufficientfunds end account error invaliddestination error invalidsource end end end def getlowbalanceaccounts minbalance amnesiatransaction accountwhere balance minbalance amnesiaselectionvalues end end def depositfunds accountid amount amnesiatransaction case accountread accountid account account adjustaccountbalance account amount error notfound end end end def withdrawfunds accountid amount amnesiatransaction case accountread accountid account account amount accountbalance adjustaccountbalance account amount else error insufficientfunds end error notfound end end end defp adjustaccountbalance account account amount account mapupdate balance amount accountwrite end end function relatively straight forward mixture read writes update account within transaction probably seem new clause query database record exquisite library amnesia depends provides ability generate mnesia match specification used perform custom query place let take test drive first seed database initial account transfer fund account open iex session via iex mix type following josh smith tom lee joe diaz enumeach fn firstname lastname amount fortknoxaccountscreateaccount firstname lastname amount end ok iex fortknoxaccountsgetaccount databaseaccount balance firstname josh id lastname smith iex fortknoxaccountsgetaccount databaseaccount balance firstname tom id lastname lee iex fortknoxaccountstransferfunds ok iex fortknoxaccountsgetaccount databaseaccount balance firstname josh id lastname smith iex fortknoxaccountsgetaccount databaseaccount balance firstname tom id lastname lee iex fortknoxaccountsgetlowbalanceaccounts databaseaccount balance firstname tom id lastname lee running command feel free quit iex via ctrlc go back using iex mix run databaseaccountcount see get value since data persisted across iex session destroyed conclusion thanks sticking end hopefully learned thing two mnesia go using within elixir application regardless whether decide use mnesia production context would highly suggest least experimenting better appreciate amazing thing get outofthebox otp guest author alex koutmos senior software engineer writes backends elixir frontends vuejs deploys apps using kubernetes programming blogging wrenching datsun p like read elixir alchemy post soon get press subscribe elixir alchemy newsletter never miss single post
15,Lobsters,elixir,Elixir programming,Scaling Up With Elixir,https://dockyard.com/blog/2020/05/28/scaling-up-with-elixir,scaling elixir,internet traffic go erlangcontrolled node whatsapp scaled serve million user erlang service written engineer scaled elixirbased video chat platform million concurrent user elixir alone million concurrent user pairing elixir rust handled billion page view per month sent billion push notification per month using five server poa network concurrencyoriented programming nonblocking io nonblocking computation error isolation erlang process gamechanger superpower applied cowboy web server phoenix web framework chris mccord phoenix channel million connected client single server phoenix liveview short exciting demo phoenix phrenzy contest entry phoenix channel scale well solid ground simpler stack icing cake nerve based usage nested io list ecto phoenix live dashboard michael crumm rustler learn dockyard,exciting website platform get spike traffic unless fails disappointing web experience quickly encourage new user look elsewhere alternative faster responsive need many facet making web experience scalable reliable including infrastructure database design code optimization one important factor code handle concurrency ability juggle multiple task read concurrency many company shown concurrent programming beat erlang virtual machine erlang vm originally built power ultrareliable device like telephone switch job admirably decade internet service experienced higher traffic became critical developer began realize problem already solved erlang began adopting example may heard internet traffic go erlangcontrolled node cisco alone shipping million device year use erlang whatsapp scaled serve million user erlang service written engineer recent year elixir language provided extremely productive way write code erlang vm success story include discord scaled elixirbased video chat platform million concurrent user elixir alone later million concurrent user pairing elixir rust also include bleacher report handled billion page view per month sent billion push notification per month using five server elixir heart dockyard approach writing scalable web service example dockyard helped poa network index million ethereum blockchain transaction fasterthanrealtime rate smart usage concurrency batching upserts welltuned postgresql database elixir erlang vm help u build scalable system concurrencyoriented programming scalable system one cope growing workload web service mean handling many request picture busy call center handle call need agent computing agent known process thread programming language rely operating system create process thread ensure get fair share cpu time o process robust expensive carefully budget many create o process create thread cheaper errorprone due need coordinate access memory share multithreaded programming notorious source tricky bug contrast erlang built concurrencyoriented programming language erlang vm create manage lightweight internal process designed run million erlang process lighter weight thread independent like o process corrupt one another data instead sharing memory use message passing coordinate work erlang vm run multiple scheduler one per cpu core ensures process efficiently spread across mean get full benefit multicore server also process run long enough need garbage collection many process pause happens due isolated nature way scheduled erlang process powerful feature nonblocking io process need input output like reading writing file database making network request process go sleep wait reply letting process get work done meantime nonblocking computation one process get stuck heavy workload erlang scheduler ensures performs work burst process get chance run small number expensive request bog whole system error isolation error occurs one process fail restarted without process affected need process notified react accordingly erlang process gamechanger picture call center every time phone ring new agent appears answer incoming web request spawn process email send spawn process need make api call query database perform calculation spawn process erlang process even spread multiple node cooperating coordinating machine superpower applied besides directly useful erlang process foundation erlang elixir exciting tool example cowboy web server spawn process every incoming web request keep error heavy work one request affecting others phoenix web framework created dockyard chris mccord us cowboy get behavior free phoenix channel use erlang process per websocket connection enabling soft realtime communication million connected client single server scalable push notification necessary part chat application multiplayer game iot service also important site realtime notification like booking auction site tell many user viewing item right channel communicate inbrowser javascript native phone apps custom hardware phoenix liveview let u build rich interactive browser application without custom javascript using fraction development time typically need pairing api frontend framework us phoenix channel track application state handle event serverside pushing fast tiny update client see short exciting demo phoenix phrenzy contest entry taste build liveview confident scalable foundation build liveview scale well phoenix channel scale well channel scale well built erlang process saša jurić explained building system erlang process like building solid ground simpler stack core technology much need fewer piece build system use library manage background job spawn task process elixir use redis shortterm state use agent genserver use thirdparty service push notification use phoenix channel write api go handinhand custom react front end write interactive site liveview use depends requirement experience lot potential simplify tech stack fewer piece mean le complexity manage something team appreciate icing cake besides inherent advantage come erlang process elixir ecosystem great performance scalability feature built common tool phoenix tiny memory footprint happily run raspberry pi zero interface nerve project phoenix template rendering blazing fast based usage nested io list framework need complex template caching ensure snappy rendering phoenix automatically universally applies simple view caching strategy static part template always cached dynamic part never cached cache invalidated template file change end strategy especially shine want personalize content every user ecto make nearly impossible write query lean database constraint ensure consistent data high load tool like erlang observer phoenix live dashboard built many contribution dockyard michael crumm give u builtin observability diagnose bottleneck slowdown production raw computation speed paramount rustler created dockyard han elia josephsen let u safely delegate rust code clear elixir silver bullet writing scalable software always requires thought care erlang process solid foundation many important piece place elixir ecosystem wonderful place build scalable reliable software dockyard love show learn dockyard digital product agency offering custom software mobile web application development consulting provide exceptional professional service strategy user experience design full stack engineering using emberjs reactjs ruby elixir nationwide staff got consultant key market across united state including san francisco los angeles denver chicago austin new york boston
16,Lobsters,elixir,Elixir programming,Transforming Programming (2017),https://www.youtube.com/watch?v=A76hM3MpEKo,transforming programming,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature transforming programming dave thomas youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature transforming programming dave thomas youtube
17,Lobsters,elixir,Elixir programming,"Of Elixir, Phoenix, and analogies to the Prime Directive",https://ekarak.com/2020/05/16/of-elixir-phoenix-and-analogies-to-the-prime-directive/,elixir phoenix analogy prime directive,lockdown elixir erlang basically power internet know phoenix generator prime directive please stop kobayashi maru zefram cochrane hexpm μου αρέσει αυτό,spent last couple month working home thanks lockdown sure felt like opportunity fresh jump like learning new technology promising mature enough use production elixir experimented erlang past say amusing recall learn erlang support legacy product previous company encounter erlang ecosystem keep positive programming erlang book joe armstrong amazing discovery erlang basically power internet know also happened work month software product based akka merely jvm implementation erlang actor model attract attention somewhere discovered cool new kid block elixir devote much time time advertised simply replacement rail make thing short happened innovation sprint current company write walking skeleton next version product suite part picked set phoenix based rest api literally time thanks builtin generator managed progress proofofconcept hey actually work real data spectacularly short time dived language miraculous stuff began happen started adding feature astonishing rate adhoc drilldowns auditing live update performance monitoring dashboard added functionality realized wanted test diverse set input data cannedresponse api would able provide purpose took interest rewriting abandoned sibling project transforming data feeding poc rest api xml spring boot project initially written line java still incomplete couple day effort ended line xslt yes goodold xml stylesheets line elixir fun part elixir implementation includes testing satisfies mvpscope requirement accidentally discovered realworld analogy prime directive exposing alien technology rest development team simply accept statement valid mean ready mean added auditing would even refuse look code day yet find soul review merge request rely automated tool like dialyxir run code check automatically stepped dangerous territory trying convince coworkers better yet friend know year threatening job security yes christ sake going support elixir code get hit bus read please stop harming team company u take plunge learn elixir relevant job market thencurrent trend say year short valid question invalid counterargument trying new language learn second foreign language student studying spanish need wipe memory clean german well maybe coworkers right maybe walking skeleton proofofconcept kobayashi maru unlike spock think cheat one think maybe something like zefram cochrane led vulcan come pay u visit upload cool new elixir artifact hexpm welcome gift μου αρέσει αυτό μου αρέσει φόρτωση
18,Lobsters,elixir,Elixir programming,JVM struggles and the BEAM (observability and performance tuning),https://medium.com/@mrjoelkemp/jvm-struggles-and-the-beam-4d9c58547410,jvm struggle beam observability performance tuning,jvm struggle beam tl dr beam built dealing highly concurrent application actorbased elixir programming language otp hitting wall jvm coincidentally found beam finding bottleneck beam single plug observercli vm give ability see bottleneck system long live beam,jvm struggle beami like talk opaqueness jvm plaguing last month fell love erlang virtual machine famously known beam extension elixir programming language tl dr beam built dealing highly concurrent application worldclass introspection give power observe manipulate running application repl simple actorbased concurrency model easy teach make easy reason scale system elixir programming language modern beamlanguage allows terse readable code fully leveraging erlang otp need build maintain high traffic backend service regret learning stackhitting wall jvmat work maintaining business critical jvmbased backend service handle thousand request per second call high traffic service without going detail service basically call database another backend service every request responds user request also offrequest operation necessary dealing database point concurrent operation going within service every requestso wanted know single instance jvmbased system would perform double current load wanted see would break bottleneck werethe state art observing jvmbased application combination using thread dump gc log thread activity visualization thread dump give snapshot name thread current running state waiting blocked etc stacktrace work currently gc log give record much garbage collected thread activity visualization show timeline thread moving different running statesrandom picture showing thread visualizer provided visual vm tool introspecting java applicationsafter performing load test using tool able find completely underutilized thread pool thread nothing least gathered piecing together disparate clue developing huncheswhen came finding thread overutilized lucky seeing random thread active tell busy needed increase threadpool size even trying understand flow control program ie handoff control thread seemed impossible might piece together stacktraces thread dump assuming visualvm perfect sampling thread stacktraces left defeatedoutside observability would also need try use monitoringmetrics help find bottleneck would need add instrumentation threadpools try gauge busy sadly though need instrument every library stack us threadpools know need tweak concurrency configuration library good luck thati blew day trying understand going system using aforementioned tool studying many library standard backend stack trying piece together clue possible bottleneck got nowhere felt helpless frustrated started talk experienced jvm engineer issue visibility system really help either better tool guide search truth folk learned trial error hearing learning java devs getting visualization control flow system like tracing thread would either require really heavy instrumentation way possible caseshow coincidentally found beama talented newly hired teammate joined squad saw struggle reasoning internals fairly simple jvm service mentioned elixir programming language made lot easieri thought another using java used x language previous company great type argument wrong week hearing elixir passing actor model iex shell faulttolerance observer got curious spent night reading tech watched lot youtube video various elixir conferencesthe turning point following visualixir showing realtime interprocess communication elixir applicationbetween sasa talk visualixir library learned elixir stack really beam supplied level deep introspection without need heavily instrumenting software comparing dozen metric graph try understand happening system became intriguedfinding bottleneck beami incredible opportunity run experiment work beam deepen study stack built clone jvm service elixir see felt write service elixir confirm quality kept reading actually helpfulafter building clone day literally going zero something production wanted see could easily find bottlenecki mirrored traffic jvm service elixir service fact global traffic horizontally scaled jvm service going single elixir service machinethe elixir service running plug handled load somewhat fine service kept accepting request despite cpu going memory usage remained fairly flat however getting many response request something choking internally causing request go unfulfilledso fired cli version observer called observercliexample observercli used deeply analyze random elixirbased production systemdue beam application adhering actor model basically allows decompose application series completelyisolated process communicate solely via message use observer reversesort mailbox size allows visually see process backed processing message word vm give ability see bottleneck systemi found process pool charge talking database process handle incoming load managing process mailbox kept growing growing causing request stall database query message could processed pooli changed configuration maybe could done running app thanks elixir repl increase database client process pool size redeployed change fired observercli saw bottleneck looking server log fulfilling request literally found bottleneck within hour increased throughput system soldlong live beamover course continuing iterate clone building infrastructure piece getting vm application metric metric store grafana beam continued shine observercli continue give visibility find bottleneck ease aspect like elixir repl faulttolerance via supervisor timeslice scheduling avoids cpu starving blew mind mind blown stack weekly kid nothaving stack give tool guarantee safely operate highly concurrent system real game changer taught shortcoming jvm comparison also jvm shine highly recommend playing beam elixir get chanceafter watching sasa talk recommend checking following resource learn
19,Lobsters,elixir,Elixir programming,"archseer/enigma - Enigma VM, an implementation of the Erlang VM in Rust",https://github.com/archseer/enigma,archseerenigma enigma vm implementation erlang vm rust,enigma vm installation rustup iex also work rendering bug feature status opcodes bifs roadmap feature goal idea experiment hyper runtime initial nongoals rustler contributing elixir slack,enigma vm implementation erlang vm rust aim complete correct fast order importance otp compatible sans distributed bit code eventually run enigma unchanged deprecated opcodes wo nt supported fun learning lot beam hipe awesome massive sloc small implementation make easier new people learn erlang internals also get platform quickly iterate idea inclusion beam installation prerequisite building enigma rust use rustup install latest nightly rust time nt support stable beta anymore relying asyncawait scheduled run stable time boot otp also need compile standard library moment relies beam build system git submodule update init depth cd otp otpbuild setup make libs make localsetup hope simplify step future enigma run compiler run cargo run install dependency build run vm default boot erlang shell iex also work rendering bug expect crash lot functionality already available prebuilt binary various platform available reach certain level stability feature status implement opcodes half bifs view detailed progress breakdown opcodes bifs roadmap feature goal idea experiment process scheduling implemented top rust future process simply long running future scheduled top tokiothreadpool workstealing queue timer delaytimeout future relying tokiotimer timewheel port future await file io asyncreadasyncwrite awaitable nifbifs future yield certain point play nice reduction allows much simpler yielding implementation future possibility write documentation sparsely documented beam aspect binary matching time wheel process monitor explore using immix gc erlang eir runtime jit via eir bif generator function yield suspendon reduce provide builtin adapter module hyper plug adapter http client crosscompile webassembly runtime initial nongoals vm nt reach certain level completeness nt make sense consider distributed erlang node tracing debugging support beam compatible nifs ffi note nifffi abi compatibility otp going quite work ruststyle nif interface available would also probably possible make adapter compatible rustler contributing contributor welcome easiest way get started look note folder pick bif opcode implement take look srcbifrs bif folder bifs implemented also issue open good first issue tag would also good introduction internals alternatively search codebase todo fixme unimplemented mark various place partial implementation exists bit work need done test coverage currently lacking varying level documentation addressing soon also enigma channel elixir slack
20,Lobsters,elixir,Elixir programming,Newtype-like tagged tuples in Elixir,https://pzel.name/2020/04/26/Newtype-like-tagged-tuples-in-Elixir.html,newtypelike tagged tuples elixir,newtypelike tagged tuples elixir defopaque motivating example unit measure bad tagged tuples name,newtypelike tagged tuples elixir thought code experiment type wrapper elixir metaprogramming time ago stumbled upon hacky way generating something akin haskell newtype declaration elixir defopaque motivating example unit measure going assume agree maxim making illegal state unrepresentable desirable feature software system let say part system deal weight would nice ensure programmer nt use plain number dealing unit measure consequence bad past let define weight module kg constructor wrapping number represent unit weight defmodule weight use defopaque defopen kg number end intention create lightweight wrapper type whose role primarily document meaning variable also prevent accidental use weightrelated function plain number macro defopen give u kg type exported weight kg n macro generate tuple containing number n second element first element tuple autogenerated atom guaranteed stable every wrapperatom wrappedsubtype pair use macro generate new kg value patternmatch existing value let see example kg unit use defmodule myapp import weight spec tellweight weightkg stringt def tellweight w case w kg twelve kilogram kg kg invalid unit end end end require weight iex myapptellweight weightkg twelve kilogram iex myapptellweight weightkg iex myapptellweight invalid unit also use patternmatch syntax match value inside constructor defmodule match import weight def count wantvalue weight kg kg kg kg enumcount weight fn kg wantvalue true kg false end end end iex matchescount iex matchescount even pattern match function head defmodule conversion import weight def kgtolb kg n n end require weight iex conversionkgtolb kg iex conversionkgtolb kg note function called conversionkgtolb kg conversionkgtolb functionclauseerror function clause matching following argument given precisely behavior wanted beginning kg unit converted plain number want expand system deal pound firstclass citizen free cheap generate new wrapper module defmodule weight use defopaque defopen kg number defopen lb number end defmodule conversion import weight def kgtolb kg n lb n def lbtokg lb n kg n end work expected allowing conversion right direction import weight iex kg re conversionkgtolb kg conversionlbtokg iex re iex kg re conversionkgtolb kg conversionkgtolb functionclauseerror function clause matching following argument given see got peek wrapper tagging implemented exactly pretty prevents module creating wrapped type without importing module type defined tagged tuples tagged tuples traditional way handling kind problem nothing wrong however nt prevent unauthorized use type example anyone create tuple kg reason module know nothing weight could nt match tagged tuple def anallegedlyweightagnosticfunction kg weight method code reference weight module good faith create tagging atom since moreorless gibberish also unique opaque tag mean dialyzer much strict checking code structs structs elixir killer feature great modeling composite data type project came attempt golf opaque structs defined internally nested module single field recommend real production project name defopaque original intent behind hack provide quickndirty way define opaque newtypes codebase later figured would also nice provide nonopaque destructurable newtypes hence two macro defopaque creates wrapper defines resulting wrapped type opaque generated constructor patternmatch macro used module opaque type defined defopen creates wrapper defines resulting wrapped type type generated constructor used outside module defined edited module name truncated sentence
21,Lobsters,elixir,Elixir programming,Build a real-time Twitter clone in 15 minutes with LiveView and Phoenix 1.5,https://www.phoenixframework.org/blog/build-a-real-time-twitter-clone-in-15-minutes-with-live-view-and-phoenix-1-5,build realtime twitter clone minute liveview phoenix,build realtime twitter clone minute liveview phoenix phoenix livedashboard http phoenix liveview generator pubsub revamped guide http changelog,build realtime twitter clone minute liveview phoenix posted april chris mccord phoenix released liveview integration release make easier ever build interactive realtime application put together quick screencast show much accomplish minute liveview video outside phoenix liveview integration release brings exciting feature including integration new phoenix livedashboard deprecation ugprade quick easy folk phoenix livedashboard heel official livedashboard release phoenix project ship livedashboard default realtime performance monitoring debugging tool point also want welcome michael crumm phoenixcore team heading dashboard work josé valim thank amazing result today dashboard brings immediate insight phoenix application focus production data even starting phoenix tooltips widget learn ifwhen worry system limit health system telemetry integration also include charting phoenix event along userdefined metric check josé twitter thread see breakdown feature screenshots http dashboard also includes streaming request logger super convenient diagnosing issue production need log specific request regular log drown request noise button click request log streamed dashboard instead sifting thru flood production log also include process tab similar observer allowing sort process system find large message queue memory hog etc mention cluster distributed node using node dropdown selector access datafeatures listed node cluster regardless web node happened loadbalance loading dashboard phoenix liveview generator phxnew project generator includes live flag include everything need get running developing liveview additionally also added phxgenlive generator boostrapping crud liveview contextinterfaces similar phxgenhtmlphxgenjson recommend taking generator test drive see existing improvement liveview recently shipped revamped liveviewtest apis powerful workflow driven testing deep diff tracking liveview template dramatically reducing server payload many case large performance improvement client rendering live navigation live flash pubsub phoenixpubsub released flexible powerful fastlane mechanism took opportunity also move phoenixpubsub endpoint explicitly supervision tree prevents race condition startup decouples pubsub system endpoint follow upgrade guide linked get speed revamped guide thanks effort josé valim phoenix builtin guide restructured revamped providing better navigation structure content sure take look like freshen phoenix knowledge notable improvement include builtin support mssql database via tds adapter inclusion phoenixectocheckrepostatus plug new project detect prompt database creationmigration directly comfort browser always provided upgrade guide bring existing application speed http complete list change see changelog find u elixir slackirc question happy coding
22,Lobsters,elixir,Elixir programming,Phoenix Live Dashboard,https://github.com/phoenixframework/phoenix_live_dashboard,phoenix live dashboard,phoenix livedashboard online documentation installation add dependency configure liveview official installation instruction add dashboard access developmentonly usage extra add dashboard access environment including production article contributing license,phoenix livedashboard online documentation livedashboard provides realtime performance monitoring debugging tool phoenix developer provides following module home see general information system o data see general information o cpu memory disk usage metric see application performs different condition visualizing telemetry event realtime chart request logging see everything logged certain request application see filter search application current node process see filter search process current node port see filter search port responsible io current node socket see filter search socket responsible tcpudp current node ets see filter search ets table inmemory storage current node dashboard also work across node node connected via distributed erlang access information node b accessing dashboard node installation start using livedashboard need three step add phoenixlivedashboard dependency configure liveview add dashboard access add phoenixlivedashboard dependency add following mixexs run mix depsget def deps phoenixlivedashboard end configure liveview livedashboard built top liveview liveview already installed app feel free skip section plan use liveview application future recommend follow official installation instruction guide cover minimum step necessary livedashboard run first update endpoint configuration include signing salt generate signing salt running mix phxgensecret note phoenix apps already configuration configconfigexs config myapp myappwebendpoint liveview signingsalt secretsalt add phoenixliveviewsocket declaration endpoint socket live phoenixliveviewsocket good go add dashboard access developmentonly usage installed update router configuration forward request livedashboard unique name choosing libmyappwebrouterex use myappweb router import phoenixlivedashboardrouter mixenv dev scope pipethrough browser livedashboard dashboard end end run mix phxserver access dashboard configure necessary module extra add dashboard access environment including production want use livedashboard production put behind authentication allow admins access application adminsonly section yet use plugbasicauth set basic authentication long also using ssl anyway libmyappwebrouterex use myappweb router import plugbasicauth import phoenixlivedashboardrouter pipeline adminsonly plug basicauth username admin password special secret end scope pipethrough browser adminsonly livedashboard dashboard end running application behind proxy webserver also make sure configured allowing websocket upgrade example article configure nginx phoenix websockets finally also want configure configprodexs use domain name checkorigin configuration checkorigin myappcom good go contributing planning contribute project run dev version dashboard following command mix setup mix dev alternatively run iex mix dev also want shell license mit license copyright c michael crumm chris mccord josé valim
23,Lobsters,elixir,Elixir programming,Squeezing the most out of the server: Erlang Profiling,http://tech.nextroll.com/blog/dev/2020/04/07/erlang-profiling.html,squeezing server erlang profiling,squeezing server erlang profiling realtime bidding past article hazardous land software optimization without profiling first infrastructure requestlevel timer recon fred hebert erlang anger recon redbug redbug erlang easy profiling eep eep kcachegrind erlgrind lookingglass erlang systemmonitor conclusion observer eprof fprof eflame eministat efficiency guide builtin profiling module,squeezing server erlang profiling written facundo olano april realtime bidding rtb platform featured several time tech blog run fleet erlang application bidder typically range one two thousand node described past article ongoing goal rtb team well source interesting technical minimize operational cost much possible obvious way reduce cost make system efficient mean entering hazardous land software optimization even experienced programmer identifying bottleneck hard enough problem using right tool trying guess could make code run faster waste time likely introduce unnecessary complexity cause problem line cousin premature optimization necessary optimization without profiling first erlang famously known concurrency model faulttolerant design one biggest strength level live inspection tuning offer often little setup runtime cost article outline leverage feature profile system driving optimization lead cost reduction minute read infrastructure interesting aspect realtime bidding fairly lowrisk test production even new code slow contains error bidder architected send nobid response whenever request fulfilled taking advantage incorporate canary deploys daytoday development workflow context optimization mean quickly test performance hypothesis updating code testing live traffic metric dashboard give feedback common metric like timeouts error amount request processed making obvious change beneficial requestlevel timer bid request processing fundamental operation bidder application improvement amount time take u send response ad exchange mean process request per server requiring fewer server handle traffic ultimately saving u money work involved bid request broadly divided series task payload parsing selection matching ad pricing particular ad response encoding common practice periodically measure time invested phase make sure degrade time help provide frame reference use look area code worthy optimization effort sample bid request timing per phase basic way profiling consists timing call given piece code perhaps one deemed suspicious one method described next section evaluates fun report evaluation time histogram metric spec timecall name fun result result timecall metric fun start erlang systemtime microsecond result fun end erlang systemtime microsecond diff end start update histogram metric diff result helper used wrap call function want measure canary deploy timed code production generate average median percentile metric compare overall request time identify bottleneck recon timing request operation useful technique understanding specific request flow give u limited perspective entire system bid request phase handled single process involve idle time waiting external system many periodic task longlived support process bidder benefit systemwide profiling look beyond bid request processing erlang toolbox come play first valuable resource piece software little book fred hebert erlang anger guide perfect reference describes method gaining insight optimizing production system backed realworld experience companion library recon provides safer friendlier productive interface powerful inspection tool follows simple example mostly derived book get node general stats bidderdev node recon nodestatsprint schedulerusage get top memory consumer bidderdev node recon proccount memory bidderbanker currentfunction genserver initialcall proclib bidguardian currentfunction genserver initialcall proclib currentfunction priminet initialcall proclib get top cpu consumer bidderdev node recon proccount reduction currentfunction exometerprobe initialcall proclib currentfunction exometerprobe initialcall proclib currentfunction exometerprobe initialcall proclib get top cpu consumer time window bidderdev node recon procwindow reduction currentfunction viewsbid initialcall proclib currentfunction timer initialcall proclib currentfunction priminet initialcall proclib get process stats including stacktrace bidderdev node recon info meta registeredname bidderbanker dictionary initialcall bidderbanker ancestor biddersup groupleader status running signal link monitor monitoredby trapexit true location initialcall proclib currentstacktrace bidderbanker file biddersrcpacingbidderbankererl bidderbanker file biddersrcpacingbidderbankererl bidderbanker file biddersrcpacingbidderbankererl bidderbanker file biddersrcpacingbidderbankererl genserver file genservererl genserver file genservererl proclib file procliberl memoryused garbagecollection maxheapsize errorlogger true kill true size work suggested book good method run recon procwindow repeatedly try identify pattern eg process frequently rank among top cpu consumer process id passed recon info get useful information stacktrace order understand process using method quickly found commonly accessed data structure contained debug data copied thousand time per second approach though tend highlight longrunning busy process shortlived one could called lot account bigger overhead overall partially overcome running procwindow repeatedly aggregating result location rather process id however better tool look aggregated process time redbug strictly speaking redbug profiling tool useful debugging live system deserves mention article allows safely trace function shell intuitive yet sophisticated way opposed rougher erlang builtin tracing module handy get quick notion function called frequently production data look like bidderdev node redbug start jiffy erlang jiffy encode bidderdev node redbug start jiffy encode return erlang jiffy encode usd erlang jiffy usd bidderdev node redbug start jiffy encode n isinteger n return erlang jiffy encode erlang jiffy including recon redbug erlang application release cost real lifesaver diagnosing production issue tool promote flow powerful adding print code feel natural step debugger useful highly concurrent world anyway erlang easy profiling eep eep allows approach profiling using erlang tracing take snapshot system operation function call count execution time interdependency requires bit effort use safe rest tool described article slow system potentially even killing used carelessly output file eat lot disk space m snapshot take system depending nature application may make sense run directly production example tracing session using eep bidderdev node eep startfiletracing filename timer sleep eep stoptracing note start sleep stop tracing line rely shell responsive tracing could send message call function well force certain part code executed taking snapshot instruction output filenametrace file release directory file need moved production server processed local erlang shell local eep converttracing filename working msg msgssec sec slowdown msg msgssec sec slowdown done turn produce callgrindoutfilename input kcachegrind qcachegrind macos note default tracing discriminate entry per process id would yield similar situation saw recon procwindow interesting view merge function call process accomplished stripping pid grep v ob callgrindoutfilename callgrindoutmergedfilename qcachegrind callgrindoutmergedfilename qcachegrind present snapshot sophisticated ui used spot frequently called function time spent etc eep output qcachegrind since eep based erlang tracing add overhead code may comparatively misrepresent work done builtin function bifs nativeimplemented function nifs timing shown snapshot need taken grain salt nevertheless still great exploratory tool understand different component system interact dependency used learn obscure suspicious area hard spot looking code note erlang profiling library tried yet produce callgrind output erlgrind lookingglass erlang systemmonitor yet another way looking application erlang bif allows set process receive message every time certain condition met particularly helpful u examining long garbage collection schedule long duration latter surface issue nifs would go unnoticed method example use shell based snippet erlang anger bidderdev node loop fun f receive monitor pid event info reconlocation recon info pid location io format monitorp pidp n infop n reconpn event pid info reconlocation end f end bidderdev node spawn fun register tempsysmonitor self erlang systemmonitor self longschedule longgc loop end timer sleep exit whereis tempsysmonitor kill monitor system second output process information shell every time garbage collection schedule take monitorlonggc pid info recon location initialcall proclib currentstacktrace bidderstat file biddersrcbidderstaterl viewsbid file biddersrcviewsviewsbiderl viewsbid file biddersrcviewsviewsbiderl erlstat file biddersrcbidderstaterl bidderwebhandler file biddersrcbidderwebhandlererl proclib file procliberl conclusion article mean exhaustive list erlang diagnosing tool observer eprof fprof eflame eministat list go erlang documentation nice efficiency guide overview builtin profiling module since started effort consistently reduced request time operational cost month month large extent gain came thanks advanced tool erlang ecosystem offer interesting achieved getting know system better fixing bug often removing rather adding specialized code
24,Lobsters,elixir,Elixir programming,Observing Processes in Elixir - The Little Elixir & OTP Guidebook (2015),https://www.akitaonrails.com/2015/11/22/observing-processes-in-elixir-the-little-elixir-otp-guidebook,observing process elixir little elixir otp guidebook,must choice otp worker wrong exactor otp supervisor ets graphically visualizing process fault tolerance supervision tree,yes erlang allows u see going inside runtime environment even take action individual process running inside cool show fault tolerancy observer need explain process matter must understand following concept successfully understand elixir programming nt object runtime instance class prototipical object copy object instead class collection function organized module without dependency internal state instead object roughly speaking process example defmodule myprocess def start acceptingmessages end def acceptingmessages state receive hello message ioputs hello message acceptingmessages state counter newstate state ioputs new state newstate acceptingmessages newstate ioputs acceptingmessages state end end end execute function inside another process spawn brand new concurrent lightweight process iex pid spawn fn myprocessstart end pid called stop block waiting receive new message send message like iex send pid hello world hello world receives hello world atom message pattern match value world message variable concatenates hello world string print recurse call block block waiting message iex send pid counter new state counter iex send pid counter new state counter iex send pid counter new state counter iex send pid counter new state send counter message process pid receive message get state value function argument increment print new state call passing new state new argument block waiting message time receives counter message increase previous state one recurses basically maintain state elixir kill process spawn new one restarts zero function nt object however process superficially process behaves like object careful think process like heavyweight thread though erlang internal scheduler control concurrency parallel load many billion lightweight process hardware allows thread super heavy erlang process super light saw example process internal mechanism receive message process message accumulate internal mailbox choose receive pattern match message recursing order receive new message want process linked monitor process example within iex shell within elixir process could iex self pid iex pid spawn fn myprocessstart end pid iex processalive pid true iex processlink pid true self see current process id iex shell spawn process call block receive call new process different id assert new process indeed alive link iex shell pid process whatever happens process cascade shell iex processexit pid kill exit pid killed interactive elixir press ctrlc exit type h enter help warning redefining module r iex self pid indeed forcefully send kill message process iex shell also killed process iex restarts new pid instead old way one way process different normal object behaves like operating system process crash process affect whole system hold external shared state corrupt system state important concept mechanism define parent process iex example child process linked parent process nt need stupidly suicide child screwed instead trap exit decide later iex processflag trapexit true false iex pid spawnlink fn myprocessstart end pid iex send pid counter new state counter first declare iex shell trap exists die spawn new process link function effect send message new pid check indeed still working iex processexit pid kill true iex processalive pid false iex flush exit pid killed ok forcefully kill new process iex crash time explicitly trapping error check killed pid assert indeed dead also inspect iex process mailbox case flushing whats queued inbox see received message saying child killed could make iex process treat message decide mourn deceased child commit suicide move spawnlink new choice face disaster otp worker letting aside grim metaphor learned parent child process importantly fit role supervisor worker supervised respectivelly worker put code code bug depend external stuff make code crash unexpected reason normal language would start using dreaded trycatch block ugly wrong nt catch error elixir let crash explained previous article everything elixir end called otp application example simple contraption expand upon let rewrite thing otp genserver defmodule myfancyprocess use genserver def startlink genserverstartlink module name module end public api def hello message genservercall module hello message end def counter genservercall module counter end genserver callback def init startcounter ok startcounter end def handlecall hello message state ioputs hello message reply noproc state end def handlecall counter state newstate state ioputs new state newstate reply noproc newstate end end new myfancyprocess essentially myprocess otp genserver top public api function genserver callback benjamin book go great lenghts detail every bit implemented understand basic module use genserver import necessary genserver bit convenience essence one thing create receive block first version wait message function create instance genserver return linked process internally call back function set initial state worker flexible language multiple way thing good single way writing code boring convention one public function call internal synchronous call asynchronous call could call handlecall outside ugly find convention everywhere place start calling directly iex myfancyprocessstartlink ok pid iex myfancyprocesshello world hello world noproc iex myfancyprocesscounter new state noproc iex myfancyprocesscounter new state noproc iex myfancyprocesscounter new state noproc much cleaner version manually spawnlink send message pid handled nicely genserver underneath said result initial crude myprocess example fact convention make u type lot boilerplate many time library called exactor grealy simplifies genserver implementation making previous code become something like defmodule myfancyprocess use exactorgenserver initialstate defcall hello message state ioputs hello message noreply end defcall counter state newcounter state ioputs new state newcounter newstate newcounter end end way cleaner using iex using version next section stick longer version myfancyprocess listed beginning section otp supervisor worker create supervisor supervise defmodule myfancysupervisor use supervisor def startlink supervisorstartlink module end def init child worker myfancyprocess opts strategy oneforone supervise child opts end end simple boilerplace supervisor many detail must learn article purpose important bit first definition child specification saying supervisor start myfancyprocess genserver instead u myfancyprocessstartlink manually second important bit opts list defines strategy oneforone meaning supervisor detects child died restart clean iex copy paste myfancyprocess myfancysupervisor start playing iex shell iex ok suppid myfancysupervisorstartlink ok pid iex myfancyprocesshello foo hello foo noproc iex myfancyprocesscounter new state noproc iex myfancyprocesscounter new state noproc start supervisor see right away start sending message myfancyprocess genserver supervisor successfully started u iex supervisorcountchildren suppid active spec supervisor worker iex supervisorwhichchildren suppid myfancyprocess pid worker myfancyprocess using supervisor pid captured right started ask count many child monitoring example ask detail child well see myfancyprocess started pid iex workerpid supervisorwhichchildren suppid myfancyprocess pid worker myfancyprocess iex processexit workerpid kill true grab worker pid manually force crash screwed right nope iex supervisorwhichchildren suppid myfancyprocess pid worker myfancyprocess iex myfancyprocesscounter new state noproc iex myfancyprocesscounter new state noproc ask supervisor list child see old process indeed vanish new one spawned place supervisor strategy oneforone defined continue making call myfancyprocess see previous state lost restarts zero add state management genserver using number different persistent storage builtin ets think ets builtin memcache service think get idea graphically visualizing process entire article motivated simple thing benjamin book end page book built simple pool system able start process pool guarded supervisor go show observer erlang builtin inspector tool called observer use supervisor builtin function inspect process demonstrated much cooler see visually assuming installed erlang solution propertly ubuntu wget http sudo dpkg start observer directly iex shell like graphical window show stats first powerful becuase insight control entire erlang runtime see status window even show uptime line unix system made stay matter process garbage collector behave nicely towards entire system hook remote observer remote erlang runtimes well wondering jump application tab see pooly exercise look like child pool child supervised proper restart strategy visually kill one one pid labeled observer immediatelly show supervisor took action spawned new child added pool bringing count back fault tolerance proper control mean using otp bit explained article enough concept finally grasp erlang high reliabiliby fuzz basic concept simple hook application otp also nobrainer otp implemented hood make application much reliable clear guideline design application supervises happen application state worker restarted divide responsabilities different group supervisorchildren application supposed look like tree supervision tree failure one leaf bring branch everything know behave recover elegantly really like unix operating system kill one process nt bring system initd monitored service get respawned important optional feature party library choose use builtin erlang must use want play choice best choice pattern implemented concurrent language represents big failure language elixir strength high level control wo nt find anywhere else still nt even talk otp application exchange message across wire really distributed system erlang runtime reload code application running zero downtime akin iex capable phoenix allow development mode code reloading otp give free well worth learning detail went process pid send kill message process trap exit parent child process feel similar unix work know unix easily grasp fit together including elixir pipe operator compared unix pipe similar finally little elixir otp guidebook easy read handson small book read couple day grasp everything quickly summarized much highly encourage buy right
25,Lobsters,elixir,Elixir programming,Introducing Ecto Resource,https://blog.testdouble.com/posts/2020-03-24-introducing-ecto-resource/,introducing ecto resource,crudy context jam work elixirphoenix application context crud ecto ectoresource clean mess ectoresource hex repo schema exdoc hex documentation,crudy context jam work elixirphoenix application context allow separation concern data business logic often time first thing add many basic crud function context essentially delegate ecto boilerplate code lead boilerplate test time crud operation add application compound problem name apis standard function start drift module causing unexpected behavior bug short mess ectoresource clean mess ectoresource hex package aim reduce boilerplate code involved basic crud operation providing macro generate crud function given ecto repo schema consider following context without using ectoresource generated mix phxgencontext account user user defmodule myappaccounts moduledoc account context import ectoquery warn false alias myappaccountsuser alias myapprepo def listusers repoall user end def getusers id repoget user id def createusers attrs user userchangeset attrs repoinsert end def updateusers user user attrs user userchangeset attrs repoupdate end def deleteusers user user repodelete user end def changeusers user user userchangeset user end end function mostly delegate repo addition binding operation user module alternatively generate function using ectoresource alleviates boilerplate allows function within module focused sophisticated operation defmodule myappaccounts moduledoc account context import ectoquery warn false alias myappaccountsuser alias myapprepo use ectoresource usingrepo repo resource user end end default resource generate basic crud function myappaccountscreateuser myappaccountsdeleteuser myappaccountsgetuser myappaccountsgetuserby myappaccountsupdateuser note generate list using following function console iex repo schema functionnames mycontextresource resource need specific use filter option usingrepo repo resource user create delete end would generate given function also use except filter option inverse usingrepo repo resource user except create create delete delete end would generate given function myappaccountsgetuser myappaccountsgetuserby myappaccountsupdateuser see ectoresource macro eliminate boilerplate function definition let context module remain focused function deviate standard crud operation function generated ectoresource api providing dependable standard might delighted know function generated context included application documentation using exdoc like see much removed context install ectoresource application adding dependency defp deps ectoresource end mix depsget set ready use ectoresource macro application check hex read documentation
26,Lobsters,elixir,Elixir programming,The BEAM Has Spoiled Me,https://gvaughn.github.io/2020/08/08/beam_spoiled_me.html,beam spoiled,beam spoiled began fault tolerance let crash freedom bigger thought game changer,august beam spoiled greg vaughn noticed change prefer develop software since focusing career elixir allows think bigger thought develop lower friction le fear want go back began fault tolerance many people introduced elixir focus concurrency joe armstrong even called erlang concurrency oriented language note point generic beam language experience come elixir perspective please excuse bias terminology find helpful consider concurrency logical consequence primeval concern fault tolerance achieving beamstyle fault tolerance come isolated process affect crash plus supervisory process informed another process dy core point process contain blast radius damage caused error happens isolation quality enable also make great candidate concurrency let crash first heard let crash mantra erlang community sounded crazy based prior development exerience important understand license irresponsibility care system crashing core recognition system error even write bugfree code hardware bug u eventually architecture managing blast radius damage little part system crashing longer scary thing le fear yes please learned write elixir code focus blast radius driver reach process even case need concurrency use process enclose damage error might cause use supervision tree durable work queue recover minor crash process learned prefer upserts insert allow logic retried safely greater idempotency two idea process enclose possible error plus idempotency become second nature elixir code write freedom automatic ability recover error change complexion topic like test coverage enforcement static type extensive code review etc heart preventing error introduced first place yes recognize secondary benefit still good thing advocating irresponsibility solid safety net fault tolerance beam able look different perspective see add friction inertia delivering software perhaps temper reliance upon favor greater delivery speed circumstance le fear mean freedom choose bigger thought elixir reignited intellectual interest software development found via erlang beam history general huge body wisdom distributed system learn new tool toolbox think software process lightweight pervasive offering freedom fear crashing perspective shifted exciting way think writing web application thought immediately limited think building system think bigger thought better abstraction build upon team happy use elixir write web application fit preexisting microservice deployment model urge developer reach bigger thought fault tolerant lighweight process enable consider process logical microservice need friction deploying separately serializing tofrom json container orchestration distributed logging etal deploy entire system million interacting logical microservices single beam release game changer elixir beam certainly game changer fearless build system hope share freedom others beam spoiled good way tag beam elixir introspection
27,Lobsters,elixir,Elixir programming,"Parse, don't validate — Elixir edition, Part Two",https://well-ironed.com/articles/parse-dont-validate-elixir-edition-part-two/,parse nt validate elixir edition part two,previous bottomup lot written resultt simple parser railwayoriented programming result module breaking specific part dataparser leveraging builtin builtin summing,couple month since published previous post topic parsing validation sketched proposal truly smart constructor could look like elixir took approach separating deserialization data onthewire happen anywhere like protocolspecific controller construction domain object crucially wanted make sure object construct semantically valid completely obviating need function validate valid smart constructor function take primitive data type return either ok thevalidobject object constructed input error thereasonfortheerror input specify valid object wait type parser bottomup lot written topic parsing computer science going take approach say parser simply function take unstructured input either produce structured output fails capture fact using following type definition type parser resultt parser function accepts conceivable input return either successfullyparsed type kind error going dwell error type interesting thing could shipped error type make descriptive string resultt defined type b ok error b simple parser following function meet criterion parser def id input resultok input end given input simply return input valid parse result one immediately useful let look practical parser def number input case isnumber input true resultok input false resulterror number inspect input end end let try integer float input satisfy parser iex number ok iex number ok sure enough elixir data type iex number hello world error number hello world iex number ok error number ok iex number error number let extend parser accept nonnegative number def nonnegnumber input case isnumber input input true resultok input false resulterror nonnegative number inspect input end end parser strictly useful detecting type u also constraining value particular range iex nonnegnumber ok iex nonnegnumber error nonnegative number iex nonnegnumber mary little lamb error nonnegative number mary little lamb completeness let clamp number interval def input case isnumber input input input true resultok input false resulterror number range inspect input end end parser succeed passed narrow range numeric input iex ok iex error number range iex ok iex list error number range list said parser getting weirdly specific slightly unwieldy right think still looking quite readable let say need parse number range string parse number range implement piling even functionality onto single specific parser def input case isnumber input input input true resultok input false case isbinary input floatparse input num num num resultok num resulterror numberlike range inspect input end end end sure enough expect iex ok iex ok iex error numberlike range iex error numberlike range iex ok iex foo error numberlike range foo however code particularly satisfying look work additionally parse number float avoid yet another nested case expression cartesian case pattern matching promise functional programming use composition extension create bigger program would nice could compose many small generic parser larger specific turn apply railwayoriented programming result module several interesting function take advantage one help u write code happy path parser passing result successful parse next parser bailing first error let see help u refactor function breaking specific decompose requirement regarding input must number string parseable number nonnegative smaller keep thing simple let first ignore string parseable number requirement simply line numeric specification like def anumber input isnumber input resultok input def anumber input resulterror number input def nonnegative input input resultok input def nonnegative input resulterror input def input input resultok input def input resulterror input def numberinrange input anumber input resultandthen resultandthen end let try use parser iex numberinrange ok iex numberinrange atom error number atom iex numberinrange error iex numberinrange error see chain parser return ok value numberinrange exit successful parse final result parser fail bail return failed parser error message caller let tackle hardest requirement input either number stringthatcanbereadasanumber conceptually like parser whose input represent set union number parser stringtonumberparser would look like first need aware elixir separate function parsing integer float stringtonumberparser need union stringtofloat parser stringtointeger parser let write basic building block first def floatstring input case isbinary input floatparse input n resultok n resulterror string representation float inspect input end end iex floatstring ok iex floatstring ok iex floatstring ok iex floatstring error string representation float iex floatstring foo bar error string representation float foo bar let write analogous parser integer def integerstring input case isbinary input integerparse input n resultok n resulterror string representation integer inspect input end end iex integerstring ok iex integerstring error string representation integer iex integerstring error string representation integer okay building block need let create parser represents union three requirement let see remember based code def numericstring input unionparser union unionparser input end union come easy part dataparser module exactly need try apply parser received order us first successful result bail appropriate message take look entire parsing program defmodule alias feresult import dataparser union def new input numericstring input resultandthen resultandthen end defp numericstring input unionparser union unionparser input end defp integerstring input case isbinary input integerparse input n resultok n resulterror string representation integer inspect input end end defp floatstring input case isbinary input floatparse input n resultok n resulterror string representation float inspect input end end defp anumber input isnumber input resultok input defp anumber input resulterror number input defp nonnegative input input resultok input defp nonnegative input resulterror input defp input input resultok input defp input resulterror input end function public function main workhorse contains result pipe railwayoriented program first step pipe say apply parser union anumber integerstring floatstring one parse successfully pas input nonnegative successful pas result returning whatever come last step presto module encapsulates parsing rule built rather verbosely hand sake learning expose one function precisely smart constructor certain every value created exactly claim validation work iex ok iex ok iex error try parse input satisfy union parser get swanky detailed domainerror structure iex hello error errordomainerror causedby nothing detail input hello parser function function function reason noparserapplies leveraging builtin dataparsers lot work building smart constructor hand save lot time using parser bundled data package particular parser generator function take predicate function map onto parser semantics first argument predicate function second either default error function receives bad input leverage second argument retain nice error message time form tagged tuples module golfed like defmodule alias feresult import dataparser union predicate def new input union predicate notanumber input resultandthen predicate isnegative resultandthen predicate end defp integerstring input case isbinary input integerparse input n resultok n resulterror string representation integer inspect input end end defp floatstring input case isbinary input floatparse input n resultok n resulterror string representation float inspect input end end end iex error iex ok iex error isnegative look pretty good still repetitive floatstring integerstring function differ elixir module used call let convert new style parser interface quite simple return function take single argument return resultt def stringreprof mod mod integer float fn input case isbinary input modparse input n resultok n resulterror string representation inspect mod inspect input end end end partially apply function module name receive nice parser work like iex stringreprof float ok iex stringreprof float foo error string representation float foo iex stringreprof integer error string representation integer iex stringreprof integer ok turn stringreprof parserbuilder part builtin suite parser come dataparser called stringof return detailed error struct failure work principle compose parser together arrive rather succinct smart constructor defmodule alias feresult import dataparser union predicate import dataparserbuiltin stringof def new input union predicate notanumber stringof integer stringof float input resultandthen predicate isnegative resultandthen predicate end end summing gone manually specifying railwayoriented parsing function special numeric data point leveraging power parser combinators specifying data point declarative fashion might rightly complain original code shorter le dependency job faster declarative smart constructor artificial scenario might indeed prudent go straightforward approach overengineered numeric bracket function quite bit indeed however hope show next installment declarative method really shine data parse becomes complex exhibit internal dependency stay tuned turn parse validate gnarly json payload correctbyconstruction elixir structs
28,Lobsters,elixir,Elixir programming,Elixir RAM and the Template of Doom,https://www.evanmiller.org/elixir-ram-and-the-template-of-doom.html,elixir ram template doom,elixir ram template doom evan miller gather script tracing limit le costly phoenix request request template doom parting wisdom phoenix chicago bos dtrace note evanmillerorg twitter r wizard data le time communicate discovery visually back evan home page subscribe r twitter youtube,elixir ram template doom evan miller april attempt convince two line code elixir interesting programming language ever used ready worry code involve quicksort metaprogramming anything like go ok file fileopen tmpsomethingtxt write raw filewrite file rereplace hello goodbye amp code nothing special open file writes short string replacing ampersand hardcoded string html entity amp probably sharp enough write equivalent code favorite language couple minute le code entirely equivalent elixir code least perspective run tracing program like strace dtruss nonelixir code probably see something like write hello usual syscall expect trace elixir program instead see something like writev give strange hexadecimal number point good old write good enough mr fancy pant elixir answer immediately obvious code sample go long way towards explaining unique performance characteristic well anomaly might encounter ever try benchmarking erlang elixirâ html template read tale technical subtlety engineering culminates inmemory rendering template doom gigabyte monster bottom sea end post promise look web server way anyway enough gabbing dive gather get handle thing first revisit stringreplacement code rereplace hello goodbye amp paste code elixir shell see something slightly unexpected hello amp goodbye instead flat string erlang oops say erlang meant elixir creates nested list containing four leaf element add string expect hello amp goodbye first glance may seem like pointless complication see computer think situation look man page writev see mean writes data multiple memory location single system call wrote little dtrace script unpack writev call saw earlier peek elixir code actually system call log script writev return writev data byte hello writev return writev data byte writev return writev data byte amp writev return writev data byte goodbye original hexademical number writev call introduction memory address vector vector contains memory address four memory address represented big hexadecimal number next string address see log elixir writing element nested list separately hello amp goodbye notice anything peculiar memory location one perhaps look like others hello amp goodbye good hexadecimal lay character stated memory address simply rearranging expanding data log boldfacing start address clarity p h e l l g b e see yet nested list string fragment list make new string start make sense three pointer original string plus outoforder pointer replacement string word set modification old string also see extra tiny optimization performed regex engine notice final string us ampersand original string rather replacement string data structure called io list designed leverage writev thus minimize data copy writing disk network language wipe original string copy whole thing missing whole class nocopy latecopy performance optimization course pointer panacea sometimes data copying cheaper pointer juggling use dtrace explore erlang vm implementation see system draw various line attempt balance engineering consideration tracing limit try tracing two line code filewrite file enummap fn foobar end filewrite file enummap fn foobar end attempt write io list file first one foobar repeated time second foobar repeated time might think task result syscalls reality first line code call writev vector element second one flattens io list single blob memory call write concatenated data much language try string slightly longer shorter foobar see trigger simply number element list rather total size resulting string hit element list erlang switch concatenating data contiguous chunk memory poke around vm code see triggered constant smallwritevec dtrace log vector reveals something else writev something might surprise take look writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar notice anything memory address well strain eye mean point different address copy foobar lying around memory interestingly case move foobar literal outside closure elixir code trace code instead foobar foobar filewrite file enummap fn foobar end see end result get rather different trace writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar time memory address work hood small string elixir instantiated wherever literal appears code foobar inside closure new string created whenever closure executed foobar outside closure execution closure result new reference string coming say javascript point might seem obvious remember string elixir immutable necessarily expect new instantiation execution code fact rule change string defined byte larger second magic number erlonheapbinlimit vm code big literal appear compiled module allocated shared heap refcounted see memory address trace regardless literal appears code worth noting string literal elixir shell always use smallstring rule complicated might thinking great care foobar got le costly show benchmark going blow mind make question everything thought knew web server performance well everything except great stuff learned article far ready going back something like scene raider lost ark one face melt head explodes simply unsee two elixir template wired excellent phoenix web framework template first iters blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah end template second iters blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah end template produce identical output lot blahblahblahblah difference second template insert string length zero middle iteration going believe one template greater throughput get excited caching computed template fragment better close look benchmark output benchmark first template without empty string running test http thread connection thread stats avg stdev max stdev latency reqsec request read socket error connect read write timeout requestssec transfersec benchmark second template empty string running test http thread connection thread stats avg stdev max stdev latency reqsec request read socket error connect read write timeout requestssec transfersec ruhroh inserting empty string template increase performance could learned anything far syscalls matter strace dtrace friend use look template perspective first template produce lot output like writev return writev data byte nblahblahblahblah second template produce output like writev return writev data byte ok first template delivered client tiny byte chunk empty string included second template along http response header flattened one big kilobyte string instead verrrrrrrry interesting tell least little curious going discrepancy traced another compiletime constant erlang vm one known erlsmalliobinlimit determines maximum string size consolidated one big string hardcoded four time value erlonheapbinlimit byte exact string smaller equal limit consolidated larger string preserved writev vector notice template example deliberately contrived byte chunk blahblahblahblah exceed limit get entry writev vector split chunk half true nefarious purpose mysterious empty string resulting chunk limit get consolidated happens computer consolidation greater throughput particular template come cost higher ram usage brings template doom enough information render template doom recently recovered sunken spanish galleon doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom end template produce file word doom repeated billion time totaling gb size template consists entirely chunk larger byte chunk compiled refer memory address know server storing million boxed pointer order magnitude gb machine vm topped gb ram usage serving single copy template doom best part make template doom crash server inserting empty string template dare try rather secondbest part best part understand crash email implemented template doom assembly using five molecule ram remember silly benchmark underpowered macbook point exercise empty string template string million time order save help give tool understand going hood system engineering situation call small memory footprint tinychunk writev strategy may better others great cpu caching slabofram may fine exercise starting point exploration parting wisdom memory architecture fit neatly onto problem dynamic template rendering rendering speed killing productivity making customer swim black pool pageload depression take look phoenix chicago bos framework work writev io list well kqueueepoll slash cpu ram usage compared nonerlang system many case obviate need serverside erlang vm clever produce oddity highly informal testing look like erlsmalliobinlimit particular cranked bit perhaps byte guardian vm might consider making tunable compiletime parameter using erlang elixir might want poke around favorite template implementation see using writev hood tracer make quick work task strace linux dtruss o x good start absolutely nothing beat dtrace power see writev trace log might opportunity improving memory architecture keep eye memory location trace output little string reuse go long way finally enjoyed using elixir code example found library could make better use io list particularly regex string module well html entityescaping without io list elixir eagercopying memory like everybody else missing one feature make erlang vm technically interesting note reading evanmillerorg random collection math tech musing liked might also enjoy get new article published via twitter r want look statistical pattern mysql postgresql sqlite database desktop statistic software wizard help analyze data le time communicate discovery visually without spending day struggling pointless command syntax check back evan home page subscribe r twitter youtube
31,Lobsters,elixir,Elixir programming,Homemade analytics with Ecto and Elixir,https://dashbit.co/blog/homemade-analytics-with-ecto-and-elixir,homemade analytics ecto elixir,homemade analytics ecto elixir tracking upserts async batched writes process dynamic process elixir registry elixir plug summary,homemade analytics ecto elixir dashbit website wanted avoid tracking user much possible mean cooky unfortunately analytics use cooky tracking andor fingerprinting however still want see page website frequently accessed purpose decided roll analytics system article cover implemented analytics system ecto upserts used elixir registry elixir process reduce pressure database tracking upserts idea simple every time someone access page store information database however need track access instant happen u tracking many access page day completely fine therefore every time page accessed given date attempt insert entry database entry already exists update counter instead luckily done upsert ecto let first define schema database resource defmodule myappmetricsmetric use ectoschema primarykey false schema metric field date date primarykey true field path string primarykey true field counter integer default end end three field date page path counter number access date path make composite primary key migration look like defmodule dashbitrepomigrationscreatemetrics use ectomigration def change create table metric primarykey false add date date primarykey true add path string primarykey true add counter integer default end end end execute following command whenever want count one page access defp upsert path counter import ectoquery date dateutctoday query dashbitmetricsmetric update inc counter counter dashbitrepoinsert dashbitmetricsmetric date date path path counter counter onconflict query conflicttarget date path end code performs upsert incrementing number access page value counter typically entry exist one immediately created core analytics straightforward solution strong requirement database accepting writes application heavily rely database analytics system place website us database believe important show article blog post even error talking storage layer address decided move upserts separate process async batched writes process laid previous section want move database writes done analytics code separate process another concern solution far handle overload huge spike traffic could end putting much pressure database sense would good idea batch writes honest application fine spike page load within hundred microsecond thanks phoenix database usage minimal hand small project perfect opportunity experiment decided explore analytics solution would look like performed writes asynchronously batch came every time user access page spawn elixir process track access page process already exists said page message existing process instead goal process collect access within time interval writing database x second going call worker process start like defmodule dashbitmetricsworker use genserver restart temporary define module process declare genserver also say process temporary ie dy want supervisor restart assuming process dy logic dynamically spawn process page eventually start new one anyway next define init callback process impl true def init path processflag trapexit true ok path counter end init callback trap exit set process state path first element page path second element number page visit process able receive bump message message sent whenever need bump counter handled handleinfo callback impl true def handleinfo bump path scheduleupsert noreply path end impl true def handleinfo bump path counter noreply path counter end receive bump page access ie counter zero bump counter also schedule upsert event eventually write access database counter simply bump return updated state scheduling upsert code look like defp scheduleupsert processsendafter self upsert enumrandom end impl true def handleinfo upsert path counter upsert path counter noreply path end defp upsert path counter function previous section end scheduleupsert function schedule message current process self message named upsert delivered random value reason picked random value avoid scenario multiple process different page spawned time write database time next define another handleinfo clause time handle scheduled upsert message clause simply invokes upsert function defined previous section reset state back path make new bump schedule new upsert finally implement terminate callback invoked whenever application shutting impl true def terminate path ok def terminate path counter upsert path counter end application shutting may pending writes worker want send database part termination logic one important thing remember terminate callback called default shutting unless trapping exit called processflag trapexit true init function process implemented delivers requirement far writes asynchronous happen separate process also batched using interval last step need implement actually spawn process fly user navigate website dynamic process elixir registry order spawn find process page going use elixir registry also need dynamic supervisor going parent worker process let implement logic overaching metric module alongside bump page function let get started basic defmodule dashbitmetrics use supervisor worker dashbitmetricsworker registry dashbitmetricsregistry supervisor dashbitmetricsworkersupervisor dashbitmetrics module supervisor two child registry supervisor worker since worker started dynamically request come use dynamicsupervisor store name worker registry dynamic supervisor process module attribute convenience next define supervisor started init callback def startlink opts supervisorstartlink module ok name module end impl true def init ok child registry key unique name registry dynamicsupervisor name supervisor strategy oneforone supervisorinit child strategy oneforall end registry dynamic supervisor place write bump function def bump path isbinary path pid case registrylookup registry path pid pid case dynamicsupervisorstartchild supervisor worker path ok pid pid error alreadystarted pid pid end end send pid bump end end bump function look registry process given path return process identifier pid one exist ask worker supervisor start worker dynamically expect two possible outcome startchild ok pid worker started error alreadystarted pid worker given path already exists need second branch address potential race condition two user may access page first time time scenario fail attempt spawn worker one succeed return already started error find pid send bump message almost two step left first need configure worker register whenever started done via startlink function let go back worker add registry dashbitmetricsregistry def startlink path genserverstartlink module path name via registry registry path end need start dashbitmetrics supervision tree typically done application supervision tree typically located libmyappapplicationex child dashbitrepo dashbitmetrics dashbitendpoint whenever user access page need call dashbitmetricsbump path path current page address case store path without host without query string using plug built connpathinfo field also perform writes page successfully rendered status overall bumping code look like plug bumpmetric defp bumpmetric conn opts registerbeforesend conn fn conn connstatus path enumjoin connpathinfo dashbitmetricsbump path end conn end end summary article covered minimal analytics system using ecto genserver elixir registry performs writes asynchronously batch usage registry dynamically spawn process map different resource lifecycle used many different scenario one important aspect solution process page created stay alive new deployment work u le page know maximum number process bound low value although elixir process lightweight thanks erlang vm large number page million page could potentially endup hundred thousand unused process case would slightly change solution terminate process every upsert something along line impl true def handleinfo upsert path counter first unregister stop receiving new message registryunregister registry path schedule stop second give u time process late message processsendafter self stop noreply path counter end impl true def handleinfo stop path counter stop terminate callback write pending writes stop shutdown path counter end hope enjoyed article learned thing two could useful next project
32,Lobsters,elixir,Elixir programming,sorentwo/oban - Robust job processing in Elixir,https://github.com/sorentwo/oban,sorentwooban robust job processing elixir,enterprise grade feature table content official documentation hexdocs feature reliability consistency observability advantage tool fewer dependency rdbms transactional control database backup advanced feature isolated queue queue control resilient queue job canceling triggered execution unique job scheduled job periodic cron job job priority historic metric node metric queue draining telemetry integration telemetry requirement oban webpro getobanpro installation hex ecto jason postgrex usage note release usage configuring queue caveat guideline defining worker enqueueing job pruning historic job caveat guideline unique job strong guarantee performance note periodic job standard rule cron expression crontab guru caveat guideline prioritizing job testing caveat guideline usage integration testing error handling error detail instrumentation limiting retries limiting execution time instrumentation logging telemetry reporting error sentry isolation supervisor isolation community contributing,robust job processing elixir backed modern postgresql reliable observable loaded enterprise grade feature table content note readme unreleased master branch please reference official documentation hexdocs latest stable release feature oban primary goal reliability consistency observability fundamentally different background job processing tool retains job data historic metric inspection leave application running indefinitely without worrying job lost orphaned due crash advantage tool fewer dependency running web app good chance running top rdbms running job queue within postgresql minimizes system dependency simplifies data backup transactional control enqueue job along database change ensuring everything committed rolled back atomically database backup job stored inside primary database mean backed together data relate advanced feature isolated queue job stored single table executed distinct queue queue run isolation ensuring job single slow queue ca nt back faster queue queue control queue started stopped paused resumed scaled independently runtime locally across running node even environment like heroku without distributed erlang resilient queue failing query wo nt crash entire supervision tree instead trip circuit breaker retried future job canceling job canceled middle execution regardless node running stop job flag discarded triggered execution database trigger ensure job dispatched soon inserted database unique job duplicate work avoided unique job control uniqueness enforced argument queue worker even subargument level period time scheduled job job scheduled time future second periodic cron job automatically enqueue job cronlike schedule duplicate job never enqueued matter many node running job priority prioritize job within queue run ahead others historic metric job processed row nt deleted instead job retained database provide metric allows user inspect historic job see aggregate data job queue argument level node metric every queue record metric database runtime used monitor queue health across node may used analytics queue draining queue shutdown delayed slow job finish executing shutdown shutdown start queue paused stop executing new job job left running shutdown grace period may rescued later telemetry integration job lifecycle event emitted via telemetry integration enables simple logging error reporting health checkup without plugins requirement oban developed actively tested elixir erlangotp postgresql running oban currently requires elixir erlang postgresql oban webpro webbased user interface managing oban along official set plugins worker available private package learn oban webpro getobanpro installation oban published hex add list dependency mixexs def deps oban end run mix depsget install oban dependency including ecto jason postgrex package installed must create database migration add obanjobs table database mix ectogenmigration addobanjobstable open generated migration editor call function obanmigrations defmodule myapprepomigrationsaddobanjobstable use ectomigration def obanmigrationsup end specify version ensuring roll way back necessary regardless version migrated def obanmigrationsdown version end end run oban versioned migration database migration version idempotent never change release new version released may need run additional migration run migration create table next see usage integrate oban application start defining job note release using release may see postgrex error logged initial deploy deploy requiring oban migration error temporary migration completed queue start producing job normally usage oban robust job processing library us postgresql storage coordination oban instance supervision tree application mean wo nt started automatically must included application supervision tree configuration passed supervisor allowing configure oban like rest application configconfigexs config myapp oban repo myapprepo plugins obanpluginspruner queue default event medium libmyappapplicationex defmodule myappapplication moduledoc false use application alias myapprepo alias myappwebendpoint def start type args child repo endpoint oban obanconfig supervisorstartlink child strategy oneforone name myappsupervisor end conditionally disable crontab queue plugins defp obanconfig applicationgetenv myapp oban end end running test want disable plugins enqueuing scheduled job job dispatching altogether testing configtestexs config myapp oban crontab false queue false plugins false see installation instruction readme hexdocs guide detail migrate database configuring queue queue specified keyword list key name queue value maximum number concurrent job following configuration would start four queue concurrency ranging queue default mailer event medium may also use expanded form configure queue individual override queue default mailer limit pollinterval timerseconds event limit paused true declared mailer limit poll deschedule job every second event queue start paused state mean wo nt process anything called start nt limit number queue many job may execute concurrently queue additional guideline caveat guideline queue run many job possible concurrently configured limit make sure system enough resource ie database connection handle concurrent load queue limit local pernode global percluster example running queue local limit one three separate node effectively global limit three require global limit must restrict number node running particular queue job configured queue execute job queue stay database untouched careful many concurrent job make expensive system call ie ffmpeg imagemagick beam ensures system stay responsive load guarantee nt apply using port shelling command defining worker worker module work processing job minimum must define function called obanjob struct note args field job struct always string key regardless key type job enqueued args stored jsonb postgresql serialization process automatically stringifies key define worker process job event queue defmodule myappbusiness use obanworker queue event impl obanworker def perform obanjob args id id model myapprepoget myappbusinessman id case args inthe business ioinspect model votefor vote ioinspect vote model ioinspect model end ok end end use macro also accepts option customize max attempt priority tag uniqueness defmodule myapplazybusiness use obanworker queue event priority maxattempts tag business unique period impl obanworker def perform job business slowly ok end end successful job return ok ok value tuple value returned used control whether job treated success failure discarded completely deferred later see obanworker doc detail failure condition obantelemetry detail job reporting enqueueing job job simply ecto structs enqueued inserting database convenience consistency worker provide function convert args map job changeset suitable insertion id inthe business ofdoing business myappbusinessnew obaninsert worker default may overridden passing option id votefor none myappbusinessnew queue special maxattempts obaninsert job may scheduled specific datetime future id myappbusinessnew scheduledat u obaninsert job may also scheduled second time future id myappbusinessnew schedulein obaninsert unique job configured worker job built email brewster examplecom myappmailernew unique period field queue worker obaninsert job priority specified using integer default highest priority id myappbackfillernew priority obaninsert number tag added job dynamically time inserted id id id myapponboardmailernew tag mailer record id obaninsert multiple job inserted single transaction ectomultinew obaninsert bjob myappbusinessnew id obaninsert mjob myappmailernew email brewser examplecom repotransaction occasionally may need insert job worker exists another application case use build changeset manually id userid obanjobnew queue default worker otherappworker obaninsert preferred way inserting job provides oban advanced feature ie unique job however use application function necessary see full list job option pruning historic job job stats queue introspection built keeping job row database completed allows administrator review completed job build informative aggregate expense storage unbounded table size prevent obanjobs table growing indefinitely oban provides active pruning completed discarded job default pruning retains job second configure longer retention period providing maxage second pruner plugin set maxage minute config myapp oban plugins obanpluginspruner maxage caveat guideline pruning besteffort performed outofband mean limit soft job beyond specified age may pruned immediately job complete pruning applied job completed discarded reached maximum number retries manually killed never delete new job scheduled job job failed retried unique job unique job feature let specify constraint prevent enqueuing duplicate job uniqueness based combination args queue worker state insertion time configured worker job level using following option period number second job longer considered duplicate always specify period infinity used indicate job considered duplicate long job retained field field compare evaluating uniqueness available field args queue worker default three used key specific subset args consider comparing historic job allows job multiple keyvalue pair args compared using subset state job state checked duplicate available state available scheduled executing retryable completed discarded default state except discarded checked prevents duplicate even previous job completed example configure worker unique across field state second use obanworker unique period configure worker unique worker queue use obanworker unique field queue worker period configure worker unique executed use obanworker unique period state available scheduled executing consider url key rather entire args use obanworker unique field args worker key url use specify uniqueness across state including discarded use obanworker unique period state obanjobstates strong guarantee unique job guaranteed transactional lock database query rely unique constraint database make uniqueness entirely configurable application code without need database migration performance note application make heavy use unique job may want add index args column obanjobs table column considered uniqueness already covered index periodic job oban allows job registered cronlike schedule enqueued automatically periodic job registered list cron worker cron worker option tuples config myapp oban repo myapprepo crontab myappminuteworker myapphourlyworker args custom arg myappdailyworker maxattempts mon myappmondayworker queue scheduled tag monday daily myappanotherdailyworker job would executed follows myappminuteworker executed every minute myapphourlyworker executed first minute every hour custom args myappdailyworker executed midnight every day retries myappmondayworker executed noon every monday scheduled queue crontab format respect standard rule one minute resolution job considered unique minute prevents duplicate job multiple node across node restarts like job recurring job use queue specified worker module default one specified cron expression standard cron expression composed rule specifying minute hour day month weekday rule field comprised literal value wildcards step value range wildcard match value literal match step match value multiple range match value within range step value used conjunction range part may multiple rule rule separated comma allowed value field follows minute hour day month alias jan feb mar etc weekday alias sun mon tue etc following cron extension supported hourly daily well midnight weekly monthly yearly well annually reboot run boot across entire cluster specific example demonstrate full range expression first minute every hour every fifteen minute standard business hour dec day midnight december fri hour rush hour friday depth information see man documentation cron crontab system alternatively experiment various expression online crontab guru caveat guideline schedule evaluated utc unless different timezone configured see information configuring timezone worker used regular scheduled job long accept different argument duplicate job prevented transactional lock unique constraint worker used regular scheduled job must specify unique option le long running job may execute simultaneously scheduling interval shorter take execute job prevent overlap passing custom unique opts crontab config customargs scheduled true uniqueopts period state available scheduled executing config myapp oban repo myapprepo crontab myappslowworker args customargs unique uniqueopts prioritizing job normally available job within queue executed order scheduled override normal behavior prioritize deprioritize job assigning numerical priority priority allowed highest priority lowest default priority unless specified job equally high priority job higher priority execute job lower priority within particular priority job executed scheduled order testing oban provides helper facilitate testing helper handle boilerplate making assertion job enqueued use helper test must include testing module specify app ecto repo use obantesting repo myapprepo assert refute list job enqueued within integration test assertenqueued worker myworker args id refuteenqueued queue special args id assert args id allenqueued worker myworker also easily unit test worker function automates validating job args option worker result single function call assert ok performjob myworker id assert ok performjob myworker id attempt maxattempts assert error performjob myworker bad arg see obantesting module detail caveat guideline noted usage guideline running test disable job dispatching setting queue false queue nil testexs config keyword configuration deep merged setting queue wo nt effect disable plugins via plugins false default plugins fixed pruner nt necessary testing mode job created within sandbox rolled back end test additionally periodic pruning query raise dbconnectionownershiperror application boot disable cron job via crontab false periodic job nt useful testing scheduling lead random ownership issue sure use ecto sandbox testing oban make use database pubsub event dispatch job pubsub event never fire within transaction since sandbox test run within transaction event fire job wo nt dispatched config myapp myapprepo pool ectoadapterssqlsandbox integration testing integration testing may necessary run job work essential test complete ie sending email processing medium etc execute available job particular queue calling directly test example process pending job mailer queue testing business logic defmodule myappbusinesstest use myappdatacase async true alias myapp business worker test stay business business ok businessscheduleameeting email monty brewstercom assert success failure obandrainqueue queue mailer make assertion email delivery end end see additional detail error handling job return error value raise error exit execution detail recorded within error array job number execution attempt configured maxattempts limit job automatically retried future retry delay exponential backoff meaning job second attempt third fourth etc see obanworker documentation customizing backoff alternative backoff strategy error detail execution error stored formatted exception along metadata failure occurred attempt caused error stored following key utc timestamp error occurred attempt attempt number error occurred error formatted error message stacktrace see instrumentation doc example integrating external error reporting system limiting retries default job retried time number retries controlled maxattempts value set worker job level example instruct worker discard job three failure use obanworker queue limited maxattempts limiting execution time default individual job may execute indefinitely undesirable may define timeout millisecond callback worker module example limit worker execution time second def myappworker use obanworker impl obanworker def perform job somethingthatmaytakealongtime ok end impl obanworker def timeout job timerseconds end function accepts obanjob struct customize timeout using job attribute define timeout value job args def timeout args timeout timeout timeout define timeout based number attempt def timeout attempt attempt attempt timerseconds instrumentation logging oban provides integration telemetry dispatching library metric easy report oban metric backend attaching oban event example sample unstructured log handler defmodule myappobanlogger require logger def handleevent oban job start measure meta loggerwarn oban started metaworker measuresystemtime end def handleevent oban job event measure meta loggerwarn oban event metaworker ran measureduration end end attach handler success failure event applicationex event oban job start oban job stop oban job exception telemetryattachmany obanlogger event obantelemetry module provides robust structured logger handle oban telemetry event example attach within applicationex module ok obantelemetryattachdefaultlogger detail default structured logger information event metadata see doc obantelemetry module reporting error another great use execution data error reporting example integrating sentry report job failure defmodule errorreporter def handleevent oban job exception measure meta extra meta maptake id args queue worker mapmerge measure sentrycaptureexception metaerror stracktrace metastacktrace extra extra end def handleevent oban circuit trip measure meta sentrycaptureexception metaerror stacktrace metastacktrace extra meta end end telemetryattachmany obanerrors oban job exception oban circuit trip use exception event send error report honeybadger rollbar appsignal application monitoring platform isolation oban support namespacing postgresql schema also called prefix ecto prefix job table reside outside primary schema usually public multiple separate job table use prefix first specify within migration defmodule myapprepomigrationsaddprefixedobanjobstable use ectomigration def obanmigrationsup prefix private end def obanmigrationsdown prefix private end end migration create private schema table function trigger within schema database migrated specify prefix configuration config myapp oban prefix private repo myapprepo queue default job inserted executed using privateobanjobs table note write job privateobanjobs table need specify prefix manually insert job directly repo supervisor isolation obanjobs table isolated within schema notification event also isolated mean insertupdate event dispatch new job prefix run multiple oban instance different prefix system entirely isolated provided give supervisor distinct id configure application start three oban supervisor using public special private prefix respectively def start type args child repo endpoint supervisorchildspec oban name obana repo repo id obana supervisorchildspec oban name obanb repo repo prefix special id obanb supervisorchildspec oban name obanc repo repo prefix private id obanc supervisorstartlink child strategy oneforone name myappsupervisor end community place connect communicate oban user contributing run oban test suite must postgresql running locally database named obantest follow step create database create database run migration ensure commit pass ci run mix ci locally executes following command check formatting mix format checkformatted lint credo mix credo strict run test mix test raise run dialyzer mix dialyzer
33,Lobsters,elixir,Elixir programming,Assorted IEx tricks,http://blog.tap349.com/elixir/iex/2017/05/21/elixir-iex/#suppress-long-output---in-pry,assorted iex trick,elixir iex http hexdocspmiexiexhtml http hexdocspmiexiexhelpershtml http http iexexs alias quickalias quit iex http shell history http nithinbekalcompostselixirshellhistory http hexdocspmiexiexhtml moduleshellhistory http githubcomferderlanghistory get result last evaluated expression pry http hexdocspmiexiexhelpershtml cancel multiline command http http cancel reverse search http readlinekablamoorgemacshtml recompile current mix application pry http suppress long output pry http truncate long list string http http hexdocspmelixirinspectoptshtml force display list integer http githubcomelixirlangelixirwikifaq http wwwtheguildnlprintlistofintegersasintegersiniex elixir set option http hexdocspmelixirinspectoptshtml set inspect option used iex http hexdocspmiexiexhtml add nonprintable character,elixir iex may erlang shell eshell erl elixir shell iex iex unix shell bash etc http hexdocspmiexiexhtml http hexdocspmiexiexhelpershtml http closed http iexexs iex load file find project iexexs local alias pollute global namespace iex configs merged current project iexexs userwide config iexexs read alias content iexexs evaluated shell context used alias popular module cut typing alias neko achievement userrate else try use quickalias package though working tried quit iex http cc cr graceful cg q cr graceful cc cc graceful c graceful graceful way quit iex save shell history using erlanghistory update since erlangotp shell history supported box using instead erlanghistory patch way quit iex allow save shell history except last one c shell history http nithinbekalcompostselixirshellhistory git clone http githubcomferderlanghistorygit cd erlanghistory sudo make install shell history since stored erlanghistnonode nohost binary file plain text update shell history stored erlanghistory might need remove erlanghistnonode nohost work shell history saved quit iex gracefully using either cc cr cg q cr command erlanghistory must compiled new version erlangotp kernel get current version kernel library erl application whichapplications stdlib ert cxc kernel ert cxc current version update erlanghistory repo cd erlanghistory git make install cd erlanghistory sudo make install password erl make recompile recompile file copied make sure file copied file copied mean current version kernel library supported probably update erlanghistory repo update http hexdocspmiexiexhtml moduleshellhistory erlangotp possible get shell history passing flag enable vm http githubcomferderlanghistory since shell history supported box although initially disabled default port library erlangotp code base enable shell version setting shellhistory kernel environment variable enabled export erlaflags kernel shellhistory enabled added environment variable zshenv export erlaflags kernel shellhistory enabled using erlanghistory longer required though found easy way uninstall get result last evaluated expression pry http hexdocspmiexiexhelpershtml iex iex v optional argument passed return nth expression current iex session positive number indicates absolute position negative number indicates relative one say v v cancel multiline command http http iex foo iex break cancel reverse search http readlinekablamoorgemacshtml cu cu first cu cancel reverse search leaf found command cursor located end line second cu deletes line current cursor position backwards start line mbackspace standard hotkey delete previous word first mbackspace cancel reverse search leaf found command like cu subsequent press delete previous word one one recompile current mix application reload pry http also possible recompile specific module suppress long output pry http add another expression end line semicolon truncate long list string http http hexdocspmelixirinspectoptshtml collection default item iex ioinspect list limit infinity string charlists default byte iex ioinspect list printablelimit infinity force display list integer http githubcomelixirlangelixirwikifaq http wwwtheguildnlprintlistofintegersasintegersiniex see also elixir post character list section way print charlist collection codepoints set charlists option http hexdocspmelixirinspectoptshtml note always return string fact value passed charlists option except ascharlists act aslists iex inspect charlists aslists iex inspect charlists ascharlists e set charlists inspect option used iex http hexdocspmiexiexhtml iex iexconfigure inspect charlists aslists iex else set iex config file iexexs iexconfigure inspect charlists aslists option respected shell printing result expression evaluation add nonprintable character usually added iex
34,Lobsters,elixir,Elixir programming,Ecto Associations in Phoenix LiveView: One to Many,https://dennisbeatty.com/2019/08/20/ecto-associations-in-phoenix-liveview-one-to-many.html,ecto association phoenix liveview one many,ecto association relationship three type relationship example liveview github page one many relationship let know twitter database migration schema live view http template http phoenixhtml creating user listing role saving role user list http http make work realtime http http let know went let know twitter video youtube retweet others find youtube channel,video part series working ecto association phoenix liveview get update release next part please subscribe channel youtube enter email bottom post subscribe email update start want apologize mia past couple month got married end july quite bit past month still reception coming washington state weekend able get back regular cadence thanks understanding said start new series almost year half ago gave talk ecto lonestar elixirconf originally planned speak mostly model ecto association ended speaking upserting data got comment last post asking talk ecto association decided want next series cover let get started ecto association one important underlying principle relational database made table related relationship allow easily manage data keeping separate table ecto relationship often called association basically row one table associated one many type data table three main type association work one one one many many many go detail super familiar relational database design databaseguide pretty good article relationship three type relationship post series cover one three type assocations use database manage phoenix liveview example three part series working example admin panel user administration liveview would helpful case would able automatically update admin panel user case multiple admins making modification time normally use case probably worth effort required set realtime functionality phoenix liveview make simple definitely worth including begin want set application phoenix liveview make sure running latest version elixir erlang writing post using elixir erlang get latest version phoenix generator mix archiveinstall hex phxnew want create project call useradmin let cd useradmin directory get work post step get started phoenix liveview keep tutorial going obsolete little longer follow liveview github page follow along youtube video top post one many relationship post talking onetomany relationship tend common type relationship model useful maintaining data integrity example modeling user role many application user role administrator editor subscriber etc typically one role role given many different user user role would best defined onetomany relationship mean one role associated many user also see way around many different user one role data model example look something like question please let know twitter hopefully clarify better otherwise let go ahead set database database migration set onetomany relationship database typically adding foreign key id corresponds id row different table table make many relationship refer diagram case roleid field user table refers id field role table order properly set foreign key postgres requires u one table case role created create foreign key many table let start creating role table recommend leveraging ecto generator mix ectogenmigration createroles create migration file privrepomigrations directory let open migration file create table ecto automatically generate id column u need add name column defmodule useradminrepomigrationscreateroles use ectomigration def change create table role add name string end end end saving go ahead run mix ectomigrate make sure role table created correctly ready add user table let use generator mix ectogenmigration createusers open newly generated migration file want create table give user name also add roleid column reference role user tell ecto want create foreign key constraint database make sure user role always valid role exist role table defmodule useradminrepomigrationscreateusers use ectomigration def change create table user add name string add roleid reference role end end end go ahead run migration database everything need let set ecto schema handling data elixir schema let work context pattern create context libuseradminusersex create empty module defmodule useradminusers end nest schema create two new file libuseradminusersroleex libuseradminusersuserex let start roleex use ectoschema macro create ecto schema mirror migration defmodule useradminusersrole use ectoschema schema role field name string end end user schema time making small change rather directly reference roleid field let ecto manage association using belongsto defmodule useradminusersuser use ectoschema alias useradminusersrole schema user field name string belongsto role role end end basic code set work data let get started actual liveview work live view worked ecto database thing start get little interesting let start creating basic liveview boilerplate libuseradminwebliveuserlivenewex defmodule useradminwebuserlivenew use phoenixliveview def mount session socket ok socket end def render assigns l end end let hook libuseradminwebrouterex phoenix know use live view defmodule useradminwebrouter scope useradminweb pipethrough browser live usersnew userlivenew end end able start server mix phxserver visit http browser view new live view notice empty template far added content yet let go ahead create template template let start creating view module delegate template libuseradminwebviewsuserviewex let add following boilerplate defmodule useradminwebuserview use useradminweb view end let create actual template libuseradminwebtemplatesusernewhtmlleex start basic html replace phoenixhtml nicety new user form fieldset label namefield name label input type text id namefield label rolefield role label select id rolefield option value admin administrator option option value mod moderator option option value user user option option value guest guest option select div input type submit value create div fieldset form let get actually displaying modifying userlivenew module render template instead empty one defmodule useradminwebuserlivenew use phoenixliveview alias useradminwebuserview def render assigns userviewrender newhtml assigns end end go http see something look like phoenixhtml phoenix includes really nice helper method make html form little cleaner let take advantage start want create changeset form operate start let add function useradminusersuser allow u get changeset user defmodule useradminusersuser import ectochangeset def changeset user change user cast change name validaterequired name end end may notice casting validating name user get save role little bit let create function useradminusers allow u get changeset without calling schema module directly defmodule useradminusers alias useradminusersuser doc create changeset change user spec changeuser usert map ectochangesett def changeuser user change userchangeset user change end end let use useradminwebuserlivenew want create changeset admin first load live view let set mount function like defmodule useradminwebuserlivenew alias useradminusers alias useradminusersuser def mount session socket changeset userschangeuser user ok assign socket changeset changeset end end actually modify template use replace form label input element let hook form live view add phxsubmit attribute form tell submit using liveview use phxdisablewith submit button prevent admins trying create user multiple time new user f formfor changeset phxsubmit create fieldset label f name namefield textinput f name id namefield label rolefield role label select id rolefield option value admin administrator option option value mod moderator option option value user user option option value guest guest option select div submit create phxdisablewith creating div fieldset form reload browser form look exactly submit form turn red show spinner check app see undefinedfunctionerror say undefined private let set actually create user creating user let start creating function context actually save user useradminusers go ahead add defmodule useradminusers alias useradminrepo doc create user spec createuser map ok usert error ectochangesett def createuser attrs user userchangeset attrs repoinsert end end let hook live view need add function app looking submitted form want call new function clear form display message creation successful error want display error message defmodule useradminwebuserlivenew alias useradminwebrouterhelpers route def handleevent create user attrs socket case userscreateuser attrs ok user socket socket putflash info user successfully created redirect routeslivepath socket module noreply socket error changeset noreply assign socket changeset changeset end end end assigning error changeset socket need actually display error let modify template add errortag textinput displayed error changeset textinput f name id namefield errortag f name refresh browser able submit form try submitting empty name field make sure error show something name field make sure success message show successfully built user creation form look running application see insert database also notice sends user name selected role let change working role listing role role probably change often let put directly database privreposeedsexs file alias useradminrepo alias useradminusersrole role w administrator moderator editor user guest enumeach role fn name repoinsert role name name end go ahead run seed mix run privreposeedsexs database five different role feel free add wish one role put html template let go ahead get template displaying role database instead first let make function user context let u get role defmodule useradminusers alias useradminrepo alias useradminusers role user doc list role database spec listroles list rolet def listroles repoall role end end let set live view use new function pas template defmodule useradminwebuserlivenew def mount session socket changeset userschangeuser user role userslistroles ok assign socket changeset changeset role role end end finally let tell swap last label select element template using phoenixhtml helper select function expects keyword list list twoitem tuples item display key sent backend need use enummap convert list role structs tuples well let add errortag case error need displayed role oh one last thing add html using roleid determine role rather using role name everything want use id key new user f formfor changeset phxsubmit create fieldset label f name namefield textinput f name id namefield errortag f name label f roleid rolefield select f roleid enummap role id rolefield errortag f roleid div submit create phxdisablewith creating div fieldset form refresh browser open dropdown see option instead try saving another user look database see role id nil let get saving saving role simplest step need change changeset function user schema accept roleid let libuseradminusersuserex defmodule useradminusersuser def changeset user change user cast change name roleid validaterequired name roleid end end successfully saving user name role effectively making use onetomany relationship finally let make user list watch new user created display role chosen user list order get list user let start adding new function user context allow u get list user defmodule useradminusers doc list user database spec listusers list usert def listusers repoall user end end let add new live view libuseradminwebliveuserliveindexex use new listusers function get user live view mounted defmodule useradminwebuserliveindex use phoenixliveview alias useradminusers def mount session socket user userslistusers ok assign socket user user end def render assigns l end end hook libuseradminwebrouterex defmodule useradminwebrouter scope useradminweb pipethrough browser live user userliveindex live usersnew userlivenew end end let go ahead create template libuseradminwebtemplatesuserindexhtmlleex want use comprehension loop user add table user table thead th name th th role th thead tbody user user tr td username td td userrolename td tr end tbody table let hook live view defmodule useradminwebuserliveindex alias useradminwebuserview def render assigns userviewrender indexhtml assigns end end point navigate browser http would expect see table user instead get nice error saying role loaded listusers function pulling user role need using repopreload user context defmodule useradminusers def listusers user repoall repopreload role end end refresh work user role added roleid validaterequired changeset function user added without role rather trying change code accomodate case let reset database start clean get rid bad record refresh page see empty user table go back http add user two come back table couple user role showing preloading role work pretty well currently hit database get user get role make little bit performant join defmodule useradminusers import ectoquery def listusers user join inner u r assoc u role preload r role r repoall end end want look performance cost join case particular case save round trip database improve performance tiny bit make work realtime point using phoenix liveview really taking advantage realtime capability websockets channel let use phoenixpubsub user list subscribe list user automatically update new user created used phoenix generator set app initially already set useradminpubsub u use start adding subscribe function user context allow u subscribe event context publish event whenever new user created defmodule useradminusers topic inspect module def createuser attrs user userchangeset attrs repoinsert broadcastchange user created end doc subscribe update user list spec subscribe ok error term def subscribe phoenixpubsubsubscribe useradminpubsub topic end spec broadcastchange ok usert list atom ok result defp broadcastchange ok result event phoenixpubsubbroadcast useradminpubsub topic module event result ok result end end event published need tell live view subscribe update template whenever subscribing pretty easy need add handleinfo function handle pubsub message whenever received defmodule useradminwebuserliveindex def mount session socket userssubscribe end def handleinfo user user socket user userslistusers noreply assign socket user user end end try opening one browser window http window open http try creating couple user see show immediately list working onetomany association realtime keep code machine continue building part go manytomany relationship one little difficult prefer already boilerplate way focus making manytomany relationship work like exercise meantime recommend making another live view add new role use useradminpubsub make new role show automatically dropdown created without refresh page let know went always love hear tutorial went get stuck anywhere question anything said wish would writemake video different topic let know twitter prefer leave comment video youtube either way try get back quickly thanks reading andor watching liked post please retweet others find also subscribe email list youtube channel see new video right away
35,Lobsters,elixir,Elixir programming,Using Benchee for Elixir Performance Tests,http://prying.io/technical/2019/07/21/using-benchee-for-elixir-performance-tests.html,using benchee elixir performance test,github page elixir school testing limit system defining performance different condition automating benchee test basic unit test case integration test gotchas,benchee useful tool find situation need test limit system need define behavior specific environment seems primarily designed development debugging also used test well github page useful tool information setup configuration information elixir school site well doc cover use benchee post focus use note experience implementing benchmarking test suite benchee useful testing limitation system defining time constrains memory impact critical process aid development write performant code article let set aside benchee dev tool focus use case involve exunit testing limit system system handle today average load system processing power handle load impact long take system process login request comment compare processing request answering question help team spend time wisely identify problem spot code using data let drive development company growth target write test assert minimum met different hardware adverse scenario without live nightmare automating test stretching system prevents regression also ensures code bottleneck growth company defining performance different condition given situation system respond within specified time given hardware b system still able handle load enough memory allocated critical situation exactly would system long would take automating benchee test benchee test play nicely test exunit tag easily avoided would recommend creating test suite dedicated benchmarking function use test suite gate release depending need test setup simple complex simple case testing standalone function asserting output moving next test benchee meant need integration test benchee still useful integration case difficult reason covered later post basic unit test case usage example documentation usage example unit test since discovering benchee workflow io install basic happy path benchee test around given function function pass test around functionality tinker crucial aspect logic might slowing processing example might change enumeach enummap single enumreduce integration test case metric like deviation percentile case valuable well since show exunit integration doc benchee exunit test would look like defmodule applicationbencheeunittest alias applicationhelpermodule alias applicationtesthelper tag benchmark test benchmark function setting output aside make assertion output output bencheerun casea fn input resource ok result helpermoduledosomething casea returning value used aftereach possible best move assertion aftereach avoid impacting test result end caseb fn input resource ok result helpermoduledosomething caseb result end beforeeach fn input test setup return input test resource iteration ok resource testhelpergetresources input return tuple input test resource input resource end aftereach fn result make assertion output iteration end iterates input scenario input firstscenario enumat outputscenarios secondscenario enumat outputscenarios make assertion performance micro second assert firstscenarioruntimedatastatisticsaverage end end integration test one strength elixir ability build application tree using genservers unfortunately case often challenging test require processing message queue aim test one module time certain case end end test genserver b processed message genserver worse still benchee scoping inherited test module setup must happen inside beforeeach inside benchee run use case found helpful create module handle event test eventbased system might right approach point way asserting process path completed moment completes assertion add time test run long apple apple comparing past performance still get value test example would look beforeeach fn input inside beforeeach start mock handle event passing test pid callback mock event handler logic pass along message mockeventhandlerstartlink callbackpid self eventhelpersubscribetoevents mockeventhandler eventa eventacompleted assert event received indicate process completed inside scenario casea fn input resource payload struct would defined mock example assertreceive event eventa match exactly pas value aftereach make assertion payload payload assertreceive event eventacomplete payload completepayload end gotchas inside benchmark run access file within application example imagine imported mock test benchee scoping inherit exunit case currently test require great deal setup tear hindsight seems obvious initially understand benchee run ran many time given chunk code possible beforeeach aftereach parameter refer iteration scenario given input cycled iteration process input beforeeach method test scenario given chunk code
36,Lobsters,elixir,Elixir programming,Why functional?,https://blog.testdouble.com/posts/2020-06-30-why-functional/,functional,functional scary think todo app taming uncertain future one elixir elm intent avoiding backwash time state please functional core imperative shell cqrs elixir elm ramda thinker,internet full information mostly related learning something come software development feel bigger question learn something imagine explaining friend confronted bear stand ground make lot noise try look big scary possible trying intimidate animal could brush aside flick claw seems ridiculous friend might decide better stick knee strategy might take advice use wrong time like mother bear cub knowing certain thing allows u trust worth importantly context know appropriate functional scary think point may looked example todo app written functionally decided maybe gave try turned unmaintainable mess without understanding goal functional programming hard receive benefit like focus developer would choose learn think functional way say need switch using functional language immediately programming functional use pattern architecture embraced functional give many benefit worth time change entire process carrying fine well one functional codebase generally lot enjoyable live work may surprise time told functional programming confusing academic hard read etc true staring blank page producing functional code may require bit upfront thought programming paradigm generally result much enjoyable read maintain think important differentiate something versus something example could use basic word say sad could say even word slightly advanced better understand feeling word choice accurate nuanced description emotion similarly functional programming concept slightly advanced accurate description kind problem trying solve program taming uncertain future generally write code solve problem automate task going happen future write code read present tense future tense may slightly complex language construct present tense future complicated future tense accurate representation situation consider two way giving driving direction left turn right go straight past blue turn left turn right keep driving straight go past blue house struggling give first scenario written present tense make assumption road closed blue house painted white work fine lot time give u false sense security sitting front sign freshly painted white house idea second scenario beginning similar writing future tense reminds u describing one possible future thing future uncertain actually many possible future therefore end direction acknowledging offering alternative course action calling help something fit expected future concept uncertain future nothing functional programming universe work choose ignore fact traditional programming risk buggy confusing code result functional programming need handle many possible future depends type problem solving case driving direction provide instruction expected case case simply reach help case self driving car say intersection light also need explicitly handle case light red person walking stop approach taken defining future depends lot use case language like elixir tend embrace style first example define case expect happen case allow erlang runtime fail immediately report problem perfect backend system monitor log fix unexpected behavior elm hand favor latter example frontend language priority seamless user experience forced always handle possible case even unlikely error handling well serf purpose word error suggests something unexpected happened thinking uncertain future nothing unexpected subtle difference point trying make future complicated rather trying describe basic language describe appropriate grammar readable code using simple language construct clearly modelling intent avoiding backwash time move completely idea want note functional pattern provide better language construct also allow u form code easily defined sequential flow time always move forward control flow logic one two way funnel one possible future result fan many possible future based result main two construct functional programming conditionals used define possible future function used describe happens one future make concrete conditionals take one input define many output function take many input produce one output define chain condition function scope possible future expands contract always moving forward time never think changing something already happened state please hold sound like saying way keep track state well hold thought first talk benefit worry state within flow logic look another example two version recipe egg stir cup flour place egg cup flour oven preheated degree whisk egg stir flour place oven produce first example look easier first glance think assumption make happens whisked egg realize flour finished combining ingredient realize oven needed preheated instruction could made little clear saying oven degree whisk two egg refrigerator stir cup flour pantry place little better still assumption state world assumes ingredient pantry oven actually work second example state front required complete recipe state produced following recipe nothing assumed ingredient working preheated oven know even start recipe consider real code example eventsbylocation const event jsonparse localstorageevents let group const event event const group group eventlocation grouppush event group eventlocation group return group got two concerning thing going right first referencing localstorage making assumption state world within function always trust function work function deterministic result input known function functional language enforce common best practice follow pattern much possible second built lot local state along way group variable mutated looping event started blur intent function simply giving linear direction keeping track thing happened past let try instead eventsbylocation event eventsreduce acc event const group acc eventlocation return acc eventlocation group event see function pure pas everything need mutable internal state everything flow beginning end elegant way using modern javascript functional language library could one liner state somewhere yes never eliminate state completely system keep seeping every part application constantly managing pattern called functional core imperative shell idea core business logic application written pure function future tense wrapped thin layer code interacts outside world deal state written state useful want stay way one way elixir lean heavily erlang otp process state maintained modifying data recursive loop elm deal state using internal architecture modify directly send message instruct internal state would like change implementation cqrs pattern redux common state management library javascript often used react regardless library architecture choose main point state business logic stay separate deal complexity uncertain state language like elixir elm suggest enforce functional pattern varying degree great thing start wherever functional way thinking language instance react helped start thinking functional way idea ui simply function state incredibly powerful redux top helped decouple state business logic even got excited pattern started using ramda library allows writing functional code fluently javascript using function composition piping currying finally started working language designed functional honestly point become functional thinker big jump hope journey encourage thoughtfulness way define problem way communicate intent
37,Lobsters,elixir,Elixir programming,Operating via development,https://www.theerlangelist.com/article/operating_via_development,operating via development,certbot siteencrypt instruction start system locally phoenix live dashboard soul erlang elixir certification acme automatic certificate management environment protocol siteencrypt make task straightforward midlevel module lowerlevel module reducing devproduction mismatch testability automation tight integration operation final thought,two year ago decided add http support site using automatic certification via let encrypt article subject relied tool called certbot couple variation mentioned requiring tool run site others using nginx certbot combination seemed installing running additional external tool production mandatory point erlangelist standalone elixirpowered system required external program seemed start worrying setting additional service interact using custom dsl would complicate operation create disconnect production development change certification configuration would need tested directly production alternatively setup staging server either way testing certification would done manually unhappy state started work siteencrypt library take different approach automatic certification siteencrypt library dependency external tool required install oslevel package use certification process periodical renewal running o process rest system o process need started everything configured project system implemented interaction siteencrypt done via elixir function data yaml ini json kind dsl required trivial run certification locally reduces difference prod local dev support automatic testing certification provided need setup staging machine make change directly production system example call integrated operation instead spread across bunch yamls inis jsons bash script somehow glued together oslevel operation done development ie place rest system implemented using language approach significantly reduces technical complexity system erlangelist mostly implemented elixir administrative task installation o package user creation port forwarding rule similar provisioning task done outside elixir also simplifies local development instruction start system locally simple install build tool elixir erlang nodejs fetch dependency invoke single command start system locally started system extremely close production version almost nothing significance running production running locally two difference note think port forwarded prod prod version us let encrypt certification local version us local ca server later may sound like much simple blog host behind scene erlangelist bit simple request responder erlangelist system run two separate web server public facing server one use read article another internal server us phoenix live dashboard expose metric small handmade database running collect aggregate persists reading stats periodically removing older stats disk system periodically renews certificate locally ci another web server act local certificate authority ca running word erlangelist blog site server app system consisting multiple activity collectively work together support full enduser service well operational aspect system activity running concurrently block crash system utilizes cpu core host machine detail work take look talk soul erlang elixir let take closer look siteencrypt certification let encrypt support automatic certification via acme automatic certificate management environment protocol protocol describes conversation client system wanting obtain certificate domain server certificate authority ca create certificate acme conversation system asks ca provide certificate domain ca asks u prove owner domain ca give u random byte make request domain expecting get byte return also called challenge successfully respond challenge ca create certificate u real story course involved simplified version hopefully give basic idea conversation activity system job need occasionally done allow system provide full service certification valid certificate people use site likewise decide shut site certification serf purpose anymore situation preferred approach run activity together rest system le fragmented system easier manage running part system externally fine stronger reason see reason simple scenario siteencrypt make task straightforward add library dep fill blank good go certification configuration provided defining certification function def certification siteencryptconfigure client native domain mysitecom wwwmysitecom email contact mysitecom anothercontact mysitecom dbfolder folderwheresiteencryptstoresfiles directoryurl directoryurl end code look pretty declarative executable code collection fact mean lot flexibility shape configuration data however want example want make certification parameter configurable system operator say via yaml file nothing stop u invoking loadconfigurationfromyaml instead hardcoding data say want make parameter configurable eg domain email leaving rest hardcoded simply keywordmerge loadsomeparamsfromyaml hardcodeddata supporting kind config source like etcd database equally straightforward always build declarative top imperative opposite require imagination trickery running external configuration generator good luck managing production also worth mentioning siteencrypt internally ship two lowerlevel module sort plumbing porcelain midlevel module provides workflowrelated operation create account perform certification lowerlevel module provides basic acme client operation module used want finer grained control certification process reducing devproduction mismatch one interesting thing happening configuration presented earlier def certification siteencryptconfigure directoryurl directoryurl end directoryurl property defines ca siteencrypt obtain certificate instead hardcoding url invoking function compute happens need use different url production v staging v local development let take look defp directoryurl case systemgetenv mode local production http staging http local internal port end end distinguishing production staging development based mode o env easily replaceable source owing programmable api env provided assume system running locally production machine go real ca staging use let encrypt staging site internal port thing use local development pas particular shape data siteencrypt internal acme server started given port sort local mock let encrypt server running inside o process rest system locally siteencrypt start mock let encrypt use mock obtain certificate word locally system certify example action local version erlangelist iex mix phxserver info running erlangelistwebblogendpoint http info running erlangelistwebblogendpoint http info running local acme server port info creating new acme account domain theerlangelistcom info ordering new certificate domain theerlangelistcom info new certificate domain theerlangelistcom obtained info certificate successfully obtained testability since local erlangelist behaves exactly real one test system behaviour example even local version http request redirected http test verifying test http request redirected http assert redirectedto clientget http localhost http localhost end likewise redirection www also tested test theerlangelistcom redirected wwwtheerlangelistcom assert redirectedto clientget http theerlangelistcom http wwwtheerlangelistcom end contrast external proxy rule defined nginx configuration typically tested mean change configuration might break something else way obvious operator addition siteencrypt ship small helper testing certification relevant test test certification cleanrestart erlangelistwebblogendpoint cert getcert erlangelistwebblogendpoint assert certdomains wtheerlangelistcom wwwtheerlangelistcom end test blog endpoint ie blog web server restarted previously existing certificate removed restart endpoint certified via local acme server certification go whole process mocking save fact local ca used http request made key generated system call ca concurrently make request system ultimately certificate obtained finished invocation getcert establish ssl connection blog server fetch certificate peer assert expected property certificate test significantly increase confidence system course always chance something going wrong production eg dns correctly configured let encrypt reach site possibility error reduced test also compiled language used example make syntax error changing configuration code even compile let alone make production make typo eg specifying theerlangelistorg instead theerlangelistcom certification test fail contrast external configuration much harder test typically end manually verified staging case production automation beyond obtaining certificate siteencrypt periodically renew periodic job executed three time day job check expiry date certificate start renewal process certificate expire day addition every time certificate obtained siteencrypt optionally generate backup data system starting siteencrypt database folder present backup file exists siteencrypt automatically restore database backup user siteencrypt zero work make happen significantly reduces amount operational work required bringing bulk regular development elaborate backup scenario siteencrypt provides callback hook endpoint module define function invoked certificate obtained use function eg store cert arbitrary secure storage choice notice becomes part regular system codebase convenient logical place express task fact running together rest system also mean testable testing new certificate correctly stored desired storage straightforward tight integration since run o process powered language siteencrypt integrate much better client lead nice benefit mentioned earlier certification conversation system ca server using certbot tool dialogue turn threeparty conversation instead system asking certificate ask certbot behalf however ca verification request aka challenge need served site since certbot external tool treat site opaque box result certbot know responded ca challenge bit conservative namely certbot sleep three second start polling ca see challenge answered native elixir acme client run o process integrate much better acme client informed challenge handler challenge fulfilled use much shorter delay start polling ca production optimization particularly relevant local dev especially test difference becomes significant certification test via certbot take second machine test via native client tight integration offer interesting possibility bit change api siteencrypt could support arbitrary storage database could also support coordination multiple node making possible implement distributed certification arbitrary node cluster initiate certification node successfully respond challenge including even node came online challenge started operation bulk system behaviour described elixir code remaining operational task done outside elixir exclusively related preparing machine run erlangelist task involve creating necessary account creating folder structure installing required o package essentially docker needed setting single systemd unit starting container production dockerized production docker image lightweight site run apk nocache upgrade apk add nocache ncurses copy frombuilder optappsitebuildprodrelerlangelist erlangelist volume volume workdir erlangelist entrypoint erlangelistbinerlangelist key part copy instruction add built release system image release contain compiled binary well minimal erlang runtime system therefore pretty much selfcontained requiring one small oslevel package installed final thought might argue using certbot optionally nginx caddy simple enough completely disagree perfectly valid reach external product solve technical challenge related business domain product help u solve problem quickly focus core challenge hand feel critical problem introduced product tried show simple example integrated operation approach reduces amount moving part technology used bridge gap production development improves testability system implementation simpler time flexible since tool driven function data approach work need runtime support managing multiple system activity beam runtime erlang elixir make possible example many case serving traffic directly phoenix without reverse proxy front work fine feature ets table genserver reduce need tool like redis running periodic job regulating load ratelimiting pipeline processing done directly elixir without requiring external product course always case external tool make sense also many case integrated approach work fine especially smaller system operating level scale complexity netflix twitter facebook similar option available would allow u start simple move external tool complicated scenario reason started work siteencrypt library still incomplete probably buggy issue fixed time effort believe benefit approach worth effort continue work library like see library appearing giving u simpler option challenge load balancing proxying persistence long technical challenge running external product option opportunity simplification u developer make happen
38,Lobsters,elixir,Elixir programming,Introducing Lean Server for Midas (HTTP server in Gleam),https://crowdhailer.me/2020-06-23/introducing-lean-server-for-midas/,introducing lean server midas http server gleam,introducing lean server midas midas web framework lean ace raxx gleam using lean server,introducing lean server midas lean server http server written gleam gleam new type safe language erlang virtual machine beam lean builtin server midas web framework import midaslean maxconcurrency import gleamhttp fn handle request httpresponse httpsetbody hello world fn startlink leanstartlink handle maxconcurrency lean simple use simple maintain fast hopefully lean incorperates lesson learnt developing ace raxx ace http server written elixir aimed abstract away difference ace also supported http long lived connection streaming requestsresponses opinion ace successful goal however feature one server increased implementation complexity since starting ace written several service use narrow subset feature application mostly json api service streaming deployed behind load balancer needed neither http lean aim focus api application sizeable list nongoals ssl streaming http pipelining websockets tackling nongoals lean simpler therefore easier maintain make easier address feature bug well easier contribute also faster though yet test course feature listed important framework writing adapter server ace cowboy midas framework able support feature gleam gleam feel like promising approach getting benefit type beam something several people wish list including mine quite long time gleam compiles readable erlang readable erlang nt controversial statement also great interop erlang elixir feature would argue considered production ready part application part application benefit type safety others write topic later time using lean server lean sever bundled part midas currently midas using feature yet part gleam stable release therefore need use git dependency midasframeworkmidas
39,Lobsters,elixir,Elixir programming,Using Mnesia in an Elixir Application,https://blog.appsignal.com/2020/05/19/using-mnesia-in-an-elixir-application.html,using mnesia elixir application,introduction mnesia check research paper detail query list comprehension match specification mnesia cap theorem use mnesia postgresql database looking mnesia doc handson project mnesia amnesia library conclusion alex koutmos p like read elixir alchemy post soon get press subscribe elixir alchemy newsletter never miss single post,today post learn mnesia see would use tool take look pro con using covering fundamental mnesia dive right sample application build elixir application us mnesia database let jump right introduction mnesia high level mnesia database management system dbms baked otp thus using elixir erlang ability leverage mnesia outofthebox additional dependency need installed separate system need running considering migrating everything existing database mnesia let discus mnesia designed problem aim solve mnesia largely designed solve problem existed telecommunication problem space specifically following requirement needed fulfilled check research paper detail fast keyvalue lookup time need soft realtime latency guarantee soft realtime system one system able service majority request within given time frame failure generally mean degradation service ie data longer useful time frame passed hard realtime system hand system must respond within given time frame else considered system failure ability perform complex query like would sql example without soft realtime latency guarantee high level fault tolerance typical dbms application would need either make network call separate machine database running would connect database process running machine either way data contained within database resides entirely separate memory space application therefore inescapable amount latency overhead hand mnesia run within memory space application result baked language runtime able fetch data mnesia soft realtime speed word application database running sidebyside little communication overhead two another important thing note mnesia store erlang data type natively need marshallunmarshall data readwrite mnesia marshalling process converting data one format another purpose storing transmitting performing complex query mnesia database either leverage query list comprehension qlc write match specification addition also add index mnesia table field know querying often using tool perform arbitrary query table extract relevant data primary requirement telecommunication system must running nonstop downtime mean missed dropped call mnesia address allowing table replicated across various node cluster running within transaction data need committed must written configured table replica node unavailable write transaction update available node replica update unavailable node replica come back online replication mechanism mnesia able provide high level fault tolerance mnesia cap theorem may wondering exactly fall regard cap theorem unfamiliar cap theorem basically state dealing distributed system three characteristic play guarantee two given time three characteristic consistency whenever read made database database respond recently updated data availability whenever request made database database respond data even date ie newer data committed propagated node partition tolerance whenever request made database able respond regardless node unavailable network partition occur ie database node unavailable system must make tradeoff favor consistency error request node unavailable favor availability servicing request understanding may data inconsistency missing node come back online given mnesia propagate transaction commits across table replica support kind eventual consistency cp style database case network partition separate partition handling request application need deal reconciliation data use mnesia postgresql database like many thing software engineering system design making correct tradeoff whether mnesia right application largely depends requirement personally used mnesia production primarily support soft realtime use case good result data stored mnesia needed duration user session would get cleared user interaction system ceased thus lot pressure system resource ram specifically table need fit ram size table would reflect number user actively using system situation need store large amount data require soft realtime response time traditional dbms mysql postgres may better choice situation see reaching redis memcached may want consider looking mnesia given fill similar need built otp information regarding topic would suggest looking mnesia doc handson project mnesia order get familiar mnesia creating simple banking application leverage mnesia database could leverage mnesia api directly via mnesia instead opt use amnesia library provides nice elixir wrapper around mnesia api banking application support following operation create new account transfer money account fetch account detail deposit fund account withdraw fund account search account low balance begin let create new elixir project using following terminal command mix new fortknox sup creating elixir project open mixexs file make sure function look like following deps amnesia end done run mix depsget fetch amnesia dependency next want create module defines table schema mnesia database sample application one table defined bank account add following content libdatabaseex amnesia defdatabase database deftable account id autoincrement firstname lastname balance type orderedset index balance end database contains account table specifies field along autoincrementing id field database definition place let go back terminal run following command mix amnesiacreate database disk executing command notice new directory mnesianonode nohost created u root project directory contains disk persisted data data maintained across application restarts delete persisted database data either rm rf mnesianonode nohost run mix amnesiadrop database schema place time work business logic let create file libfortknoxaccountsex start creating function create new account fetch existing account fortknoxaccounts require amnesia require amnesiahelper require exquisite require databaseaccount alias databaseaccount def createaccount firstname lastname startingbalance amnesiatransaction account firstname firstname lastname lastname balance startingbalance accountwrite end end def getaccount accountid amnesiatransaction accountread accountid end case account account account error notfound end end end module begin require statement pull amnesia functionality leverage account struct conveniently interact account table mnesia create new account entry table create struct call accountwrite within transaction want perform database action within transaction also leverage dirty readwrite api call recommended looking existing account id leverage transaction match account struct account found let go ahead add remainder functionality libfortknoxaccountsex fortknoxaccounts def transferfunds sourceaccountid destinationaccountid amount amnesiatransaction account accountread sourceaccountid accountread destinationaccountid case account account sourceaccount account destinationaccount amount sourceaccountbalance adjustaccountbalance destinationaccount amount adjustaccountbalance sourceaccount amount ok else error insufficientfunds end account error invaliddestination error invalidsource end end end def getlowbalanceaccounts minbalance amnesiatransaction accountwhere balance minbalance amnesiaselectionvalues end end def depositfunds accountid amount amnesiatransaction case accountread accountid account account adjustaccountbalance account amount error notfound end end end def withdrawfunds accountid amount amnesiatransaction case accountread accountid account account amount accountbalance adjustaccountbalance account amount else error insufficientfunds end error notfound end end end defp adjustaccountbalance account account amount account mapupdate balance amount accountwrite end end function relatively straight forward mixture read writes update account within transaction probably seem new clause query database record exquisite library amnesia depends provides ability generate mnesia match specification used perform custom query place let take test drive first seed database initial account transfer fund account open iex session via iex mix type following josh smith tom lee joe diaz enumeach fn firstname lastname amount fortknoxaccountscreateaccount firstname lastname amount end ok iex fortknoxaccountsgetaccount databaseaccount balance firstname josh id lastname smith iex fortknoxaccountsgetaccount databaseaccount balance firstname tom id lastname lee iex fortknoxaccountstransferfunds ok iex fortknoxaccountsgetaccount databaseaccount balance firstname josh id lastname smith iex fortknoxaccountsgetaccount databaseaccount balance firstname tom id lastname lee iex fortknoxaccountsgetlowbalanceaccounts databaseaccount balance firstname tom id lastname lee running command feel free quit iex via ctrlc go back using iex mix run databaseaccountcount see get value since data persisted across iex session destroyed conclusion thanks sticking end hopefully learned thing two mnesia go using within elixir application regardless whether decide use mnesia production context would highly suggest least experimenting better appreciate amazing thing get outofthebox otp guest author alex koutmos senior software engineer writes backends elixir frontends vuejs deploys apps using kubernetes programming blogging wrenching datsun p like read elixir alchemy post soon get press subscribe elixir alchemy newsletter never miss single post
40,Lobsters,elixir,Elixir programming,Scaling Up With Elixir,https://dockyard.com/blog/2020/05/28/scaling-up-with-elixir,scaling elixir,internet traffic go erlangcontrolled node whatsapp scaled serve million user erlang service written engineer scaled elixirbased video chat platform million concurrent user elixir alone million concurrent user pairing elixir rust handled billion page view per month sent billion push notification per month using five server poa network concurrencyoriented programming nonblocking io nonblocking computation error isolation erlang process gamechanger superpower applied cowboy web server phoenix web framework chris mccord phoenix channel million connected client single server phoenix liveview short exciting demo phoenix phrenzy contest entry phoenix channel scale well solid ground simpler stack icing cake nerve based usage nested io list ecto phoenix live dashboard michael crumm rustler learn dockyard,exciting website platform get spike traffic unless fails disappointing web experience quickly encourage new user look elsewhere alternative faster responsive need many facet making web experience scalable reliable including infrastructure database design code optimization one important factor code handle concurrency ability juggle multiple task read concurrency many company shown concurrent programming beat erlang virtual machine erlang vm originally built power ultrareliable device like telephone switch job admirably decade internet service experienced higher traffic became critical developer began realize problem already solved erlang began adopting example may heard internet traffic go erlangcontrolled node cisco alone shipping million device year use erlang whatsapp scaled serve million user erlang service written engineer recent year elixir language provided extremely productive way write code erlang vm success story include discord scaled elixirbased video chat platform million concurrent user elixir alone later million concurrent user pairing elixir rust also include bleacher report handled billion page view per month sent billion push notification per month using five server elixir heart dockyard approach writing scalable web service example dockyard helped poa network index million ethereum blockchain transaction fasterthanrealtime rate smart usage concurrency batching upserts welltuned postgresql database elixir erlang vm help u build scalable system concurrencyoriented programming scalable system one cope growing workload web service mean handling many request picture busy call center handle call need agent computing agent known process thread programming language rely operating system create process thread ensure get fair share cpu time o process robust expensive carefully budget many create o process create thread cheaper errorprone due need coordinate access memory share multithreaded programming notorious source tricky bug contrast erlang built concurrencyoriented programming language erlang vm create manage lightweight internal process designed run million erlang process lighter weight thread independent like o process corrupt one another data instead sharing memory use message passing coordinate work erlang vm run multiple scheduler one per cpu core ensures process efficiently spread across mean get full benefit multicore server also process run long enough need garbage collection many process pause happens due isolated nature way scheduled erlang process powerful feature nonblocking io process need input output like reading writing file database making network request process go sleep wait reply letting process get work done meantime nonblocking computation one process get stuck heavy workload erlang scheduler ensures performs work burst process get chance run small number expensive request bog whole system error isolation error occurs one process fail restarted without process affected need process notified react accordingly erlang process gamechanger picture call center every time phone ring new agent appears answer incoming web request spawn process email send spawn process need make api call query database perform calculation spawn process erlang process even spread multiple node cooperating coordinating machine superpower applied besides directly useful erlang process foundation erlang elixir exciting tool example cowboy web server spawn process every incoming web request keep error heavy work one request affecting others phoenix web framework created dockyard chris mccord us cowboy get behavior free phoenix channel use erlang process per websocket connection enabling soft realtime communication million connected client single server scalable push notification necessary part chat application multiplayer game iot service also important site realtime notification like booking auction site tell many user viewing item right channel communicate inbrowser javascript native phone apps custom hardware phoenix liveview let u build rich interactive browser application without custom javascript using fraction development time typically need pairing api frontend framework us phoenix channel track application state handle event serverside pushing fast tiny update client see short exciting demo phoenix phrenzy contest entry taste build liveview confident scalable foundation build liveview scale well phoenix channel scale well channel scale well built erlang process saša jurić explained building system erlang process like building solid ground simpler stack core technology much need fewer piece build system use library manage background job spawn task process elixir use redis shortterm state use agent genserver use thirdparty service push notification use phoenix channel write api go handinhand custom react front end write interactive site liveview use depends requirement experience lot potential simplify tech stack fewer piece mean le complexity manage something team appreciate icing cake besides inherent advantage come erlang process elixir ecosystem great performance scalability feature built common tool phoenix tiny memory footprint happily run raspberry pi zero interface nerve project phoenix template rendering blazing fast based usage nested io list framework need complex template caching ensure snappy rendering phoenix automatically universally applies simple view caching strategy static part template always cached dynamic part never cached cache invalidated template file change end strategy especially shine want personalize content every user ecto make nearly impossible write query lean database constraint ensure consistent data high load tool like erlang observer phoenix live dashboard built many contribution dockyard michael crumm give u builtin observability diagnose bottleneck slowdown production raw computation speed paramount rustler created dockyard han elia josephsen let u safely delegate rust code clear elixir silver bullet writing scalable software always requires thought care erlang process solid foundation many important piece place elixir ecosystem wonderful place build scalable reliable software dockyard love show learn dockyard digital product agency offering custom software mobile web application development consulting provide exceptional professional service strategy user experience design full stack engineering using emberjs reactjs ruby elixir nationwide staff got consultant key market across united state including san francisco los angeles denver chicago austin new york boston
41,Lobsters,elixir,Elixir programming,Transforming Programming (2017),https://www.youtube.com/watch?v=A76hM3MpEKo,transforming programming,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature transforming programming dave thomas youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature transforming programming dave thomas youtube
42,Lobsters,elixir,Elixir programming,"Of Elixir, Phoenix, and analogies to the Prime Directive",https://ekarak.com/2020/05/16/of-elixir-phoenix-and-analogies-to-the-prime-directive/,elixir phoenix analogy prime directive,lockdown elixir erlang basically power internet know phoenix generator prime directive please stop kobayashi maru zefram cochrane hexpm μου αρέσει αυτό,spent last couple month working home thanks lockdown sure felt like opportunity fresh jump like learning new technology promising mature enough use production elixir experimented erlang past say amusing recall learn erlang support legacy product previous company encounter erlang ecosystem keep positive programming erlang book joe armstrong amazing discovery erlang basically power internet know also happened work month software product based akka merely jvm implementation erlang actor model attract attention somewhere discovered cool new kid block elixir devote much time time advertised simply replacement rail make thing short happened innovation sprint current company write walking skeleton next version product suite part picked set phoenix based rest api literally time thanks builtin generator managed progress proofofconcept hey actually work real data spectacularly short time dived language miraculous stuff began happen started adding feature astonishing rate adhoc drilldowns auditing live update performance monitoring dashboard added functionality realized wanted test diverse set input data cannedresponse api would able provide purpose took interest rewriting abandoned sibling project transforming data feeding poc rest api xml spring boot project initially written line java still incomplete couple day effort ended line xslt yes goodold xml stylesheets line elixir fun part elixir implementation includes testing satisfies mvpscope requirement accidentally discovered realworld analogy prime directive exposing alien technology rest development team simply accept statement valid mean ready mean added auditing would even refuse look code day yet find soul review merge request rely automated tool like dialyxir run code check automatically stepped dangerous territory trying convince coworkers better yet friend know year threatening job security yes christ sake going support elixir code get hit bus read please stop harming team company u take plunge learn elixir relevant job market thencurrent trend say year short valid question invalid counterargument trying new language learn second foreign language student studying spanish need wipe memory clean german well maybe coworkers right maybe walking skeleton proofofconcept kobayashi maru unlike spock think cheat one think maybe something like zefram cochrane led vulcan come pay u visit upload cool new elixir artifact hexpm welcome gift μου αρέσει αυτό μου αρέσει φόρτωση
43,Lobsters,elixir,Elixir programming,JVM struggles and the BEAM (observability and performance tuning),https://medium.com/@mrjoelkemp/jvm-struggles-and-the-beam-4d9c58547410,jvm struggle beam observability performance tuning,jvm struggle beam tl dr beam built dealing highly concurrent application actorbased elixir programming language otp hitting wall jvm coincidentally found beam finding bottleneck beam single plug observercli vm give ability see bottleneck system long live beam,jvm struggle beami like talk opaqueness jvm plaguing last month fell love erlang virtual machine famously known beam extension elixir programming language tl dr beam built dealing highly concurrent application worldclass introspection give power observe manipulate running application repl simple actorbased concurrency model easy teach make easy reason scale system elixir programming language modern beamlanguage allows terse readable code fully leveraging erlang otp need build maintain high traffic backend service regret learning stackhitting wall jvmat work maintaining business critical jvmbased backend service handle thousand request per second call high traffic service without going detail service basically call database another backend service every request responds user request also offrequest operation necessary dealing database point concurrent operation going within service every requestso wanted know single instance jvmbased system would perform double current load wanted see would break bottleneck werethe state art observing jvmbased application combination using thread dump gc log thread activity visualization thread dump give snapshot name thread current running state waiting blocked etc stacktrace work currently gc log give record much garbage collected thread activity visualization show timeline thread moving different running statesrandom picture showing thread visualizer provided visual vm tool introspecting java applicationsafter performing load test using tool able find completely underutilized thread pool thread nothing least gathered piecing together disparate clue developing huncheswhen came finding thread overutilized lucky seeing random thread active tell busy needed increase threadpool size even trying understand flow control program ie handoff control thread seemed impossible might piece together stacktraces thread dump assuming visualvm perfect sampling thread stacktraces left defeatedoutside observability would also need try use monitoringmetrics help find bottleneck would need add instrumentation threadpools try gauge busy sadly though need instrument every library stack us threadpools know need tweak concurrency configuration library good luck thati blew day trying understand going system using aforementioned tool studying many library standard backend stack trying piece together clue possible bottleneck got nowhere felt helpless frustrated started talk experienced jvm engineer issue visibility system really help either better tool guide search truth folk learned trial error hearing learning java devs getting visualization control flow system like tracing thread would either require really heavy instrumentation way possible caseshow coincidentally found beama talented newly hired teammate joined squad saw struggle reasoning internals fairly simple jvm service mentioned elixir programming language made lot easieri thought another using java used x language previous company great type argument wrong week hearing elixir passing actor model iex shell faulttolerance observer got curious spent night reading tech watched lot youtube video various elixir conferencesthe turning point following visualixir showing realtime interprocess communication elixir applicationbetween sasa talk visualixir library learned elixir stack really beam supplied level deep introspection without need heavily instrumenting software comparing dozen metric graph try understand happening system became intriguedfinding bottleneck beami incredible opportunity run experiment work beam deepen study stack built clone jvm service elixir see felt write service elixir confirm quality kept reading actually helpfulafter building clone day literally going zero something production wanted see could easily find bottlenecki mirrored traffic jvm service elixir service fact global traffic horizontally scaled jvm service going single elixir service machinethe elixir service running plug handled load somewhat fine service kept accepting request despite cpu going memory usage remained fairly flat however getting many response request something choking internally causing request go unfulfilledso fired cli version observer called observercliexample observercli used deeply analyze random elixirbased production systemdue beam application adhering actor model basically allows decompose application series completelyisolated process communicate solely via message use observer reversesort mailbox size allows visually see process backed processing message word vm give ability see bottleneck systemi found process pool charge talking database process handle incoming load managing process mailbox kept growing growing causing request stall database query message could processed pooli changed configuration maybe could done running app thanks elixir repl increase database client process pool size redeployed change fired observercli saw bottleneck looking server log fulfilling request literally found bottleneck within hour increased throughput system soldlong live beamover course continuing iterate clone building infrastructure piece getting vm application metric metric store grafana beam continued shine observercli continue give visibility find bottleneck ease aspect like elixir repl faulttolerance via supervisor timeslice scheduling avoids cpu starving blew mind mind blown stack weekly kid nothaving stack give tool guarantee safely operate highly concurrent system real game changer taught shortcoming jvm comparison also jvm shine highly recommend playing beam elixir get chanceafter watching sasa talk recommend checking following resource learn
44,Lobsters,elixir,Elixir programming,"archseer/enigma - Enigma VM, an implementation of the Erlang VM in Rust",https://github.com/archseer/enigma,archseerenigma enigma vm implementation erlang vm rust,enigma vm installation rustup iex also work rendering bug feature status opcodes bifs roadmap feature goal idea experiment hyper runtime initial nongoals rustler contributing elixir slack,enigma vm implementation erlang vm rust aim complete correct fast order importance otp compatible sans distributed bit code eventually run enigma unchanged deprecated opcodes wo nt supported fun learning lot beam hipe awesome massive sloc small implementation make easier new people learn erlang internals also get platform quickly iterate idea inclusion beam installation prerequisite building enigma rust use rustup install latest nightly rust time nt support stable beta anymore relying asyncawait scheduled run stable time boot otp also need compile standard library moment relies beam build system git submodule update init depth cd otp otpbuild setup make libs make localsetup hope simplify step future enigma run compiler run cargo run install dependency build run vm default boot erlang shell iex also work rendering bug expect crash lot functionality already available prebuilt binary various platform available reach certain level stability feature status implement opcodes half bifs view detailed progress breakdown opcodes bifs roadmap feature goal idea experiment process scheduling implemented top rust future process simply long running future scheduled top tokiothreadpool workstealing queue timer delaytimeout future relying tokiotimer timewheel port future await file io asyncreadasyncwrite awaitable nifbifs future yield certain point play nice reduction allows much simpler yielding implementation future possibility write documentation sparsely documented beam aspect binary matching time wheel process monitor explore using immix gc erlang eir runtime jit via eir bif generator function yield suspendon reduce provide builtin adapter module hyper plug adapter http client crosscompile webassembly runtime initial nongoals vm nt reach certain level completeness nt make sense consider distributed erlang node tracing debugging support beam compatible nifs ffi note nifffi abi compatibility otp going quite work ruststyle nif interface available would also probably possible make adapter compatible rustler contributing contributor welcome easiest way get started look note folder pick bif opcode implement take look srcbifrs bif folder bifs implemented also issue open good first issue tag would also good introduction internals alternatively search codebase todo fixme unimplemented mark various place partial implementation exists bit work need done test coverage currently lacking varying level documentation addressing soon also enigma channel elixir slack
45,Lobsters,elixir,Elixir programming,Newtype-like tagged tuples in Elixir,https://pzel.name/2020/04/26/Newtype-like-tagged-tuples-in-Elixir.html,newtypelike tagged tuples elixir,newtypelike tagged tuples elixir defopaque motivating example unit measure bad tagged tuples name,newtypelike tagged tuples elixir thought code experiment type wrapper elixir metaprogramming time ago stumbled upon hacky way generating something akin haskell newtype declaration elixir defopaque motivating example unit measure going assume agree maxim making illegal state unrepresentable desirable feature software system let say part system deal weight would nice ensure programmer nt use plain number dealing unit measure consequence bad past let define weight module kg constructor wrapping number represent unit weight defmodule weight use defopaque defopen kg number end intention create lightweight wrapper type whose role primarily document meaning variable also prevent accidental use weightrelated function plain number macro defopen give u kg type exported weight kg n macro generate tuple containing number n second element first element tuple autogenerated atom guaranteed stable every wrapperatom wrappedsubtype pair use macro generate new kg value patternmatch existing value let see example kg unit use defmodule myapp import weight spec tellweight weightkg stringt def tellweight w case w kg twelve kilogram kg kg invalid unit end end end require weight iex myapptellweight weightkg twelve kilogram iex myapptellweight weightkg iex myapptellweight invalid unit also use patternmatch syntax match value inside constructor defmodule match import weight def count wantvalue weight kg kg kg kg enumcount weight fn kg wantvalue true kg false end end end iex matchescount iex matchescount even pattern match function head defmodule conversion import weight def kgtolb kg n n end require weight iex conversionkgtolb kg iex conversionkgtolb kg note function called conversionkgtolb kg conversionkgtolb functionclauseerror function clause matching following argument given precisely behavior wanted beginning kg unit converted plain number want expand system deal pound firstclass citizen free cheap generate new wrapper module defmodule weight use defopaque defopen kg number defopen lb number end defmodule conversion import weight def kgtolb kg n lb n def lbtokg lb n kg n end work expected allowing conversion right direction import weight iex kg re conversionkgtolb kg conversionlbtokg iex re iex kg re conversionkgtolb kg conversionkgtolb functionclauseerror function clause matching following argument given see got peek wrapper tagging implemented exactly pretty prevents module creating wrapped type without importing module type defined tagged tuples tagged tuples traditional way handling kind problem nothing wrong however nt prevent unauthorized use type example anyone create tuple kg reason module know nothing weight could nt match tagged tuple def anallegedlyweightagnosticfunction kg weight method code reference weight module good faith create tagging atom since moreorless gibberish also unique opaque tag mean dialyzer much strict checking code structs structs elixir killer feature great modeling composite data type project came attempt golf opaque structs defined internally nested module single field recommend real production project name defopaque original intent behind hack provide quickndirty way define opaque newtypes codebase later figured would also nice provide nonopaque destructurable newtypes hence two macro defopaque creates wrapper defines resulting wrapped type opaque generated constructor patternmatch macro used module opaque type defined defopen creates wrapper defines resulting wrapped type type generated constructor used outside module defined edited module name truncated sentence
46,Lobsters,elixir,Elixir programming,Build a real-time Twitter clone in 15 minutes with LiveView and Phoenix 1.5,https://www.phoenixframework.org/blog/build-a-real-time-twitter-clone-in-15-minutes-with-live-view-and-phoenix-1-5,build realtime twitter clone minute liveview phoenix,build realtime twitter clone minute liveview phoenix phoenix livedashboard http phoenix liveview generator pubsub revamped guide http changelog,build realtime twitter clone minute liveview phoenix posted april chris mccord phoenix released liveview integration release make easier ever build interactive realtime application put together quick screencast show much accomplish minute liveview video outside phoenix liveview integration release brings exciting feature including integration new phoenix livedashboard deprecation ugprade quick easy folk phoenix livedashboard heel official livedashboard release phoenix project ship livedashboard default realtime performance monitoring debugging tool point also want welcome michael crumm phoenixcore team heading dashboard work josé valim thank amazing result today dashboard brings immediate insight phoenix application focus production data even starting phoenix tooltips widget learn ifwhen worry system limit health system telemetry integration also include charting phoenix event along userdefined metric check josé twitter thread see breakdown feature screenshots http dashboard also includes streaming request logger super convenient diagnosing issue production need log specific request regular log drown request noise button click request log streamed dashboard instead sifting thru flood production log also include process tab similar observer allowing sort process system find large message queue memory hog etc mention cluster distributed node using node dropdown selector access datafeatures listed node cluster regardless web node happened loadbalance loading dashboard phoenix liveview generator phxnew project generator includes live flag include everything need get running developing liveview additionally also added phxgenlive generator boostrapping crud liveview contextinterfaces similar phxgenhtmlphxgenjson recommend taking generator test drive see existing improvement liveview recently shipped revamped liveviewtest apis powerful workflow driven testing deep diff tracking liveview template dramatically reducing server payload many case large performance improvement client rendering live navigation live flash pubsub phoenixpubsub released flexible powerful fastlane mechanism took opportunity also move phoenixpubsub endpoint explicitly supervision tree prevents race condition startup decouples pubsub system endpoint follow upgrade guide linked get speed revamped guide thanks effort josé valim phoenix builtin guide restructured revamped providing better navigation structure content sure take look like freshen phoenix knowledge notable improvement include builtin support mssql database via tds adapter inclusion phoenixectocheckrepostatus plug new project detect prompt database creationmigration directly comfort browser always provided upgrade guide bring existing application speed http complete list change see changelog find u elixir slackirc question happy coding
47,Lobsters,elixir,Elixir programming,Phoenix Live Dashboard,https://github.com/phoenixframework/phoenix_live_dashboard,phoenix live dashboard,phoenix livedashboard online documentation installation add dependency configure liveview official installation instruction add dashboard access developmentonly usage extra add dashboard access environment including production article contributing license,phoenix livedashboard online documentation livedashboard provides realtime performance monitoring debugging tool phoenix developer provides following module home see general information system o data see general information o cpu memory disk usage metric see application performs different condition visualizing telemetry event realtime chart request logging see everything logged certain request application see filter search application current node process see filter search process current node port see filter search port responsible io current node socket see filter search socket responsible tcpudp current node ets see filter search ets table inmemory storage current node dashboard also work across node node connected via distributed erlang access information node b accessing dashboard node installation start using livedashboard need three step add phoenixlivedashboard dependency configure liveview add dashboard access add phoenixlivedashboard dependency add following mixexs run mix depsget def deps phoenixlivedashboard end configure liveview livedashboard built top liveview liveview already installed app feel free skip section plan use liveview application future recommend follow official installation instruction guide cover minimum step necessary livedashboard run first update endpoint configuration include signing salt generate signing salt running mix phxgensecret note phoenix apps already configuration configconfigexs config myapp myappwebendpoint liveview signingsalt secretsalt add phoenixliveviewsocket declaration endpoint socket live phoenixliveviewsocket good go add dashboard access developmentonly usage installed update router configuration forward request livedashboard unique name choosing libmyappwebrouterex use myappweb router import phoenixlivedashboardrouter mixenv dev scope pipethrough browser livedashboard dashboard end end run mix phxserver access dashboard configure necessary module extra add dashboard access environment including production want use livedashboard production put behind authentication allow admins access application adminsonly section yet use plugbasicauth set basic authentication long also using ssl anyway libmyappwebrouterex use myappweb router import plugbasicauth import phoenixlivedashboardrouter pipeline adminsonly plug basicauth username admin password special secret end scope pipethrough browser adminsonly livedashboard dashboard end running application behind proxy webserver also make sure configured allowing websocket upgrade example article configure nginx phoenix websockets finally also want configure configprodexs use domain name checkorigin configuration checkorigin myappcom good go contributing planning contribute project run dev version dashboard following command mix setup mix dev alternatively run iex mix dev also want shell license mit license copyright c michael crumm chris mccord josé valim
48,Lobsters,elixir,Elixir programming,Squeezing the most out of the server: Erlang Profiling,http://tech.nextroll.com/blog/dev/2020/04/07/erlang-profiling.html,squeezing server erlang profiling,squeezing server erlang profiling realtime bidding past article hazardous land software optimization without profiling first infrastructure requestlevel timer recon fred hebert erlang anger recon redbug redbug erlang easy profiling eep eep kcachegrind erlgrind lookingglass erlang systemmonitor conclusion observer eprof fprof eflame eministat efficiency guide builtin profiling module,squeezing server erlang profiling written facundo olano april realtime bidding rtb platform featured several time tech blog run fleet erlang application bidder typically range one two thousand node described past article ongoing goal rtb team well source interesting technical minimize operational cost much possible obvious way reduce cost make system efficient mean entering hazardous land software optimization even experienced programmer identifying bottleneck hard enough problem using right tool trying guess could make code run faster waste time likely introduce unnecessary complexity cause problem line cousin premature optimization necessary optimization without profiling first erlang famously known concurrency model faulttolerant design one biggest strength level live inspection tuning offer often little setup runtime cost article outline leverage feature profile system driving optimization lead cost reduction minute read infrastructure interesting aspect realtime bidding fairly lowrisk test production even new code slow contains error bidder architected send nobid response whenever request fulfilled taking advantage incorporate canary deploys daytoday development workflow context optimization mean quickly test performance hypothesis updating code testing live traffic metric dashboard give feedback common metric like timeouts error amount request processed making obvious change beneficial requestlevel timer bid request processing fundamental operation bidder application improvement amount time take u send response ad exchange mean process request per server requiring fewer server handle traffic ultimately saving u money work involved bid request broadly divided series task payload parsing selection matching ad pricing particular ad response encoding common practice periodically measure time invested phase make sure degrade time help provide frame reference use look area code worthy optimization effort sample bid request timing per phase basic way profiling consists timing call given piece code perhaps one deemed suspicious one method described next section evaluates fun report evaluation time histogram metric spec timecall name fun result result timecall metric fun start erlang systemtime microsecond result fun end erlang systemtime microsecond diff end start update histogram metric diff result helper used wrap call function want measure canary deploy timed code production generate average median percentile metric compare overall request time identify bottleneck recon timing request operation useful technique understanding specific request flow give u limited perspective entire system bid request phase handled single process involve idle time waiting external system many periodic task longlived support process bidder benefit systemwide profiling look beyond bid request processing erlang toolbox come play first valuable resource piece software little book fred hebert erlang anger guide perfect reference describes method gaining insight optimizing production system backed realworld experience companion library recon provides safer friendlier productive interface powerful inspection tool follows simple example mostly derived book get node general stats bidderdev node recon nodestatsprint schedulerusage get top memory consumer bidderdev node recon proccount memory bidderbanker currentfunction genserver initialcall proclib bidguardian currentfunction genserver initialcall proclib currentfunction priminet initialcall proclib get top cpu consumer bidderdev node recon proccount reduction currentfunction exometerprobe initialcall proclib currentfunction exometerprobe initialcall proclib currentfunction exometerprobe initialcall proclib get top cpu consumer time window bidderdev node recon procwindow reduction currentfunction viewsbid initialcall proclib currentfunction timer initialcall proclib currentfunction priminet initialcall proclib get process stats including stacktrace bidderdev node recon info meta registeredname bidderbanker dictionary initialcall bidderbanker ancestor biddersup groupleader status running signal link monitor monitoredby trapexit true location initialcall proclib currentstacktrace bidderbanker file biddersrcpacingbidderbankererl bidderbanker file biddersrcpacingbidderbankererl bidderbanker file biddersrcpacingbidderbankererl bidderbanker file biddersrcpacingbidderbankererl genserver file genservererl genserver file genservererl proclib file procliberl memoryused garbagecollection maxheapsize errorlogger true kill true size work suggested book good method run recon procwindow repeatedly try identify pattern eg process frequently rank among top cpu consumer process id passed recon info get useful information stacktrace order understand process using method quickly found commonly accessed data structure contained debug data copied thousand time per second approach though tend highlight longrunning busy process shortlived one could called lot account bigger overhead overall partially overcome running procwindow repeatedly aggregating result location rather process id however better tool look aggregated process time redbug strictly speaking redbug profiling tool useful debugging live system deserves mention article allows safely trace function shell intuitive yet sophisticated way opposed rougher erlang builtin tracing module handy get quick notion function called frequently production data look like bidderdev node redbug start jiffy erlang jiffy encode bidderdev node redbug start jiffy encode return erlang jiffy encode usd erlang jiffy usd bidderdev node redbug start jiffy encode n isinteger n return erlang jiffy encode erlang jiffy including recon redbug erlang application release cost real lifesaver diagnosing production issue tool promote flow powerful adding print code feel natural step debugger useful highly concurrent world anyway erlang easy profiling eep eep allows approach profiling using erlang tracing take snapshot system operation function call count execution time interdependency requires bit effort use safe rest tool described article slow system potentially even killing used carelessly output file eat lot disk space m snapshot take system depending nature application may make sense run directly production example tracing session using eep bidderdev node eep startfiletracing filename timer sleep eep stoptracing note start sleep stop tracing line rely shell responsive tracing could send message call function well force certain part code executed taking snapshot instruction output filenametrace file release directory file need moved production server processed local erlang shell local eep converttracing filename working msg msgssec sec slowdown msg msgssec sec slowdown done turn produce callgrindoutfilename input kcachegrind qcachegrind macos note default tracing discriminate entry per process id would yield similar situation saw recon procwindow interesting view merge function call process accomplished stripping pid grep v ob callgrindoutfilename callgrindoutmergedfilename qcachegrind callgrindoutmergedfilename qcachegrind present snapshot sophisticated ui used spot frequently called function time spent etc eep output qcachegrind since eep based erlang tracing add overhead code may comparatively misrepresent work done builtin function bifs nativeimplemented function nifs timing shown snapshot need taken grain salt nevertheless still great exploratory tool understand different component system interact dependency used learn obscure suspicious area hard spot looking code note erlang profiling library tried yet produce callgrind output erlgrind lookingglass erlang systemmonitor yet another way looking application erlang bif allows set process receive message every time certain condition met particularly helpful u examining long garbage collection schedule long duration latter surface issue nifs would go unnoticed method example use shell based snippet erlang anger bidderdev node loop fun f receive monitor pid event info reconlocation recon info pid location io format monitorp pidp n infop n reconpn event pid info reconlocation end f end bidderdev node spawn fun register tempsysmonitor self erlang systemmonitor self longschedule longgc loop end timer sleep exit whereis tempsysmonitor kill monitor system second output process information shell every time garbage collection schedule take monitorlonggc pid info recon location initialcall proclib currentstacktrace bidderstat file biddersrcbidderstaterl viewsbid file biddersrcviewsviewsbiderl viewsbid file biddersrcviewsviewsbiderl erlstat file biddersrcbidderstaterl bidderwebhandler file biddersrcbidderwebhandlererl proclib file procliberl conclusion article mean exhaustive list erlang diagnosing tool observer eprof fprof eflame eministat list go erlang documentation nice efficiency guide overview builtin profiling module since started effort consistently reduced request time operational cost month month large extent gain came thanks advanced tool erlang ecosystem offer interesting achieved getting know system better fixing bug often removing rather adding specialized code
49,Lobsters,elixir,Elixir programming,Observing Processes in Elixir - The Little Elixir & OTP Guidebook (2015),https://www.akitaonrails.com/2015/11/22/observing-processes-in-elixir-the-little-elixir-otp-guidebook,observing process elixir little elixir otp guidebook,must choice otp worker wrong exactor otp supervisor ets graphically visualizing process fault tolerance supervision tree,yes erlang allows u see going inside runtime environment even take action individual process running inside cool show fault tolerancy observer need explain process matter must understand following concept successfully understand elixir programming nt object runtime instance class prototipical object copy object instead class collection function organized module without dependency internal state instead object roughly speaking process example defmodule myprocess def start acceptingmessages end def acceptingmessages state receive hello message ioputs hello message acceptingmessages state counter newstate state ioputs new state newstate acceptingmessages newstate ioputs acceptingmessages state end end end execute function inside another process spawn brand new concurrent lightweight process iex pid spawn fn myprocessstart end pid called stop block waiting receive new message send message like iex send pid hello world hello world receives hello world atom message pattern match value world message variable concatenates hello world string print recurse call block block waiting message iex send pid counter new state counter iex send pid counter new state counter iex send pid counter new state counter iex send pid counter new state send counter message process pid receive message get state value function argument increment print new state call passing new state new argument block waiting message time receives counter message increase previous state one recurses basically maintain state elixir kill process spawn new one restarts zero function nt object however process superficially process behaves like object careful think process like heavyweight thread though erlang internal scheduler control concurrency parallel load many billion lightweight process hardware allows thread super heavy erlang process super light saw example process internal mechanism receive message process message accumulate internal mailbox choose receive pattern match message recursing order receive new message want process linked monitor process example within iex shell within elixir process could iex self pid iex pid spawn fn myprocessstart end pid iex processalive pid true iex processlink pid true self see current process id iex shell spawn process call block receive call new process different id assert new process indeed alive link iex shell pid process whatever happens process cascade shell iex processexit pid kill exit pid killed interactive elixir press ctrlc exit type h enter help warning redefining module r iex self pid indeed forcefully send kill message process iex shell also killed process iex restarts new pid instead old way one way process different normal object behaves like operating system process crash process affect whole system hold external shared state corrupt system state important concept mechanism define parent process iex example child process linked parent process nt need stupidly suicide child screwed instead trap exit decide later iex processflag trapexit true false iex pid spawnlink fn myprocessstart end pid iex send pid counter new state counter first declare iex shell trap exists die spawn new process link function effect send message new pid check indeed still working iex processexit pid kill true iex processalive pid false iex flush exit pid killed ok forcefully kill new process iex crash time explicitly trapping error check killed pid assert indeed dead also inspect iex process mailbox case flushing whats queued inbox see received message saying child killed could make iex process treat message decide mourn deceased child commit suicide move spawnlink new choice face disaster otp worker letting aside grim metaphor learned parent child process importantly fit role supervisor worker supervised respectivelly worker put code code bug depend external stuff make code crash unexpected reason normal language would start using dreaded trycatch block ugly wrong nt catch error elixir let crash explained previous article everything elixir end called otp application example simple contraption expand upon let rewrite thing otp genserver defmodule myfancyprocess use genserver def startlink genserverstartlink module name module end public api def hello message genservercall module hello message end def counter genservercall module counter end genserver callback def init startcounter ok startcounter end def handlecall hello message state ioputs hello message reply noproc state end def handlecall counter state newstate state ioputs new state newstate reply noproc newstate end end new myfancyprocess essentially myprocess otp genserver top public api function genserver callback benjamin book go great lenghts detail every bit implemented understand basic module use genserver import necessary genserver bit convenience essence one thing create receive block first version wait message function create instance genserver return linked process internally call back function set initial state worker flexible language multiple way thing good single way writing code boring convention one public function call internal synchronous call asynchronous call could call handlecall outside ugly find convention everywhere place start calling directly iex myfancyprocessstartlink ok pid iex myfancyprocesshello world hello world noproc iex myfancyprocesscounter new state noproc iex myfancyprocesscounter new state noproc iex myfancyprocesscounter new state noproc much cleaner version manually spawnlink send message pid handled nicely genserver underneath said result initial crude myprocess example fact convention make u type lot boilerplate many time library called exactor grealy simplifies genserver implementation making previous code become something like defmodule myfancyprocess use exactorgenserver initialstate defcall hello message state ioputs hello message noreply end defcall counter state newcounter state ioputs new state newcounter newstate newcounter end end way cleaner using iex using version next section stick longer version myfancyprocess listed beginning section otp supervisor worker create supervisor supervise defmodule myfancysupervisor use supervisor def startlink supervisorstartlink module end def init child worker myfancyprocess opts strategy oneforone supervise child opts end end simple boilerplace supervisor many detail must learn article purpose important bit first definition child specification saying supervisor start myfancyprocess genserver instead u myfancyprocessstartlink manually second important bit opts list defines strategy oneforone meaning supervisor detects child died restart clean iex copy paste myfancyprocess myfancysupervisor start playing iex shell iex ok suppid myfancysupervisorstartlink ok pid iex myfancyprocesshello foo hello foo noproc iex myfancyprocesscounter new state noproc iex myfancyprocesscounter new state noproc start supervisor see right away start sending message myfancyprocess genserver supervisor successfully started u iex supervisorcountchildren suppid active spec supervisor worker iex supervisorwhichchildren suppid myfancyprocess pid worker myfancyprocess using supervisor pid captured right started ask count many child monitoring example ask detail child well see myfancyprocess started pid iex workerpid supervisorwhichchildren suppid myfancyprocess pid worker myfancyprocess iex processexit workerpid kill true grab worker pid manually force crash screwed right nope iex supervisorwhichchildren suppid myfancyprocess pid worker myfancyprocess iex myfancyprocesscounter new state noproc iex myfancyprocesscounter new state noproc ask supervisor list child see old process indeed vanish new one spawned place supervisor strategy oneforone defined continue making call myfancyprocess see previous state lost restarts zero add state management genserver using number different persistent storage builtin ets think ets builtin memcache service think get idea graphically visualizing process entire article motivated simple thing benjamin book end page book built simple pool system able start process pool guarded supervisor go show observer erlang builtin inspector tool called observer use supervisor builtin function inspect process demonstrated much cooler see visually assuming installed erlang solution propertly ubuntu wget http sudo dpkg start observer directly iex shell like graphical window show stats first powerful becuase insight control entire erlang runtime see status window even show uptime line unix system made stay matter process garbage collector behave nicely towards entire system hook remote observer remote erlang runtimes well wondering jump application tab see pooly exercise look like child pool child supervised proper restart strategy visually kill one one pid labeled observer immediatelly show supervisor took action spawned new child added pool bringing count back fault tolerance proper control mean using otp bit explained article enough concept finally grasp erlang high reliabiliby fuzz basic concept simple hook application otp also nobrainer otp implemented hood make application much reliable clear guideline design application supervises happen application state worker restarted divide responsabilities different group supervisorchildren application supposed look like tree supervision tree failure one leaf bring branch everything know behave recover elegantly really like unix operating system kill one process nt bring system initd monitored service get respawned important optional feature party library choose use builtin erlang must use want play choice best choice pattern implemented concurrent language represents big failure language elixir strength high level control wo nt find anywhere else still nt even talk otp application exchange message across wire really distributed system erlang runtime reload code application running zero downtime akin iex capable phoenix allow development mode code reloading otp give free well worth learning detail went process pid send kill message process trap exit parent child process feel similar unix work know unix easily grasp fit together including elixir pipe operator compared unix pipe similar finally little elixir otp guidebook easy read handson small book read couple day grasp everything quickly summarized much highly encourage buy right
50,Lobsters,elixir,Elixir programming,Introducing Ecto Resource,https://blog.testdouble.com/posts/2020-03-24-introducing-ecto-resource/,introducing ecto resource,crudy context jam work elixirphoenix application context crud ecto ectoresource clean mess ectoresource hex repo schema exdoc hex documentation,crudy context jam work elixirphoenix application context allow separation concern data business logic often time first thing add many basic crud function context essentially delegate ecto boilerplate code lead boilerplate test time crud operation add application compound problem name apis standard function start drift module causing unexpected behavior bug short mess ectoresource clean mess ectoresource hex package aim reduce boilerplate code involved basic crud operation providing macro generate crud function given ecto repo schema consider following context without using ectoresource generated mix phxgencontext account user user defmodule myappaccounts moduledoc account context import ectoquery warn false alias myappaccountsuser alias myapprepo def listusers repoall user end def getusers id repoget user id def createusers attrs user userchangeset attrs repoinsert end def updateusers user user attrs user userchangeset attrs repoupdate end def deleteusers user user repodelete user end def changeusers user user userchangeset user end end function mostly delegate repo addition binding operation user module alternatively generate function using ectoresource alleviates boilerplate allows function within module focused sophisticated operation defmodule myappaccounts moduledoc account context import ectoquery warn false alias myappaccountsuser alias myapprepo use ectoresource usingrepo repo resource user end end default resource generate basic crud function myappaccountscreateuser myappaccountsdeleteuser myappaccountsgetuser myappaccountsgetuserby myappaccountsupdateuser note generate list using following function console iex repo schema functionnames mycontextresource resource need specific use filter option usingrepo repo resource user create delete end would generate given function also use except filter option inverse usingrepo repo resource user except create create delete delete end would generate given function myappaccountsgetuser myappaccountsgetuserby myappaccountsupdateuser see ectoresource macro eliminate boilerplate function definition let context module remain focused function deviate standard crud operation function generated ectoresource api providing dependable standard might delighted know function generated context included application documentation using exdoc like see much removed context install ectoresource application adding dependency defp deps ectoresource end mix depsget set ready use ectoresource macro application check hex read documentation
51,Lobsters,elixir,Elixir programming,Mixing Gleam & Elixir,https://dev.to/contact-stack/mixing-gleam-elixir-3fe3,mixing gleam elixir,contact stack elm gleam mix compiler task http githubcommichaeljonesgleamphoenixmix installation instruction phoenix http githubcommichaeljonesgleamphoenixmix final thought,contact stack chosen elixir phoenix core tech stack happy choice miss really good type system helpful compiler like elm guide u development elixir target beam virtual machine statically typed language target beam well going look simple set integrating gleam elixir project using mix compiler task gleam statically typed functional programming language us syntax approachable say javascript c java programmer ml flavoured language gleam compiler written rust output erlang source file compiled beam erlang compiler mix multifunctional build tool elixir project manage dependency run test execute task compile elixir code also support compiling erlang file default extended mix compiler task compile language going create mix compiler task gleam mix use gleam compiler build gleam file try step check demonstration repository http githubcommichaeljonesgleamphoenixmix go assuming gleam compiler available environment execute run check nt follow installation instruction gleam doc going go setting phoenix project scratch wo nt go detail clear base work run following command set empty phoenix project mkdir gleamphoenixmix cd gleamphoenixmix mix phxnew app myapp mix ectocreate cd asset npm install cd need create mix compiler task put libmixtaskscompile directory reflect module name need give mixtaskscompilegleam create new directory mkdir p libmixtaskscompile add follow code file called libmixtaskscompilegleamex defmodule mixtaskscompilegleam use mixtaskcompiler def run args systemcmd gleam build ok end end really running gleam compiler directly build argument get build gleam file find run elixir compiler compile mix task try use make gleam happy need set toml config file create file called gleamtoml root project follow content create src directory gleam file gleam compiler expects gleam file src directory different elixirmix expects lib directory default elixirmix configured gleam ca nt time writing create gleam module making file called srchelloworldgleam following code pub fn hello hello gleam next make following change mixexs file add compiler task list compiler run mix compile make sure mix erlang compiler look gen folder erlang file gleam compiler compiles gleam file src folder erl file gen folder need erlang compiler find elixir elixircpaths elixircpaths mixenv erlcpaths src gen compiler phoenix gettext mixcompilers compiler phoenix gettext gleam mixcompilers startpermanent mixenv prod alias alias assume mix run compiler start end list want gleam entry erlang entry mixcompilers erlang compiler run gleam compile compile erlang file gleam compiler creates simple demonstration interop elixir compiled gleam file make following change libmyappwebcontrollerspagecontrollerex defmodule myappwebpagecontroller use myappweb controller def index conn params render conn indexhtml render conn indexhtml title helloworldhello end end work gleam module compiled erlang module elixir erlang module accessible via atom name make following change libmyappwebtemplatespageindexhtmleex section class phxhero gettext welcome name name phoenix title p productive web framework br compromise speed maintainability p section finally run mix compile mix phxserver load http browser see hello gleam centre standard phoenix welcome page remember curious check final result demonstration repo github http githubcommichaeljonesgleamphoenixmix final thought exciting see nt hard incorporate gleam code elixir project using mix great mix built kind extensibility mind definitely question answer rough edge smooth exciting avenue using strongly typed language beam
52,Lobsters,elixir,Elixir programming,Discord Incident Report (March 16 Outage),https://status.discordapp.com/incidents/62gt9cgjwdgf,discord incident report march outage,summary timeline http http investigation analysis http githubcometcdioetcd action item response,time pdt summary discord unavailable user period hour root cause well understood fixed bug service discovery system used service within infrastructure discover one another instance service discovery used real time chat service service order discover rpc endpoint use load data database connect discord discord server guild created first time need reloaded database timeline set node serve api traffic scale deal growing load api cluster event happens throughout day single node called scaled unexpected error announcing service discovery elixir service used handle real time connection chat message processing started crash resulting instantaneous loss capacity causing cascading failure dependent system multiple alarm internally go signal drop key metric look well anomaly alert cluster utilization incident declared phone bridge set available engineer hop start investigating establish internal external communication status page incident opened let user know investigating http tweet posted letting user know looking issue check status page update http engineer investigate exactly lost much capacity real time system engineer focus recovering service restarting lost capacity begin throttle connection discord order help service recovery additionally begin stop database maintenance operation antientropy repair two scylladb cluster would lead resource starvation everyone attempting reconnect engineer pinpoint issue strongly correlated spike error originating service discovery module determined service discovery process api service gotten crash loop due unexpected deserialization error triggered event called max restart intensity process supervisor determined crashing frequently decided trigger full restart node event occurred instantaneously across approximately node watching api node across multiple cluster believed related u hitting cap number watcher etcd keyvalue store use service discovery attempt increase using runtime configuration engineer continue remediate failed node restore service user connection throttle continually increased allowing user reconnect service recover status page incident resolved service deemed fully operational mitigation issue deployed production order prevent issue recurring root cause fully understood investigation analysis root cause outage determined invalid service entry inserted service discovery causing parse error trying deserialize entry loading etcd engineer worked recreate issue test environment able reproduce issue observed production development environment discord us open source distributed reliable keyvalue store called etcd http githubcometcdioetcd order store service discovery information service discoverable announce setting key specific directory etcd pertains cluster part key second ttl service responsible heartbeating etcd reannounce key discord using etcd api node joined api cluster introduced google cloud managed instance group autoscaler normal event happens hundred time day utilization platform increase approach peak hour node logged error attempting initially announce etcd httpclientremotedisconnected remote end closed connection without response nearly immediately almost elixir node logged service watcher discordapi service crashed attempting parse json metadata stored key value etcd process crashlooped briefly due invalid json data etcd cluster lasted api node retried announcing service discovery fixing corrupt key written etcd node announce etcd issuing http put request contains urlencoded form body contains value key case value json encoded metadata information relevant discovery service etcd client us python builtin http client sends put request along contentlength header one packet request body another packet determined connection reset sending first packet second packet could sent wellbehaved http server would see received request specifying contentlength incomplete nonexistent body reject request etcd written go programming language us go standard library nethttp http request handler key api order parse form body sent client us nethttprequestparseform method method check see request body length match length specified contentlength header caused key written empty string value announce request able successfully send header send body turn caused invalid key written service discovery caused downstream service crash key rewritten announcing node retried action item response code within service discovery system resilient type failure within expectation key could announced without value due transient network error service discovery system resilient various failure mode within etcd however anticipate client able write corrupt record due improper http handling golang nethttp module violation http specification specific case introduced additional failure case anticipate expected contentlength header incomplete body rejected server incomplete unfortunately nethttp check byte read body portion request match contentlength header since hardened system reduce likelihood occurring also handle invalid service announced without crash looping order reduce likelihood invalid key written service discovery modified etcd client send announce request single tcp packet instead two mean header body either received completely added additional error handling ignore service corrupt key value case issue recur worst happen service discovered able investigate additionally filling upstream bug report go project aware issue hopefully nobody else learn hard way sorry inconvenience caused working around clock make sure discord reliable available everyone especially utilization platform time high thank choosing discord place hang talk friend
53,Lobsters,elixir,Elixir programming,Building Command-Line Applications in Elixir,https://zorbash.com/post/building-command-line-applications-with-elixir/,building commandline application elixir,tefter elixir ratatouille source download elixir tefter previous post ratatouille elm termbox ratatouille pro ets dets mnesia release ratatouille command con demo time tefter cli web app browser extension mobile desktop apps slack app shortcut authentication search app architecture termbox anatomy view alias alias bookmark ratatouille ratatouille adding bookmark deleting bookmark filtering extermbox development repo packaging framework ratatouille architecture ratatouilleruntime caveat next list organisation thank ndreynolds,always fascinated wellmade application terminal nt install htop new machine right plan build something use daily people would potentially find useful therefore decided build cli app tefter built elixir ratatouille opensource check source download try install via brew brew tap tefterhomebrewcli brew install tefter elixir elixir getting popular web distributed application day devs tend write cli apps rust go c use elixir tefter see previous post case code reuse point stumbled upon ratatouille elm inspired framework leverage termbox c library textbased user interface charmed beautiful api ratatouille eager overcome potential hurdle chose elixir pro highlevel language faulttolerance optimal offline storage ets dets mnesia portability release decent framework ratatouille fantastic concurrency see command codereloading quick debugging much fun con release bundle vm could smaller release truly portable release built linux machine wo nt work mac etc trivial way forkexec demo time take glimpse app behaves sorry browser nt support embedded video tefter going detail specific cli let talk tefter first tool aiming optimise web surfing routine combination personal searchengine social bookmarking tool place archive stuff read later write note one would interact tefter web app browser extension mobile desktop apps slack app moment writing feature three main tab search alias bookmark advantage cli app rest available nt leave terminal keyboard vimstyle keybindings mouse support work offline shortcut key action ctrls jump search tab ctrla jump alias tab ctrlb jump bookmark tab ctrlh jump help tab tab jump next tab home jump first tab move ctrlk move move ctrlj move ctrld scroll ctrlu scroll enter open browser window item cursor esc cancel command quit modal force refresh resource ctrlq quit enter filtering mode enter command mode authentication authentication implemented seamless possible wo nt ask user type username password first time application started look authentication token tefter file file hold plain json config found start tiny web server listening random port open browser window special tefter endpoint redirects address local web server authentication token encoded query params app proceeds create tefter file see action sorry browser nt support embedded video search work similar manner autocomplete web app user type result appear panel result bookmark list domain tag alias app architecture let look work moment app structured follows libteftercli app â stateex appex applicationex authserverex authenticationex bookmarksex cacheex commandex configex systemex view alias â actionsex â stateex aliasesex authenticationex bookmark â actionsex â stateex bookmarksex component â bottombarex â cursorex â infopanelex â paginationex â topbarex helpex helper â textex listsex search â stateex searchex view directory module per tab searchex aliasesex bookmarksex helpex view state management module eg viewsbookmarksstateex applicable module action action handle sideeffects interaction server cache main entrypoint application appex rather brief fit snippet defmodule teftercliapp behaviour ratatouilleapp alias ratatouilleruntime subscription alias teftercliappstate alias teftercliviews search bookmark list alias authentication help tab search alias bookmark help impl true def init stateinit impl true def update state msg stateupdate state msg impl true def render token nil state authenticationrender state def render tab search state searchrender state def render tab bookmark state bookmarksrender state def render tab alias state aliasesrender state def render tab list state listsrender state def render tab help state helprender state doc return available application tab def tab tab impl true def subscribe token nil subscriptioninterval checktoken def subscribe subscriptioninterval checktoken end placed supervision tree ratatouilleruntimesupervisor runtime app teftercliapp quitevents key ratatouilleconstantskey ctrlq declare main module app ctrl q quits important function teftercliapp receives model current state app first argument message second one message usually tuple event event event termbox mouse keyboard event like following extermboxevent ch h key mod type w x return updated state case may return model commandt command later receives model must return ratatouilleelement thankfully nt assemble element structs manually macro example def render model view label content hello modelname end end teftercli view module like teftercliviewsbookmarks define function delegate state management module like teftercliviewsbookmarksstate moment model teftercli plain map refactored struct future anatomy view view share topbar bottombar view paginated resource infopanel display pagination info permit typing command alias alias think alias dynamic shortened link create map alias pointing http wwwgooglecommapssearch hlen sourceopensearch browser extension installed type gomapslondon address bar redirected http wwwgooglecommapssearchlondon hlen sourceopensearch set dynamic segment shortened link dynamic segment optional though commandline app view alias created create alias c alias url command delete alias command search alias typing open browser window link alias pressing enter example sorry browser nt support embedded video bookmark bookmark tab similar alias user likely way bookmark alias since average user bookmark fewer alias call different pagination strategy alias sliding viewport offset controlled cursor nt work well bookmark tested initially bookmark bookmark sluggish reason every keyboard mouse event ratatouille try rerender everything case thousand bookmark within viewport render every bookmark despite offscreen solution feed slice bookmark list viewport similar note ratatouille rerender everything every see adding bookmark one add bookmark typing c url deleting bookmark delete bookmark type currently selected bookmark deleted filtering filter type highlight result used unfortunately extermbox seems drop diacritical mark string would let render highlighted text like see resorted surrounding matching text development clone repo run iex mix make change welcome submit pullrequest since app take iex session simplify debugging event logged file logdevlog development drop iex console go search tab hit ctrl reload source without restarting app hit packaging two simple bash script prepare release linux macos binreleaselinux binreleasemacos respectively use mix release prepare tarball bundle erlang vm linux script leverage docker ensure release built even nonlinux machine also maintain formula install via homebrew brew tap tefterhomebrewcli brew install tefter framework ratatouille ratatouille impressive make want write something well documented also rather simple one read source one go architecture view better explained quoting documentation ratatouille view simply tree element element tree hold attribute map list zero child node visually look like something element tag view attribute child element tag row attribute child element tag column attribute size child element tag column attribute size child element tag column attribute size child runtime basically defp loop state ok windowupdate statewindow stateapprender statemodel receive event type resizeevent event state processupdate resize event loop event event quitevent statequitevents event shutdown state else state processupdate event event loop end commandresult message state processupdate message loop stateinterval state processsubscriptions loop end end change ratatouilleruntime genserver plenty reason introspection sys one caveat ratatouille fantastic thing could improved performs unnecessary rerenderings lack form control next debian homebrew package window support mention desktop app list organisation create delete alias display note overlay edit bookmark trigger edit mode e command open editor tempfile containing json representation bookmark editor closed update bookmark import chrome firefox bookmark thank want thank ndreynolds creating ratatouille hope people gain something reading post source app provide feedback
55,Lobsters,elixir,Elixir programming,Complex Unique Constraints with PostgreSQL Triggers in Ecto,http://johnwilger.com/2020/02/16/ecto-custom-unique-constraint-trigger.html,complex unique constraint postgresql trigger ecto,ecto changeset validation uniqueness constraint something complex tl dr raise relevant code ectosql,ecto make easy work typical uniqueness constraint database define table like defmodule myapprepomigrationscreatefoos use ectomigration def change create table foos add name text null false end create uniqueindex foos name end end module changeset validation uniqueness constraint perhaps like defmodule myappfoo use ectoschema import ectochangeset schema foos field name string end def changeset module foo change foo cast change name uniqueconstraint name end end run result myappfoochangeset myappfoo name bar myapprepoinsert ecto library attempt insert record already record name column set bar ecto see uniqueness constraint violation error produced database turn validation error changeset would look something like error ectochangeset error name already taken result something complex recently needed enforce database constraint similar spirit unique index record violation wanted behavior elixir end changeset report value field already taken however criterion considered unique complex simple unique index postgresql would able deal let pretend project managing meeting room reservation process reserving meeting room follows customer chooses room selects time range reservation assuming room available time system place hold room hour within period customer pay room completes contractual information must signed customer facility manager payment complete contract signed reservation confirmed business rule creating reservation room reservation made given room timeperiod exists another room reservation room overlapping timeperiod existing reservation confirmed status room reservation made given room timeperiod exists another room reservation room overlapping timeperiod existing reservation hold status existing reservation created within last hour decide store room reservation table defined defmodule meetingsrepomigrationscreateroomreservations use ectomigration def change create table roomreservations add customerid binaryid null false add roomid binaryid null false add reservationstartsat timestamp null false add reservationendsat timestamp null false add status text null false default hold timestamps end end end ideally like able model roomreservation elixir defmodule meetingsroomreservation use ectoschema import ectochangeset schema roomreservations field customerid binaryid field roomid binaryid field reservationstartsat utcdatetime field reservationendsat utcdatetime field status string timestamps end def create resdata module cast resdata customerid roomid reservationstartsat reservationendsat validaterequired customerid roomid reservationstartsat reservationendsat putchange status hold uniqueconstraint roomid message already reserved meetingrepoinsert end end interesting bit uniqueconstraint roomid line customer try reserve room already reserved given time period want function return validation error error ectochangeset error roomid already reserved meetingsroomreservationcreate customerid roomid reservationstartsat datetimefromnaive n etcutc reservationendsat datetimefromnaive n etcutc clearly according business rule system put unique index roomid column best knowledge exclusion constraint also work need check row status hold insertedat timestamp hour ago relative current time however possible use trigger function enforce constraint database defmodule meetingsrepomigrationscreateroomreservations use ectomigration def change create table roomreservations add customerid binaryid null false add roomid binaryid null false add reservationstartsat timestamp null false add reservationendsat timestamp null false add status text null false default hold timestamps end execute create function roomreservationscheckroomavailability return trigger begin exists select roomreservations rr rrroomid newroomid tsrange rrreservationstartsat rrreservationendsat tsrange newreservationstartsat newreservationendsat rrstatus confirmed rrinsertedat currenttimestamp interval hour raise room already reserved end return new end language plpgsql drop function roomreservationscheckroomavailability execute create trigger roomreservationsroomavailabilitycheck insert roomreservations row execute procedure roomreservationscheckroomavailability drop trigger roomreservationsroomavailabilitycheck roomreservations end end problem instead nice validation error changeset want get instead end unhandled postgrexerror exception could course simply rescue exception function add error changeset start look little ugly defmodule meetingsroomreservation def create resdata changeset module cast resdata customerid roomid reservationstartsat reservationendsat validaterequired customerid roomid reservationstartsat reservationendsat putchange status hold meetingrepoinsert changeset rescue error postgrexerror case error postgres message room already reserved changeset adderror roomid already reserved end end end tl dr raise knowing work intercepting error raised database set see could implement complex unique constraint logic database still able use validation without needing modify elixir code looking relevant code ectosql see trick getting roomreservationscheckroomavailability functionality work function change postgresql exception use correct error code well constraint name linked changeset validation redifine postgresql function create function roomreservationscheckroomavailability return trigger begin exists select roomreservations rr rrroomid newroomid tsrange rrreservationstartsat rrreservationendsat tsrange newreservationstartsat newreservationendsat rrstatus confirmed rrinsertedat currenttimestamp interval hour raise uniqueviolation using constraint roomreservationsroomreserved end return new end language plpgsql add name option uniqueconstraint changeset validation defmodule meetingsroomreservation def create resdata module cast resdata customerid roomid reservationstartsat reservationendsat validaterequired customerid roomid reservationstartsat reservationendsat putchange status hold uniqueconstraint roomid message already reserved name roomreservationsroomreserved meetingrepoinsert end end
56,Lobsters,elixir,Elixir programming,Ranking list algorithm in Elixir,https://enpo.no/2020/2020-02-19-ranking-list-algorithm-in-elixir.html,ranking list algorithm elixir,back homepage back blog back archive ranking list algorithm elixir call proposal edit lobster solution elixir script ex output adrian enpono,back homepage back blog back archive ranking list algorithm elixir written adrian dalhaug utc interesting problem landed desk work today make ranking list algorithm elixir rule ranking start two participant share number point get ranking ranking indicate many participant ranked higher given rank last rule interesting gap ranking rule get play example rank point rank point rank point rank point rank point call proposal made solution elixir current project us love someone would send email link implementation favourite language add contribution edit got bunch response lobster great solution problem solution elixir script ex defmodule ranking def ranking participant participant enumsort rankingwork end defp rankingwork participant prevpoints prevranking prevcount rankinglist defp rankingwork rankinglist rankinglist end defp rankingwork participant otherparticipants prevpoints prevranking prevcount rankinglist newpoints newranking newcount newrankinglist prevpoints participantpoints newranking formatrank prevranking prevpoints newranking prevcount rankinglist mapmerge participant ranking newranking else newranking formatrank prevranking prevcount participantpoints newranking rankinglist mapmerge participant ranking newranking end rankingwork otherparticipants newpoints newranking newcount newrankinglist end defp formatrank rank even every person rank never use rank rank else rank end end def rankmockdata id point id point id point id point id point id point id point id point id point id point ranking end end rankingrankmockdata inspect pretty true ioputs output elixir rankingexs id point ranking id point ranking id point ranking id point ranking id point ranking id point ranking id point ranking id point ranking id point ranking id point ranking comment mail adrian enpono generated utc
57,Lobsters,elixir,Elixir programming,Elixir and Postgres: A Rarely Mentioned Problem,https://blog.soykaf.com/post/postgresql-elixir-troubles/,elixir postgres rarely mentioned problem,use index benchmarking prepared statement unprepared ecto documentation option update tl dr,last time talked magic trick make full text search go fast time tell another performance issue encountered probably also affect performance least using ecto postgresql story interplay ecto postgresql postgresql query planner truth universally acknowledged social network possession good amount post must want hashtags user love hashtags help discover new people view nsfw picture site research purpose database need able return list post tagged certain tag sorted descending post id way implement way example name type id integer content text tag varchar insertion put hashtags occur text tag array use array operator find post certain tag pleromabenchmark select count activity array cofe varchar tag count row would query using get post select activity array cofe varchar tag order id desc limit overlap operator true two array share element fast well sort descending post id database walk every post one one check condition match speed depends heavily hashtag searching general hashtags follow power law distribution pretentious way saying lot hashtags unpopular hashtags popular new post every day contain cofe many contain phantasmagoric example popular hashtag cofe fast quickly find post match going hundred post even le example performance pleromabenchmark explain analyze select activity array cofe varchar tag order id desc limit query plan limit actual index scan backward using activitiespkey activity actual filter cofe character varying tag row removed filter planning time m execution time m row phantasmagoric take lot longer maybe go million post post match even worse even post look whole database absolutely ruining performance always solution use index index array using old friend gin index speed operator look phantasmagoric index used example pleromabenchmark explain analyze select activity array phantasmagoric varchar tag order id desc limit query plan limit actual sort actual sort key id desc sort method topn heapsort memory bitmap heap scan activity actual recheck cond phantasmagoric character varying tag heap block bitmap index scan activitiestagsindex actual index cond tag phantasmagoric character varying planning time m execution time m row also really fast even us different plan query cofe also use index answer good thing tradeoff index give exact match unsorted note extra sort step plan phantasmagoric lot match actually faster go database like cofe example result already sorted postgresql keep statistic data distribution index decide plan best given input benchmarking wrote benchmark benchee http githubcombencheeorgbenchee test hashtag timeline speed different hashtags distribution post count tag benchmark input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m well look bad every tag rather bad performance even worse seems decrease popular tag get look like using index every query even one le optimal true let show interesting variation benchmark run code input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m exact benchmark run reverse order difference popular hashtags super fast others great still fine solution seems easy tell user look hashtags order kidding course speed query depend order read well tell first talk parallel universe prepared statement prepared statement unprepared know query select type thing another way prepared statement similar normal query essentially parameterized version prepare please find tag query execute tag argument well prevents injection attack query input strictly separated also advantage planning would take long time prepared statement plan generic plan reused every execution favorite notorm ecto also us prepared statemens every query plot thiccens postgresql use generic plan every query quite like look documentation read postgresql custom plan first time query run check better generic plan use remaining query otherwise use generic plan never custom plan look like happened start unpopular hashtags query plan using index used every query start popular hashtags use one without index hope get alright generic query used everything point index statistic select different plan different input way tell postgresql custom plan even prepared statement answer used postgresql added option version named plancachemode set one forcecustomplan let show benchmark option set input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m input name ip average deviation median hashtag fetching m m m wanted performance great across input finally stop running puzzling benchmark day standard behavior especially devilish see bad performance application run query psql new plan generated performance fine general using ecto always suggest using forcecustomplan unless know update came attention give prepare unnamed option ecto database configuration achieve similar effect postgres version work universally give performance forcecustomplan option testing presumably lose performance boost skipping parsing step prepared query give u tl dr use postgresql possible use ecto set plancachemode forcecustomplan postgresql config use postgresql version set prepare unnamed ecto database setting
58,Lobsters,elixir,Elixir programming,druid: Failing to parse Elixir with Megaparsec,https://evuez.github.io/projects/druid-failing-to-parse-elixir-with-megaparsec.html,druid failing parse elixir megaparsec,druid failing parse elixir megaparsec repo megaparsec lalrpop function application parens space line break semicolon structs map update custom overridable binary operator map structs separate parser hard test elixir parser syntax reference operator page,druid failing parse elixir megaparsec repo last year spent time trying parse elixir megaparsec one colleague started writing parser elixir rust using lalrpop thought fun write one parser combinator could compare implementation never got point turn elixir syntax simple might think clear failure parse elixir nothing megaparsec sure anyone decent knowledge would problem solving many issue faced spent many hour trying solve issue greater appreciation effort put making elixir syntax easy pick list syntax quirk learned writing parser might obvious hopefully still learn thing two reading never huge fan data key syntax feel like nt make clear data unknownkey key wo nt throw error return nil instead ca nt say spending many hour trying parse properly changed mind syntax sure exactly made complex parse example hard time data key proper access syntax accessget data key data key function call data key key think syntax error wrong valid access syntax accessget key data b valid equivalent data b data b data syntax error data n access syntax newlines allowed inside datan hand obviously block code two separate statement know really seem obvious used writing elixir took make obvious parser overall example nt look bad fact access syntax list use nt need parens function application made lot harder parse thought would nt know came reach ca nt decide whether list syntax error access syntax function application parens space able write def foo bar instead def foo bar pretty nice making sense syntax try parse really nt example foo valid foo b nt make kind hard know ignore space ca nt maybe rule nt figured yet line break semicolon remember said datan block code two separate statement well true nt always true depends end first line start second line equivalent different unary higher precedence binary last example long pipeline look nice split multiple line nt miss add semicolon end every statement definitely something come free parser structs map update defined custom overridable binary operator also used special operator update syntax map structs make parsing operator little complex since carry around context know currently map struct parse accordingly bad given megaparsec skill great ended creating separate parser keywords list keywords list function call foo another one foo keywords list b syntax error b nt keyword list b first element every tuple must atom valid access syntax data data think equivalent well let ask quote iex quote data access get data elixir iex quote data access get data elixir data probably expect accessget data hand data might expected equivalent data accessget data accessget data hopefully nt need example one parsing keywords list hard many thing careful parsing elixir check test wrote incomplete parser extensive list official elixir parser syntax reference operator page good reference want learn elixir syntax even though definitely failed writing complete parser learned lot elixir definitely improved megaparsec skill great exercise feeling adventurous want learn elixir programming language parsing general definitely encourage try
59,Lobsters,elixir,Elixir programming,Elixir v1.10 released,https://elixir-lang.org/blog/2020/01/27/elixir-v1-10-0-released/,elixir released,feature added release improvement full release note improvement improvement sortbased apis enum tracking compiletime configuration compiler tracing introducing compiler tracing enhancement credo boundary exunit full release note install section getting started guide,elixir come improvement standard library compiler well several addition mix release feature added particular version add lot polish existing feature configuration system sorting apis also note elixir requires erlangotp allows u provide tighter integration erlangotp new logger mean logger level logger metadata well log message shared erlang elixir apis let take look else new release improvement elixir introduced release mechanism package selfcontained application elixir improves release bug fix new enhancement based feedback got community highlight allow dual boot system release disabled environment boottime sensitive embedded device track raise compiletime configuration set change runtime next section support overlay easily add extra file packaged release allow releasedistribution set none order fully disable distribution add builtin tar step automatically package release see full release note improvement improvement sortbased apis enum elixir default sort lowest highest iex enumsort banana apple pineapple apple banana pineapple want sort highest lowest need call custom sorting function enumsort collection immediately obvious someone reading code iex enumsort banana apple pineapple pineapple banana apple furthermore comparison operator perform structural sorting instead semantic one example using sort date descendingly yield correct result iex enumsort perform proper semantic comparison date one would also need pas custom sorting function iex enumsort datecompare lt elixir streamlines sorting function introducing asc desc shortcut iex enumsort banana apple pineapple asc apple banana pineapple iex enumsort banana apple pineapple desc pineapple banana apple well adding possibility pas module perform semantic comparison example sort date one need pas date module even desc date descending semantical sort iex enumsort date iex enumsort desc date api improvement make code concise readable also added enumsortby enumminby enummaxby friend tracking compiletime configuration elixir organize code application library dependency project separate application application elixir also come application environment application environment keyvalue store allows u configure said application reading application environment runtime preferred approach rare occasion may want use application environment configure compilation certain project often done calling outside function defmodule myappdbclient dbhost applicationgetenv myapp dbhost dblocal def startlink somelibdbclientstartlink host dbhost end end approach one big limitation change value application environment code compiled value used runtime going change example using mix release configreleasesexs config myapp dbhost dbproduction configreleasesexs read code compiled new value effect code compiled connect dblocal course obvious solution mismatch read application environment compilation time first place instead move code inside function defmodule myappdbclient def startlink somelibdbclientstartlink host dbhost end defp dbhost applicationgetenv myapp dbhost dblocal end end preferred approach still two scenario need address everyone may aware pitfall mistakenly read application environment compiletime bitten behaviour rare occasion trully need read application environment compiletime want warned try configure runtime something valid compilation time elixir aim solve two scenario introducing function example read value compile time dbhost applicationcompileenv myapp dbhost dblocal using elixir store value used compilation compare runtime value whenever system start raising error case differ help developer ensure running production system configuration intend future version deprecate use compiletime clear message pointing user configuration best practice effectively addressing scenario user read application environment compile time unaware pitfall compiler tracing release brings enhancement elixir compiler add new capability developer listen compilation event previous elixir version elixir would compile database cross reference module function call reference structs etc project order perform kind check deprecation undefined function although database public developer would still use run check project time developer would request data included database problematic elixir use additional data database meant used externally first place elixir addressed problem introducing compiler tracing compiler tracing allows developer listen event emitted compiler store information need information need elixir using new compiler tracing provide new functionality one advantage approach developer disable undefined function warning directly callsite example imagine optional dependency may available case tell compiler skip warning call optional module compile nowarnundefined optionaldependency defdelegate myfunctioncall arg optionaldependency previously information added overall project configuration far away optional call effectively happened enhancement elixir calendar data type got many improvement sigil support thirdparty calendar well addition datetimenow datetimeshiftzone many improvement related elixir ast release two new option tokenmetadata literalencoder give control elixir parser information already available elixir code formatter made public change alongside compiler tracing mean tool like credo boundary ide integration even better foundation analyze source code exunit test framework ship two small important improvement exunitcaptureio used test run concurrently added patternmatching diffing understand last feature take code assert status body key foo jsonpayload imagine jsonpayload large json blob key inside body value foo previous elixir version assertion failed elixir would print right side let device figure went wrong elixir diff data structure pattern see exactly part data matched pattern one note exunit already performed diffing comparing data type new version add diffing matching data pattern finally release also add two new guard thanks strict requirement erlangotp learn else new read full release note check install section get elixir installed read getting started guide learn fun
60,Lobsters,elixir,Elixir programming,Breadth-First Search in Elixir,https://pabloaguiar.me/post/breadth-first-search-in-elixir/,breadthfirst search elixir,breadthfirst search elixir fun ctional holiday lobster elixir elixir fun hackerrank pattern matching problem problem castle grid shortest reach breadthfirst search shortest reach reading input spoiler alert doc mapset breadthfirst search map pattern matching guard drafted day ago erlangotp shortest reach wrap repl pablo aguiar read,breadthfirst search elixir holiday wanted share one thing dedicated fun ctional holiday typically take vacation time relax disconnect everything workrelated computer scientist like mean distance keyboard tech book tech blog podcasts hackernews lobster twitter etc time travel get involved sport activity like biking hiking manual labor like upgrading bike ax cutting massive fullgrown cupania vernalis struck lightning firewood winter time however decided stay home learn new programming language elixir list month thought time remove top idea soon fall love elixir fun year away hackerrank found back fun easy problem help find way elixir intricate curve slope started enjoy syntax particularly fond pattern matching immutability besides every day get chance play functional language fun elixir beautiful sudden start writing elegant solution problem defmodule jumpingontheclouds def main iogets iogets stringtrim stringsplit enummap jump ioputs end defp jump cloud jump cloud defp jump defp jump jump rem jump defp jump cloud cloud jump cloud cloud defp jump cloud cloud jump cloud cloud end jumpingonthecloudsmain problem thing progressed started get bit serious ventured medium challenge castle grid shortest reach solved breadthfirst search surprised know time writing one elixir first problem given grid obstacle need find cost shortest path one cell another second one given several node edge must find cost shortest path start node every node graph generic bfs implementation solution shortest reach one discus input following form numberofgraphs numberofnodes numberofedges edgefromnode edgetonode startnode example two graph query problem describes node edge graph edge node node edge node node starting node node edge graph edge node node starting node reading input spoiler alert pause like solve problem solution consists module shortestreach bunch small function welldefined responsibility frequently aim working functional language main job read first line remove blank space newlines convert integer pipe result shortestreach shortestreach def main iogets stringtrim stringtointeger shortestreach end shortestreach sequence thing every graph query hence q graph left process defp shortestreach end defp shortestreach q n iogets stringtrim stringsplit enummap nil edge readedges nil start node read adding edge avoid adding edge node back start node would wasteful iogets stringtrim stringtointeger initgraph n addedges edge bfs expandpaths n enumreverse enumjoin ioputs shortestreach q end next function read edge input defp readedges edge edge defp readedges edge edge iogets stringtrim stringsplit enummap readedges end notice new edge prepended list instead appended important detail observe elixir variable immutable whenever list receives another b appended like b first need copied new list appending b becomes problem increase length best always consider prepending instead edge appended solution would nt run time limit case look doc moving initgraph responsible initializing graph n node empty set immediate neighbor node mapset used ensure neighbor node unique case duplicate edge fact key solution run limit set hackerrank defp initgraph mapsetnew defp initgraph n initgraph n mapput n mapsetnew pattern matching ftw graph initialized edge processed adding edge back start node would wasteful whenever encounter edge involving start node add node edge immediate neighbor start node second third function defp addedges graph graph add v immediate neighbor defp addedges graph v edgestail mapput graph mapsetput graph v addedges edgestail end add u immediate neighbor defp addedges graph u edgestail mapput graph mapsetput graph u addedges edgestail end add u v immediate neighbor defp addedges graph u v edgestail mapput graph u mapsetput graph u v mapput v mapsetput graph v u addedges edgestail end take moment marvel pattern matching shine point already noticed order function declared matter breadthfirst search great load graph memory breadthfirst search finally take place receives initialized graph start node bfs graph initiate real bfs see later goal bfs return map path key node value number edge node take following graph example output bfs graph graph would bfs need visit node neighboring layer advancing next layer every new node register distance number layer advanced starting function bootstrap bfs five argument per comment bfs graph bootstrap bfs empty map initialized graph list neighbor empty list node visit next initial layer bfs graph mapsettolist graph every layer list node visited visit one one using head tail pattern matching every unvisited node one yet path map immediate neighbor added list node neighbor visited next layer tail becomes empty list mean unvisited node layer bfs proceed next one layer incremented accumulated neighbor turn visited process repeat list empty path returned see pattern matching make elixir declarative bfs path path bfs path graph neighbor layer bfs path graph neighbor layer bfs path graph u tail neighbor layer cond maphaskey path u bfs path graph tail neighbor layer true mapputnew path u layer bfs graph tail mapsettolist graph u neighbor layer end bfs return path number edge reachable node graph would solution problem statement nt add small detail cost edge unit every unreachable node cost last function expandpaths take care expandpaths expandpaths path expandpaths path expandpaths path n cond maphaskey path n path n expandpaths path n true expandpaths path n end would nt nice guard could check whether n key path good news next version elixir allow first release candidate drafted day ago requires erlangotp brings two new guard released refactored much readable declarative version bfs path path bfs path graph neighbor layer bfs path graph neighbor layer bfs path graph u tail neighbor layer ismapkey path u bfs path graph tail neighbor layer bfs path graph u tail neighbor layer mapputnew path u layer bfs graph tail mapsettolist graph u neighbor layer expandpaths expandpaths path expandpaths path expandpaths path n ismapkey path n path n expandpaths path n expandpaths path n expandpaths path n hope noticed expandpaths prepends cost get reversed line shortest reach solution graph presented wrap could certainly attest holiday packed fun despite devotion learning fantastic language cool outdoor activity even short trip salzburg lovely wife enjoyed lot hope enjoyed content post find complete solution repl experiment love read thought comment section bottom case spotted anything could done differently better grateful could share idea shortestreach def main iogets stringtrim stringtointeger shortestreach end defp shortestreach end defp shortestreach q n iogets stringtrim stringsplit enummap nil edge readedges nil start node read adding edge avoid adding edge node back start node would wasteful iogets stringtrim stringtointeger initgraph n addedges edge bfs expandpaths n enumreverse enumjoin ioputs shortestreach q end defp readedges edge edge defp readedges edge edge iogets stringtrim stringsplit enummap readedges end defp initgraph mapsetnew defp initgraph n initgraph n mapput n mapsetnew defp addedges graph graph add v immediate neighbor defp addedges graph v edgestail mapput graph mapsetput graph v addedges edgestail end add u immediate neighbor defp addedges graph u edgestail mapput graph mapsetput graph u addedges edgestail end add u v immediate neighbor defp addedges graph u v edgestail mapput graph u mapsetput graph u v mapput v mapsetput graph v u addedges edgestail end defp bfs graph bootstrap bfs empty map initialized graph list neighbor empty list node visit next initial layer bfs graph mapsettolist graph end defp bfs path path defp bfs path graph neighbor layer bfs path graph neighbor layer end defp bfs path graph u tail neighbor layer cond maphaskey path u bfs path graph tail neighbor layer true mapputnew path u layer bfs graph tail mapsettolist graph u neighbor layer end end defp expandpaths defp expandpaths path expandpaths path defp expandpaths path n cond maphaskey path n path n expandpaths path n true expandpaths path n end end experiment solution using following repl author pablo aguiar software engineer coffee geek brazil curious computer math science enjoys good coffee love literature read
61,Lobsters,elixir,Elixir programming,Ernie - binary encoding format based on External Term Format (Erlang),https://github.com/hauleth/ernie,ernie binary encoding format based external term format erlang,ernie external term format bert name rpc schemastructured data specification introduction bcp type encoding open question license creative common attributionsharealike international license,ernie simple binary data exchange format based external term format erlang update bert little bit outdated right name ernie fun original bert name sesame street bert ernie couple rpc document define rpc syntax reason scope document meant define data encoding format service one use author document belief rpc bad use instead use message passing service schemastructured data meant encode freeform data want encode structured data schema highly suggest take look format like encoding protobuffers apache thrift flatbuffers cap nproto specification introduction key word must must required shall shall recommended may optional document interpreted described bcp type integer binary representation integer implementation must support least unsigned signed integer full precision float ieee double precision float implementation must support nonnan noninfinite nonsubnormal value described ieee spec implementation encode value tuple fixed length sequence value list dynamic length sequence value binary representation byte arbitrary length used store humanreadable string must encoded correct string map list keyvalue pair arbitrary order key must appear twice map encoding top level binary encoded data must start magic byte decimal value followed single byte tag value followed arbitrary length data tag data integer integer encoded different form value range aka byte data data unsigned byte representation value value range signed value data data signed representation integer bigendian encoding short arbitrary long signed integer n sign data n bigendian unsigned integer data represents littleendian encoded n byte long integer sign positive integer negative one long arbitrary long signed integer long n sign data n bigendian unsigned integer data represents littleendian encoded n byte long integer sign positive integer negative one float data data ieee double precision floatingpoint number encoded bigendian tuple tuples element arity data tuples element arity data arity bigendian unsigned integer declaring amount element data list byte list n data optimisation list contains value range inclusive general list arity data arity bigendian unsigned integer declaring amount element data empty list binary n data map arity data arity field unsigned integer bigendian format determines number keyvalue pair map key value pair ki vi encoded section data following order kn vn open question support atom allow defining improper list license document released creative common attributionsharealike international license
62,Lobsters,elixir,Elixir programming,systemd integration library for Erlang applications,https://github.com/hauleth/erlang-systemd,systemd integration library erlang application,systemd feature installation nonsystemd system usage log standard error datagram socket license license,systemd simple library notifying systemd process state feature notifysocket handled notify supervisor event happening application watchdog process started automatically enabled also handle sending keepalive message automatically file descriptor fetching environment journal logger handler formatters installation add rebarconfig case mix project mixexs defp deps systemd end call systemd notify ready application ready workaccept connection nonsystemd system application function within safe call even nonsystemd nonlinux os case systemd configuration option function simply work almost noops usage assuming myappservice unit like unit descriptionmy awesome app service userappuser groupappgroup allow using systemd informing system supervisor application status typenotify application need start foreground instead forking background otherwise may correctly detected system try start execstartpathtomyapp start enable watchdog process expect message given timeframe otherwise restart process defunct managed automatically systemd application case send message twice often equested force failure using systemd watchdog trigger manually ping systemd watchdog via systemd watchdog ping restartonfailure install wantedbymultiusertarget inform systemd state application call make systemctl start myappservice wait application running want restart application notify systemd systemd notify reloading message application shutting handled automatically simplification readiness notification systemd ready function return child spec temporary process used part supervision tree mark point application ready ex module myappsup behaviour supervisor export startlink opts supervisor startlink local module module opts init opts supflags strategy oneforone child myappdb childspec myappwebserver childspec systemd ready myappperiodicjob childspec ok supflags child log handle log possible option output data standard output error special prefix approach much simpler straightforward however support structured logging multiline message use datagram socket special communication protocol requires little bit effort set seamlessly support structured logging multiline message library support format one app decide use standard error systemdkmsgformatter format data using kmsglike level prefix used logger output standard output standard error attached journal default systemd library update handler use loggerstdh type standardio standarderror attached journal automatically detected via journalstream environment variable disable behaviour setting systemd autoformatter false custom logger use formatter adding new option parent formatter option used upstream formatter ex logger addhandler examplehandler loggerdisklogh formatter systemdkmsgformatter parent loggerformatter template msg config file varlogmyapplog datagram socket one requires systemd application started spawn process required handling socket best way handle add predefined systemd handler application start logger addhandlers systemd aware one guaranteed work nonsystemd system nt sure application ran systemdenabled o nt use logger solution application end logger attached handler used systemdkmsgformatter result pointless kmsglike prefix log message license see license
63,Lobsters,elixir,Elixir programming,"LambdaConf 2020 Call for Proposals: Scala, Haskell, Kotlin, Purescript, Rust, Elm, Elixir, F#",https://lambdaconf.zohobackstage.com/LambdaConf2020#/cfp?lang=en,lambdaconf call proposal scala haskell kotlin purescript rust elm elixir f,,
64,Lobsters,elixir,Elixir programming,Elixir 1.10 Release Candidate 0,https://github.com/elixir-lang/elixir/releases/tag/v1.10.0-rc.0,elixir release candidate,support erlangotp release improvement improvement sortbased apis enum tracking compiletime configuration compiler tracing enhancement enhancement elixir exunit iex logger mix bug fix eex elixir iex mix softdeprecations warning emitted elixir mix harddeprecations elixir logger mix checksum,support erlangotp elixir requires erlangotp allowing elixir integrate erlangotp new logger currently mean logger level logger metadata well log message shared erlang elixir apis continue improving relationship logging system future release particular plan expose log level runtime filtering functionality available erlang directly elixir next elixir version release also add two new guard thanks strict requirement erlangotp release improvement elixir introduced release mechanism package selfcontained application elixir improves release bug fix new enhancement based feedback got community highlight allow dual boot system release disabled environment boottime sensitive embedded device track raise compiletime configuration set change runtime next section support easily adding extra file release via overlay allow releasedistribution set none order fully disable add builtin tar step automatically package release see full changelog improvement improvement sortbased apis enum elixir always sort lowest highest want sort highest lowest need call custom sorting function enumsort collection immediately obvious someone reading code make matter worse comparison operator perform structural sorting instead semantic one example using sort date descendingly wo nt yield correct result therefore sort date recent oldest one write enumsort date datecompare lt elixir streamlines sorting function introducing asc desc shortcut enumsort collection asc default enumsort collection desc reverse furthermore want perform semantic comparison pas module provides relevant comparison function example sort date enumsort birthdates date enumsort birthdates asc date enumsort birthdates desc date new api also added enumsortby enumminby enummaxby friend tracking compiletime configuration application elixir come application environment environment keyvalue store allows u configure said application reading application environment runtime preferred approach rare occasion may want use application environment configure compilation certain project often done calling outside function defmodule myappdbclient dbhost applicationgetenv myapp dbhost dblocal def startlink somelibdbclientstartlink host dbhost end end approach one big limitation change value application environment code compiled value used runtime going change example using mix release configreleasesexs config myapp dbhost dbproduction new value effect code compiled connect dblocal mostly likely unavailable production environment reason reading application environment runtime first choice however really read application environment compilation elixir introduces function dbhost applicationcompileenv myapp dbhost dblocal using elixir store value used compilation compare compilation value runtime value whenever system start raising error case differ help developer ensure running production system configuration intend compiler tracing release brings enhancement elixir compiler add new capability developer listen compilation event previous elixir release elixir would compile database cross reference module function call reference structs etc project although developer could traverse database often requested event information made available elixir replaced database compiler tracing mean developer directly listen event emitted compiler store collect information need information need elixir already using new compiler tracing provide new functionality particular compiler check undefined function warning consistently previous version would emit undefined function warning file lib skipping test file script furthermore elixir developer disable undefined function warning directly callsite example imagine optional dependency may available case tell compiler skip warning call optional module compile nowarnundefined optionaldependency defdelegate myfunctioncall arg optionaldependency finally consequence improvement functionality related xref previous database deprecated favor new compiler tracing enhancement calendar data type got many improvement sigil support thirdparty calendar well addition datetimenow datetimeshiftzone many improvement related elixir ast release first two new option tokenmetadata literalencoder give control elixir parser information already available elixir formatter couple version made public furthermore public metadata entry ast node extensively documented change alongside compiler improvement previous section mean tool like credo boundary better foundation analyze source code finally exunit come two small important improvement exunitcaptureio used test run asynchronously added datastructure diffing performing assertion pattern matching whenever assertion assert field value expression fails exunit show lefthand righthand side highlighting part match red enhancement elixir application add applicationcompileenv reading value compilation time tracking accidentally change runtime calendar allow custom calendar representation calendar sigils calendar add c c c c callback calendar behaviour cli add support nocolor environment variable code add tokenmetadata literalencoder support code add compiler tracing lift event done compiler code return error unavailable module deadlock datetime add datetimenow datetimeshiftzone enum speed getting one random element enumerables enum add enum allow sorting function enumminmaxminbymaxby enum add ascdesc support exception add version alongside app name stacktraces function add kernel add kernel warn function head come immediately implementation instead implementation kernel warn duplicate key found struct declaration kernel print undefined function warning raise allows user see undefined call would otherwise require compile code multiple time keyword add keywordpop map add mappop mapset optimize multiple operation module add modulehasattribute module add compile nowarnundefined mfaormodule turn undefined function warning naivedatetime add record warn duplicate key found record declaration string update unicode stringio add encoding option stringio optimize getchars operation exunit exunitassertions support diffs pattern matching assertreceive exunitcaptureio support capturing named device asynchronous test iex iex warn circular file import loading default iexexs iex allow customization continuation prompt iex logger logger allow startoptions configured logger genevent logger integrate elixir logger erlangotp logger mean setting logger level elixir automatically change logger level erlang viceversa mix mix compile add profile time flag profile compilation step mix depscompile add skipumbrellaapps flag new flag compile umbrella apps useful building cache cdci pipeline mix depsunlock add checkunused flag new flag raise unused dependency lock file mix release allow releasedistribution set none mix release support overlay reloverlays mix release allow configuration reboot disabled release mix test add support simple roundrobin test partitioning across multiple machine mixproject add mixdepspath environment variable setting depspath mixproject add return deps scms mixtask add callback simplify compiler may need run something multiple step bug fix eex eex ensure multiline doend space compile trim mode elixir enum allow positive range slice infinite stream given kernel raise error functionsguards without implementation keyword ensure keyword replace update preserve order module raise instead silently failing performing write module operation aftercompile module fix macrocallback definition clause path fix correctly handle unc path window stream close correct accumulator called singleelement list stream allow double nested inside uri preserve slash uris without authority iex iex exit iex session group leader exit iex allow pry used nontty terminal mix mix compile filter warning external file diagnostics mixproject ensure user given manager dependency higher precedence scm one mixproject recompile umbrella child config file change mix compile called umbrella root mixtask always recompile running task dependency mixtask ensure project logger config used running mix task softdeprecations warning emitted elixir code deprecated favor mix mix xref deprecated favor compiler tracer mix xref xrefexclude option moved elixircoptionsnowarnundefined xref pas moved compiler harddeprecations elixir code deprecated favor code deprecated favor respectively code codeensurecompiled deprecated favor string deprecated favor ship part erlangotp supervisor deprecated favor new supervisor child specification supervisor simpleoneforone strategy supervisor deprecated favor dynamicsupervisor logger logger compiletimepurgelevel application environment configuration deprecated favor general compiletimepurgematching config logger deprecate logging nonchardata value mix mix compilexref check moved compiler effect mix xref deprecation check moved compiler effect mix xref unreachable check moved compiler effect checksum precompiledzip precompiledzip docszip docszip
65,Lobsters,elixir,Elixir programming,"I tried to win $1,000 recently",https://blog.neillyons.io/I-tried-to-win-1000-dollars-recently/,tried win recently,tried win recently people youtube push notification api post json youtube api insert comment register app google heroku performance dyno,tried win recently december needed one first ten comment youtube video wrote little program would post comment whenever video published hope faster anyone else idea anyone trying post comment manually plan nt quite fast enough actually five people total using program unfortunately none u even sure position comment came easy way check know top many comment saw clicked video guess actually top hundred dec video comment people idea bot like people posted comment manually program work receiving post request xml body contains new video id order get xml sent needed register endpoint youtube push notification api use video id post json youtube api insert comment use youtube api need register app google dance user get access token increase odds success hosted program u hope reducing latency server youtube push notification server sure helped nt know server located guess u youtube u company also rented fast server heroku performance dyno quite expensive rent per month knew exact time video published needed hour cost posting comment behalf several people wanted post comment normally use python everything project chose elixir better concurrency story think project would worked fine python asyncio elixir super easy efficient utilise core server ca nt efficiently python plus wanted learn elixir execute code parallel need pas asyncstream enumerable python land would iterable function taskasyncstream fn ioputs work cpu core end streamrun time would used erlang term storage ets cache user memory instead performing network request fetching postgres database reality nt think would made big difference outcome main culprit fact youtube push notification service nt instant definitly second delay video published push notification event first project elixir really impressed new comer language mix tool setup new project manage dependency fantastic looking forward building next project elixir
66,Lobsters,elixir,Elixir programming,A Redis like server for Cloud Native read intensive workloads in Elixir,https://github.com/coosto/redex,redis like server cloud native read intensive workload elixir,redex redex problem redex solve redis cluster redis sentinel redex replacement redis redex key feature mnesia nimbleparsec configuration recovering network partition benchmark dockercompose supported command license credit farhadi coosto coostodev,redex cloudnative strong consistent masterless high available redis implemented elixir redex redex attempt implement redis alternative cloudnative apps mind problem redex solve running application cloud easily scale app running multiple instance let assume application us redis cache frequently accessed resource us pubsub feature send event around happens scale application use redis sidecar container app scaling app standalone instance redis running difficult manage whenever invalidate cache entry probably want invalidate instance whenever publish event likely want event published instance might also want writes immediately available instance use atomic incrementsdecrements perform atomic operation across cluster easiest solution run single instance redis instance app communicate single redis instance lose fastaccess lowlatency benefit running redis sidecar container also single instance redis become bottleneck single point failure preventing scalability highavailability service might also think setting redis cluster drawback difficult setup need least master node work expected slave highavailability furthermore mainly designed partitioningsharding data set nt fit single instance writeintensive use case single instance handle writes case nt need partitioning need replication official solution replicated cluster redis node redis sentinel also downside need least sentinel instance robust deployment need sentinel support client need lot tweak scripting get work dynamic cluster environment like kubernetes guarantee acknowledged writes retained failure since redis us asynchronous replication redex came need simple redis solution used like single local redis instance able form replicated cluster scaled multiple instance use redex sidecar container appsmicroservices easily scale updown app without worrying data inconsistency node redex masterless client nt need know anything cluster topology interact local redex instance like single redis instance unlike redis write operation strong consistent across cluster redex replacement redis course redex solution use case need replicated redis cluster dynamic cluster environment like kubernetes without hassle official redis solution well suited readintensive use case within small cluster strong consistency requirement strong consistency make write operation gradually slower adding node hence redex suitable writeintensive use case cluster large number node redex support feature command redis provides suitable data set fit ram support partitioning data multiple node persisting data disk redex key feature us battletested mnesia inmemory database storage extremely fast redis protocol parser implemented nimbleparsec writes strong consistent across cluster read local fast comparable redis write performance comparable redis single node setup gradually degrades adding node support distributed publishsubscribe using erlang distributed process group support automatic cluster formationhealing using gossip protocol support automatic cluster formationhealing using kubernetes selector ease use app interacts redex like local singlenode redis instance case scaling updown data preserved far one node remains running automatic recovery netsplits quorum size configured prevent data inconsistency configuration redex configured using following env variable redexip node ip address node communicate default hostname used detect node ip address used discover redex pod using api formheal redex cluster redexgossipsecret secret used gossip strategy redexquorum minimum number node redex cluster obtain order become operational default redexport redex port number default recovering network partition setting proper quorum size enforce consistency netsplits case network partition partition containing least quorum size number node remain fully functional side become readonly connected readonly part update copying data side benchmark benchmark use redis official benchmark tool redisbenchmark first make sure dockercompose installed inside benchmark folder run following command dockercompose redex redis start single node redex redis use command run benchmark redis redex dockercompose run redisbenchmark dockercompose run redexbenchmark result machine redisbenchmark set request per second get request per second redexbenchmark set request per second get request per second let scale redex mutiple node run benchmark dockercompose scale redex dockercompose run redexbenchmark dockercompose scale redex dockercompose run redexbenchmark dockercompose scale redex dockercompose run redexbenchmark result machine redexbenchmark node set request per second get request per second redexbenchmark node set request per second get request per second redexbenchmark node set request per second get request per second course result would different run node different machine supported command small subset command supported get mget set setex mset getset incr incrby decr decrby del lpush lpop llen lrange lindex rpush rpop publish subscribe expire pexpire ttl pttl ping select key flushall without async argument info keyspace section quit license redex source code released apache license credit made farhadi supported coosto coostodev
67,Lobsters,elixir,Elixir programming,Awesome Concurrency with Elixir Tasks,https://www.slideshare.net/yonkeltron/awesome-concurrency-with-elixir-tasks,awesome concurrency elixir task,user agreement privacy policy privacy policy user agreement,slideshare us cooky improve functionality performance provide relevant advertising continue browsing site agree use cooky website see user agreement privacy policy slideshare us cooky improve functionality performance provide relevant advertising continue browsing site agree use cooky website see privacy policy user agreement detail
68,Lobsters,elixir,Elixir programming,A rapid admin generator for Elixir & Phoenix,https://github.com/mojotech/torch,rapid admin generator elixir phoenix,torch installation note install phoenix slime usage association filter filtrex http http example styling internationalization example,torch torch rapid admin generator phoenix apps creates custom template relies phoenix html generator hood installation install torch perform following step add torch list dependency mixexs run mix depsget def deps torch end add plugstatic plug endpointex plug plugstatic torch torch privstatic gzip true cachecontrolforetags public configure torch adding following configexs config torch otpapp myappname templateformat eex slime run mix torchinstall note also choose use slime template need first install phoenix slime update configuration specify templateformat slime ready start generating admin usage torch us phoenix generator hood torch injects custom template privstatic directory run mix phxgenhtml task option passed finally uninstalls custom template nt interfere running plain phoenix generator light fact torchgenhtml task take argument phxgenhtml extra configuration either end checkout mix help phxgenhtml detail supported option format example wanted generate blog post model could run following command mix torchgenhtml blog post post title string body text publishedat datetime published boolean view integer output would look like add resource browser scope libmyappwebrouterex resource post postcontroller ensure following added endpointex plug plugstatic torch torch privstatic gzip true cachecontrolforetags public header accesscontrolalloworigin fire torch generated html post fire torch also installed admin layout myappwebtemplateslayouttorchhtmleex want update include new navigation link nav class torchnav href post post nav may time adding torch already existing system application already contains module controller want use torch admin interface since torchgen mix task wrapper around existing phxgen task use flag add admin interface post previous example model controller module already exist use following command mix torchgenhtml blog post post noschema nocontext web admin title string body text publishedat datetime published boolean view integer association filter torch support association filter time filtrex yet support checkout two issue see latest update http http however mean ca nt roll example accountsuser model hasmany credential accountscredential want support filtering user credentialsemail update account domain accountsex defp dopaginateusers filter params credentialparams mapget params credential params mapdrop params credential user filtrexquery filter credentialfilters credentialparams orderby sort params paginate repo params pagination end defp credentialfilters query nil query defp credentialfilters query params searchstring params email u query join c assoc u credential like cemail searchstring groupby uid end update form filter usersindexhtmleex div class field label credential email label textinput credential email value maybe connparams credential email div note need install import maybe view maybe eex work styling torch generates two cs theme use basecss themecss base style basically bare bone theme style look like screenshot change stylesheet link torchhtmleex layout want use theme override color need include stylesheet specific override internationalization torch come po file en ru e locale using torch provide u translation file language please submit pull request translation file love add many translation possible wish add customized translation configure torch use custom messagesbackend adding torch configuration setting configexs find message customized default file customizing backend standard spoken language please submit back proper po translation file u include official torch release user take advantage example defmodule myappcustommessagesbackend def message contains custom contains def message equal custom equal def message prev def message next add fallback wo nt break newly added message message customize def message text text end configexs config torch otpapp myappname myappcustommessagesbackend templateformat eex slime
69,Lobsters,elixir,Elixir programming,How to Use Broadway in Your Elixir Application,https://blog.appsignal.com/2019/12/12/how-to-use-broadway-in-your-elixir-application.html,use broadway elixir application,broadway http openweathermaporg broadway use elixir app issue using genstage production additional supporting library official broadway producer support kafka embarrassingly parallel broadway work internally broadwayproducer module token bucket handson broadway http openweathermaporg http openweathermaporg summary alex koutmos p like read elixir alchemy post soon get press subscribe elixir alchemy newsletter never miss single post,today post covering elixir library named broadway library maintained kind folk plataformatec allows u create highly concurrent data processing pipeline relative ease overview broadway work use dive sample project leverage broadway fetch temperature data http openweathermaporg order find coldest city earth broadway pipeline loop list city world genstage producer write let jump right broadway use elixir app broadway allows u create highly concurrent data processing pipeline largely due built top genstage genstage another elixir library used construct eventmessage exchange process specifically genstage provides feature necessary create coordinated producer consumer process ensure event pipeline never flooded consumer subscribe upstream producer demand message free work model scale number consumer process needed task hand achieve performance desire issue using genstage production major problem using genstage directly productiongrade application onus developer create proper supervision tree ensure failure handled properly exactly broadway come play broadway provides necessary abstraction top genstage would leverage production context rate limiting batching ordering partitioning automatic restarts graceful shutdown automatic message acknowledgment additional supporting library addition aforementioned feature broadway also several supporting library allow use message queue service broadway producer maintained plataformatec community maintained time writing post official broadway producer available amazon sqs google pubsub rabbitmq support kafka currently underway release yet cut project benefit using broadway producer abstract away problem come along managing persistent valid connection data source provides convenient way using data source entry point data processing pipeline well good reach tool like broadway broadway useful tool task hand embarrassingly parallel spawning process yield positive result also useful etl extract transform load pipeline want break problem discrete component scale independently one example would processing user image uploads increasing number worker allow process image uploads disconnect image upload http requestresponse cycle leveraging queuing system like rabbitmq sqs etc broadway work internally previously mentioned broadway leverage genstage order orchestrate event pipeline look broadwayproducer module notice line use genstage top read module find implementation callback name defined genstage behavior magic broadway come play automatically creates supervision tree ensures pipeline faulttolerant reliable supervision tree world temperature application writing shortly let break supervision tree step step top tree project defined applicationex file turn focus worldtemptempprocessor broadway module creating worldtempcityproducer worldtemptemptracker supporting genservers supervision tree get worldtemptempprocessorbroadwaysupervisor supervisor responsible monitoring various component broadway restarting error occur process worldtemptempprocessorbroadwaysupervisor supervises listed along purpose worldtemptempprocessorbroadwayproducersupervisor supervisor responsible monitoring data producer process supervision tree strategy oneforone need restart particular data producer experiencing issue producer keep running everything okay worldtemptempprocessorbroadwayprocesssupervisor supervisor responsible monitoring worker process consume data producer supervision tree strategy oneforall reason oneforone processing callback function write stateless error occur handled without crashing process error occur crash process likely internal bookkeeping related broadway gone awry consumer need restarted worldtemptempprocessorbroadwayterminator process responsible proper stoppage broadway pipeline notify consumer process resubscribe producer terminate also notifies producer flush current event ignore subsequent data request worldtemptempprocessorratelimiter process optionally started pipeline requires rate limiter effectively token bucket rate limiter throttle much work processor perform within configurable time interval also important note worldtemptempprocessorbroadwaysupervisor supervision policy restforone reason producer supervision tree crash parent supervisor restart subsequent supervision tree restore pipeline back working fresh state handson broadway previously mentioned creating simple broadway based application read weather data api keep running record coldest city earth also using new feature broadway rate limiting ensure go free plan limit http openweathermaporg said let jump right start creating new project using mix new worldtemp sup want use sup flag convenience set root application supervision tree new project created want change project directory open mixexs file update dependency look like following use fork broadway pending issue rate limiter fixed fork deps httpoison jason broadway github plataformatecbroadway tag end fetch dependency run mix depsget project directory want create file libcityproducerex act data producer broadway pipeline purpose sample project data producer genstage based module use broadway producer better serf need kafka rabbitmq sqs etc libcityproducer file add following worldtempcityproducer use genstage require logger def startlink args genstagestartlink module name module end def init args producer citylist end demand greater state genstate process readd city list reprocess def handledemand demand state demand length state handledemand demand state citylist end enough data available genstage state serve consumer def handledemand demand state todispatch remaining enumsplit state demand noreply todispatch remaining end list city get weather data defp citylist abu dhabi united arab emirate abuja nigeria accra ghana adamstown pitcairn island addis ababa ethiopia algiers algeria alofi niue full content function go github project http githubcomakoutmosworldtemp end end next want create module fetch weather data openweathermap api want go http openweathermaporg create free account get api key go ahead create libtempfetcherex following content worldtemptempfetcher require logger apikey youapikeygoeshere def fetchdata city country city generateurl country httpoisonget handleresponse end defp handleresponse ok httpoisonresponse statuscode body body body jasondecode getin main temp end defp handleresponse resp loggerwarn failed fetch temperature data inspect resp error end defp generateurl city country http q city country appid apikey end end place need create broadway consumer module leverage http api wrapper create libtempprocessorex following content go shortly worldtemptempprocessor use broadway alias broadwaymessage def startlink opts broadwaystartlink module name module producer module worldtempcityproducer transformer module transform ratelimiting allowedmessages interval processor default concurrency end impl true def handlemessage default message context message messageupdatedata fn city country citydata city country worldtemptempfetcherfetchdata city country worldtemptemptrackerupdatecoldestcity citydata end end def transform event opts message data event acknowledger module ackid ackdata end def ack ackid successful failed ok end end function defines various option required broadway orchestrate data pipeline notice genstage producer previously created referenced producer keyword list section also defined rate limiter ensure go free tier usage openweathermap transformer entry invokes function bottom module required boilerplate format incoming message broadwaymessage struct important thing note specify concurrent processor recall supervision tree image earlier consumer process changing one value determine much concurrencythroughput would like broadway pipeline meat logic retrieve message citycountry tuple make api call update rolling record coldest city let create worldtemptemptracker module libtemptrackerex following content worldtemptemptracker use agent def startlink agentstartlink fn nil end name module end def getcoldestcity agentget module fn city country temp coldest city earth currently city country temperature kelvintoc temp end end def updatecoldestcity error nil def updatecoldestcity newtemp newdata agentupdate module fn origtemp origdata newtemp origtemp newdata else origdata nil newdata end end defp kelvintoc kelvin kelvin end module relatively straight forward agentbased module allows u retrieve current coldest city update provided value lower currently set value lastly need update libworldtempapplicationex file add couple item supervision tree named module applicationex file look like worldtempapplication moduledoc false use application alias worldtemp cityproducer tempprocessor temptracker def start type args child temptracker cityproducer tempprocessor opts strategy oneforone name worldtempsupervisor supervisorstartlink child opts end end place run iex mix command line able interact application worldtemptemptrackergetcoldestcity coldest city earth currently bern switzerland temperature iex worldtemptemptrackergetcoldestcity coldest city earth currently copenhagen denmark temperature iex worldtemptemptrackergetcoldestcity coldest city earth currently copenhagen denmark temperature iex worldtemptemptrackergetcoldestcity coldest city earth currently helsinki finland temperature iex worldtemptemptrackergetcoldestcity coldest city earth currently roseau dominica temperature calling worldtemptemptrackergetcoldestcity periodically see broadway processor work citycountry list city coldest temperature change may take minute run whole list given processing city minute list length element summary see sample application written relative ease able create data processing pipeline elixir application using broadway abstraction given u via broadway rest easy knowing pipeline operate intended recover issue arise addition lever necessary adjust performance characteristic pipeline via configuration thanks sticking end would like learn broadway suggest going following resource guest author alex koutmos senior software engineer writes backends elixir frontends vuejs deploys apps using kubernetes programming blogging wrenching datsun p like read elixir alchemy post soon get press subscribe elixir alchemy newsletter never miss single post
70,Lobsters,elixir,Elixir programming,ElixirConfLA 2019 - Erlang/OTP: What is in the box? by João Britto,https://www.youtube.com/watch?v=WXqbOBH9xjg,elixirconfla erlangotp box joão britto,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature elixirconfla erlangotp box britto youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature elixirconfla erlangotp box britto youtube
71,Lobsters,elixir,Elixir programming,Survey of Cowboy Webserver Performance - Part 2,https://stressgrid.com/blog/cowboy_performance_part_2/,survey cowboy webserver performance part,part cowboy ranch fast stream handler fast stream pull request conclusion discussion lobster,article follow part survey cowboy webserver performance part surprise observed version le performant article analyze root cause performance degradation cowboy also point solution show effect test result decided start analysis looking erlang vm supervision tree dummy web application see supervision tree reflecting request handled made handler sleep several minute started request curl cowboy quickly identified ranch connection supervisor pid connection process serving request pid running elixir processsleep next experiment cowboy see ranch connection supervisor pid connection process pid another process pid spawned connection process running processsleep additional process undoubtedly introduce overhead passing request response process cowboy primary goal cowboy redesign cowboy introduce support http http possible handle multiple requestresponse interaction single tcp connection also possible overlap interaction word client may submit request without waiting response http achieves defining concept stream multiple stream multiplexed single tcp connection within stream request frame must followed response frame make logically corresponding single http connection cowboy defines straightforward interface programmer write applicationlevel http handler ranch responsible creating process handle tcp connection process responsible receiving parsing request calling application handler building writing response application handler expressed single function essence get request parameter return response since nothing else happen tcp connection call done synchronously http cowboy simple design work anymore process responsible handling tcp connection blocked waiting application handler respond since able process request response concurrently two possible way solving one change programmer interface require asynchronous handling another introduce one process dedicated handling stream interaction keep interface simple mostly compatible cowboy cowboy box keep handler interface simple cost introducing stream process also provides ability programmer write stream handler replaces default stream handler corresponding complexity handle multiple stream asynchronously downside http http share design therefore incur overhead even need http fast stream handler validate performance theory implemented version dummy web application replaces default cowboy stream fast stream handle request directly inside tcp connection like cowboy note fast stream implementation hack used beyond experimentation approach work nicely http server may affect scalability multiple http stream handler blocking test result confirming theory show cowboy performance comparable cowboy using process architecture reached response per second cowboy slightly faster active n another potential optimization using active n tcptls socket option note tl option available since otp otp active mode mean process attached socket receive data message instead proactively calling recv function cowboy traditionally us active sends single message reset back passive mode pull request us active n instead sends n message resetting passive mode n currently set change reduces number call otp port driver giving finegrained flow control test result showing improvement fast stream handler combined active n change cowboy reach response per second active n change alone improves response per second conclusion main finding http design cowboy add significant overhead even used http way work around implementing custom stream handler process request directly tcp connection process without spawning dedicated stream process approach cowboy performance comparable cowboy approach combined active n socket option cowboy achieves significant performance improvement cowboy discussion lobster
72,Lobsters,elixir,Elixir programming,Elixir Module and Struct Interoperability for Erlang,http://marianoguerra.org/posts/rfc-elixir-module-and-struct-interoperability-for-erlang.html,elixir module struct interoperability erlang,warianoguerra http githubcommarianoguerraexat http hexpmpackagesexat exatexample erlang friendly elixir module name alias long elixir module name creating structs alias structs pattern matching structs note static compilation literal structs use build run syntax bikesheding,rfc shape project actually use interested feedback find marianoguerra erlang elixir slack warianoguerra twitter project github http githubcommarianoguerraexat hexpm http hexpmpackagesexat see exatexample project simple usage example description project write erlang friendly module name get translated right elixir module name automatically project parse transform also escript easily debug transformation done correctly erlang friendly elixir module name call like ex abc myfun translated automatically elixirabc myfun build time using parse transform trick symbol allowed atom first character thank node name use ex prefix identify module must translate since one us prefix module erlang alias long elixir module name since elixir module name tend nest long define alias use code save typing example following alias declaration ex alias ex baz ex foobarbaz bare ex foolong translate ex bar foo ex foobarbaz foo turn become elixirfoobarbaz foo also translate module name bare foo ex foolong foo turn become elixirfoolong foo creating structs code ex learnuser mapvar becomes elixirlearnuser struct mapvar code ex learnuser name bob age becomes elixirlearnuser struct name bob age elixir would learnuser name bob age alias structs following alias declaration ex alias ex structalias ex learnuser expand ex structalias name bob age elixirlearnuser struct name bob age pattern matching structs function call allowed pattern match position example functioncaseetc clause left side different syntax getname ex structalias name name name getname ex structalias error noname becomes getname struct elixirlearnuser name name name getname struct elixirlearnuser error noname ex structalias name ex learnuser name bob age becomes struct elixirlearnuser name elixirlearnuser struct name bob age pattern match map also key note static compilation literal structs elixir pas field struct compiled map place since compiler know field default compile time exat us slower version merges default provided field using elixirenum reduce future try get default compile time struct compiled already beam file compiled current file use add rebarconfig dep parse transform erlopts parsetransform exat deps exat build build escript escriptize run run escript builddefaultbinexat pp erlast pathtomoduleerl example exat repo builddefaultbinexat pp erl builddefaultbinexat pp ast syntax bikesheding syntax chose balance need produce compilerlinter error warning objective avoiding accidentally translating something nt translated please let know think famous last word
73,Lobsters,elixir,Elixir programming,Survey of Cowboy Webserver Performance,https://stressgrid.com/blog/cowboy_performance/,survey cowboy webserver performance,cowboy cowlib ranch gun stressgrid first second third cowboy version otp version conclusion part discussion lobster,cowboy small modular webserver written erlang heart elixir phoenix web application framework well many project erlang elixir ecosystem cowboy evolved year version released latest version important note change significant required change user code cowboy composed two main component cowlib ranch cowlib generic parser builder http based protocol ranch socket acceptor pool stand directly top tcpip tl functionality exposed erlang otp cowlib sufficiently abstract shared library http server client gun ranch may underpin server implementing protocol top tl tcpip article benchmark performance cowboy release case use ranch cowlib linked release default benchmark default ranch separately newest ranch simulate generic web application client server behavior devised following synthetic workload client device open connection sends request millisecond one server handle request sleeping millisecond simulate backend database request return kb payload without additional delay result average connection lifetime second average load request per second per device following stressgrid script represents client side workload enumeach fn get delay end serverside three separate implementation first cowboy second cowboy third cowboy higher benchmark tested aws instance vcpus gib ram used ubuntu kernel following sysctld override fsfilemax netcoresomaxconn minute test load linearly increased device correspond request per second specifically selected maximum load outside capacity observe saturation point version cowboy cowboy version first series test used erlang otp graph show response rate observed client word completed request per second big difference version version surprising leader peaked request per second stayed ranch version significant effect performance percentile connection response latency tell similar story significantly outperforming otp version second series test decided use cowboy vary three otp version otp combined cowboy show best performance peaking almost request per second otp close second cowboy difference otp otp le significant version cowboy otp performance lowest conclusion surprising conclusion survey combination cowboy relatively old otp demonstrated best performance another surprise significant difference various version cowboy well ranch update part analyze root cause performance degradation cowboy also point solution show effect test result discussion lobster
74,Lobsters,elixir,Elixir programming,Riak Core on Partisan on Elixir Tutorial: Migrating Data with Handoff,http://marianoguerra.org/posts/riak-core-on-partisan-on-elixir-tutorial-handoff.html,riak core partisan elixir tutorial migrating data handoff,riak core partisan elixir tutorial make key value store,previous post riak core partisan elixir tutorial make key value store going implement handoff completing remaining callback vnode node dy another take work add new node vnodes must rebalanced need handle handoff reason start handoff ring update event ring node already seen secondary vnode idle period time primary original owner partition happen riakcore inform vnode handoff starting calling handoffstarting return false cancelled return true call isempty must return false inform vnode something handoff empty true inform vnode empty case ask first element ets table special value endoftable know empty return true handoff considered finished false call done handlehandoffcommand macro defined riakcorevnodehrl header file include using record module function must iterate key store call foldfun key first argument value second argument latest accin value third result function call new accin must pas next call foldfun last accumulator value accfinal must returned handlehandoffcommand call foldfun k v accin riakcore send new vnode must encode data sending calling encodehandoffitem k v must encode data sending value received new vnode must decode something done function handlehandoffdata decode received data appropriate thing sent keyvalues handofffinished called delete cleanup data old vnode decide handle command sent vnode handoff running choose one following handle current vnode forward vnode handing drop depends design app tradeoff diagram flow true false starting isempty foldreq false true ok v v cancelled finished delete replace content libcivilevnodeex defmodule civilevnode require logger behaviour riakcorevnode require record recorddefrecord recordextract fromlib riakcoreincluderiakcorevnodehrl def startvnode partition riakcorevnodemastergetvnodepid partition module end def init partition tablename erlanglisttoatom civile erlangintegertolist partition tableid etsnew tablename set writeconcurrency false readconcurrency false state partition partition tablename tablename tableid tableid ok state end def handlecommand ping v sender state partition partition reply pong v node partition state end def handlecommand put k v sender state tableid tableid partition partition etsinsert tableid k v re ok node partition nil reply re state end def handlecommand get k sender state tableid tableid partition partition re case etslookup tableid k ok node partition nil value ok node partition value end reply re state end def handoffstarting dest state partition partition loggerdebug handoffstarting partition true state end def handoffcancelled state partition partition loggerdebug handoffcancelled partition ok state end def handofffinished dest state partition partition loggerdebug handofffinished partition ok state end def handlehandoffcommand foldreq sender state tableid tableid partition partition loggerdebug handoff partition foldfun foldreq foldfun foldreq accfinal etsfoldl fn k v accin loggerdebug handoff partition k v foldfun k v accin end tableid reply accfinal state end def handlehandoffcommand request sender state partition partition loggerdebug handoff generic request ignoring partition noreply state end def isempty state tableid tableid partition partition isempty etsfirst tableid endoftable loggerdebug isempty partition isempty isempty state end def terminate reason partition partition loggerdebug terminate partition reason ok end def delete state tableid tableid partition partition loggerdebug delete partition true etsdelete tableid ok state end def handlehandoffdata bindata state tableid tableid partition partition k v erlangbinarytoterm bindata etsinsert tableid k v loggerdebug handlehandoffdata partition k v reply ok state end def encodehandoffitem k v loggerdebug encodehandoffitem k v erlangtermtobinary k v end def handlecoverage req keyspaces sender state stop notimplemented state end def handleexit pid reason state noreply state end def handleoverloadcommand ok end def handleoverloadinfo idx ok end end stop node running let clean data node ring state join time want try handoff make simpler run command remember put file called makefile root project make sure indented line indented tab space startsingle iex name dev mix run iex name mix run iex name mix run iex name mix run clean rm rf data log ringdatadir setup mix depsget project stage available tag let clean date start scratch make clean new terminal make inside iex run listsseq civileserviceput k end insert since running single node go vnodes new terminal make inside iex run listsseq civileserviceput k end insert since nt joined go vnodes new terminal make inside iex run listsseq civileserviceput k end insert since nt joined go vnodes let join form cluster run riakcorejoin see handoff transfering vnodes data node stopping vnodes old node finish transfering data removing periodically check status ok ring riakcoreringmanagergetmyring riakcoreringprettyprint ring legend
75,Lobsters,elixir,Elixir programming,Modeling Systems with TLA+,https://www.youtube.com/watch?v=efCKA-Ug8w4,modeling system tla,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature gig city elixir speaker talk ben marx youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature gig city elixir speaker talk ben marx youtube
76,Lobsters,elixir,Elixir programming,A More Type-Driven Elixir Workflow? Maybe,https://well-ironed.com/articles/a-more-type-driven-elixir-workflow-maybe/,typedriven elixir workflow maybe,option type motivating example problem dialyzer dialyxir bad initialization dialyzer success typing good initialization dialyzer dynamic initialization dialyzer ever fail typechecking ever pas typechecking bad initialization never pas type check possible execution code function ever return successfully good initialization always pas type check case ever return successfully dynamic initialization sometimes pas type check could case ever return successfully back basic let get type right maybe type functional elixir optional bad initialization dialyzer good initialization incompatible api dialyzer explicitly handle maybe type good initialization compatible api dialyzer bad initialization compatible api dialyzer dynamic initialization runtime dialyzer pushing runtime dynamic initialization wrong type dialyzer maybetyped dialyzer help u land evil type dialyzer smart constructor ignoring option typing option maybe functional elixir,typedriven functional style writing elixir possible require macro language extension simply take advantage typesystem tooling already available elixir beam ecosystem process introduce small library put together capture pattern first installment series option type motivating example problem let say data structure representing customer contact information require every customer provide address allow customer also optionally supply phone number sake brevity represent address number string also phoneservice take datastructure responsible placing call customer phone number maybe requirement clear junior developer working feature problem one main benefit type system catch error code thinking let try put together data structure service pretend make mistake along way see dialyzer via dialyxir help u diagnose mistake maybe definition contactinformation defmodule contactinformation defstruct address phonenumber type module address stringt phonenumber stringt nil end see expressed optionality phonenumber typing stringt nil phoneservice defmodule phoneservice spec call contactinformationt integer def call contact url http examplecomcall contactphonenumber ok status post url status end defp post url isbinary url external call happens ok end end ok let try see various way get wrong bad initialization dialyzer let try wrongest thing think junior developer come writes following code defmodule example def badinitialization mycontactinformation contactinformation phoneservicecall mycontactinformation end end running mix dialyzer codebase get following piece advice reported line number different function local return call elixirphoneservice call contactinformation struct elixircontactinformation address nil phonenumber nil never return since success typing atom phonenumber binary contract elixircontactinformation integer dialyzer report two issue really show problem two angle first issue function local return mean way function finish execution throwing kind exception case second issue answer say call elixirphoneservice call never return since success typing atom phonenumber binary contract elixircontactinformation integer essentially dialyzer determined success typing call expects parameter either atom contactphonenumber valid modulefunction syntax irrelevant problem map key phonenumber holding binary value code call call struct nil phonenumber compatible success typing additionally dialyzer tell u contract specified equivalent parameter passed dialyzer right call never return let run code see eye iex mix interactive elixir press ctrlc exit type h enter help iex examplesbadinitialization argumenterror argument error erlangbytesize nil example iex erlangbytesize called part binary concatenation nil valid value concatenated fair enough one point dialyzer one point junior developer good judgment even run dialyzer good initialization dialyzer first error warmup junior developer simply making sure dialyzer actually hooked working codebase let write proper code make sure clear typecheck def fullinitialization contactinformation contactinformation address road city country phonenumber phoneservicecall contactinformation end running mix dialyzer give u done done passed successfully great look like legitimate code dialyzer agrees another point developer dialyzer dynamic initialization dialyzer till using literal value making thing easy dialyzer soon discover literal value dialyzer forte runtime dynamism weak spot watch junior developer step game propertybased testing spec phoneno stringt nil defp phonenoornil case randuniform x x nil end end def runtimedynamicinitialization contactinformation contactinformation address road city country phonenumber phonenoornil phoneservicecall contactinformation end dialyzer say done passed successfully intuition tell u code crash initialize contactinformation nil phone number let run shell see iex examplesruntimedynamicinitialization iex examplesruntimedynamicinitialization argumenterror argument error erlangbytesize nil example go dialyzer tell u code could fail short answer dialyzer check code ever fail typechecking dialyzer check code ever pas typechecking hence name success typing let take apart example see logic action bad initialization never pas type check mycontactinformation contactinformation phoneservicecall mycontactinformation line initialize struct nil phonenumber field default behavior elixir dialyzer know variable mycontactinformation ever typed phonenumber nil say possible execution code result different type assigned mycontactinformation dialyzer proceeds check phoneservicecall expects map field phonenumber binary see possible execution code would result phoneservicecall returning successfully say confidence function ever return successfully good initialization always pas type check situation next example similarly straightforward dialyzer let take look code contactinformation contactinformation address road city country phonenumber phoneservicecall contactinformation bad example unambiguously illtyped example unambiguously welltyped dialyzer based binary literal line know sure argument passed phoneservicecall map field phonenumber binary based information dialyzer say confidence case function ever return successfully please note distinction dialyzer verdict case simple negation previous verdict dialyzer making claim argument phoneservicecall line always typecheck although example clear case simply saying possible execution code typechecks dynamic initialization sometimes pas type check see dialyzer failed warn u possible nil field type dynamic example probably guess reason based two example runtime phonenumber field could optionally take binary value nil dialyzer could find possible execution code would result successful return phoneservicecall execution phonenumber passed binary datum term previous example dialyzer verdict dynamic code identical good code case function ever return successfully mean dialyzer useless optional value created runtime maybe make work u back basic let get type right let consider mean say contactinformation struct phonenumber mean want able create contactinformation instance without phone number later crash number missing obviously say mean completely legal contactinformation number completely legal contactinformation number instead hiding fact behind stringt nil type let make decision explicit prominent defmodule contactinformationmaybe alias femaybe defstruct address phonenumber type module address stringt phonenumber maybet stringt end used maybe type functional elixir library type definition brutally simple defmodule femaybe type nothing end instead saying value typed nil say value either tuple atom nothing way make impossible ignore fact presence value optional armed type let see dialyzer treat potential mistake make bad initialization dialyzer def badinitialization contactinformation contactinformationmaybe phoneservicecall contactinformation end dialyzer catch error saying struct contains nil special gain made comparison previous data structure let continue good initialization incompatible api dialyzer def goodinitializationoldapi alias femaybe contactinformation contactinformationmaybe address road city country phonenumber maybejust phoneservicecall contactinformation end exposed first benefit using maybe type dialyzer like code although contactinformationmaybe struct welltyped error message function local return call elixirphoneservice call contactinformation struct elixircontactinformationmaybe address phonenumber never return since success typing atom phonenumber binary contract elixircontactinformation integer dialyzer noticed argument passing phoneservicecall field typed phonenumber success typing requires field binary good dialyzer shown u need explicitly handle maybe type wherever want use optional content let adapt phoneservice unpack maybe value defmodule phoneservicemaybe alias femaybe spec call contactinformationmaybet integer def call contact case contactphonenumber number url http examplecomcall number ok status post url status nothing end end defp post url isbinary url external call happens ok end end see simply access contactphonenumber run value actually write code handle two possible case typing allows forced refactoring api one largest benefit using option type even dynamicallytyped language like elixir assistance tooling able make code bit accidentproof selfdocumenting boot good initialization compatible api dialyzer dialyzer forced u handle maybe value callsite let create proper structure make sure typechecks def goodinitializationnewapi alias femaybe contactinformationwithnumber contactinformationmaybe address road city country phonenumber maybejust phoneservicemaybecall contactinformationwithnumber contactinformationwithoutnumber contactinformationmaybe address road city country phonenumber maybenothing phoneservicemaybecall contactinformationwithoutnumber end expected desired dialyzer happy code case nothing case bad initialization compatible api dialyzer modified downstream code explicitly work maybe type let see happens accidentally pas plain binary def badinitializationnewapi alias femaybe contactinformationwithnumber contactinformationmaybe address road city country phonenumber wrong phoneservicemaybecall contactinformationwithnumber end dialyzer tell u expected way call succeed since function expects phonenumber nothing binary provided binary function local return call elixirphoneservicemaybe call contactinformationwithnumber struct elixircontactinformationmaybe address phonenumber never return since success typing atom phonenumber nothing binary ok contract elixircontactinformationmaybe integer great let try supplying either binary nothing runtime expect dialyzer happy code also expect code crash u dynamic initialization runtime dialyzer first helper function generate dynamic value spec maybephoneno maybet stringt defp maybephoneno case randuniform x x maybejust maybenothing end end example code def dynamicinitialization contactinformation contactinformationmaybe address road city country phonenumber maybephoneno phoneservicemaybecall contactinformation end iex examplesdynamicinitialization iex examplesdynamicinitialization iex examplesdynamicinitialization iex examplesdynamicinitialization indeed code typecheck properly handle value want legitimately handle pushing runtime dynamic initialization wrong type dialyzer internalized dialyzer approach correctness described first half post undoubtedly thinking well ok generate value runtime maybetyped bump limit dialyzer previous example dialyzer determine possible code welltyped runtime let thing slide let see limit first let try instantiate data structure phone number maybe type def dynamicilltypedinitialization phone randuniform nil contactinformation contactinformationmaybe address road city country phonenumber phone phoneservicemaybecall contactinformation end fly dialyzer typing mismatch phonenumber false nil v phonenumber nothing binary see using maybe type allows dialyzer catch egregious case supply value completely different type real life sufficient catch tripups likely make writing code however possible contrive value break contract without dialyzer complaining dialyzer help u land evil type dialyzer code make dialyzer happy u weeping sadness def dynamiceviltypedinitialization phone randuniform maybejust nil contactinformation contactinformationmaybe address road city country phonenumber phone phoneservicemaybecall contactinformation end unfortunately pass dialyzer typecheck fails runtime iex mix iex examplesdynamiceviltypedinitialization caseclauseerror case clause matching nil example iex examplesdynamiceviltypedinitialization iex let take look line key possible type phone assume meanwhile phoneservicemaybecall expects phonenumber one two binary nothing hopefully see going possible execution input typed way call phoneservicemaybecall succeeds dialyzer put stamp approval code move given way success typing work erlang ecosystem much pathological case like fortunately diligence evil typing like one example avoided recommend getting habit using smart constructor everywhere output function always go type funnel case generating random phone number would mean always using return valid value return valid nonvalue similarly initialize structs conform type specification treat struct constructor private function write smart constructor mymodulenew ensure field struct welltyped even caveat place feel consistent use option typing codebase well worth let recap ignoring option typing option think using maybe type explicitly encode optionality value brings enormous maintainability benefit spec provide documentation help clarify intent using tagged tuples v anil type help dialyzer catch error apis access optionallytyped value must explicitly handle presence absence value question developed maybe library based reallife experience optional typing erlang elixir project besides providing type definition constructor includes bunch function help building fluent code handle optionality gracefully succinctly like start using maybe code one mix depsget away grab functional elixir hexpm embrace optionality def deps fe end see next time continue tour functional elixir
77,Lobsters,elixir,Elixir programming,Riak Core on Partisan on Elixir: We can make a Key Value Store out of that,http://marianoguerra.org/posts/riak-core-on-partisan-on-elixir-tutorial-we-can-make-a-key-value-store-out-of-that.html,riak core partisan elixir make key value store,riak core partisan elixir tutorial getting started dynamo architecture ets,previous post riak core partisan elixir tutorial getting started foundation service laid let make something useful given riakcore implementation dynamo architecture created build scalable key value store follow path build one let start end imagine code ready would interaction let imagine like first ask service get value key nt exist yet iex dev civileserviceget ok dev nil get tuple response item status ok request handled correctly node dev node handled request partition id partition handled request result nil operation result nil since key value yet let set iex dev civileserviceput ok dev nil get tuple response item status ok request handled correctly node dev node handled request partition id partition handled request result nil nothing interest result use item tuple keep shape get let get iex dev civileserviceget ok dev get result let try another key iex dev civileserviceget ok dev nil response notice partition changed see later let set hello iex dev civileserviceput hello ok dev nil get iex dev civileserviceget ok dev hello let build first let create api libcivileserviceex defmodule civileservice def ping v sendcmd ping v ping v end def put k v sendcmd k put k v end def get k sendcmd k get k end defp sendcmd k cmd idx riakcoreutilchashkey civile k preflist riakcoreaplgetprimaryapl idx civileservice indexnode type preflist riakcorevnodemastersynccommand indexnode cmd civilevnodemaster end end module refactored reuse hashing logic common function called use passing value used hash first argument command send vnode second argument vnode side going use ets storage key value store need initialize function def init partition tablename erlanglisttoatom civile erlangintegertolist partition tableid etsnew tablename set writeconcurrency false readconcurrency false state partition partition tablename tablename tableid tableid ok state end create table name unique app partition create new ets table read write concurrency set false since vnode reading writing let handle put command def handlecommand put k v sender state tableid tableid partition partition etsinsert tableid k v re ok node partition nil reply re state end code extracting value need state run useful line etsinsert tableid k v building response return get command def handlecommand get k sender state tableid tableid partition partition re case etslookup tableid k ok node partition nil value ok node partition value end reply re state end call handle case value one available project stage available tag see code correct compiling project mix compile start one node try command top chapter let first clean current state start fresh rm rf data data ringdatadir let run node setting right profile mixenv running command iex name mix run iex name mix run iex name mix run console run following join node riakcorejoin let check ring status settle since migrating data vnode migration yet ok ring riakcoreringmanagergetmyring riakcoreringprettyprint ring legend iex civileserviceget ok nil iex civileserviceput ok nil iex civileserviceget ok see request handled partition since used key request used decide vnodepartion would handle
78,Lobsters,elixir,Elixir programming,Riak Core on Partisan on Elixir Tutorial: Getting Started,http://marianoguerra.org/posts/riak-core-on-partisan-on-elixir-tutorial-getting-started.html,riak core partisan elixir tutorial getting started,riak core partisan elixir tutorial introduction riak core partisan elixir tutorial setup creating project add uniendo dependency add application configuration first build making start implementing vnode playing clustering machine configdevexs,previous post riak core partisan elixir tutorial introduction riak core partisan elixir tutorial setup creating project mix new civiledb app civile cd civiledb project stage available tag add uniendo dependency uniendo library contains required dependency override single place make easy use project add deps section mixexs like defp deps uniendo git git githubcommarianoguerrauniendogit branch master end project stage available tag add application configuration need add riakcore list application start start supervisor tree modify application section mixexs like def application extraapplications riakcore logger mod civile end project stage available tag first build let try building project mainly test dependency compiled correctly first need get dependency mix depsget first time may ask could find hex needed build dependency folsom shall install hex running noninteractively use mix localhex force yn hit enter continue finish try build project mix compile project stage available tag first time build project dependency written erlang may ask shall install running noninteractively use mix localrebar force yn hit enter continue get error compiling may want try updating version mix us mix localrebar setup fails build try commenting line depssetuprebarconfig posthooks compile make escriptize like posthooks compile make escriptize making start need start application riakcore need initial setup mkdir priv config cp depsriakcoreprivriakcoreschema priv project stage available tag add following content file configconfigexs use mixconfig config riakcore ringstatedir ringdatadir handoffport handoffip schemadirs priv config sasl errlogtype error project stage available tag edit libcivileex change content defmodule civile use application require logger def start type args case civilesupervisorstartlink ok pid ok pid error reason loggererror unable start civile supervisor inspect reason end end end create new file called libcivilesupervisorex following content defmodule civilesupervisor use supervisor def startlink riakcore appends sup application name supervisorstartlink module name civilesup end def init args child supervise child strategy oneforone maxrestarts maxseconds end end project stage available tag recompile project mix compile start iex name dev mix run see something like erlangotp source hipe info starting reporter info using node name dev info resolving info resolved dev info resolved info partisan listening listenaddrs ip port info using container orchestration disabling info node dev choosing random seed info node dev choosing random seed info configuring partisan dispatch false dets file dataclustermetamanifestdets properly closed repairing info new capability riakcore vnoderouting proxy info new capability riakcore stagedjoins true info new capability riakcore resizablering true info new capability riakcore foldreqversion info new capability riakcore security true info new capability riakcore buckettypes true info new capability riakcore netticktime true interactive elixir press ctrlc exit type h enter help iex dev may get lager crash log startup ignore hit ctrlc twice quit implementing vnode write following new file called libcivilevnodeex defmodule civilevnode behaviour riakcorevnode def startvnode partition riakcorevnodemastergetvnodepid partition module end def init partition ok partition partition end def handlecommand ping v sender state partition partition reply pong v node partition state end def handoffstarting dest state true state end def handoffcancelled state ok state end def handofffinished dest state ok state end def handlehandoffcommand foldreq sender state noreply state end def isempty state true state end def terminate reason state ok end def delete state ok state end def handlehandoffdata bindata state reply ok state end def encodehandoffitem k v end def handlecoverage req keyspaces sender state stop notimplemented state end def handleexit pid reason state noreply state end def handleoverloadcommand ok end def handleoverloadinfo idx ok end end write following new file called libcivileserviceex defmodule civileservice def ping idx riakcoreutilchashkey civile ping v preflist riakcoreaplgetprimaryapl idx civileservice indexnode type preflist riakcorevnodemastersynccommand indexnode ping v civilevnodemaster end end libcivilesupervisorex add vnode master child supervisor change def init args child supervise child strategy oneforone maxrestarts maxseconds end def init args child worker riakcorevnodemaster civilevnode id civilevnodemasterworker supervise child strategy oneforone maxrestarts maxseconds end register vnode implementation riakcore libcivileex change def start type args case civilesupervisorstartlink ok pid ok pid error reason loggererror unable start civile supervisor inspect reason end end def start type args case civilesupervisorstartlink ok pid ok riakcoreregister vnodemodule civilevnode ok riakcorenodewatcherserviceup civileservice self ok pid error reason loggererror unable start civile supervisor inspect reason end end project stage available tag compile run mix compile iex name dev mix run inside shell try new service iex dev civileserviceping pong dev iex dev civileserviceping pong dev response tuple contains atom pong number passed default incremented one node partition handled reply right one node useful next step make sense playing clustering machine build cluster machine need make build slightly different configuration avoid running node reading another node file trying use another node port create different configs make different build first add line end configconfigexs importconfig mixenv ex import configuration given mix environment create following file use mixconfig config riakcore node webport handoffport ringstatedir platformdatadir use mixconfig config riakcore node webport handoffport ringstatedir platformdatadir use mixconfig config riakcore node webport handoffport ringstatedir platformdatadir since default environment dev need file one without config since one configexs ok configdevexs use mixconfig project stage available tag let run node setting right profile mixenv running command iex name mix run iex name mix run iex name mix run console run following join node riakcorejoin let check ring status ok ring riakcoreringmanagergetmyring riakcoreringprettyprint ring legend take ring rebalances run two line periodically settle run ping node work civileserviceping given number pas used decide target vnode mean call number end node node work transparently running node cluster rebalanced around got iex civileserviceping pong iex civileserviceping pong iex civileserviceping pong mean value handled node vnode matter function called
79,Lobsters,elixir,Elixir programming,Kubernetes and the Erlang VM: orchestration on the large and the small,http://blog.plataformatec.com.br/2019/10/kubernetes-and-the-erlang-vm-orchestration-on-the-large-and-the-small/,kubernetes erlang vm orchestration large small,selfhealing service discovery distributed erlang libcluster make phoenix breeze build distributed webrealtime system automated rollouts v hot code swapping use hot code swapping smarter client migrate client connection node deploying configuration management configuration provider unified api configuring application configuration provider officially made part elixir language version stay alert pod resource reducing busy waiting summing erlang april,look feature listed kubernetes compare language run erlang vm erlang elixir impression share many keywords selfhealing horizontal scaling distribution etc sharing often lead confusion provide distinct behavior overlap instance purpose elixir fault tolerance kubernetes also provides selfhealing article go many topic show mostly complementary discus rare case overlap selfhealing kubernetes automatically restarts replaces container fail also kill container respond userdefined health check similarly erlang elixir structure code help supervisor automatically restart part application case failure kubernetes provides faulttolerance within cluster erlangelixir provide within application understand better let take application talk database external system language handle keeping pool database connection database go offline bad configuration hardware failure database erlangelixir system respond negatively health check would cause kubernetes act potentially relocate nodewide failure kubernetes got back however happens part connection database sporadically failing example imagine system load suddenly started running connection limit mysql prepared statement limit failure likely cause health check fail code fail whenever one many connection reach said limit reason error today application confidently say faulty connection dropped another connection started place faulty one comfortably say error cascade application bringing remaining connection pool erlangelixir abstraction fault tolerance allow reason question language level provides mechanism reason connection resource inmemory state background worker etc explicitly say started shut happen thing go wrong feature also extremely helpful face partial failure example imagine news website live stock ticker website continue running potentially serving stale data everything crash mental model provided erlangelixir allows u reason scenario course always let failure bubble retries even immediately becomes nodewide failure handled nutshell kubernetes container provide isolation ability restart individual node fail replacement isolation fault handling within software regardless language choice using erlangelixir allow apply similar selfhealing faulttolerance principle large cluster small languageinstance service discovery distributed erlang erlang vm also provides distributed erlang allows exchange message different instance running different machine elixir easy node nodelist send node myprocess helloworld end running distributed mode requirement way need explicitly enable erlang vm automatically serialize deserialize data well make sure connection node alive provide node discovery programmer responsibility say exactly node located connect node together luckily kubernetes provides service discovery box mean allows u fully automate node discovery would otherwise manual error prone library like libcluster exactly rolling complicated either another great example kubernetes erlang vm complement however may still wondering benefit running distributed erlang kubernetes service discovery make relatively easy system communicating especially considering rpc protocol thrift grpc others talking different language different system communicating picking one existing rpc mechanism likely best choice also work fine erlangelixir scenario erlang vm really shine opinion building homogeneous system ie multiple deployment container exchange information example imagine building realtime application want track user chat room city block mountain track user connect disconnect node brought could somehow update database communicate via complex rpc mechanism carefully watching cluster topology change erlang vm broadcast exchange information directly without worry serialization protocol connection management etc everything provided vm without external dependency one many feature make phoenix breeze build distributed webrealtime system automated rollouts v hot code swapping come deployment kubernetes automatically roll change application configuration avoiding changing instance time time erlang vm support hot code swapping allows change code running production within single instance without shutting said instance two deployment technique obviously conflicting fact hot code swapping go well general whole idea immutable container mean kubernetes erlang vm poor fit really use hot code swapping fact people elixir application deployed using bluegreen canary similar technique truth hot code swapping actually complicated pull practice let use database example deploying new version software whenever update database never perform destructive change example want rename column add new column migrate data remove column rename column failure whenever rollouts two version software running one using old column using new one hot code swapping precisely issue except applies state inside application company use hot code swapping often report spend much time developing software testing upgrade course mean hot code swapping useless erlang vm development mostly driven business need legitimate need hot code swapping particular building telephone switch never appropriate moment shut instance update given time system full long running connection perhaps day even week able upgrade live system extremely helpful similar need hot code swapping may option another option smarter client migrate client connection node deploying hot code swapping also used circumstance development provide live code loading without need restart server replace smaller component production require replacing whole instance configuration management configuration provider another feature provided elixir kubernetes configuration management however seen work distinct level elixir provides unified api configuring application relatively lowlevel production system often want configuration secret managed higher level tool one provided kubernetes luckily incorporate said configuration tool deployment workflow help configuration provider functionality part elixir release officially made part elixir language version stay alert pod resource provisioning erlang elixir kubernetes important stay alert one particular configuration pod resource using technology common practice break large node bunch small podscontainers example node core could allocate half cpu pod split memory equally total pod approach make sense many technology exploit cpu io concurrency simultaneously however erlang vm excels managing system resource system likely efficient assign large pod erlang elixir application instead breaking apart bunch small one erlang vm sharing machine application may want consider reducing busy waiting vm optimize lower cpu usage making better neighbor slightly higher latency summing kubernetes erlang vm work distinct level kubernetes orchestrates within cluster erlang vm orchestrates language level within instance fred hebert summed distinction well tweet still seeing bad comparison kubernetes erlangotp otp region failover operate different layer abstraction impact distinct componentsotp allows handling partial failure within instance something help fred hebert mononcqc april using erlangelixir wonder kubernetes applies compared language use kubernetes erlang vm would technology given erlangelixir software typically scale horizontally vertically give many option want allocate resource within area kubernetes erlang vm nicely complement using service discovery connect erlang vm instance course distributed erlang requirement erlangelixir great language even stateless apps thanks scalability reliability one really need hot code swapping production erlang vm may one best platform keep mind straying away common path technology finally appreciate kubernetes concept may enjoy working erlang elixir give opportunity apply similar idiom small large thanks fernando tapia rico fred hebert george guimarães tristan sloughter wojtek mach reviewing article
80,Lobsters,elixir,Elixir programming,A Slack bookmarking application in Elixir,https://zorbash.com/post/slack-bookmarks-collaboration-elixir/,slack bookmarking application elixir,tefter relationship slack irssi finch tefter tefter organisation create bookmark create alias search retrieve link alias microlith opus others creating bookmark opus concurrency task visualising pipeline closing thought,post describes used elixir opus one service tefter implement bookmarking collaboration slack relationship slack remember slack started getting viral set main chat app work reluctant use quite happy irc always favour open protocol since supported irc xmpp gateway tweaking irssi config later finch trivial overall experience good later developed first slack apps experiment accomplish trivial task participate company hackathons tefter recently tefter released new organisation feature feature give user ability collaborate within slack workspace essential command slack app create bookmark create alias tefter alias alias url search tefter search query alternatively tefter query search look like retrieve link alias alias especially useful recurring question concerning link example api documentation page service x create doc alias point people link calling tefter doc microlith microservice dealing side system named microlith contradict tendency become monolith written elixir leverage library railwayoriented programming called opus surprisingly never blogged tiny library mine others incorporates software design principle keep close heart main principle opus opus pipeline module single entry point return tagged tuples ok value error error pipeline composition stateless stage stage returning error halt pipeline stage may skipped based condition function unless option exception converted error error tuples default exception may left raise using raise option stage pipeline instrumented metric captured automatically disabled error meaningful predictable post show code example microlith opus used great thing opus usecase described series stage similar grandma beef stew recipe creating bookmark opus recipe create bookmark slack check payload correct format check payload contains url bookmark normalise url retrieve tefter account slack identifier check account create bookmark create bookmark respond user next move translate pseudocode opus term check validpayload check payloadcontainsurl step normalizeurl step fetchuser check cancreatebookmark step createbookmark step respond quick rundown available stage opus step stage process input value success value next stage called value error value pipeline halted error returned check stage intended validation call stage function unless return true halt pipeline tee stage intended side effect notification call external system return value meaningful never halt pipeline link stage link another opuspipeline module call provided module module opuspipeline ignored skip skip macro used linked pipeline linked pipeline may act true bypass based condition expressed either unless skipped none stage executed return input used next stage caller pipeline define opuspipeline module defmodule microlithcommandscreatebookmark moduledoc pipeline handle bookmark command create bookmark use opuspipeline alias microlithpipelinesfetchuser check validpayload errormessage invalidpayload check containsurl errormessage command called without url step trimurl url stringtrim url step fetchuser check cancreatebookmark step createbookmark step respond end module defined used follows payload input http zorbashcom slackuserid slack user identifier teamid slack team identifier teamdomain whitehouse responseurl http hooksapislackcomdeadbeef case microlithcommandscreatebookmarkcall payload ok response json response error error loggerwarn inspect error sendresp conn request could accepted end concurrency like decent cooking recipe implementation left chef may want crack egg one hand stirring sauce endresult thankfully elixir toolset well equipped facility make operation pipeline concurrent case start task pas next stage stage requires result task used visualising pipeline kept favourite part last opus visualise pipeline using opusgraph using point development microlith looked like protip prefer svg output hover stage pipeline read documentation closing thought hope post give idea feature opus promise cover next following post using opus glad hear feedback represent opensource community interested try tefter organization let know add unlimited plan without cost
81,Lobsters,elixir,Elixir programming,Phoenix Phrenzy Winners Announced,https://phoenixphrenzy.com/results,phoenix phrenzy winner announced,,norton commander implemented elixir right browse directory look like norton commander know safe deploy thing server need anyway attempt create complete desktop application buildsh script create osx bundle know know ready distribute lot quirk good start
82,Lobsters,elixir,Elixir programming,The One Who Created Elixir - interview with Jose Valim,https://www.welcometothejungle.co/en/articles/btc-elixir-jose-valim,one created elixir interview jose valim,learning thing mastering ruby first multicore issue making problem disappear exploring functional programming language getting good advice defining overall goal learning failure going talking people adding great tooling ease learning curve importance letting get distracted staying involved elixir behind code get published twitter,creator functional programming language elixir cofounder plataformatec software consultancy specializing elixir ruby josé valim discus started programming lesson learned creating elixir involvement futurelearning thingswhen year old first home computer kind relatively early mother studying data processing able play little bit remember getting one book trying thing visual basic something similar would try couple day clueless kid actually know remember way back probably around think lot people remember tool even know could create fighting game people would design character stage could download game could customize necessarily would call programming tinkering trying put thing together seeing would work kind contributing whole idea would change file definitely code source file language recall first year university class c time computer u time professor would write program blackboard took exam would write program piece paper first year university friend formed band decided make website band flash actionscript kind stuff vacation first time actually programming ownmastering ruby firstso first language became really proficient really confident ruby really liked ruby ability explore language unrestricted try different thing change many different way really attracted ruby time started ruby rail big sensation rail leveraging kind feature ruby hasthe multicore issuegoing back first computer got year old powerful computer time two year later even pentium boy school told pentium like come got computer barely finished paying come machine twice fast mine computer getting twice fast every two year longer true happening instead machine core started see interest growing machine run multiple core read became clear going multicore future would running powerful machine one core would bunch core would need find good way write software leveraged true core working rail time would sometimes make thing faster would happen would improve thing someone would bug report come back saying hey running new version specific situation finding bug bug would hard reproduce hard fix really fault rail per se criticizing rail naturally occurs write software language ruby java c thing change big impact one core one thing running two core two thing running time address thing like happens two thing running time try thing try change place memory try handle resource time called race condition two thing happening time may happen may happen knowmaking problem disappearso found situation like multicores become important hard tackle problem solution started working elixir started looking problem best way solve like say two point return journey final solution felt like know maybe change way write software altogether first time occurred found functional programming example said happens two core running time try change place functional programming stop thinking changing thing think transformation first revelation wait think transformation time software wrote past know concurrency bug would work whole problem would disappear best way solve problem find solution problem make problem disappear altogether yeah take first point second point found erlang virtual machine platform elixir run top look happened past year lot language focusing concurrency good great focusing multiple core point writing software writing system one machine enough powerful machine core want use everything machine efficiently possible previously lot time would use machine machine cluster everyone thinking solve concurrency problem thing running single machine erlang already solved problem problem erlang focused multiple machine well erlang always ahead curve looked thought well great resolved already working next want point know elixir would thing definitely felt moment career going change path try something else information felt like ok area explore venture intoexploring functional programming languagesso explore figured wanted explore functional programming language also decided actually wanted try writing programming language period really trying explore bunch different thing even language really mainstream sometimes niche language focus particular idea example language called frink better way working unit measure tried bunch different thing bunch different functional programming language get idea see would work elixir clojure example big help feature elixir heavily inspired feature clojure course idea came naming come haskell reason go language using erlang virtual machine platform wanted wanted write software using platform really matter wanted thisgetting good advicei met creator mike always welcoming nice sometimes would get talk technical challenge robert example bunch language running erlang virtual machine sometimes would ask question sometimes would like oh implement elixir consider language whenever opportunity meet would really great conversation also met erlang otp team also welcoming open discussing idea nice feel like working something today erlang maintained erlang team within able meet different developer team time time remember elixir come bit push got comment like need new programming language point one ericsson developer sent email saying something like listen continue really great also reassuring like work work work work go ahead continue fun defining overall goalso one thing helped lot target erlang virtual machine target thing thing often saw feature language liked protocol clojure something added elixir would like ok would implement context erlang virtual machine much smaller hurdle compared starting language scratch start adding enough thing bit like jenga game take piece away make sure tower collapse creating language thing never stay separate add everything overlap add something impact elsewhere something also need aware creating language help define overall actually want language kind software want write help whenever question like part language always look overall goal check whether fit within itlearning failuremy first prototype want adventure go github go way back work failed trying run ruby erlang virtual machine trying bring behavior feature ruby erlang virtual machine work two incompatible bunch way important lesson learned mistake instead saying something like let bring would ask would want bring going gain would think problem general oh want bring allows maybe thing would allow meaning could say ok know looking look different solution choose one think best one process think learned made stronger designing language carry process today stillgoing talking peopleif want language used people need go talk could write greatest language world tell anybody purpose nobody would use knew would go would attend event would talk people would write think rail example harnessed idea marketing really well know talk get people excited get people involved something knew knew previous experience opensource community welladding great tooling ease learning curvethe best bit elixir came erlang allowed u develop language great foundation allowed u focus specific thing elixir elixir addition great tooling realised beginning would also need focus sure would talk people also knew needed great tooling could go give talk conference inspire people try got home would pointless got stuck get started know gettingstarted experience simple product accessible easy use able go zero something running relatively quickly something elixir focus welcoming also education general computer science general programming general focus functional programming language majority knew people would learn bunch different thing would need learn functional programming would need learn concurrency wanted ease learning curve much possiblethe importance letting get distractedevery day working try make sure distraction possible unless important pretty much way reach interrupt also regular reader news site hackernews place go break regularly becomes break always rabbit hole disappear try make sure access really keep clear mind focused whatever need topic need know look paper subject read take kindle something internet nothing could distract mestaying involved elixiri continue involved right always pressure another thing deal another thing another thing happen much time sense prefer stay involved always havethis article part behind code medium developer developer discover article video visiting behind code want contribute get published follow u twitter stay tuned illustration wttjvideo
83,Lobsters,elixir,Elixir programming,Using Nix in Elixir projects,https://ejpcmac.net/blog/using-nix-in-elixir-projects/,using nix elixir project,medium nix rather long article elixir erlang derivation toplevel elixir erlang derivation building custom derivation erlang elixir standard elixir project exunit notifier nerve project set environment nerve project edit previous version article stated made patch phoenix project working local postgresql instance setup script direnv little script conclusion,article originally published medium nix purely functional package manager make possible create reproducible setup share developer written rather long article recently want continue specific instruction elixir project much concise way assume know bit nix case read previous article search web information elixir erlang derivation look go shellnix different elixir project let study make elixir available toplevel elixir erlang derivation obvious derivation erlang erlang erlang version considered stable may last one instance time writing article last erlangotp version erlang get specific erlangotp major version release derivation exist currently install last available version corresponding major release elixir elixir installs elixir release considered stable may may last one available exist let install last patch version minor release please aware one thing global elixir derivation built top default erlang isolated nix install instance running erl get erlang shell otp running iex get iex shell running otp us internally erlang derivation otp notice generally need make erlang directly available elixir project unless erlang source code escripts differs say asdf nixpkgs offer nicety work beam language take form beam module let talk beaminterpreters erlang elixir derivation inherited beaminterpreters instance fact go elixir module defines thing erlangrxx derivation erlang alias one erlangrxx beampackageserlang module group package built top given erlangotp release elixir derivation alias beampackageserlangelixir see built erlang derivation generally need use derivation module aliased toplevel definition mainly internal organisation beampackages beampackages module define set derivation built top erlang release instance beampackageserlangelixir default elixir version built top default erlang version elixir aliased fact currently alias last elixir version built top last erlangotp version last rebar built last erlangotp version building custom derivation sometimes may need nonstandard erlang elixir build enable builtin erlang elixir derivation overridable instance want build erlangotp without hipe create custom derivation let enablehipe false custom erlang derivation build module like beampackageserlang using beampackageswith way want derive top custom derivation would instead let elixir beampackageswith also specify custom source revision instance build current elixir master custom erlang let elixir beampackageswith elixiroverride version rev version version specify rev automatically default v version specify rev arbitrary value used match current real version master please note precised commit hash rev instead master set rev master would work immediately however master branch would change would match anymore thus broking derivation curious option take look erlang elixir generic builder standard elixir project bare minimum dependency elixir project elixir git usually specify erlangotp elixir version ensure update nonbreaking pkgs import nixpkgs pkgs let like define variable derivation specific version subject change time elixir mkshell buildinputs elixir git project build us escript need make escript executable available path adding erlang derivation would match one used elixir hex package may need additional dependency work standard elixir project generate xgen install filesystem exunit notifier need external dependency come shellnix work linux macos pkgs import nixpkgs pkgs let inherit lib optional optionals elixir mkshell buildinputs elixir git optional stdenvislinux libnotify exunit notifier linux optional stdenvislinux inotifytools filesystem linux optional stdenvisdarwin terminalnotifier exunit notifier macos optionals stdenvisdarwin darwinapplesdkframeworks filesystem macos corefoundation coreservices nerve project ever set environment nerve project notice package install instruction given official documentation macos debianlike linux fedora linux distribution nix perfect fit make setup easier far shareable developer minimum shellnix found work following pkgs import nixpkgs pkgs let inherit lib optional optionals elixir mkshell buildinputs elixir git fwup squashfstools file optional stdenvisdarwin coreutilsprefixed nerve macos optional stdenvislinux nerve linux hook needed linux make nerve use correct sshaskpass shellhooks optional stdenvislinux export sudoaskpass one able build burn firmware nix shell edit previous version article stated linux fwup requires run root run hand sudo fwup build target prodnervesimages app fw due fwup available root user path change future made patch nerve use fwup available running mix firmwareburn patch since landed nerve phoenix project phoenix project depend least filesystem external dependency shown previously also often use nodejs build asset database like postgresql shellnix working standard phoenix project pkgs import nixpkgs pkgs let inherit lib optional optionals elixir nodejs postgresql mkshell buildinputs elixir nodejs git postgresql optional stdenvislinux inotifytools filesystem linux optionals stdenvisdarwin darwinapplesdkframeworks filesystem macos corefoundation coreservices put postgresql database project diretory shellhook export pgdata pwddb shellnix postgresql available locally help keeping dependency explicit avoiding mix different project global postgresql instance shellhook set pgdata variable automatically used postgresql know store data working local postgresql instance use local postgresql instance ensure instance running insist multiple postgresql instance ensure serve different port cover use case pgdata set shellhook postgresql use db directory project whenever run nix shell initialise database running initdb nolocale nolocale part optional macos work well without issue linux locale seems missing start local instance pgctl l pgdataserverlog start l pgdataserverlog argument optional without get postgresql log console usually want precise log file phoenix project work box default value need create postgres user createdb permission createuser postgres createdb good setup ecto repo mix ectosetup lazy run command hand time need setup project automation good written setup script step necessary commit project help setup environment info readmemd working project forget stop local postgresql instance running still nix shell pgctl stop lazy aliased start stop command pgst pgsp respectively define alias finger need also sometimes lightheaded use direnv automatically switch environment nix shell project directory added little script check wether postgresql instance running emits warning local one case see warning want switch local one remember one running killall postgres pgctl l pgdataserverlog start obviously aliased pgswitch automatic switching since open another project without wanting switch conclusion nix elixir match really well come enhance software development experience tend make complex task easier joy use nix user user configuration workflow wanted switch asdf use also elixir development workflow even pushed integrating needed tool different kind project enabling build easily machine instruction easy installing nix running nix shell getting shellnix taken week really wanted share help community define better pattern hope enjoy suggestion enhancement especially way handling local postgresql instance comment really welcome nice happy day
84,Lobsters,elixir,Elixir programming,Application Layering - A Pattern for Extensible Elixir Application Design,https://aaronrenner.io/2019/09/18/application-layering-a-pattern-for-extensible-elixir-application-design.html,application layering pattern extensible elixir application design,introduction background alternative approach pattern http githubcomaaronrennerzonemealtracker break app multiple layer phoenix application patternoriented software architecture volume building toplevel api elixir writing documentation guide leveraging namespaces indicate layer leveraging namespaces way naturally created layer make implementation swappable mechanic swapping child layer elixir swapping approach injecting collaborating function optional parameter benefit drawback swapping approach looking current implementation calling function benefit drawback swapping approach calling api module delegate current implementation behind scene benefit drawback unit testing email protected email protected swappable layer way file structure mirror application structure johnny winn talk delete integration testing wallaby hound tip trick add swapping mechanism needed keep implementation detail apis working long namespaces logic api module email protected relationship prior work art destroying software final advice resource,introduction designing application question inevitably raised code go many time answer readily available resulting code end project junk drawer like utils model happens enough codebase becomes tangled team ability maintain software time significantly decreased sign developer inexperience naming hard instead likely symptom application lack structure goal paper help elixir developer learn structure large codebases maintainable adaptable extensible without getting bogged tangled web interdependency technical cruft background phoenix context good first step toward app organization work well small scale apps however app continues grow tendency keep context sibling single layer without way indicate different level abstraction within codebase thing increase complexity business logic requires assembly data multiple context clear place logic go real problem many level abstraction grouped single context level abstraction mixed module place put overarching business logic codebase becomes muddy difficult reason alternative approach sometimes come alternative approach one take several step back examine problem different point view library layer abstraction functionality provide developer write api client library think http request parsing response serializing data everything else go api client idea applies database adapter web server hardware driver many library provide clean api wrap potentially complex operation hide layer complexity developer focus writing application without worry low level concern like opening socket web server even library use every day delegate complexity library focus lower level abstraction example let look ectosql dependency tree ectosql hex package dbconnection hex package connection hex package ecto hex package decimal hex package postgrex hex package telemetry hex package ectosql provides api application interact database code inside ectosql focus writing application data database reading back however come lower level concern like maintaining database connection connection pooling metric database specific communication call library focus lower level abstraction idea library focus certain level abstraction practiced fruitfully daily basis elixir ecosystem library author try provide easy use apis application build top without getting bogged level abstraction library meant wrap sort modularity separation concern key factor allowing developer build better maintainable application focus business logic delegate lowerlevel concern library within elixir ecosystem since pattern layering modular dependency isolate level abstraction work well extend pattern application codebases tree modular component isolate logic appropriate level abstraction pattern pattern application layering consists two part breaking app tree layer based app various level abstraction allowing layer implementation easily swapped alternative implementation improve testability increase adaptability changing business requirement go pattern also example repo built using technique discussed http githubcomaaronrennerzonemealtracker app refactored using technique discussed later section article go back commit history see earlier step break app multiple layer common practice developer elixirphoenix community split project separate web business logic apps use phoenix context originally inspired lance halvorsen talk phoenix application championed phoenix framework code generator separation greatly simplifies web app allowing focus web concern thin interface underlying business application also allows developer focus core logic project separately elixir application solves business need although see huge gain separating web layer rest application many project stop two layer fine small codebase larger codebases lead application becomes tangled complicated main idea behind application layering decompose app multiple layer isolate application various level abstraction concept originally introduced layer pattern patternoriented software architecture volume pattern benefit include understandability layer focused single level abstraction code becomes easier follow example business logic layer focus process registering user creating user database sending welcome email etc without cluttered lowerlevel detail sql command email delivery maintainability code understandable simpler developer update application separated multiple layer much easier understand new logic written update data serialized sent external api make sense go lowlevel layer like api client likewise logic supporting new business process go higherlevel business logic layer adaptability since parent layer communicate child layer clearly defined apis implementation child layer replaced improved implementation conforms api allows replacing implementation entire layer without change rippling parent application layering take strictvariant layer pattern layer coupled direct child layer instead creating application wide layer create tree child layer focused particular level abstraction go solving task hand great part tree layer approach implementation decomposed logical child module child module decomposed child module necessary decomposition naturally creates layer move toward lower level abstraction business logic layer able stay simple readable flexible even though may coordinating several complex lowerlevel layer also make easy low level layer like api client extracted standalone library decoupled higher level layer building toplevel api discussed high level structure application layering let look implement order make clear functionality application expose treat application toplevel module public api place outside world interact code elixir writing documentation guide indicates public api show documentation internal functionsmodules hidden moduledoc false allows developer get clear view application contract outside world without getting confused internal module actually implementation detail important single module related structs application public api couple reason additional module made public becomes difficult understand child module part public api lowerlevel implementation detail meant called internally adding new business process span multiple component like user registration creates account sends welcome notification toplevel public api module serf place tie component together single business process without single agreed upon place top level business logic becomes unclear logic go leveraging namespaces indicate layer top level module public api child module one two thing structonly module referenced public api internal helper module implementation detail public api meant called publicly mentioned previously document module part public api easy tell module function public v internal defmodule zonemealtracker moduledoc public api zonemealtracker application alias zonemealtrackeruser doc register new user email password spec registeruser stringt stringt ok usert error emailalreadyregistered def registeruser email password end defmodule zonemealtrackeruser moduledoc user struct struct module used public api defstruct id email type id stringt type module id id email stringt end defmodule zonemealtrackernotifications moduledoc false module implementation detail zonemealtracker exposed public api tell moduledoc false nt define struct module zonemealtracker call part public api spec sendwelcomemessage usert end great thing approach exposing functionality world public api layer module child helper module part lower implementation layer meant called public give u flexibility organize reorganize child module implementation layer security know called module parent public api effort maintain simplicity important keep function sideeffects structonly module added retrieve user database effectively splitting public api across multiple module lead several problem including confusion around public api clear place overarching business logic instead write either lookup logic directly function delegate function internal data store module like leveraging namespaces way previously used namespaces indicate top level module public api child module either structonly module referenced public api internal helper module implementation detail public api meant called publicly great thing pattern repeat many level deep application still provides structure guarantee really pattern setting forth current module api child module either structs referenced current module api internal module used api implementation module access direct child accessing sibling grandchild great grandchild etc need access sibling logic go next higher namespace need access grandchild child module need provide api functionality naturally created layer great thing using namespaces way naturally creates layer example zonemealtrackernotificationsnotificationpreferencestore focused storing user preference notification system zonemealtracker focused around overall business logic application developer layered structure provides couple benefit need look child module unless care module logic implemented example calling function able trust user registered properly reason look code child module need know register user keep codebase easy understand bos say need send metric user registered nice logical place integrate new functionality toplevel public api available user registration may placed traditional context like however make zonemealtrackeraccounts module difficult understand function operate business logic layer others operate persistence layer developer keep mind function high level business logic function lower level persistence logic call function appropriate level currently working much simpler module api operates single level abstraction make implementation swappable application layered use namespaces welldefined apis layer take one step allow code behind apis swapped different implementation although layer pattern hint able swap implementation mention exchangeability concept covered detail hexagonal architecture paper alistair cockburn hexagonal architecture aka port adapter say order keep application flexible business logic communicate thing outside world database http apis etc well defined interface give developer huge amount flexibility welldefined interface created current implementation replaced implementation also conforms well defined interface case layer application communicates layer interface implementation lowerlevel layer easily swapped without affecting code higherlevel layer hexagonal architecture diagram instead talking higherlevel lowerlevel layer turn diagram degree left say higherlevel layer call logic inside hexagon left side port logic inside hexagon call lowerlevel layer right side port hexagon shape significant easy draw shape flat side represents port original zonemealtracker app zonemealtracker new implementation swapped power swap implementation right side port allows u easily unit test business logic without calling external service build implementation child layer return fake data higher layer app developed team still building lower layer solidify function lower layer api without actually writing lower layer implementation code allows u defer technical decision like data store use structure database table etc clearer understanding interface need provide easily adapt changing business requirement example business want u migrate new api provider need swap new implementation child layer long new implementation provide codelevel interface previous implementation new implementation swapped without affecting anything upstream mechanic swapping child layer elixir although ability swap different implementation sound great actually implementing difficult way tried injecting collaborating function optional parameter looking current implementation calling function calling api module delegate current implementation behind scene reference example function modify using different method swapping implementation spec registeruser stringt stringt ok usert error emailalreadyregistered def registeruser email password case accountstorecreateuser email password ok user id userid user ok notificationssetuseremail userid email ok notificationssendwelcomemessage userid ok user error emailnotunique error emailalreadyregistered end end swapping approach injecting collaborating function optional parameter approach involves modifying function accept new parameter developer swap implementation test type registeruseropt createuserfn stringt stringt ok usert error changesett setprimarynotificationemailfn stringt stringt ok sendwelcomemessagefn stringt ok spec registeruser stringt stringt ok usert error emailalreadyregistered def registeruser email password opts createuserfn keywordget opts createuserfn setprimarynotificationemailfn keywordget opts setprimarynotificationemail sendwelcomemessagefn keywordget opts sendwelcomemessage case createuserfn email password ok user id userid user ok setprimarynotificationemailfn userid email ok sendwelcomemessagefn userid ok user error emailnotunique error emailalreadyregistered end end benefit low barrier entry allows collaborating function swapped implementation require additional module defined alternative implementation swapped per function call global configuration application environment drawback quickly make function complicated harder reason requires significant code change easy mock alternative implementation drift expected dialyzer support swapping approach looking current implementation calling function approach involves looking module contains current implementation application environment happens module calling function spec registeruser stringt stringt ok usert error emailalreadyregistered def registeruser email password case accountstore createuser email password ok user id userid user ok notification setuseremail userid email ok notification sendwelcomemessage userid ok user error emailnotunique error emailalreadyregistered end end defp accountstore applicationgetenv zonemealtracker accountstore accountstore end defp notification applicationgetenv zonemealtracker notification notification end benefit drawback requires code change calling function work dialyzer module name dynamically resolved every caller module look current implementation becomes significant burden current implementation controlled globally via application environment make difficult multiple implementation run parallel swapping approach calling api module delegate current implementation behind scene approach let client code continue call original module change instead original module modified delegate function call current implementation approach basically split module public api implementation approach client code remains spec registeruser stringt stringt ok usert error emailalreadyregistered def registeruser email password case accountstorecreateuser email password ok user id userid user ok notificationssetuseremail userid email ok notificationssendwelcomemessage userid ok user error emailnotunique error emailalreadyregistered end end collaborating module adjustment made defmodule zonemealtrackeraccountstore moduledoc false alias zonemealtrackeraccountstoreuser behaviour zonemealtrackeraccountstoreimpl impl true spec createuser useremail userpassword ok usert error emailnotunique def createuser email password impl createuser email password end defp impl applicationgetenv zonemealtracker accountstore modulepostgresimpl end end actual implementation moved module defmodule zonemealtrackeraccountstorepostgresimpl moduledoc false alias ectochangeset alias zonemealtrackeraccountstorepostgresimplinvaliddataerror alias zonemealtrackeraccountstorepostgresimplrepo alias zonemealtrackeraccountstoreuser behaviour zonemealtrackeraccountstoreimpl impl true spec createuser useremail userpassword ok usert error emailnotunique def createuser email password isemail email ispassword password user userchangeset email email password password repoinsert case ok user user ok user error changeset error error enumany error match email isalreadyregistered error emailnotunique else raise invaliddataerror error error end end end end finally api implementation kept sync behaviour defmodule zonemealtrackeraccountstoreimpl moduledoc false alias zonemealtrackeraccountstoreuser callback createuser useremail userpassword ok usert error emailnotunique end benefit require changing client code dialyzer work single place swap implementation compatible mox extra namespace make easy keep multiple implementation separate implementation namespace deleting implementation easy deleting namespace drawback requires scaffolding add extra level namespace hierarchy current implementation controlled globally via application environment make difficult multiple implementation run parallel calling api module delegate current implementation behind scene approach one found work best approach using rest article unit testing swapping mechanism place easily test zonemealtracker isolation without set even implementation completed zonemealtrackeraccountstore zonemealtrackernotifications zonemealtracker module along test libzonemealtrackerex defmodule zonemealtracker moduledoc public api zonemealtracker alias zonemealtrackeraccountstore alias zonemealtrackernotifications spec registeruser stringt stringt ok usert error emailalreadyregistered def registeruser email password case accountstorecreateuser email password ok user id userid user ok notificationssetuseremail userid email ok notificationssendwelcomemessage userid ok user error emailnotunique error emailalreadyregistered end end end testtesthelperexs moxdefmock zonemealtrackermockaccountstore zonemealtrackeraccountstoreimpl applicationputenv zonemealtracker accountstore zonemealtrackermockaccountstore applicationputenv zonemealtracker notificationsimpl zonemealtrackermocknotifications moxdefmock zonemealtrackermocknotifications zonemealtrackernotificationsimpl testzonemealtrackerexs defmodule zonemealtrackertest use exunitcase async true import mox alias zonemealtracker alias zonemealtrackermockaccountstore alias zonemealtrackermocknotifications alias zonemealtrackeruser setup setmoxfromcontext verifyonexit test email unique email email protected password password userid user user id userid email email expect mockaccountstore createuser fn email password ok user end mocknotifications expect setuseremail fn userid email ok end expect sendwelcomemessage fn userid ok end assert ok user zonemealtrackerregisteruser email password end test email already taken email email protected password password expect mockaccountstore createuser fn email password error emailnotunique end assert error emailalreadyregistered zonemealtrackerregisteruser email password end end since clear apis dependency easy way swap mock implementation easy unit test business logic level abstraction code written mock implementation swapped easily test notification sent return error emailnotunique mock save u first create user database email could ensure second user registration failed notification sent failure instead approach allows u unit test layer isolation relies contract module apis enforced dialyzer accountstoreimpl behaviour doublechecked integration test ensure module work together expected approach allows higher layer focus testing known response lower layer without coupled detail underlying implementation furthermore account store migrated local postgresbased implementation highavailability riakbased implementation business logic test zonemealtracker modified compatible new zonemealtrackeraccountstore implementation swappable layer way although scope hexagonal architecture limited saying business logic inside hexagon communicate outside system welldefined api pattern also lends repeated multiple layer throughout application allow swappable implementation layer end tree neatly layered dependency implementation easily replaced point significantly help testing let test layer focus level abstraction without coupled underlying implementation example test ensure email address registered given user id welcome email sent address swap mock notificationpreferencestore email module test coupled notification preference stored email delivered instead able focus business logic email sent appropriate user function called file structure mirror application structure another great thing pattern make separation public api module underlying implementation even clear libzonemealtracker accountstoreex top level api module accountstore implex behaviour implemented top level module impls inmemoryimplex inmemory implementation inmemoryimpl module used specific implementation stateex loginex struct returned public api postgresimplex postgresbacked implementation postgresimpl module used specific implementation domaintranslatorex exceptionsex loginex repoex supervisorex userex supervisorex helper module used across implementation moduledoc false userex struct returned public api looking module folder thing stand anything ending impl implementation anything inside implname impl folder helper module used implementation implex behaviour keep top level module implementation sync module folder exception well known module like applicationex supervisorex structonly module referenced api structure uniformity make easy understand layer glancing file tree furthermore may started inmemoryimpl expanded postgresimpl improved understanding api needed provide structure allows postgresimpl developed isolation inmemoryimpl still used time switch inmemoryimpl postgresimpl done single line change top level module set default implementation postgresimpl could also changed via application environment allow easy rollback migration complete ready remove old implementation thing need done delete inmemoryimplex inmemoryimpl since entire implementation contained file folder removing extremely simple idea originally inspired johnny winn talk delete integration testing although layer fully unit tested dialyzer running type checking layer still important endtoend test ensure default implementation integrate expected could simple writing automated test go user registration flow ensure everything work expected since test manipulate application environment swap mock implementation various layer generally best integration tester outside umbrella app start app clean environment example integration tester integrationtester folder zonemealtracker app need browserbased integration testing wallaby hound great tool allow drive app via real web browser writing app api worth considering building api client make integration testing easier also helpful time call api another elixir application tip trick although pattern work well give flexibility maintaining long lived application item keep mind working application sort structure add swapping mechanism needed first starting tempting add swapping mechanism every module unfortunately many swapping mechanism bring needle pain frustration insert swapping business logic layer layer reach external service api database etc distinct business logic layer example developer could insert swapping mechanism zonemealtrackernotifications parent layer zonemealtracker could tested isolation testing zonemealtracker care notification sent appropriate function called zonemealtrackernotifications many time helper module like zonemealtrackernotificationsloggerformatterthat contain pure function extracted parent zonemealtrackernotificationslogger module interact external service part system therefore need swapping logic adding swapping logic module would complicate testing overall application structure keep implementation detail apis also important let implementation detail leak app apis developer disciplined return ecto schema changesets api may able swap ectobased local account store new implementation reach http account microservice key ensure structs accepted returned via public api coupling underlying implementation mean ecto schema changesets leak public api would prevent u switching nonecto data store working long namespaces started layering application appropriate level abstraction complete swapping logic time namespaces get deep nesting swappable layer module name get long cumbersome defmodule zonemealtrackerdefaultimplnotificationsdefaultimpl notificationpreferencestorepostgresimplprimaryemail end point come work well pick logical standalone layer like zonemealtrackerdefaultimplnotifications extract application umbrella indicate internal app prefix application project initial like zmtnotifications extraction shorten length namespaces also brings several benefit internal app mixexs make easy tell layer introduces dependency standalone library like api client easily extracted umbrella project published hex even internal application top level module expose api rest system build since module enough functionality made worth extracting also add documentation toplevel internal api developer generate exdoc project see main public api zonemealtracker internal apis reach well like zmtnotifications logic api module building api module function passthroughs current implementation developer add logic api module forced also keep logic mind want return specific data function example api module contains logic defmodule zmtnotifications spec fetchregisteredemail stringt ok stringt error notfound def fetchregisteredemail email currentimpl fetchregisteredemail end spec emailregistered stringt boolean def emailregistered email contains logic instead passthrough match ok fetchemailregistered email end end module tested defmodule zonemealtracker spec emailregistered stringt boolean def emailregistered email code test zmtnotificationsemailregistered email end end test case defmodule zonemealtrackertest use exunitcase import mox alias zonemealtrackermockzmtnotifications test emailregistered return true email registered although code test calling zmtnotificationsemailregistered know mock logic zmtnotificationsemailregistered instead straight passthrough expect mockzmtnotifications fetchregisteredemail fn email ok email assert zonemealtrackeremailregistered email protected end end example instead able simply expect mockzmtnotificationsemailregistered returned value wanted need know underlying implementation call order make mockzmtnotificationsemailregistered return true actually make return ok email lot unnecessary coupling complication test seemingly simple function bit logic would put api module would guard clause ensure appropriate data type passed underlying implementation make error message nicer calling function api module invalid data keep u forgetting guard clause actual implementation function api module complete passthrough current implementation relationship prior work software design idea applying somebody earlier work slightly different context greg young art destroying software excellent talk discus composing large system collection tiny program component deleted rewritten week help keep part larger system small understandable easily adaptable changing business requirement idea application layering mesh extremely well philosophy application layering build application tree component swapped time example want change zmtnotificationsdefaultimplnotificationpreferencestore write riak database instead postgres database write new zmtnotificationsdefaultimplnotificationpreferencestoreriakimpl module swap ready transition postgres riak complete delete zmtnotificationsdefaultimplnotificationpreferencestorepostgresimpl child module database logic isolated small component easily follow greg idea able delete rewrite component week take one step business requirement change may find need completely change design notification system existing swapping infrastructure place define new zmtnotificationsenhancedimpl module start work new improved notification system implementation may need separate data store service zmtnotificationsdefaultimpl implementation tucked zmtnotificationsenhancedimpl namespace long fulfill contract defined zmtnotificationsimpl behaviour free rewrite tree component without affecting upstream layer also component isolated rest system many case also rewritten week greg talk mention benefit able rewrite tiny program component within application week application layering swappable implementation analogous one tiny program greg mention difference great code sucky code size program layer layer focused single level abstraction business logic persistence etc layer stay small easily replaced requirement change sort structure unshackles developer large complex codebases give freedom rewrite small part system change needed experience make extremely enjoyable application work final advice building software process proper software design come apparent go many time tried skip step create layer actually need realize chosen wrong need rewrite code try follow following process public function made easier read extracting private function several related private function extracted need write unit test private function extract child module test business logic difficult write require call external service separate section business logic insert swappable layer module serf boundary business logic external serviceseparate domain also help writing module ask module public api help think contract need fulfill support rest system giving flexibility experiment implementation working higher layer call function wish child layer go implement lowerlevel logic solidified child layer api help make sure child layer apis make sense although take thought discipline design system way lead amazingly flexible codebase easy adapt maintain encourage everyone nontrivial application try pattern edge application could either boundary external service like api client topmost boundary application web layer business logic time figure in out work best structure system ultimately done correctly end flexible adaptable codebase said forget add full stack integration test ensure application continues function restructure codebase happy coding resource
86,Lobsters,elixir,Elixir programming,Spawnfest 2019 Submissions,https://github.com/spawnfest?q=2019,spawnfest submission,grow team github sign repository fiqusprexent used topic reload reload,dismiss grow team github github home million developer working together join grow development team manage permission collaborate project sign result repository matching repository commandline spritesheet generator elixir elixir updated sep realtime databaseasaservice reststyle resource location time traveling feature support elixir updated jul javascript updated jul elixir updated sep elixir updated jul idea tech festival available one roof elixir updated jul ejdbc erlang jdbc erlang bridge jdbc api erlang updated sep elixir updated sep tuple space based erlang application fast fourier transforms erlang updated sep erlang updated sep kanban board built using elixir phoenix liveview using liveview hook elixir updated jul erlang updated sep forked fiqusprexent fast live beautiful presentation markdown powered phoenix liveview elixir mit updated sep used topic perform action time signed another tab window reload refresh session signed another tab window reload refresh session
87,Lobsters,elixir,Elixir programming,Deploying Phoenix to Kubernetes from Scratch,https://quan.io/blog/deploying-phoenix-to-kubernetes-from-scratch/,deploying phoenix kubernetes scratch,introduction work gigalixir open issue github note cost digital ocean referral link kubernetes cluster referral link kubernetes cluster creation page instruction connecting digital ocean cluster kubectl doctl kubectx kubens nginx ingres let encrypt nginx ingres certmanager tutorial nginx ingres doc cert manager doc dns http freednsafraidorg subdomains private docker registry gitlab dockerhub github digital ocean space space api key brief note troubleshooting creating managed database navigate creating phoenix app follow guide elixir release phoenix documentation phoenix documentation secret configuration kubernetes doc creating pushing docker image phoenix doc database migration running application next step,introduction kubernetes exciting technology overwhelming starting many reason use kubernetes likely equal number valid reason use something different anything interesting new add debate though use kubernetes work personal project love option give deploying application initial burden getting cluster set learning basic deploying application easy quick highly recommend gigalixir kubernetes excite want simple reliable way deploy phoenix application post meant complete guide deploying brand new phoenix application brand new kubernetes cluster prerequisite call place substitute existing solution kubernetes elixirphoenix expert likely better way thing see thing please leave comment open issue code used guide life github used reference note cost able complete tutorial free digital ocean google cloud aws azure provide trial credit get running digital ocean referral link get credit plenty tutorial believe google cloud also offer new account tutorial however using digital ocean product way cut cost running kubernetes cluster also try call completely free way playing around kubernetes locally experience easier learn real kubernetes cluster one old spare computer building kubernetes cluster enriching fun using managed kubernetes solution let focus deploying application kubernetes cluster digital ocean provides fantastic kubernetes product lack google bell whistle cheaper work really well mentioned use referral link get free credit kubernetes cluster already skip next section create new account navigate kubernetes cluster creation page create new cluster using latest kubernetes version region closest node digital ocean let create two node cluster area save money high availability primary concern named cluster testphoenixcluster take minute start new kubernetes cluster take time follow instruction connecting digital ocean cluster requires setting kubectl doctl setting kubectx kubens also recommended strictly necessary cluster ready run doctl kubernetes cluster kubeconfig save testphoenixcluster set config authentication finished able run following get similar result kubectl get node name status role age version ready none phoenixpoolbqkp ready none phoenixpoolbqks ready none nginx ingres let encrypt web application need accessible outside cluster accessible via http going accomplish using nginx ingres certmanager tutorial foundational understanding worked basic idea section provide kubernetes ability easily link application container load balancer automatically put http reverse proxy front application first let get nginx ingres running run following taken nginx ingres doc kubectl apply f http kubectl apply f http command request creation load balancer minute load balancer created get something similar kubectl get svc namespaceingressnginx name type clusterip externalip port age ingressnginx loadbalancer make note externalip reference shortly time install certmanager run following taken cert manager doc kubectl create namespace certmanager kubectl label namespace certmanager kubectl apply f http next create following file named prodissueryaml apiversion kind clusterissuer metadata name letsencryptprod spec acme server http email youremailhere privatekeysecretref name letsencryptprod replacing youremailhere email necessary config file certmanager let add annotation automatically request cert let encrypt apply file kubectl apply f prodissueryaml dns need point two thing domain control private docker registry phoenix application already domain control create two different record pointing externalip skip next section create account http freednsafraidorg free want completed create two record subdomains page type need subdomain whatever long record domain whatever long record destination externalip case output page look like take time propagate private docker registry kubernetes container management system going need place keep container many way approach gitlab free container registry dockerhub offer free private repository per account github invite beta registry docker push registry feel free skip next section advantage controlling private docker registry like image live data center cluster advantage likely outweigh managing another piece infrastructure existing solution first create digital ocean space equivalent backing storage private registry try putting region cluster cdn necessary restrict file listing pick name unique name make note mine testphoenixkubernetes created create new space api key top generated string access key bottom one secret key run following value echo n youraccesskey accesskey echo n yoursecretkey secretkey new line env var secret bitten n necessary next create namespace registry kubectl create namespace registry next create authentication file htpasswd cb htpasswd admin entering password prompt tell note b bcrypt poorly documented required docker registry create kubernetes secret authentication kubectl create secret namespace registry generic auth fromfilehtpasswd fromfileaccesskey fromfilesecretkey create registryyaml following value apiversion kind deployment metadata label app registry name registry namespace registry spec replica strategy type rollingupdate template metadata label app registry spec container name registry image resource request memory cpu limit memory cpu port containerport env name registryauth value htpasswd name registryauthhtpasswdpath value authhtpasswd name registryauthhtpasswdrealm value registry realm name registrystorage value name valuefrom secretkeyref name auth key accesskey name value testphoenixkubernetes replace name value replace region name value replace region endpoint name valuefrom secretkeyref name auth key secretkey volumemounts name auth mountpath auth volume name auth secret secretname auth apiversion kind service metadata name registry namespace registry spec selector app registry port name port targetport apiversion kind ingres metadata name registryingress namespace registry annotation kubernetesioingressclass nginx nginxingresskubernetesioproxybodysize nginxingresskubernetesioproxyrequestbuffering letsencryptprod spec tl host replace secretname letsencryptprod rule host replace http path backend servicename registry serviceport replace value replace comment value registry ensure dns entry created section resolve externalip dig hostname wait dns propagation finish take continue part next step certificate issuing let encrypt need reach kubernetes cluster via hostname run kubectl apply f registryyaml change made minute two run kubectl get pod n registry result something similar name ready status restarts age running see something like cmacmehttpsolver fine wait minute run command anymore verify registry working run docker login yourregistryhostname login username password created htpasswd command docker pull docker tag docker push brief note troubleshooting thing working point go debugging command kubectl get pod kubectl log podid kubectl describe pod podid hopefully give enough output begin searching fix creating managed database phoenix application going backed managed postgres instance navigate create one pick instance data center nearest take minute provisioned done created add user clicking user database tab auto generate password case user phoenixtestproject record autogenerated password somewhere production system want create user via psql client able fine control role ability create database via ui page called phoenixtestproject well finally go setting tab add kubernetes cluster computer ip address trusted source section note possible deploy postgres kubernetes save cost done though prefer paying worry managing properly creating phoenix app finally time create phoenix application need help installing phoenix elixir follow guide create phoenix application mix phxnew kubernetesphoenix cd directory going using elixir release phoenix documentation comprehensive turn want dive deeper run mix releaseinit generate release helper mentioned phoenix documentation add file libreleaseex deal migration defmodule kubernetesphoenixrelease app kubernetesphoenix def migrate repo repos ok ectomigratorwithrepo repo ectomigratorrun true end end def rollback repo version ok ectomigratorwithrepo repo ectomigratorrun version end defp repos applicationload app ok applicationensureallstarted app phoenix documentation necessary ensure ssl started applicationfetchenv app ectorepos end end also per phoenix documentation rename configprodsecretexs configreleasesexs mv configprodsecretexs configreleasesexs configreleasesexs change use mixconfig import config remove importconfig prodsecretexs prodexs uncomment config kubernetesphoenix kubernetesphoenixwebendpoint server true releasesexs uncomment ssl true releasesexs repo config add ssl list extraapplications mixexs file like extraapplications logger runtimetools ssl ensure ecto talk postgres ssl change examplecom prodexs dns name chose earlier mine look like url host port worry port section using nginx certmanager ensure traffic encrypted via tl secret configuration let create kubernetes namespace generate secret application need kubectl create namespace phoenix mix phxgensecret tr n secretkeybase new line worst echo n ecto username password hostname portdatabase postgresurl example mine echo n ecto phoenixtestproject reallysecurepassword postgresurl kubectl create secret namespace phoenix generic phoenixsecrets fromfilesecretkeybase fromfilepostgresurl need create secret allows kubernetes pull private registry following kubernetes doc fill value private docker registry kubectl create secret namespace phoenix dockerregistry regcred dockerserver yourregistryserver dockerusername yourname dockerpassword yourpword dockeremail youremail creating pushing docker image add dockerfile application taken phoenix doc build run apk add update buildbase git npm run mkdir app workdir app run mix localhex force mix localrebar force env mixenvprod copy mixexs mixlock copy config config run mix depsget run mix depscompile copy asset asset run cd asset npm install npm run deploy run mix phxdigest copy priv priv copy lib lib run mix compile copy rel rel run mix release app run apk add update bash openssl run mkdir app workdir app copy frombuild appbuildprodrelkubernetesphoenix run chown r nobody app user nobody env homeapp cmd binkubernetesphoenix start run following substituting private container registry docker build latest docker push latest database migration database migration done kubernetes job create migratejobyaml following apiversion kind job metadata name migratejoblatest namespace phoenix spec template spec container name migratelatest image latest use registry command binkubernetesphoenix eval kubernetesphoenixreleasemigrate env name databaseurl valuefrom secretkeyref name phoenixsecrets key postgresurl name secretkeybase valuefrom secretkeyref name phoenixsecrets key secretkeybase imagepullsecrets name regcred restartpolicy never replace image value image run migration kubectl apply f migratejobyaml run kubectl get pod n phoenix went well get output similar kubectl get pod n phoenix name ready status restarts age completed check log using kubectl log n phoenix podname like kubectl log n phoenix info running kubernetesphoenixwebendpoint cowboy http info access kubernetesphoenixwebendpoint http info already delete job completes kubectl delete f migratejobyaml running application create applicationyaml following apiversion kind deployment metadata name phoenix namespace phoenix spec selector matchlabels app phoenix replica strategy rollingupdate maxunavailable maxsurge type rollingupdate template metadata label app phoenix spec container name phoenix image latest use registry resource request memory cpu limit memory cpu port containerport livenessprobe httpget path port initialdelayseconds successthreshold failurethreshold readinessprobe httpget path port initialdelayseconds successthreshold failurethreshold env name databaseurl valuefrom secretkeyref name phoenixsecrets key postgresurl name secretkeybase valuefrom secretkeyref name phoenixsecrets key secretkeybase imagepullsecrets name regcred apiversion kind service metadata name phoenixservice namespace phoenix spec selector app phoenix port protocol tcp port name web apiversion kind ingres metadata name phoenixingress namespace phoenix annotation kubernetesioingressclass nginx letsencryptprod spec tl host use hostname secretname letsencryptprod rule host use hostname http path backend servicename phoenixservice serviceport replace image value image replace host dns entry obtained deploy application kubectl apply f applicationyaml run kubectl get pod n phoenix went well output look like minute two name ready status restarts age running running website available dns address picked case available http anymore next step hopefully thing went smoothly please leave comment remember delete unused resource done lot exciting thing newly deployed application idea
88,Lobsters,elixir,Elixir programming,Animating a Canvas with Phoenix LiveView,http://www.petecorey.com/blog/2019/09/02/animating-a-canvas-with-phoenix-liveview/,animating canvas phoenix liveview,phoenix liveview javascript interoperability liveview lifecycle liveview hook complete game changer getting set check sophie debenedetto thorough walkthrough official documentation generating data animate hooking liveview various point dom node lifecycle point instance class various piece data related current set hook resizing canvas animating circle requesting animation frame request animation frame browser taking check example project probably absolutely yes check entire source example github update joxy sure check issue filed,phoenix liveview recently released new feature called hook introduces javascript interoperability liveview lifecycle put simply run arbitrary javascript every time dom node changed liveview liveview hook complete game changer open door whole new world application built amazing technology proof concept let use liveview hook animate canvas real time using data provided server getting set keep article short er skip rigmarole configuring application use liveview need help step highly recommend check sophie debenedetto thorough walkthrough sure cross reference official documentation thing moving quickly liveview world moving forward let assume barebones liveview component attached route look something like defmodule livecanvaswebpagelive use phoenixliveview def render assigns l canvas canvas supported canvas end def mount session socket ok socket end end also assume assetsjsappjs file creating liveview connection import livesocket phoenixliveview let livesocket new livesocket live livesocketconnect page let get started generating data animate start animating client data animate start storing numeric value called liveview process assigns def mount session socket ok assign socket end next increase instructing liveview process send update message delay millisecond def mount session socket processsendafter self update ok assign socket end handle udpate message process schedule another recursive call update increment value socket assigns def handleinfo update assigns socket processsendafter self update noreply assign socket end liveview process value slowly increasing approximately sixty time per second data animate let add canvas liveview template hold animation def render assigns l canvas datai canvas supported canvas end notice associating value canvas assigning data attribute dom element every time change process state liveview update canvas set value datai new value great render animation canvas need way executing clientside javascript every time canvas update thankfully liveview new hook functionality let u exactly hooking liveview liveview hook let u execute javascript various point dom node lifecycle node first mounted updated liveview destroyed removed dom becomes disconnected reconnected phoenix server hook liveview clientside lifecycle need create set hook pas livesocket constructor let create hook initializes canvas rendering context element mount render static circle every time element update let hook canvas mounted let canvas thisel let context canvasgetcontext objectassign canvas context updated let canvas context let halfheight canvasheight let halfwidth canvaswidth let smallerhalf mathmin halfheight halfwidth contextclearrect canvaswidth canvasheight contextfillstyle rgba contextbeginpath contextarc halfwidth halfheight smallerhalf mathpi contextfill let livesocket new livesocket live hook livesocketconnect notice storing reference canvas newly created rendering context liveview call lifecycle callback point instance viewhook class viewhook instance hold reference provided lifecycle method reference current dom node el various piece data related current set hook long careful overwrite field safe store data next need instruct liveview attach new set canvas hook canvas dom element phxhook attribute canvas datai phxhook canvas canvas supported canvas page reloads see circle rendered gloriously center canvas resizing canvas display glorious circle may appear fuzzy distorted fixed scaling canvas match pixel density display might want resize canvas fill entire available window space accomplish mounted callback mounted let canvas thisel let context canvasgetcontext let ratio getpixelratio context resize canvas ratio objectassign canvas context getpixelratio helper function determines ratio physical pixel current device screen cs pixel used within rendering context canvas const getpixelratio context var backingstore contextbackingstorepixelratio contextwebkitbackingstorepixelratio contextmozbackingstorepixelratio contextmsbackingstorepixelratio contextobackingstorepixelratio contextbackingstorepixelratio return windowdevicepixelratio backingstore resize helper function modifies canvas width height attribute order resize canvas fit current window fixing pixel density issue may experiencing const resize canvas ratio canvaswidth windowinnerwidth ratio canvasheight windowinnerheight ratio canvasstylewidth windowinnerwidth px canvasstyleheight windowinnerheight px unfortunately canvas seem able hold onto change subsequent call updated callback seem lose resize change canvas reverts back original blurry self liveview update canvas dom node reset width height attribute revert pixel density fix also forcefully clear canvas rendering context liveview quick fix getting around problem setting phxupdate ignore canvas element instruct liveview leave canvas element alone initial mount canvas datai phxhook canvas phxupdate ignore canvas supported canvas circle rendered crisply center screen animating circle go way render static circle canvas let tie everything together animate circle based everchanging value provided server first thing need update updated callback grab current value datai attribute let jsonparse canvasdataseti value canvasdataseti reflect content datai attribute data attribute stored string call jsonparse convert value numeric counterpart next update rendering code move circle based value contextarc halfwidth mathcos smallerhalf halfheight mathsin smallerhalf smallerhalf mathpi two change circle rotate around center canvas based entirely realtime data provided server requesting animation frame solution work forcing rerenders browser bad net citizen client may forcing rerenders tab focus may rerendering sixty time per second wasting cpu cycle instead telling browser rerender canvas every liveview update invert control rendering request animation frame browser every update process straight forward updated callback wrap rendering code lambda passed requestanimationframe save resulting request reference thisanimationframerequest thisanimationframerequest requestanimationframe contextclearrect canvaswidth canvasheight contextbeginpath contextarc halfwidth mathcos smallerhalf halfheight mathsin smallerhalf smallerhalf mathpi contextfill conceivable liveview component may update multiple time browser ready rerender canvas situation need cancel previously requested animation frame rerequest new frame placing guard call requestanimationframe thisanimationframerequest cancelanimationframe thisanimationframerequest two change liveview hook politely request animation frame browser resulting smoother experience everyone involved taking using canvas animate numeric value updated realtime liveview process running server demonstrates huge potential power liveview hook much look take thing generating animating much larger set data server check example project simulates two hundred simple particle render client approximately sixty frame per second good idea take approach goal animate bunch particle client probably amazing liveview give u tool absolutely yes sure check entire source example github hook opened door world new possibility liveviewbased application hope demonstration given taste possibility hope eager explore liveview moving forward update technique using phxhook phxupdate ignore single component longer work phoenixliveview version ignore update rule cause hook updated callback called update joxy pointed issue helped come workaround solution landed wrap canvas component another dom element like div leave phxupdate ignore canvas preserve computed width height attribute move phxhook data attribute wrapping div div phxhook canvas dataparticles jasonencode particle canvas phxupdate ignore canvas supported canvas div mounted callback canvas hook need look first child div find canvas element mounted let canvas thiselfirstelementchild finally need pas reference phoenix socket directly livesocket constructor compatible new version phoenixliveview import socket phoenix let livesocket new livesocket live socket hook liveviewpowered confetti generator back running addition small layer markup information update sure check issue filed try get clarity situation like give huge thanks joxy hard work putting fix together
89,Lobsters,elixir,Elixir programming,lumen/lumen - Compile Erlang/Elixir Applications to WebAssembly,https://github.com/lumen/lumen,lumenlumen compile erlangelixir application webassembly,lumen new compiler runtime beam language contributing tool first need install rustup wasmpack repository llvm ninja ccache note building lumen note project structure lumen frontend diagnostics library moved compiler mlir interpreter runtime making change lumen goal nongoals architecture compiler internally compiler represents erlangelixir code form similar continuationpassing style continuation powerful construct enable straightforward implementation nonlocal returnsexceptions green threading optimization primarily performed representation prior lowering llvm ir see eirprojecteir runtime nifs license,lumen new compiler runtime beam language machine vendor operating system host subgroup status unknown unknown macos na unknown unknown linux na apple darwin macos compiler apple darwin macos library apple darwin macos runtime full unknown linuxgnu linux library unknown linuxgnu linux runtime full contributing order build lumen make change need following installed tool first need install rustup follow instruction link installed rustup need install nightly version rust currently ci build nightly require nightly due large number nightly feature use well dependency webassembly target make use use latest nightly rustup default nightly case issue install nightly match ci rustup default may also want install following tool editor support rustfmt required pull request rustup component add rls rustfmt clippy next need install target toolchain rustup target add toolchain name nightly chose previous step also need install wasmbindgen commandline tool cargo install wasmbindgencli set nightly toolchain default need instead cargo nightly install wasmbindgencli finally need wasmpack needed build example get running follow installation instruction wasmpack repository llvm llvm modification used lumen code generation backend needed build compiler typically need build instruction also provide prebuilt distribution everything needed installing prebuilt distribution recommended linux instruction reference xdgdatahome environment variable recommended export xdg variable general replace usage xdgdatahome homelocalshare usual default xdg variable mkdir p xdgdatahomellvmlumen cd xdgdatahomellvmlumen http tar xz stripcomponents f rm cd macos mkdir p xdgdatahomellvm cd xdgdatahomellvmlumen wget http tar xzf rm mv lumen cd nt yet provide prebuilt package operating system need build source following direction building source llvm requires cmake cc compiler python highly recommended also install ninja ccache make build significantly faster especially subsequent rebuilds find dependency system package manager including homebrew macos build le fully automated three simple step git clone http githubcomlumenllvmproject cd llvmproject make llvm install llvm xdgdatahomellvmlumen homelocalsharellvmlumen xdgdatahome set assumes ninja ccache installed customize llvm target makefile use make instead removing g ninja invocation cmake likewise change setting use ccache removing option well note building llvm first time take long time grab coffee smoke em got em etc building lumen llvm installedbuilt build lumen executable make build create compiler executable associated toolchain host machine bin root project invoke lumen via symlink binlumen eg binlumen help compile erlang file executable currently binlumen compile outputdir build lc pathtosourceerl produce executable name source file current working directory exe extension depending platform note compilerruntime still experimental stage stability guaranteed may need provide additional compiler flag linker warns missing symbol eg lpthread project structure lumen currently divided major component compiler interpreter runtime lumen frontend diagnostics library moved eir project includes erlang parser highlevel intermediate representation eir short erlang intermediate representation lumen depends eir library component compiler lumen compiler composed following sublibrariescomponents liblumentarget contains target platform metadata configuration liblumensession contains state configuration single instantiation compiler session find bulk option processing inputoutput generation related item liblumenincremental contains core incremental compilation engine based salsa query inputsparsing defined liblumencompiler contains core compiler driver well higher level query generating artifact parsed source liblumencodegen contains code generation backend divided two primary phase first handle translation eir dialect mlir case llvm ir directly translation mostly aim preserve level abstraction found eir preparing conversion llvm ir second phase conversion mlir dialect llvm bulk codegen work occurs liblumenterm contains essential part term encoding scheme shared runtime library compiler requires order handle encoding constant term compilation interpreter interpreter alternative way test execute erlang code build top eir similar compiler work albeit significant difference due nature interpreting eir rather translating code generation runtime runtime broken multiple library liblumencore contains essential apis interacting system performing allocation well various common type used throughout lumen liblumenalloc contains bulk erlang runtime system core data type apis liblumencrt act core runtime entry point executables handle bootstrapping runtime system linked compilergenerated executables lumenrtcore wip core runtime library used across targetspecific runtimes lumenrtminimal wip experimental runtime library built top lumenrtcore designed platform currently used runtime executables generated compiler lumenweb original webassembly runtime build lumenrtfull lumenrtfull original runtime library target slowly broken smaller piece either merged lumenrtcore new targetspecific runtime crate currently used interpreter contains bif function implemented far collection library correspond ert beam virtual machine making change making major change please open issue tagged rfc problem need solve proposed solution outstanding question term implementation core team use issue talk change either green light proposal request change case proposal may request change either incompatible project goal impose high maintenance complexity burden turned importance rfc discussion first prevents someone bunch work ultimately upstreamed allows core team community provide feedback may make work simpler better end smaller changesbug fix feel free open issue first new project want guidance working fix otherwise acceptable open pr directly fix let review happen always feel free open issue bug even perceived issue question useful resource others please make sure use search function avoid duplication plan participate discussion contribute project aware project tolerate abuse kind member community feel someone abusive inappropriate please contact one core team member directly u want foster environment people new experienced feel welcomed question answered hopefully work together make project better lumen lumen compiler runtime well consists two part compiler erlang native code given target arm webassembly erlang runtime implemented rust provides core functionality needed implement otp primary motivator lumen development ability compile elixir application could target webassembly enabling use elixir language frontend development also possible use lumen target platform well producing selfcontained executables platform lumen different beam following way aheadoftime compiler rather virtual machine operates bytecode additional restriction allow powerful optimization take place particular hot code reloading supported runtime library provided lumen written rust similar differs mostly transparent way one goal provide better foundation learning runtime implemented take advantage rust powerful static analysis catch bug early support targeting webassembly well target result compiling beam application via lumen static executable differs significantly deployment beam work today ie via otp release sacrifice ability perform hot upgradesdowngrades make huge gain crossplatform compatibility ease use simply drop executable compatible platform run tool required special consideration build work way building rust go application work today goal support webassembly build target produce easytodeploy static executables build artifact integrate tooling provided beam language efficient execution removing need interpreter runtime feature parity mainline otp exception nongoals listed nongoals support hot upgradesdowngrades support dynamic code loading lumen alternative implementation erlangotp result battle tested necessarily performant beam chance run benchmark hard know difference two term performance actually lumen intended replace beam point time minimum stated nongoals project mean least percentage project required functionality would missing however meant dropin replacement application better served feature set architecture compiler compiler frontend accepts erlang source file parsed abstract syntax tree lowered eir erlang intermediate representation finally lowered llvm ir codegen performed internally compiler represents erlangelixir code form similar continuationpassing style continuation powerful construct enable straightforward implementation nonlocal returnsexceptions green threading optimization primarily performed representation prior lowering llvm ir see eirprojecteir information compiler frontend eir lowering llvm ir continuation representation stripped away platformspecific method implementing various construct generated example handwritten assembly used perform extremely cheap stack switching scheduler provide dynamic function application facility implementation apply currently cstyle zerocost exception model used implementing exception future proposal progress webassembly may allow u use continuation exception yet stabilized implemented browser compiler produce object file handle linking object together executable also dump intermediate artifact ast eir mlir various form llvm ir llvm bitcode plain assembly runtime runtime design mostly otp running interpreter instead code aheadoftime compiled entry point set environment start scheduler scheduler composed one scheduler per thread scheduler steal work scheduler short work process spawned scheduler process spawned scheduler able steal away load balance io asynchronous dedicated thread event loop dispatch initial version quite spartan focus getting runtime behavior rock solid circle back add capability nifs nifs able defined language c ffi need compiled object file passed via linker flag compiler compiler ensure nifs linked executable design ffi still air likely compatibility layer mimic existing erlnifh interface since runtime different may opportunity provide direct hook part system license apache
90,Lobsters,elixir,Elixir programming,Financial Portfolio rebalancing with Elixir,https://elviovicosa.com/2019/08/25/financial-portfolio-rebalancing-with-elixir/,financial portfolio rebalancing elixir,portfolio investopedia prosperity inflation deflation recession distribution prosperity inflation deflation recession yahoo finance rebalancing portfolio using elixir rebalance alphavantage demo http elviovicosacompermanentportfolio,portfolio portfolio grouping financial asset stock bond commodity currency cash equivalent well fundâ counterpart including mutual exchangetraded closed fund portfolio also consist nonpublicly tradable security like real estate art private investment source investopedia created harry browne assumes economy four possible state prosperity period economic growth thriving business low unemployment rate lowinterest rate inflation period consumer price generally rising deflation opposite inflation recession significant decline economic activity spread across economy distribution based economic condition browne identified volatile asset class proposing following distribution prosperity â stock inflation â gold deflation â long term government bond recession â cash selfregulation factor one fundamental concept idea cover different scenario economy looking way compensate loss increase return concept make appealing people want actively managing portfolio daily even monthly basis take look historical price gold index measure stock performance large company listed stock exchange united state source yahoo finance year global financial crisis stock investor definitively got worried market result value p index plunge year p value stayed low getting back precrisis value case investment purely stock fun ride time around price gold started rising comparing p value time behaviour present almost inverted shape gold value covered stock loss also contributed profitable year many investor incredibly affected crisis holder following return despite small glitch return always positive considering whole period portfolio average return per year one property make usage appealing riskaverse human like fast forward many people concerned new financial crisis germany live declare two consecutive quarterly contraction economy look chart see unbalanced form p gold course looking chart amateur investor draw conclusion whether recession coming next essential highlight behaviour supporting potential crisis scenario rebalancing portfolio portfolio distribution stock gold long term government bond cash change time individual class increase others decrease change shift asset class desired allocation embrace fact market cyclical prosperity time stock value rise gold plunge also time stock market best option rebalancing portfolio mean getting asset class back desired allocation selling one overweight buying underweight one financial crisis created unbalanced portfolio situation portfolio holder sell part gold use profit buy stock extremely low value balance back desired weight long run remember market cyclical continuously rebalancing portfolio using builtin volatility portfolio cheap sell using elixir rebalance use elixir rebalance permanent portfolio essential point thinking optimal rebalancing strategy sell overweight item eg current allocation higher buy underweight item eg current allocation lower using profit overweight sell reduce number operation eg buy sell every transaction also cost take decision based realtime information imagine following interface allocation iau tlt vgsh vti order rebalancexrebalanceportfolio allocation based number allocation amount unit specific item call rebalancexrebalanceportfolio return number order performed order contain information given symbol must bought sold kept sell iau sell tlt sell vgsh buy vti considering point code responsible rebalancing portfolio defmodule rebalancex alias rebalancexquote underweight overweight def rebalanceportfolio allocation quoteservice quote portfolio cash allocation allocation price getprices allocation quoteservice newportfolio dorebalanceportfolio portfolio price createorder portfolio newportfolio end defp dorebalanceportfolio portfolio price position getpositions portfolioallocations price weight getweights position underweightsymbol getunderweight weight overweightsymbol getoverweight weight portfolio maybebuyunderweight underweightsymbol price maybeselloverweight overweightsymbol price mayberebalanceagain underweightsymbol overweightsymbol price end defp getprices allocation quoteservice allocation enumreduce fn symbol acc mapput acc symbol quoteservicepricefor symbol end end defp getprice price symbol mapfetch price symbol end defp getpositions portfolio price portfolio enumreduce fn symbolname unit acc mapput acc symbolname getprice price symbolname unit end end defp getweights position totalvalue enumreduce position fn position acc position acc end position enumreduce fn symbolname position acc mapput acc symbolname position totalvalue end end defp getunderweight weight symbol weight weight enumfilter fn value value underweight end enumminby fn value value end fn nil nil end symbol end defp getoverweight weight symbol weight weight enumfilter fn value value overweight end enummaxby fn value value end fn nil nil end symbol end defp maybebuyunderweight portfolio nil portfolio end defp maybebuyunderweight portfolio symbol price price getprice price symbol maybebuyunderweight portfolio symbol price portfoliocash end defp maybebuyunderweight portfolio symbol price cash cash price portfolio incr symbol withdraw price end defp maybebuyunderweight portfolio symbol price cash portfolio end defp maybeselloverweight portfolio nil price portfolio end defp maybeselloverweight portfolio symbol price price getprice price symbol portfolio decr symbol deposit price end defp mayberebalanceagain portfolio nil nil price portfolio end defp mayberebalanceagain portfolio price dorebalanceportfolio portfolio price end defp incr allocation allocation portfolio symbol newallocations mapput allocation symbol allocation symbol portfolio allocation newallocations end defp decr allocation allocation portfolio symbol newallocations mapput allocation symbol allocation symbol portfolio allocation newallocations end defp deposit cash cash portfolio amount portfolio cash cash amount defp withdraw cash cash portfolio amount portfolio cash cash amount defp createorder allocation oldallocations allocation newallocations enummap oldallocations fn symbol oldunits cond newallocations symbol oldunits buy symbol newallocations symbol oldunits newallocations symbol oldunits sell symbol oldunits newallocations symbol true keep symbol end end end end thing point rebalancexquote module fetch realtime price using alphavantage api buy sell single unit time reevaluates weight affected keep rebalancing portfolio underweight overweight item order created comparing original portfolio rebalanced one demo created project visualize evolution value time starting amount change different variable like monthly deposit rebalancing strategy region see impact final value demo project api built using elixir plug frontend application built using react redux data visualization using visit http elviovicosacompermanentportfolio test live
92,Lobsters,elixir,Elixir programming,Elixir + gRPC: the road to production,https://code.tubitv.com/elixir-grpc-the-road-to-production-5d7daad4945b,elixir grpc road production,elixir grpc road production grpc elixir rpc remote procedure call protobuf erlang otp elixirgrpc performance best practice benchmark benchmark stability cowboy interoperability test envoy interceptor envoy official guide statsd interceptor prometheus interceptor corner case goaway conclusion come join tubi,elixir grpc road productiontubi stream thousand free movie series million user hope leverage technology deliver happiness user last year combined grpc elixir run several mission critical service production service used serve listing title content metadata exhaustive detail essential part core viewing experience tubigrpc highperformance rpc remote procedure call framework derived google us protobuf define rpcs used generate code different language think using transport encoded protobuf using grpc consistent interface teamselixir modern functional language designed building scalable maintainable application elixir built top erlang whose actor model otp library manage actor allow u build lowlatency faulttolerant system handful engineersas primary author elixirgrpc grateful contribution community happy see work help u building service let talk interesting lesson learned recent workperformanceone protobuf message field need return hundred sometimes found slow encode decode much data one reason grpc request slow improved decoding performance encoding end explain decoding improvement detailwe manipulate binary data flexibly highlevel language like erlangelixir program may slow unnecessary memory allocation especially project like protobuf processing binary data follow best practice erlang avoid kind problemfor example want parse binary sum last bit every byte two possible alternative elixir binaryparsefast faster erlang optimization avoiding creating sub binary know remaining binary passed function directly benchmark show fast version twice fast slow version erlang provides compile option give u hint potential problem export erlcompileroptionsbinoptinfo mix run binaryparseslowexswarning binary created binary used term returned function mix run binaryparsefastexswarning optimized match context reused good mean erlang compiler optimize code otherwise try improve help u lot optimizing protobufelixir performancebesides elixirgrpc support compression protobuf produce smaller data compared json generally compression still good result case like protobuf message many string use utility like gzip compress data may help reduce network traffic improve performanceperformance tuning never finished many area improved like protobuf encoding library optimization even improved performance benchmark still need run benchmark using test case please let u know find performance fit situationstabilityit difficult judge software stability used many user elixir service unavailable user watch title perhaps worst thing video streaming companywe gain confidence erlangotp cowboy productionready http server provides solid foundationinteroperability test elixirgrpc cover feature grpc implementation like large response streaming request error etcplenty test run hour service datasetnow multiple businesscritical production service running interceptorsenvoy proxy sidecar service manages connection service provide useful feature like dynamic service discovery load balancing retries need implement feature every service already firstclass component tubi infrastructure time using reduces work lot like grpc load balancing elixirgrpc builtin clientside load balancing official guide describes envoy lot metric like request rate response time useful detailed metric still missing like request rate response time per grpc method collect detailed metric using interceptor middleware elixirgrpc builtin interceptor like statsd interceptor prometheus interceptor even write example many platform like firetv web io android whose performance qps different wrote interceptor add platform tag metricscorner casesthough cowboy gun http client good support still new feature handle corner case well like may get error deploying service problem solved simple retries make request slow fixed problem trying merge improvement upstreamfirst flow control add flow control allow application control fast peer send data window side control data frame like http body sent peer windowupdate frame need sent update peer window data frame sent windowupdate frame sent correctly communication stuck big problemin cowboy window correct time wrong one stream terminates early like raising error prevent stream sending message connection stream timeout new connection need flow control examplein graph client maintains connectionlevel window stream level window know many byte send server let keep simple say initial window flow control algorithm simply sending windowupdate receiving data step client sends data frame byte stream window decreased server sends windowupdate frame back client window increased normal casestep client sends data frame byte stream window decreased server close stream sending windowupdatestep spec request peer send windowupdate even case stream closed abnormally otherwise connectionlevel window wrong cowboy handle wellstep new stream send data connectionlevel window client hang hereanother issue gun handle goaway well goaway frame used shut connection gracefully gun problem may get error deploying servicesin graph deploying service server first sends goaway frame containing stream identifier last peerinitiated stream client continue handling stream stream stream id le id goaway finished create new stream connection stream gracefully shut connectionthe problem gun return error instead continuing handle existing stream moment graph show client get error unfinished stream stream gun handle goaway wellconclusionswith success combination grpc elixir going build service using elixirgrpc future building project like elixirgrpc hard beginning making ready use production real fun deep learning happens business grows rapidly challenge always ready solve kind interesting technical problem want fun working cutting edge technology scale come join tubi
93,Lobsters,elixir,Elixir programming,Macro Madness: How to use `use` well,https://dockyard.com/blog/2017/12/07/macro-madness-how-to-use-use-well,macro madness use use well,kernel callback real code genserver make dialyzer happy helpful error message easier debug doc genserver put callback module default implementation defined macro example miskatonic university william dyer williamdyer old one naming hard great old one gustafjohansen using bobhoward bobhoward bobhoward laundry jepsen yithians carlyraejepsencompilationerror carlyraejepsenclientstartlinkcallback getmodule nathaniel wingate peaslee clause match defoverridable defoverridable defoverridablebehaviour tl dr,elixir macro used define thing would keywords language defmodule def defp defmacro defmacrop macro defined standard library kernel exunit assert able run code passed see test passing also print code fails need custom dsl show tested genserver use genserver defines default implementation required callback want headtrip look implementation defmacro defined using defmacro defmacro defmacro call expr nil define defmacro call expr caller end worry like language defined defmacro defined using bootstrap library written underlying language elixir case elixirbootstrap defines minimal version defmodule def defp defmacro defmacrop erlang enough kernel parsed defines full version way need last version elixir build next version erlang import kernel except defmodule def def defp defmacro defmacro defmacrop import elixirbootstrap kernel macro allow u generate code dynamically compile time one reason added elixir reduce amount boiler plate needed written behaviour genserver erlang boiler plate manually added file using emacs template introduction optionalcallbacks attribute erlang way add new callback without everyone update code add copy default implementation genserver callback need implement every genserver use would need correct signature return value callback implement bare minimum get away oneliners case need remember shape return even care hotcode upgrade additionally oneliners raise type check dialyzer warn nonlocal return dialyzer way saying raising exception throwing real code genserver make dialyzer happy give helpful error message easier debug def init args ok args def handlecall msg state raise implemented def handleinfo msg state errorloggererrormsg p p received unexpected message pn module self msg noreply state end def handlecast msg state raise implemented def terminate reason state ok def codechange old state extra ok state read doc genserver know need implement callback put use genserver callback module default implementation defined go haphazardly copy default implementation callback module single line like defmodule various def call definition use keyword elixir macro kernel think use convention keyword use magic short piece code complex give convenience automatically require using macro macro used without explicit require first us enummap pas multiple alias use namespace raise argumenterror called wrong defmacro use module opts call enummap expandaliases module caller fn expanded isatom expanded quote require unquote expanded unquote expanded using unquote opts end otherwise raise argumenterror invalid argument use expected compile time atom alias got macrotostring module end quote unquotesplicing call end use call using macro using macro supposed requirement behaves like macro return quoted code rest convention best practice doc kerneluse example let look example using using misteps make along way fix working miskatonic university william dyer started compendium various specie university encountered university mad enough try bring earth use client library establish communication grad student working field defmodule miskatonicoldones def get id ok clientpid clientstartlink miskatonicclientshow clientpid id end end defp clientstartlink miskatonicclientsportalstartlink entrance witchhouse end end miskatonicoldones williamdyer researching old one miskatonic grad student found record referring greater specie old one studying naming hard miskatonic started call great old one defmodule miskatonicgreatoldones def get id ok clientpid clientstartlink miskatonicclientshow clientpid id end end defp clientstartlink miskatonicclientsboatstartlink latitude longitude end end miskatonicgreatoldones gustafjohansen two module get function getting research resource communicate grad student field differ want make communicating new exciting thing want drive u mad easier keep losing grad student need refactor two module extract common piece general shape function take id internally function hide different way communicate realm different specie defmodule miskatonicspecies def get id ok clientpid clientstartlink miskatonicclientshow clientpid id end end defp clientstartlink end end using use using use convention move definition quote block using macro new general miskatonicspecies module move move clientstartlink defmodule miskatonicspecies defmacro using quote def get id ok clientpid clientstartlink miskatonicclientshow clientpid id end end end end end miskatonicspecies bobhoward use miskatonicspecies allow u get rid duplicate code module still need clientstartlink since differs defmodule miskatonicoldones use miskatonicspecies defp clientstartlink miskatonicclientsportalstartlink entrance witchhouse end end miskatonicoldones bobhoward defmodule miskatonicgreatoldones use miskatonicspecies defp clientstartlink miskatonicclientsboatstartlink latitude longitude end end miskatonicgreatoneone bobhoward bob howard get pulled project sent laundry new grad student carly rae jepsen need contact yithians old one fought seeing useful use miskatonicspecies module carly rae jepsen try get cryptic error message undefined defmodule miskatonicyithians use miskatonicspecies end miskatonicyithians carlyraejepsencompilationerror compilation error file libmiskatonicyithiansex compileerror undefined function stdlib stdlib mix compile carly rae track miskatonicspecies depends defined miskatonicspecies currently making best use compiler tell developer using callback declare required behaviour miskatonicspecies carly rae add quote block defmodule miskatonicspecies callback clientstartlink ok pid error reason term defmacro using quote behaviour miskatonicspecies def get id ok clientpid clientstartlink miskatonicclientshow clientpid id end end end end end miskatonicspecies carlyraejepsenclientstartlinkcallback great carly rae get compiler warning specific carly rae need clientstartlink miskatonicyithians look like callback implementation need public change defp clientstartlink def clientstartlink warning undefined behaviour function behaviour miskatonicspecies warning undefined behaviour function behaviour miskatonicspecies warning undefined behaviour function behaviour miskatonicspecies mix compile switch public learn old one great old one yithians code could better although writing def get every file stored see ask debug info one function big deal add function unnecessary bloat know exactly code code loading still take time beam even faster language need interpreted source first iex ok module debuginfo version backend data beamlibchunks builddevlibmiskatonicebinelixirmiskatonicyithiansbeam debuginfo iex ok debuginfo backenddebuginfo module data iex ok definition definition backenddebuginfo module data iex listkeyfind definition get get def line generated true line generated true id counter line miskatonicspecies line line ok clientpid counter line miskatonicspecies clientstartlink line line miskatonicclient show line clientpid counter line miskatonicspecies id counter line miskatonicspecies general approach want take making function using quote block short possible recommend immediately calling normal function outer module take module argument reason recommended always passing module illustrated well module needed called outside quote block module call use miskatonicspecies anymore defmodule miskatonicspecies callback clientstartlink ok pid error reason term defmacro using quote behaviour miskatonicspecies def get id miskatonicspeciesget module id end end def get module id ok clientpid moduleclientstartlink miskatonicclientshow clientpid id end end end miskatonicspecies getmodule carly rae jepsen good job code university want risk going mad field miskatonic university decided fund another graduate position team nathaniel wingate peaslee join team discovers yithian psychic link limited swamping location used swap time mean study yithians miskatonicyithians module try mind transferring yithian different time getting info yithian fails defmodule miskatonicyithians use miskatonicspecies def clientstartlink keywords yithian librarian miskatonicclientspsychicstartlink keywords end def get id case miskatonicspeciesget module id error notfound ok pid clientstartlink yithian coleopterous miskatonicclientshow pid id end found found end end end miskatonicyithians clause match ah nathaniel seems unable override use miskatonicspecies inserting line line use miskatonicspecies called line nathaniel wrote def get warning clause match previous clause line always match mix compile use defoverridable function defined quote block overridden outer scope defines name arity instead outer scope appending clause name arity although mixing clause quote block outer scope allowed mostly going cause confusing bug recommend always marking function defined quote block defoverridable quote function clause defined yes quote function us quote clause function us quote clause quote defmodule function us quote defmodule clause function us defmodule clause nathaniel mark overridable override work without warning defmodule miskatonicspecies callback clientstartlink ok pid error reason term defmacro using quote behaviour miskatonicspecies def get id miskatonicspeciesget module id defoverridable get end end def get module id ok clientpid moduleclientstartlink miskatonicclientshow clientpid id end end end miskatonicspecies defoverridable able override defoverridable function call overridden function super allows user using macro look implementation function overriding mean code likely continue working change implementation detail defmodule miskatonicyithians use miskatonicspecies def clientstartlink keywords yithian librarian miskatonicclientspsychicstartlink keywords end def get id case super id error notfound ok pid clientstartlink yithian coleopterous miskatonicclientshow pid id end found found end end end miskatonicyithians defoverridable miskatonic university library really well still slight bug every module overridable callback may seem weird mark callback since client code call want make test mock test code depends miskatonicspecies really need callback making callback also use compact form defoverridable take name behaviour whose callback overridable instead listing function namearity defmodule miskatonicspecies callback clientstartlink ok pid error reason term callback get id stringt term defmacro using quote behaviour miskatonicspecies def get id miskatonicspeciesget module id defoverridable miskatonicspecies end end def get module id ok clientpid moduleclientstartlink miskatonicclientshow clientpid id end end end miskatonicspecies defoverridablebehaviour one final check elixir give u impl impl like override java better mark function implementation callback document behaviour function make finding doc source easier reader force callback behaviour use impl maintain consistent documentation miskatonicspecies one behaviour stack behaviour building top genserver marking callback genserver behaviour helpful defmodule miskatonicspecies callback clientstartlink ok pid error reason term callback get id stringt term defmacro using quote behaviour miskatonicspecies impl miskatonicspecies def get id miskatonicspeciesget module id defoverridable miskatonicspecies end end def get module id ok clientpid moduleclientstartlink miskatonicclientshow clientpid id end end end miskatonicspecies impl tl dr let review miskatonic university finding thank graduate student turning mad use use call using call quote inject default implementation defs quote block declared callback outer module defmacro using put behaviour outer module behaviour name top quote block default function oneliners call function name outer module module prepended argument mark default function impl force callback behaviour also use impl double check got name arity right callback implementation quote block use passed module whenever need call another callback outer module function override callback always called call outer module function directly use defoverridable outer module confusing error clause mixing quote block use using module note updated clarify defoverridable table
94,Lobsters,elixir,Elixir programming,Phoenix Phrenzy: Build exciting demos using Phoenix LiveView,https://phoenixphrenzy.com/,phoenix phrenzy build exciting demo using phoenix liveview,phoenix phrenzy,phoenix phrenzy build exciting demo using phoenix liveview phoenix phrenzy contest developer build phoenix liveview show software engineering skill help demonstrate capability great technology open source community sake simplicity contest prize bragging right contest complete winner vote tally remain publicly listed site
95,Lobsters,elixir,Elixir programming,Pattern Matching Versus Elixir's Access Behavior,https://stratus3d.com/blog/2019/07/13/pattern-matching-versus-elixirs-access-behavior,pattern matching versus elixir access behavior,,nummapkeys numkeystotal key numkeystotal enummap fn key integertostring key end map key enumtakerandom nummapkeys mapnew true numtimes bencheerun compare empty loop baseline baseline fn key key numtimes ok ok end mapget fn key key numtimes mapget map key end ok end access fn key key numtimes map key end ok end
96,Lobsters,elixir,Elixir programming,Litmus: Data validation library in Elixir,https://github.com/lob/litmus,litmus data validation library elixir,litmus installation usage supported type plug integration example,litmus data validation elixir installation package installed adding litmus list dependency mixexs def deps litmus end usage litmus validates data predefined schema function data valid function return ok data data returned coerced according provided schema data passed follow rule defined schema function return error errormessage also return error receiving field specified provided schema schema id litmustypeany required true username litmustypestring minlength required true pin litmustypenumber min max required true newuser litmustypeboolean truthy falsy accountids litmustypelist maxlength type number rememberme litmustypeboolean default false params id username user pin newuser accountids litmusvalidate params schema ok id newuser true pin username user accountids rememberme false litmusvalidate schema error id required supported type litmus currently support following type litmustypeany litmustypeboolean litmustypedatetime litmustypelist litmustypenumber litmustypestring plug integration litmus come plug easy integration plug builtin router automatically validate query parameter body parameter passing litmusquery litmusbody private option route declaring plug must include function called validation fails recommended initialize plug match dispatch plug want processing stop validation error sure halt request example defmodule myrouter use plugrouter plug plugparsers parser urlencoded multipart plug match plug litmusplug onerror plug dispatch schema id litmustypenumber required true get test private litmusquery schema plugconnsendresp conn item end post test private litmusbody schema plugconnsendresp conn item end def onerror conn errormessage conn plugconnsendresp errormessage plugconnhalt end end
97,Lobsters,elixir,Elixir programming,The wide world of almost-actors: comparing Pony to BEAM languages,https://www.youtube.com/watch?v=_0m0_qtfzLs,wide world almostactors comparing pony beam language,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature scott lystig fritchie wide world almostactors comparing pony beam language youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature scott lystig fritchie wide world almostactors comparing pony beam language youtube
98,Lobsters,elixir,Elixir programming,Why am I interested in Elixir?,http://underjord.io/why-am-i-interested-in-elixir.html,interested elixir,interested elixir juicy bit otp beam erlang root phoenix phoenix presence crdt phoenix liveview demo live ecto nerve nerve project push firmware ssh scenic scenic github talk rustler rustler github eir summary lars underjordio,interested elixir juicy bit elixir brain recently recently probably mean year defense think fair say blooming right much need opportunity daytoday maintaining python legacy system renewing another legacy optimizing elasticsearch tried hobby project spent time fun mostly really watched community feeling want primarily touch beam otp phoenix presence phoenix liveview nerve scenic rustler make interesting programming language try religious matter try outline attracted elixir made keep yearning digging recently made time actually get comfortable otp beam erlang root elixir built foundation laid erlangotp run vm called beam sometimes beam vm matter long time web stuff primarily care much underlying runtime environment involved microservice implementation lot multithreading python story fairly wellknown lock gil solution thread safety considerable rather pragmatic tradeoff experience made pay attention concurrency parallelism core usage addition sort bother lot desktop application bad using multiple core would make sense specifically considering cpu core count modern machine anyway beam built run distributed fashion believe came really used multiple core happened carry particularly well scheduler facility spawn lightweight process o thread process isolated communicate message passing bit copying data lot le problem understand beambased application launch vm default number thread equal core count machine process scheduled across thread thing make beam really interesting thing generally come otp open telecom platform designed build telecom system ericsson purpose high focus resilience recovery feature never heard elsewhere hot update resilience recovery idea supervision tree idea hierarchy supervisor process monitoring part application part also supervisor underlying structure process supervisor branch like tree supervision supervision tree something go wrong process crash supervisor part responsible making sure recover good state nt supervisor crash passing buck tree supervisor may know recover build thought error surface level handle save simple code handle every potential error could suffer point tree correct place handle problem handled given birth saying let crash may terrible general marketing might sound interesting tech people much nuance think supervision tree make think architecture application healthy layered way build tree stable trunk usually ephemeral leaf also translates interesting thinking see scenic another rare feature need incredibly rad hot code update way update application running replacing version module running dug seems rad guess annoying bring telephone switch update software used much simpler system think fascinating concurrency robustness resilience distribution model erlangotp beam brings making thing happen believe quite exists programming environment seen least make interesting runtime let get project leverage phoenix elixir showed radar phoenix ecto let put pin ecto phoenix web framework elixir rail ruby idea phoenix batteriesincluded automagical rail different focus phoenix definitely feel explicit le magical like provides nt seem overprovide worked ton seems solid project language need strong web framework phoenix fit bill find interesting allowed people chris mccord merry crew conspires brainwarping work make compelling idea land optional library phoenix one mind called presence liveview phoenix presence allows tracking currently online different device similar metadata provided distributed system eventually consistent way us particular crdt achieve limit amount data need passed around allowing reliable distributed reporting client connection phoenix channel system layer top websockets typical usecase chat service online went offline actually contact right mobile active desktop distribute data eventually everyone get memo even server go come back actually missed memo well use phoenix presence basically worry could done language runtimes imagine beam already distribution system already made run one place place likely large part done want build presence functionality need make work distributed fashion living stated goal ecosystem phoenix liveview recently made available public quite release state last time checked fully working though clever curious one chris wanted save backend developer needing write javascript every trivial little piece interactivity u know drill need progressive enhancement form validation suddenly need frontend javascript backend support suddenly complexity liveview way rendering page function basic page form j active hook liveview javascript liveview backend endpoint talk phoenix channel voila lot frontendscripting backend saw chris demo live elixirconf treat already knew supposed blown away detail cleverness minimal overhead ecto mostly database library also used validation come see independent sql root day generally encounter phoenix database operation scratched surface actual use approach idea database library novel way quite seen recommend reading nerve nerve project oh one love take resilience beam put minimal linux image add elixirerlang application burn firmware image sd card plug computer typically embeddedlevel device raspberry pi ready fun nerve built create connected device iot try provide developer convenience along resilient le frustrating state affair beam good recovery resilience iot famed durability would say nerve definitely move needle area instead running everything raspbian installation includes device starting minimal linux bundle elixir code beam basically operating system along part linux feel need add project allows get started building serious software project durable solution le work nicer workflow team incredibly responsive elixir slack nerve channel well support raspberry pidevices great common hobbyelectronicsneeds library gpio spi uart networking many shape form importantly push firmware ssh stress enough useful actually ported pimoroni inky eink display library elixir using nerve heavily process people joined help get presentable useful find version inky also experimented using nerve sensor hub ongoing project hampered mostly incompetent soldering nerve incredibly useful project making something beyond toy small linux server raspberry pi though work great toy project absolutely fantastic resource learn working hardware linux buildroot people community channel incredibly dedicated helpful heard nothing quite like building embedded device single board computer size also people use push application cloud new firmware seems fun nerve team also developing nerveshub solution managing fleet device secure firmware update encryption hardware sort thing typically difficult expensive infrastructure develop iot device seems straight forward scenic scenic github independent functional ui framework say independent run close basic opengl given platform believe depends glfw get thing going desktop operating system custom driver raspberry pi official touchscreen qt electron whatever else crossplatform ui day something look every native closetonative ui require webbrowser chromium slow pi webbrowser always best experience mean open port mean lot software beyond need web browser immense platform compared application need especially embedded situation scenic focused towards embedded device fixedsize screen quite minimalist wellfeatured interesting design believe component ui arranged supervision tree graph component primitive us resilience feature otp create ui specific component crash without bringing whole ui recover might lose data problem isolated bunch cool aspect design allows thing multiple viewportsdisplays potential wild thing future get best overview talk code beam sto good conf still early day scenic use right fast friendly plan boyd fascinating saying early day much come interested getting ground floor scenic channel elixir slack good place drop good people let u know want contribute somehow try running come share joy confusion rustler rustler github elixir beam limitation moment fp paradigm limiting want call native functionality implemented elixirfriendly way escapehatches integrating language system built beam powerful one probably nif native implemented function generally way write function c got ta go fast nifs bit risky actually cause problem beam write memory issue nif memory issue beam nice supervision tree unlikely save barely touched rust understanding away lot riskiest part system language allowing efficiency sonny scroggin held talk really piqued interest code beam sto year sadly video seem release yet rustler project cool norwegian named han working seems quite mature make nifs using rust work nicely easily keeping beam safe hopefully thing likely use bridge alsa territory see looking forward trying han also additionally mindbending call eir stuff concerning intermediate representation beam code making work llvm held talk boil two proofofconcepts niffy allows smack small annotation function elixir compiled nif instead running beam far understand least whirl would let beam language run webassembly seems wild fun summary beam otp runtime platform provides cool possibility seen elsewhere cheap easy parallelism concurrency beyond distribution important resilience scalability base especially appearance elixir often considered approachable erlang see interesting us tech pop nerve scenic set mind fire possibility fascinating ecosystem springing around elixir nt know anything quite like intended hyperbole slight favored language simply enthusiastic possibly ignorant much cooler toy access tell know languagesruntimes actually provide similar tool seen similarly singular fantastic potential open source space pas revolutionary thing elixir space love hear get touch lars underjordio
99,Lobsters,elixir,Elixir programming,Performance of Elixir's Access Behavior,https://stratus3d.com/blog/2019/06/29/performance-of-elixirs-access-behavior,performance elixir access behavior,,defmodule elixiraccessbenchmark impls elixiraccess elixirmapget time numkeys key map numkeystoinclude def measure module map key time ok timertc module measureimpl module map key time end def run enumeach impls fn module ioputs benchmarking module time runimpl module len length time total listfoldl time fn time sum time sum end average total len ioputs average time looking key inspect average microsecond end end def runimpl module enummap time fn listofkeys generatekeys map generatemapwithsomekeys listofkeys measure module map listofkeys end end def measureimpl module map key enumeach key fn key apply module get map key end end defp generatekeys numkeys enumtolist enummap fn key integertostring key end end defp generatemapwithsomekeys key key enumtakerandom numkeystoinclude mapnew fn key key true end end end elixiraccessbenchmarkrun
100,Lobsters,elixir,Elixir programming,An Unprecedented Subtraction,https://medium.com/erlang-battleground/erlang-elixir-list-subtraction-wat-5b764020d69c,unprecedented subtraction,going elixir whole page doc right left side integer erlang erlang expression table dedicated self self self something flush something,going usual better first try decipher mystery go ahead check found know happening fair elixir dev slightly better situation erlang counterpart documentation believe much clearerbut let go step step first let see happens add parenthesis iex actually make sense look like associate right left let see find documentation prof itin elixirwhat looking operator associativity elixir actually whole page doc dedicated see binary two argument list operation associate right leftthat easyas aside let try verify one actually right argumenterror range first last expect side integer got elixir erlangnow let try find thing page operator associativity google carefully redirected doc erlang expression deep last part page find table dedicated operator precedencetable operator precedenceif squint bit find see right associative like never seen operator erlang row actually stating right associativewhich actually cool since let stuff self self self flush shell got somethingshell got somethingshell got something broadcast message pi yeah article insightful deep revealing others topic sitting towrite list almost year way
101,Lobsters,elixir,Elixir programming,Pleroma 1.0.0,https://blog.soykaf.com/post/pleroma-1.0/,pleroma,pleroma pleroma post poll doc doc otp release documentation switch tracker lot stuff changelog doc thanks,long month bugfix security release finally releasing longawaited release nine pleroma know great pleroma favorite free software federated social network written elixir really know yet check post think achieved state project call let talk bit new stuff store poll know secondfavorite social network also make funny poll pleroma rule bit relaxed elsewhere make lot option attach picture want want know rei asuka best girl find doc doc finally find u irc anymore figure install new emojis otp release otp release interesting hosting pleroma server bundle compiled pleroma code necessary runtime file erlang elixir need install seperately kind like binary release pleroma check documentation switch current source based installation method also allow change configuration setting without recompilation word warning method release still slightly experimental encounter anything weird please file issue tracker switch back source based installation needed lot stuff check changelog doc find cool new stuff like emoji pack mix task help keep database small mongooseim integration share account xmpp thanks first want thank reading blog post want thank people work pleroma many mention name thankful made possible without code base fediverse community also want thank everybody contributes pleroma way code write issue bug tracker run instance donate time money another way appreciated last want thank fediverse community working pleroma fun technology make fun actually use stuff look forward great year pleroma fediverse let make happen sooner pyongyang escape social network stuff see ya
102,Lobsters,elixir,Elixir programming,Building and Playing the Go Game with Phoenix LiveView,https://blog.appsignal.com/2019/06/18/elixir-alchemy-building-go-with-phoenix-live-view.html,building playing go game phoenix liveview,phoenix liveview go final result phoenix liveview let go starter app source code readme module documentation module http making move preventing illegal move capturing stone scoring history ko rule ko rule,welcome back another elixir alchemy time discover power phoenix liveview building interactive game rendering html server communicating frontend backend web socket liveview help u build realtime interface without writing javascript worrying updating state browser updating state server side liveview make sure update part page need resulting fast application send minimal amount data wire illustrate build game phoenix use liveview make interactive although tictactoe fun go something bit ambitious building go go abstract strategy board game two player aim surround territory opponent game invented china year ago believed oldest board game continuously played present day final result implementation go game allows player take turn placing stone board player capture stone game keep track stone captured along way learn phoenix liveview help build interactive application without duplicating code frontend backend keeping everything elixir let go starter app phoenix application part already set master branch hold source code completed project prefer skip ahead starter app clean generated file add styling go board preinstalls phoenix liveview according install guide readme module keep track game state game state module describes state game starter app already come state module focus working liveview state struct keep track stone board position list know player next current key libhayagostateex defmodule hayagostate alias hayagostate defstruct position enummap fn nil end current black end newly created state initialized list nil value position board empty position player black stone first move current key set black new state state module expose two function first place new stone board new stone steal liberty another stone captured stone removed board automatically legal function check move legal checking another stone already occupies position making sure stone immediately captured like learn implementation state module use check module documentation explains handle placing stone board capturing stone validating possible move gamelive module start rendering board first add live view application handle rendering updating board called gamelive callback function libhayagoweblivegameliveex defmodule hayagowebgamelive use phoenixliveview def render assigns hayagowebgameviewrender indexhtml assigns end def mount session socket ok assign socket state hayagostate end end callback set assigns socket set initial state view use create new state add socket assigns make available template next add template render board name indexhtmlleex making live eex template although similar regular eex template live template track change order send minimal amount data wire whenever view update libhayagowebtemplatesgameindexhtmlleex div class board statecurrent position statepositions button button end div loop position state struct assigned live view empty button element button div element stylesheet automatically style go board also add current color class name board allow stylesheet show stone place hover position finally route request gamelive module router libhayagowebrouterex defmodule hayagowebrouter scope hayagoweb pipethrough browser live gamelive end end start phoenix server navigate http browser see app render empty go board place stone yet hovering position board show u new stone would placed making move place stone board state implement function take state struct index replaces position corresponds index value current key either black white depending player turn template add phxclick phxvalue attribute button attribute tell liveview send event gamelive module libhayagowebtemplatesgameindexhtmlleex div class board value index enumwithindex statepositions button phxclick place phxvalue index class value button end div live view handle event matching attribute set template use passed index call return new state stone placed board return noreplytuple new state libhayagoweblivegameliveex defmodule hayagowebgamelive def handleevent place index assigns assigns socket newstate stateplace assignsstate stringtointeger index noreply assign socket state newstate end end updating state socket liveview know rerender part template changed updated page compared rendered page apply minimal patch alreadyrendered page back browser automatically refreshed page made change project already starting look like proper go game place stone board even surround enemy stone removed look thing write code send data browser worry updating rendered page liveview took care updating page whenever state changed however click position twice already placed stone replaced another prevent happening disable button represent illegal move preventing illegal move prevent illegal move render disabled button every position either stone already one newly placed stone liberty make work use statelegal take current state index return value indicating whether current player place stone div class board statecurrent value index enumwithindex statepositions hayagostatelegal state index button phxclick place phxvalue index class value button else button class value disabled disabled button end end div liveview take care updating page add ifstatement template check placing stone position legal move render button otherwise render disabled button stylesheet make sure show hovers disabled button change cursor indidcate stone placed capturing stone capturing stone function increment counter current state capture map hold counter black white stone captured stone show stone board since capture already available state struct receive live view loop counter render span correct class name stylesheet turn button div class capture div statecapturesblack statecapturesblack span class black span end div div statecaptureswhite statecaptureswhite span class white span end div div since using range list comprehension make sure add filter ensures list empty looping way keep track stone captured stone displayed board scoring history ko rule made stride implementing go learned set liveview project seen carefully updating state enough make build interface without worry updating view instead focussed rendering static representation current state left work updating page player see liveview aside setting live view module code wrote show state board done adding logic template write javascript however still thing next time meet add history game allow player undo move implement ko rule prevent repeating move see
103,Lobsters,elixir,Elixir programming,Elixir v1.9 released,https://elixir-lang.org/blog/2019/06/24/elixir-v1-9-0-released/,elixir released,fernando tapia rico release distillery dockyard distillery plataformatec elixirconf paul tristan erlang relx hex package manager already using release production release released assembled hook configuration extensive documentation release configuration relying configuration undesired library improvement next issue tracker cirrusci install section getting started guide advanced mix otp start elixir,elixir release support improved configuration also glad announce fernando tapia rico joined elixir core team fernando extremely helpful keeping issue tracker tidy fixing bug improving elixir many different area code formatter iex compiler others let take look new new version release main feature elixir addition release release selfcontained directory consists application code dependency plus whole erlang virtual machine vm runtime release assembled packaged deployed target long target run operating system o distribution version machine running mix release command release always part elixir community thanks paul schoenfelder work distillery exrm distillery announced july dockyard hired paul work improving deployment effort would lead distillery distillery provided important answer area community struggling establish convention best practice configuration beginning year thanks plataformatec able prioritize work bringing release directly elixir paul aware wanted release elixir elixirconf announced release last planned feature elixir goal elixir release double important concept provided distillery provide extension point bit community may find important paul tristan maintains erlang relx provided excellent feedback elixir implementation thankful hex package manager already using release production also got feedback company enough background let see would want use release assemble one release release allow developer precompile package code runtime single unit benefit release code preloading vm two mechanism loading code interactive embedded default run interactive mode dynamically load module used first time first time application call vm find enum module load downside start new server production may need load many module causing first request unusual spike response time release run embedded mode load available module upfront guaranteeing system ready handle request booting configuration customization release give developer fine grained control system configuration vm flag used start system selfcontained release require source code included production artifact code precompiled packaged release even require erlang elixir server include erlang vm runtime default furthermore erlang elixir standard library stripped bring part actually using multiple release assemble different release different configuration per application even different application altogether management script release come script start restart connect running system remotely execute rpc call run daemon run window service released assembled start new project assemble release three easy step mix new myapp cd myapp mixenvprod mix release release assembled buildprodrelmyapp inside release binmyapp file entry point system support multiple command binmyapp start binmyapp startiex binmyapp restart binmyapp stop general management release binmyapp rpc command binmyapp remote running command running system connect running system binmyapp eval command start fresh system run single command shuts binmyapp daemon binmyapp daemoniex start system daemon unixlike system binmyapp install install system service window machine hook configuration release also provide builtin hook configuring almost every need production system configconfigexs configprodexs provides buildtime application configuration executed release assembled configreleasesexs provides runtime application configuration executed every time release boot extensible via config provider relvmargseex template file copied every release provides static configuration erlang virtual machine runtime flag relenvsheex relenvbateex template file copied every release executed every command set environment variable including one specific vm general environment written extensive documentation release recommend checking information configuration also use work release streamline elixir configuration api new config module added elixir previous configuration api mixconfig part mix build tool however since release provide runtime configuration mix included release ported mixconfig api elixir word use mixconfig softdeprecated favor import config another important change related configuration mix new longer generate configconfigexs file relying configuration undesired library generated config file pushed library author wrong direction furthermore mix new umbrella longer generate configuration child app instead configuration declared umbrella root always behaved making explicit improvement many enhancement elixir elixir cli got handful new option order best support release logger computes syncasyncdiscard threshold decentralized fashion reducing contention eex embedded elixir template support complex expression finally new u sigil working utc datetimes well new function file registry system module next mentioned earlier release last planned feature elixir major userfacing feature work planned know certain consider fact excing part announcement course mean last elixir version continue shipping new release every month enhancement bug fix improvement see issue tracker detail also working structural change one move mix xref pas straight compiler would allow u emit undefined function deprecation warning place also considering move cirrusci test elixir window unix freebsd single service also important highlight two main reason afford empty backlog first elixir built top erlangotp simply leverage work done ericsson otp team runtime virtual machine elixir team always aimed contribute back much possible contribution increased last year second elixir designed extensible language tool abstraction used create enhance language also available library framework mean community continue improve ecosystem without need change language would effectively become bottleneck progress check install section get elixir installed read getting started guide learn also updated advanced mix otp talk release looking fast paced introduction language see start elixir tutorial also brought latest greatest fun
104,Lobsters,elixir,Elixir programming,(BEAM) Data Types Memory Layout,http://beam-wisdoms.clau.se/en/latest/indepth-memory-layout.html,beam data type memory layout,data type memory layout list con boxed,data type memory layout describes data format heap seen c code debugger never able see format erlang code list con list term boxed value ie contains pointer heap leastsignificant bit list value remaining bit pointer value heap contains word namely car list head cdr list tail see car cdr macro emulatorbeamerltermh pair word called con cell terminology lisp functional programming con cell header word stored memory con cell contains pointer next cell cdr tail also visible erlang last con cell list contains nil special value empty list nonlist term value make improper list structure may look inefficient hand allows connecting tail list multiple con cell reuse existing data boxed boxed value pointer leastsignificant bit tagged remaining bit pointer boxed pointer must always point header see explanation header boxed value found everywhere register stack heap box always point header garbage collection box point another box thenonvalue mark moved object never
105,Lobsters,elixir,Elixir programming,Finding Bugs with Property Based Testing in a Statistics Calculation,https://pragtob.wordpress.com/2019/06/24/finding-bugs-with-property-based-testing-in-a-statistics-calculation/,finding bug property based testing statistic calculation,property based testing statistic function bencheestatistex first property based test streamdata wait test failing another property failed original source implementing percentile interpolation pr learning although property loosely defined still uncovered bug property based testing good finding edge case like,always loved idea property based testing mind blowing idea encountered learning clojure many year back however always found hard apply practice barely encountered easy case operation reversible encode term decode equal original term instance property came always seemed loose catch bug thought well let give another shot got statistic function bencheestatistex data easy generate let give shot surely find first property based test nothing else wanted make sure matter number throw statistic module blow implement used streamdata check sample listof float minlength stats statistic sample assert statssamplesize assert statsminimum statsmaximum assert statsminimum statsaverage assert statsaverage statsmaximum assert statsminimum statsmedian assert statsmedian statsmaximum assert statsmedian statspercentiles assert statsstandarddeviation assert statsstandarddeviationratio property mode occurs sample omitted brevity end came sample non empty list float bunch check make sure value somewhere minimum maximum bigger way test wait test failing failed generated value successful run clause sample listof float minlength generated assertion failed code assert statsstandarddeviationratio left right honestly shocked closer inspection standard deviation ratio negative said always positive generated sample contains negative number average negative well ratio calculated dividing standard deviation average turned negative usually work positive sample hence never occurred ratio still always positive call fixed another property thinking came another property check sample listof float minlength percy percentile sample assert percy percy assert percy percy assert percy percy assert percy percy end much like first property making sure percentile value order absolutely possibility fail absolutely none well tested chance fail failed failed generated value successful run clause sample listof float minlength generated assertion failed code assert percy percy left right wait percentile bigger percentile way ok lot digging googling reading original source implementing percentile interpolation later figured problem basically interpolation small sample size hard also uncommon missed clausecase stated source point small percentile sample size value set minimum note p simply set minimum value p percentile implementing clause guard clause fixed test check full implementation bug fix pr learning generation part super easy case shown however impressive although property loosely defined still uncovered bug code many running quite benchee sure specific edge case property based testing good finding edge case idea property check happy listen learn give property based testing shot even loose property might surprised find like like loading related
106,Lobsters,elixir,Elixir programming,BEAM + Rust A match made in heaven,https://codesync.global/media/beam-rust-a-match-made-in-heaven/,beam rust match made heaven,objective audience,beam wellknown faulttolerant property quite performant memory efficient many usecases occasionally find hitting limit beam provide u happens need interface directly hardware specific part application need fast possible talk sonny introduce audience rust system programming language aim empower everyone build reliable efficient software various method used integrate beam objective demonstrate flexiblity beam integrating outside world introduce audience rust programming language benefit provides audience anyone want learn rust use within beambased application
107,Lobsters,elixir,Elixir programming,Help Dialyzer Help You,https://medium.com/erlang-battleground/help-dialyzer-help-you-94db66bfbc5a,help dialyzer help,going latest talk codebeamsf dialyzer say dialyzer mean opaque would like dialyzer say elli fragkaki started local return elixirmyodt elixirmyodt argument vodt elixirmyodt,going ok usually happens many question never let see figure sean brilliantly expressed latest talk codebeamsf must little misunderstanding dialyzerwhat dialyzer saysso let obvious thing dialyzer say call proper myodtt argument using argument function odt variable according spec wrote myodtuserprintodt actually instance myodtt also say myodtuserprintodt never return likely considering discrepancy fix one remove oncewhat dialyzer meansif check stavros talk video learn dialyzer work inferring broader possible type variable emitting warning infer possible type onewith mind since complaining odt let try figure dialyzer inferred success typeactually go far warning vodt might noticed vodt erlang representation variable odt typethat map somewhat similar opaque type myodtt since allows map key value long field called myodtt allows key required could dialyzer found type odt let try see information available inferring typesthere typespec dialyzer us typespecs narrow success type found case spec dialyzer mind time warningthe info available fact odt used call key solve mystery check code module notice spec tnot spec dialyzer best figure type odt success typing argument function ie type opaque since spec say way dialyzer tell actually requires instance myodtt map keythen dialyzer try match type success typing argument ie myodtt way match random map type opaque type matter fact type match opaque type opaque type whole point even manage build something look like definition opaque type dialyzer prove fact expected opaque type emit warning word violating opaqueness argumentsimply adding spec remove warning lead u lesson day define opaque type add spec exported function use ie module api would like dialyzer sayone day someone finish elli fragkaki started dialyzer tell u something along line function local call elixirmyodt requires opaque term type elixirmyodt argument variable using vodt must type since also used call elixirmyodt something even clearer helpful
108,Lobsters,elixir,Elixir programming,What’s the Fastest Data Structure to Implement a Game Board in Elixir?,https://pragtob.wordpress.com/2019/06/17/comparing-the-performance-of-different-board-implementations-in-elixir/,fastest data structure implement game board elixir,one first question ever asked community elixirboardsbenchmark repo benchmark design settled board size functional web development elixir otp phoenix get set mixed bag getting setting full board contender board behaviour erlang array learn erlang basically skim say cautious using maptuple maptuplefull maptuple maptuplehalffull maptuplequarterfull etsset erlang ets etsorderedset processdictionary special request michał record structs system setup benchmarking result benchee repo bencheemarkdown bencheehtml go size take load maptuple maptuple maptuplefull maptuple processdictionary observation ets winner get v get get get maptuple v maptuplequarterfull v maptuplehalffull v maptuplefull johanna one entry erlang source code provided johanna tradeoff pay maptuple top performance performance difference array v tuple length encoding expanded whole tuple holding value performance optimization especially making writesupdates faster compared huge tuples conclusion missing data structure please pr detail update johanna pointing suggestion michał update uhauleth reddit ufriendlysock lobster like,ever wanted implement something board game like elixir chess go island well gon na need board data structure would efficient one use elixir conventional wisdom lot programming language use sort array however programming language immutable data structure real array data structure talk erlang array later really like array non functional language elixir one language like board game one first question ever asked community also interesting relatable example see understand performance tradeoff different data structure complete source found elixirboardsbenchmark repo benchmark design benchmark specific board game mind settled board size bit bigger normal chess board exactly size smallest normal goboard one smaller board used island implemented functional web development elixir otp phoenix seemed like good compromise different size likely sport different performance characteristic without concrete usage scenario mind settled couple different benchmark getting value coordinate fairly nanomicro benchmark data access provides good balance value beginningmiddleend thinking list term setting value coordinate still nanomicro benchmark combine two previous benchmark getting setting three mentioned value call mixed bag stop previous one last benchmark set get every possible coordinate first set get set get forth also simulates board filling important data structure completely filling board unrealistic board game however game finish stage one called getting setting full board something notably benchmarked creation board almost board implementation could resolve constant value similar time take create overly interested property want make code le readable inlining constant creation need also noteworthy benchmark mostly treat reading writing equally experience aisbots much readheavy writeheavy take caveat benchmark design consideration looking result doubt course best write benchmark taking account concrete usage pattern domain without ado let look different implementation benchmarked far contender board need implement simple board behaviour defmodule board ca nt specific witht type implementation representation type board type field callback new board callback get board nonneginteger nonneginteger field callback set board nonneginteger nonneginteger field board end board built accessing previously unset field return nil assumption data stored board made rule string implementation type benchmark atom used value description data type x used mark value stored dimensional list representing row column using knowledge constant board size encode onedimensional list resolving index dimension x basically like tuples instead list basically like tuple instead list erlang array exactly common sight even learn erlang basically skim say cautious using even forgot first version post internally map tuple usage interesting way discussedillustrated way conceptually much like see data structure general otherwise conceptually like maptuple map take tuple coordinate x key value whatever board bit unfair compared others shown far start empty map course much smaller data structure smaller usually faster retrieve value benchmark start empty board massive advantage also included full map benchmark see next maptuplefull basically initialized already hold key value pair initialized nil serf purpose see performs also see maptuple performs filled maptuplehalffull looking complete full performance empty performance seem good either added another one initialized column bit board half totalling keyvalue pair maptuplequarterfull another one time keyvalue pair interesting performance characteristic read find akin etc map map etsset erlang ets storage table type set storage layout wise basically maptuple tuple coordinate pointing stored value etsorderedset table type orderedset processdictionary special request michał probably great default variant practically creating process global state mean two board within process without causing mayham also might accidentally conflict code using process dictionary still might worth considering want always run board process significant point mentioned data type except ets process dictionary immutable mean especially benchmark new board created beforeeach hook count towards measured time avoid contamination another notable exception save string aforementioned constraint record record internally represented tuples give keyvalue access map however elixir common use structs backed map map tuples already present benchmark including likely lead new insight system setup operating system linux cpu information intel r core tm cpu number available core available memory gb elixir version erlang version benchmarking result benchmark course run benchee benchmarking script nothing fancy check repo markdown thanks bencheemarkdown html report bencheehtml careful though mobile html report contain raw measurement hence go size take load also due j drawing graph result getting setting full board getting setting full board iteration per second higher better tight race top come run time maptuple within striking range sharp fall also fair bit variance involved shown black whisker usual benchmark finish nanosecond microsecond garbage collection interference etc one best get better picture let look whole table result name ip average deviation median mode minimum maximum k μs μs μs μs μs k μs μs μs μs μs maptuple k μs μs μs μs μs processdictionary k μs μs μs μs μs etsset k μs μs μs μs μs k μs μs μs μs μs maptuplefull k μs μs μs μs μs maptuplehalffull k μs μs μs μs μs k μs μs μs μs μs etsorderedset k μs μs μs μs μs k μs μs μs μs μs k μs μs μs μs μs maptuplequarterfull k μs μs μs μs μs k μs μs μs μs μs median mode good value look unsure usually fastest value middle value common respectively much le likely impacted outlier garbage collection seem reinforce really fastest negligible margin maptuple fast sibling maptuplefull already start full time slower whether significant depends start truly empty board go start empty board chess instance somewhat expectedly worst getting value towards end list traverse entire list incredibly slow aside easy see box plot high deviation mainly caused big outlier boxplot getting setting full board dot outlier dot denote outlier big rest chart practically unreadable remains actual box practically thick line memory consumption getting setting full board memory usage lower better see immediate drawback memory consumption many time worse others educated guess replacecopyupdate whole tuple value every update operation much economical need update tuple holding column one holding specific column updating best understanding big tuples like relatively uncommon real world experience though fixed size nature make inapplicable lot case luckily case one maptuple amazingly well overall probably structure quite people would intuitively reached good constant memory access speed memory consumption also impressively low processdictionary memory efficient also constantly top come run time however least run time wise quite margin μs μs seem make risk worth overall observation let take look thing seem note worthy ets winner surprised bit however used ets much ets always tagged go option performance mind looking doc use case know make sense though likely see benefit much larger data set relatively small ets provide ability store large quantity data erlang runtime system constant access time data value hardly qualifies large blindly follow conventional wisdom always benchmark get v get let look time take retrieve value usually much common operation writing get name ip average deviation median mode minimum maximum n n n n n n n n n n n n n n n maptuple n n n n n maptuplequarterfull n n n n n n n n n n n n n n n processdictionary n n n n n n n n n n maptuplehalffull n n n n n maptuplefull n n n n n etsset n n n n n n n n n n etsorderedset n n n n n get name ip average deviation median mode minimum maximum n n n n n n n n n n n n n n n maptuple n n n n n processdictionary n n n n n n n n n n n n n n n maptuplehalffull n n n n n etsset n n n n n maptuplefull n n n n n etsorderedset n n n n n maptuplequarterfull n n n n n n n n n n n n n n n top remain relatively unchanged illustrative look though get vastly outperforms sibling even closest top group easy explain basically translates looking first element list fast linked list however looking last element slow get translates element traversed end reached whole thing almost time slower still slow structure need look element instead maptuple v maptuplequarterfull v maptuplehalffull v maptuplefull scenario including biggest scenario maptuplequarterfull performs worse maptuple expected maptuplehalffull unexpected maptuplefull unexpected expected performance worse maptuple better maptuplefull maptuplehalffull idea johanna one might magic limit map really becomes map list linearly searched limit defined entry erlang source code link also provided johanna quarter full implementation limit entry hence often performance characteristic akin see good get performance bad get performance real map cousin best understanding switch implementation size performance optimization small data set linear search often performs better overhead introduced hashing looking etc also see tradeoff pay big benchmark whole board filled incrementally maptuple initially empty grows still provides top performance still fully understand sometimes maptuplefull seems still outperform maptuplehalffull negligible margin notably big getting setting full board benchmark difference however small warrant investigation believe unless idea course performance difference array v tuple introduction said array backed tuples come performance way worse well let look array actually look like iex mine arraynew default nil array nil iex arrayset boom mine array nil nil nil nil boom nil nil nil nil nil nil cleverly even initialize field us kind length encoding saying value default value nil next field also saving set size limit fun fact array configured also dynamically grow set value index representation change showing still length encoding nothing first entry index expanded whole tuple holding value best understanding array work adding stretch tuples size need general performance optimization especially making writesupdates faster compared huge tuples mainly holding concrete value need get updated instead whole thing however custom tuple implementation perfectly sized begin huge moreover whole size set compiletime probably enables optimization believe hence tuple implementation outperform array shabby especially read access compared implementation conclusion tuples good use case known compile time sized collection need fast access simple flat map performs amazingly well least relatively small board size field benchmarked big caveat map though fast start empty map grow size new piece set completely initialized map maptuplefull performs way worse tuples clear winner missing data structure please pr behaviour implement list add module name detail update fixed maptuplehalffull update actually quarter full wildly different performance characteristic reason described along maptuplequarterfull implementation thanks go johanna pointing also process registry added another possible implementation suggestion michał also added run time box plot show outlier clearer visually update added investigated array thanks uhauleth reddit also added remark record thanks ufriendlysock lobster like like loading related
109,Lobsters,elixir,Elixir programming,Memento – Mnesia Real-time Distributed Database in Elixir,https://github.com/sheharyarn/memento,memento mnesia realtime distributed database elixir,get easy use mnesia realtime powerful query detailed documentation hexdocs persistent distributed atomic focused mnesia compatible dependency mit licensed memento mnesia installation configuration usage crud operation query persisting disk sample implementation roadmap faq mementomnesia nt use mementomnesia nt already amnesia library project using memento que contributing fork license mit license,simple powerful elixir interface erlang mnesia database mnesia memento get easy use provides simple intuitive api working mnesia realtime extremely fast realtime data search even across many node powerful query top erlang matchspec qlc much easier use detailed documentation example method hexdocs persistent schema coherently kept disc memory distributed data easily replicated several node atomic series operation grouped single atomic transaction focused encourages good pattern omitting dirty call database mnesia compatible still use mnesia method schema table created memento dependency zero external dependency us builtin mnesia module mit licensed free personal commercial use memento extremely easytouse powerful wrapper elixir make intuitive work mnesia erlang distributed realtime database original mnesia api erlang convoluted unorganized combined complex matchspec qlc query language hard work elixir especially beginner memento attempt define simple api work schema removing majority complexity associated installation add memento list dependency mix file def deps memento end elixir version lower also add application list def application application memento end preferable add memento mnesia along ensure otp call mnesia go supervisor spec specified memento configuration highly recommended custom path mnesia database location specified even local dev environment add mnesia gitignore configconfigexs config mnesia dir mnesia mixenv node notice single quote usage start defining module memento table specifying attribute type option least two attribute required first one primarykey table simple definition look like defmodule blogauthor use mementotable attribute username fullname end slightly complex definition us option could look like defmodule blogpost use mementotable attribute id title content status author index status author type orderedset autoincrement true also define method helper function module end defined schema need create interact mementotablecreate blogauthor mementotablecreate blogpost see mementotable documentation detailed example information option crud operation query table created perform readwritedelete operation record api operation exposed mementoquery module method ca nt called directly instead must always called inside mementotransaction mementotransaction fn mementoqueryall blogauthor end blogauthor username sye fullname sheharyar naseer blogauthor username jeanne fullname jeanne bolding blogauthor username pshore fullname paul shore sake succinctness transaction ignored example still required quick overview basic operation get record table mementoqueryall post get specific record primary key mementoqueryread post id mementoqueryread author username write record mementoquerywrite author username sarah name sarah molton delete record primary key mementoquerydelete post id mementoquerydelete author username delete record passing full object mementoquerydeleterecord author username pshore name paul shore complex read operation memento expose method let chain condition using simplified version erlang matchspec query would look like movie table see information guard operator detailed example persisting disk setting disk persistence mnesia always bit weird involves stopping application creating schema disk restarting application creating table certain option step need take list node want persist node node create schema mementostop mementoschemacreate node mementostart create table disccopies one want persisted disk mementotablecreate tablea disccopies node mementotablecreate tableb disccopies node mementotablecreate tablec need done every time application start also make sense create helper function mix task see sample implementation roadmap faq mementomnesia application kind data storage mechanism needed usually mean relying sort external dependency program memento used situation might always make sense application eg data ephemeral project need kept lightweight need simple data store persists across application restarts datacode decoupling important etc nt use mementomnesia like mentioned previous point mementomnesia specific usecases might always make sense use usually nt want couple code database want allow independent external access transformation data circumstance always prefer using datastore like redis postgres etc nt already amnesia library longtime user amnesia package recent release elixir library started show age amnesia dependence exquisite package caused lot compilation problem complex macrointensive structure nt made easy fix either library nt even compile elixir finally decided write desperately needed update mnesiabased project memento meant extremely lightweight wrapper mnesia providing easy set helper forcing good decision avoiding dirty method project using memento memento new package nt many open source example available que another library us memento background job processing storing state job project us memento feel free send pullrequest mentioned contributing fork enhance send pr lock issue bug feature request implement something roadmap spread word license package available open source term mit license
110,Lobsters,elixir,Elixir programming,Elixir 1.9 RC.0 - Releases support and a configuration overhaul,https://github.com/elixir-lang/elixir/releases/tag/v1.9.0-rc.0,elixir release support configuration overhaul,reload reload,perform action time signed another tab window reload refresh session signed another tab window reload refresh session
111,Lobsters,elixir,Elixir programming,BEAM Architecture Handbook,https://speakerdeck.com/whatyouhide/beam-architecture-handbook,beam architecture handbook,fewer faster,copyright fewer faster llc slide content description owned creator
112,Lobsters,elixir,Elixir programming,Minimum Viable Phoenix,http://www.petecorey.com/blog/2019/05/20/minimum-viable-phoenix/,minimum viable phoenix,minimum viable phoenix application confused first compilation also evaluation mix build tool cowboy plug macro initial configuration plug pipeline defines helper function hood generates handful helpful macro modulebased plug establishes plug automatic layout view module detection view controller module configuration option final thought phoenix codebase elixir metaprogramming plug,phoenix ship quite bell whistle whenever fire mix phxnew create new web application forty six file created spread across thirty directory overwhelming developer new phoenix build better understanding framework moving piece interact let strip phoenix bare bone let start zero slowly build minimum viable phoenix application starting beginning need recognize phoenix application elixir application first step process building minimum viable phoenix application really build minimum viable elixir application interestingly simplest possible elixir application simply ex file contains source code set success later let place code libminimalapplicationex start simply printing hello console ioputs hello surprisingly execute newly written elixir application compiling elixirc libminimalapplicationex hello confused first explained elixir world compilation also evaluation libminimalapplicationex ioputs hello executionbycompilation work really nothing onthefly evaluation generating compilation artifact reused later deployed elsewhere fix moving code module compile newly modularized applicationex new elixirminimalapplicationbeam file appear root project run compiled elixir program running elixir directory contains beam file specifying expression evaluate using e flag elixir e minimalapplicationstart hello similarly could spin interactive shell iex directory evaluate expression iex minimalapplicationstart hello gitignore beam dsstore libminimalapplicationex ioputs hello defmodule minimalapplication def start ioputs hello end end great manually managing beam file bootstrap expression little cumbersome mention fact even started working dependency yet let make life easier incorporating mix build tool application development process creating mixexs elixir script file root project defines module us mixproject describes application write callback new mixproject module requirement return application name minimal version def project app minimal version end mix requires return app version configuration value worth taking look configuration option available u especially elixir startpermanent buildpath elixircpaths others next need specify callback mixproject module tell mix module want run application fire def application mod minimalapplication end pointing minimalapplication module wrote previously normal application startup process elixir call function module specify normal first argument whatever specify case second mind let modify function accept parameter def start normal ioputs hello ok self end notice also changed return value ok tuple whose second value pid normally application would spin supervisor process first act life return pid yet simply return current process pid change done run application mix mix run fire interactive elixir shell iex mix bootstrap expression required gitignore beam dsstore dsstore build libminimalapplicationex defmodule minimalapplication def start def start normal ioputs hello ok self end mixexs defmodule minimalmixproject use mixproject def project app minimal version end def application mod minimalapplication end end built minimum viable elixir project let turn attention phoenix framework first thing need incorporate phoenix elixir project install dependency start adding deps array callback mixexs file deps list phoenix plugcowboy jason dependency default mix store downloaded dependency deps folder root project let sure add folder gitignore done install dependency mix depsget reliance phoenix make sense already pulling plugcowboy jason hood phoenix us cowboy web server plug compose functionality top web server would make sense phoenix relies plugcowboy bring two component application try go building application without installing plugcowboy greeted following error undefinedfunctionerror function undefined module plugcowboy available plugcowboychildspec scheme http plug minimalwebendpoint similarly phoenix relies json serialization library installed configured without either jason poison installed receive following warning trying run application warning failed load jason phoenix json encoding module jason available ensure jason exists deps mixexs configured phoenix use json encoding verifying following exists configconfigexs config phoenix jsonlibrary jason heeding advice install jason add configuration line new file project configconfigexs gitignore build deps configconfigexs use mixconfig config phoenix jsonlibrary jason mixexs app minimal version version deps jason phoenix plugcowboy installed dependency phoenix framework web server us hood time define web server incorporates application defining endpoint application interface underlying http web server client interface web application following phoenix convention define endpoint creating minimalwebendpoint module us phoenixendpoint specifies name otp application minimal defmodule minimalwebendpoint use phoenixendpoint otpapp minimal end macro phoenixendpoint quite bit heaving lifting among many thing load endpoint initial configuration set plug pipeline using plugbuilder defines helper function describe endpoint otp process curious phoenix work low level start search phoenixendpoint us value provide otpapp look configuration value application phoenix complain provide bare minimum configuration entry endpoint add configconfigexs file config minimal minimalwebendpoint configuration value want pas endpoint like host port want serve value usually environmentdependent add line bottom configconfigexs load another configuration file based current environment importconfig mixenv ex next create new configdevexs file specifies host port serve development use mixconfig config minimal minimalwebendpoint url host localhost http port start application point still greeted hello printed console rather running phoenix server still need incorporate phoenix endpoint application turning minimalapplication proper supervisor instructing load endpoint supervised child use application def start normal supervisorstartlink minimalwebendpoint strategy oneforone end done fire application using mix phxserver iex mix phxserver see endpoint listening localhost port alternatively want use old standby mix run either configure phoenix serve endpoint startup mix phxserver hood config phoenix serveendpoints true configure application endpoint specifically config minimal minimalwebendpoint server true configconfigexs config minimal minimalwebendpoint config phoenix jsonlibrary jason importconfig mixenv ex configdevexs use mixconfig config minimal minimalwebendpoint url host localhost http port libminimalapplicationex defmodule minimalapplication use application def start normal ioputs hello ok self supervisorstartlink minimalwebendpoint strategy oneforone end libminimalwebendpointex defmodule minimalwebendpoint use phoenixendpoint otpapp minimal end phoenix endpoint listening inbound http request u much good serving content first step serving content phoenix application configure router router map request sent route path web server specific module function function job handle request return response add route application making new module minimalwebrouter us phoenixrouter defmodule minimalwebrouter use phoenixrouter end instruct minimalwebendpoint use new router plug minimalwebrouter phoenixrouter module generates handful helpful macro like match get post configures modulebased plug reason seamlessly incorporate endpoint using plug macro router wired endpoint let add route application get minimalwebhomecontroller index instructing phoenix send http get request function minimalwebhomecontroller controller module minimalwebhomecontroller module need use phoenixcontroller provide minimalweb module namespace configuration option defmodule minimalwebhomecontroller use phoenixcontroller namespace minimalweb end phoenixcontroller like phoenixendpoint phoenixrouter quite bit establishes plug using phoenixcontrollerpipeline us namespace module provide automatic layout view module detection controller module essentially glorified plug expect phoenix pas conn first argument specified controller function userprovided parameter second argument like plug function return potentially modified conn def index conn params conn end returning unmodified conn like essentially noop let spice thing bit return simple html response requester simplest way use phoenix builtin function take conn first argument html want send back client second phoenixcontrollerhtml conn hello dig find using plug builtin function plugconnsendresp conn hello ultimately modifying conn structure directly conn status respbody hello state set three expression identical use whichever one choose return html fragment controller follow best practice stick phoenix helper function libminimalwebcontrollershomecontrollerex defmodule minimalwebhomecontroller use phoenixcontroller namespace minimalweb def index conn params phoenixcontrollerhtml conn hello end end libminimalwebendpointex use phoenixendpoint otpapp minimal plug minimalwebrouter end libminimalwebrouterex defmodule minimalwebrouter use phoenixrouter get minimalwebhomecontroller index end phoenixbased web application successfully serving content route navigate http greeted friendly homecontroller behind scene issue browser automatically request faciconico asset server idea respond request asset exist phoenix kill request process automatically return http status code need way handing request missing content thankfully stack trace phoenix gave u killed request process give u hint request get faviconico exit exception raised undefinedfunctionerror function undefined module minimalweberrorview available minimalweberrorviewrender conn phoenix attempting call first argument request conn second finding module function exist let fix defmodule minimalweberrorview def render assigns found end end function view controller return content want render response conn said distinction view controller may outside scope building minimum viable phoenix application skim sure read move errorview module incorporates application endpoint also note module called render error customizable rendererrors configuration option libminimalwebviewserrorviewex defmodule minimalweberrorview def render assigns found end end final thought minimum viable phoenix application probably worth pointing using phrase minimum viable loosely sure people come minimal phoenix application similarly sure concept tool left like view template would cause people argue example minimal idea explore phoenix framework ground building requisite component without relying automatically generated boilerplate like think accomplished goal certainly learned thing two one thing taken away process magic behind phoenix everything understood little familiarity phoenix codebase healthy understanding elixir metaprogramming little knowledge plug
113,Lobsters,elixir,Elixir programming,Using Rust to Scale Elixir for 11 Million Concurrent Users,https://blog.discordapp.com/using-rust-to-scale-elixir-for-11-million-concurrent-users-c6f19fc029d3,using rust scale elixir million concurrent user,getting faster everyday persistent data structure pushing elixir limit skiplist skip list orderedset must go faster rustler happily ever released sortedset open source library go check job page,last year backend infrastructure team discord hard work improving scalability performance core realtime communication infrastructureone big project undertook changing update member list nifty people right side screen instead sending update every single person member list could send update visible portion member list obvious benefit le network traffic le cpu usage better battery life list go onhowever posed one big problem server side needed data structure capable holding hundred thousand entry sorted particular way accept process ton mutation report back index thing added removedelixir functional language data structure immutable great reasoning code supporting massive concurrency enjoy write elixir doubleedged sword immutable data structure mutation modeled taking existing data structure operation creating brand new data structure result applying operation existing data structurethis meant someone joined server internally referred guild member list member would build new list member beam vm pretty speedy getting faster everyday try take advantage persistent data structure scale operate large list could updated fast enoughpushing elixir limitstwo engineer took challenge making pure elixir data structure could hold large sorted set support fast mutation operation easier said done let put computer science helmet go spelunking cave data structure designelixir ship set implementation called mapset mapset general purpose data structure built top map data structure useful lot set operation provides guarantee around ordering key requirement member list pretty much ruled mapset contendernext would venerable list type wrap list helper would enforce uniqueness sort list insertion new element quick benchmark approach show small list insertion time measured already far slow viableeven worse performance insertion scaled size list depth position list worst case benchmarked adding new element end item list came around basically eternitytwo beam competition yeterlang ship module called ordsets ordsets ordered set sound like found solution problem let break benchmarking check viability list small performance look pretty great measuring sadly size tested increased worstcase performance increased five time faster custom list implementation still fast enoughhaving exhausted obvious candidate come language cursory search package done see someone else already solved open sourced solution problem package checked none provided property performance required thankfully field computer science optimizing algorithm data structure storing sorting data last year plenty idea proceedskiplistthe ordsets perform extremely well small size maybe way could chain bunch small ordsets together quickly access correct one accessing particular position turn head sideways squint real hard start look like skip list exactly implementedthe first incarnation new data structure pretty straightforward orderedset wrapper around list cell inside cell small ordset first item ordset last item ordset count number item allowed orderedset quickly traverse list cell find appropriate cell fast ordset operation leveraging compile time guard implementation traversal get pretty good performance worst case scenario stymie ordset insertion item end item list dropped five time faster raw ordsets time faster naive list implementationso pop champagne cork celebrate right quitethe old worst case better new worst case insertion beginning list created item list clocking wat make sense think data structure insert item front orderedset end first cell cell full evicts last item next cell cell full evicts last item next cell point engineer would shrug say cake eat discord pushing envelope quantum cake technologyorderedsetthe problem thing fill operation cascade cell cell could something clever allow cell swell split dynamically inserting new cell middle list slightly expensive benefit worst case cell split instead cell operation n number cellsanother day coding data structure ready benchmarkat small list size new dynamic orderedset could perform insertion point list bad real test came cranked size inserting beginning list looking fast remember last time made one number fast made another slow maybe end list horrible better checkwith list size item inserting item end list took look like winnermust go fasterthis solution would work guild member scaling limit lot people would end story discord using rust make thing go fast posed question could use rust go faster rust functional language happily let mutate data structure also runtime provides zerocost abstraction could somehow get rust manage set would probably perform much betterour core service written rust elixirbased elixir serf purpose well lucky u beam vm another nifty trick sleeve beam vm three type function function written erlang elixir simple userspace functionsfunctions built language act building block userspace function called bifs builtin functionsthen nifs native implemented function function built c rust compiled beam vm calling function like calling bif control doesthere fantastic elixir project called rustler provides nice support elixir rust side making safe nif well behaved using guarantee rust guaranteed crash vm leak memorywe set aside week see would worth effort end week limited proofofconcept could measure first benchmark extremely promising best case adding item set worst case compared orderedset benchmark using integer enough evidence build support wider range erlang term fill rest functionalitywith spike showing much promise continued building support erlang term functionality needed member list time benchmark cranked number item way item test machine churned minute finally printed result sortedset best case worst case testing multiple size set itemsfor second iteration row able make worst case good previous iteration bestcase timingsthe rust backed nif provides massive performance benefit without trading ease use memory since library operation clocked well millisecond threshold could use builtin rustler guarantee need worry reduction yielding sortedset module look caller vanilla elixir module performs crazy fasthappily ever aftertoday rust backed sortedset power every single discord guild person guild planning trip japan people enjoying latest fun gamesince deploying sortedset seen performance improve across board impact memory pressure learned rust elixir work side side operate extremely tight performance constraint still keep core realtime communication logic higherlevel elixir wonderful guarantee easy concurrency dropping rust neededif need highspeed mutation friendly sortedset released sortedset open source libraryif solving hard problem awesome tool like elixir rust interesting go check job page
114,Lobsters,elixir,Elixir programming,"Mobilizon, an open and federated alternative for Facebook events",https://joinmobilizon.org/en/,mobilizon open federated alternative facebook event,beta version fall learn milestone team degooglise internet peertube guest designer godwin paccard mcgodwincom geoffrey dorne designandhumancom,gather organize mobilize birthday party friend family march climate change right gathering trapped inside tech platform organize click without providing private data facebook locking inside meetup framasoft want create mobilizon freelibre software allow community create space publish event order better emancipate tech giant want develop digital common everyone make respect privacy activism design maquette page g dorne et mc paccard asked professional designer help u develop vision mobilizon took time study digital habit activist order understand feature need gather organize mobilize maquette page groupe g dorne et mc paccardwe want make mobilizon userfriendly emancipatory ethical tool whether want create event one mobilizon instance set mobilizon feature tool depend mean give u develop beta version fall fundraising determine resource count work software order release beta version fall day let people know fundraising find want see mobilizon cumulative milestone money help fund milestone free basic eventpublishing toolux studiesgraphic designfree documented codemilestone emancipating federated federation linksadministration toolstestdemo instanceactivitypub integrationmilestone ideal friendly group managementmessagingmultiple identitiesmanaging external toolsand durable resilient funding beyond mappingimproved interfacemobile application learn milestone team framasoft u nonprofit association created focus popular education stake digital world small organisation fewer member fewer employee known carried project degooglise internet proposes ethical alternative online toolssince developing peertube free federated alternative youtube thanks donation previous crowdfunding campaign peertube enjoys growing success bolstered experience imagined mobilizon projectrecognised service public interest organisation funded donation mainly french supporter today need generosity help u make mobilizon reality throughout world framasoft guest designer asked two designer work u project mobilizon would right conception fit need us people going use godwin paccard designer ux researcher seek thoroughly understand usability design userfriendly ethical inclusive mcgodwincomgeoffrey dorne designer founder design designandhumancom
115,Lobsters,elixir,Elixir programming,Gun. The powerful Erlang HTTP client,http://big-elephants.com/2019-05/gun/,gun powerful erlang http client,blog post problem hackney httpoison hackney hexpm mint issue gun rescue gun cowboy previous highlight word ssl certifi sslverifyhostname conclusion p whatyouhide ericmj announced mint,previous blog post described send million http request using genstage without mentioning http client app depends sending request given app requirement http client must fast importantly reliable send http request back pressure mechanism matter strongly recommend reading previous blog post diving deep one problem hackney come http client elixir first option would httpoison httpoison wrapper around erlang http client called hackney according hexpm httpoison popular http client elixir fact mint release httpoison elixirerlang http client proper ssl verification default box httpoison provides simple straightforward interface send http request hiding complexity establishing connection maintaining connection pool however encountered issue hackney occasionally hackney could get stuck call httpoison would hanging blocking caller process would look like graph see new genstage process spawned anymore already spawned process blocked call httpoison way get state restart hackney app using function likely problem encountered related issue gun rescue thankfully time started looking around alternative http client gun reached version gun erlang http library author cowboy gun provides lowlevel abstraction work http protocol every connection gun process supervised gun supervisor gunsup request simply message gun process response streamed back message process initiated connection full documentation could found asynchronous nature gun allows performing http request multiple connection without locking calling process gun provide connection pool manage connection manually implemented gun based httpclient module app defmodule httpclient def connection host port opts keepalive infinity host tocharlist host connectopts connecttimeout timerminutes retry retrytimeout httpopts keepalive opts keepalive keepalive opts keepalive ok connpid gunopen host port connectopts ok protocol gunawaitup connpid timerminutes ok connpid else error reason error reason end end creates new connection new gun process given host port process started connection established gun process sends back gunup message caught point gun process ready receive request call function upon campaignproducer start campaignproducer first process genstage pipeline actually sends http request defmodule campaignsproducer use genstage def init meta connpid obtainconnection meta connpid meta mapput meta connpid connpid producer demandstate queuenew meta meta else ignore end end defp obtainconnection meta case httpclientconnection metahost metaport keepalive ok connpid connpid error reason log error nil end end end way campaignsproducer owner gun process receive message gun campaignproducer get campaign facebook pass pipeline spawn genstage worker also send request facebook idea child genstage process would send subsequent request facebook using one connection created campaignproducer process thus number campaignproducer across facebook account equal number gun workersconnections mean control let show scheme previous blog post insight costdata costdata producer producer producer campaignproducer initiate new gun connection sends request facebook get campaign pass pipeline insightsproducer costdataproducerconsumer use gun connection received campaignproducer pas httpclient function order send http request worth noting sending get post request case spawn new process connection genstage worker spawned campaignproducer send http request utilizing gun connection campaign consumed campaignproducer close gun connection dy normal state effectively built pool gun connection within existing genstage pipeline let see sending get post request gun would look like defmodule httpclient def get connpid query header header converttoelixir header monitorref processmonitor connpid streamref gunget connpid tocharlist query header asyncresponse connpid streamref monitorref end def post connpid query body header header converttoelixir header header contentlength bytesize body header monitorref processmonitor connpid streamref gunpost connpid tocharlist query header body asyncresponse connpid streamref monitorref end defp asyncresponse connpid streamref monitorref receive gunresponse connpid streamref fin status header httpclientresponse statuscode status body header header gunresponse connpid streamref nofin status header case receivedata connpid streamref monitorref ok data httpclientresponse statuscode status body data header header error reason httpclienterrorresponse message reason end gunerror connpid streamref reason httpclienterrorresponse message reason gunerror connpid error httpclienterrorresponse message error gundown connpid protocol reason killedstreams unprocessedstreams httpclienterrorresponse message gundown monitorref process connpid reason httpclienterrorresponse message reason timerminutes httpclienterrorresponse message recvtimeout end end defp receivedata connpid streamref monitorref responsedata receive gundata connpid streamref fin data ok responsedata data gundata connpid streamref nofin data receivedata connpid streamref monitorref responsedata data gundown connpid protocol reason killedstreams unprocessedstreams error reason monitorref process connpid reason error reason timerminutes error recvtimeout end end defp converttoelixir header enummap header fn name value name tocharlist value end end end quite lot code gun documentation highlight well stating advantage developer architecture may seem verbose using message like advantage never locking process allowing easily debug code also allows start one connection concurrently perform query time sending request basically sending message gun worker connpid variable example process initiated connection start receive response message gun process request uniquely identified streamref important pattern match receive block receiving full response achieved receiving message gun process till fin mark please note implementation block process process waiting message inside receive block receive block suffice case order avoid process locking implement receive block via genserver handleinfo callback word ssl mentioned httpoison elixirerlang library proper ssl certificate verification default order instruct gun well need provide certain option function transport tl transportopts verify verifypeer cacerts certificacerts depth servernameindication host reusesessions false verifyfun checkhostname host certifi sslverifyhostname dependency listed mixexs conclusion gun lowlevel http client quite verbose look bit awkward first glance however provides lowlevel abstraction work http giving full control connection allowing receive response asynchronously without locking process exactly need send million http request per day important thing case ability control connection split different branch genstage pipeline way single dropped connection impact others making app resilent http error p recently two elixir core contributor whatyouhide ericmj announced first stable release mint first native elixir http client big deal elixir community ask mint ssl verification default share principle gun however mint basic idea gun fundamental difference mint completely processless gun supervisor gunsup spawn gun worker hold connection every connection gun process mint connection mint struct looking forward trying mint one project future
116,Lobsters,elixir,Elixir programming,My Take on Property-Based Testing,https://medium.com/erlang-battleground/property-based-testing-erlang-elixir-de72ad24966b,take propertybased testing,opinion stuff tested way code podcast data structure optimization refactoring library generic processing complex algorithm checkout code kata complex stateful system system opaque data structure hernán inaka try find library final note,opinionsfirst want set one thing straight believe reasoning behind propertybased testing sound fred put propertybased testing able write simple short concise test automatically comb code way obsessive tester couldwriting good property letting good framework check code undoubtedly test code much much better unit test obsessive tester ever write think anybody deny stuff tested way worth test code property think basis thesis project problem tried use quickcheck test everything including gui wise choice various reason propertybased test slower unit test bydesign since property tested multitude time instead using one examplewriting good property easy fred state multiple time book sometimes good unit test hard write even cover one possible scenario writing property capture thing general way different instance test system much complexwriting enough property easy way hardly ever sure wrote enough unit test really cover functionality modulecomponentsystem testing hard sure wrote enough property fred great job showing situation book describes different type property write particularly verifying system behavior model also wary adding many property since property take time run want suite run worth testing property believe fred summarized idea quite well podcast said come figuring want write test first propertybased test really really hard need find general rule something stupid simple rule test want find something trivial understand well significant complexity implementation usually data structure interesting perspective thing totally worth checking property general one used fred example structureswhen writing module manage new complex data structure like new model list particular kind tree hash table etc writing unit test almost certainly miss bunch corner case propertybased testing writing test property also help define module better come nicer api besides book show list test otp propertybased test use far le code toooptimizations refactoringone best scenario find use property testing refactoring something sure work correctly let say trying optimize certain function performance module readability use previous version model verify new implementation work exactly old one writing property least easy writing unit test think easier since need come example give much confidencelibraries generic processingmuch like data structure writing library like csv parser fred present book something really know use case beforehand maybe standard rfc guide great since encoding rfcs property easier coming general property properly written specification another thing make use property easier complementary functionality like encodingdecoding write symmetric propertiescomplex algorithmsthis least experience common place reap benefit writing property system point write algorithmic piece sits core system logic likely get free library might involve multiple data structure andor complex piece book fred present checkout code kata example algorithm respond correctly parameter may vary widely quite edge case writing property instead unit test definitely pay would personally still write unit test shrunk value produced time property found bug system mecomplex stateful systemsthen stateful property great way test system whole multiple api endpoint executed different sequence conflict writing system stated code user perceives simple code implemented get lot benefit writing stateful property system big complex like usual crud http server code really hard model maybe muchwhat system question often write system worth testing property often create new data structure work opaque data structure almost every day work generally flat ie map record multiple field accessors regularly create new type tree hash tableshow often work large enough refactoringoptimization task large complex enough merit adding property compare new version old one thoroughly people remember hernán instance may muchhow often write new generic library actually used lot inaka believe many library would certainly benefit propertybased testing indeed hand scenario like one described book find writing system need parse csv well think ever face requirement go ok write generic csv parser either try find library write code exactly system need ie parse csv file case book often write complex algorithm whole stateful system actually happens often stuff previous paragraph happens least per system maybe course includes relatively small piece system build believe using propertybased testing would nice additionfinal notesin conclusion see propertybased testing great tool seriously consider using place benefit traditional examplebased test outweigh drawback basically time consumed writing running property test tool tool disposal therefore would advocate propertiesdriven developmentifwhen decide start using propertybased testing totally read fred book guide process make smooth enjoyable make expert writing property get far book take
117,Lobsters,elixir,Elixir programming,Introducing Telemetry,https://www.erlang-solutions.com/blog/introducing-telemetry.html,introducing telemetry,introducing telemetry need monitoring telemetry exometer folsom ecto plug core library tree fallen forest one around hear ecosystem telemetry library telemetrypoller prometheus statsd next monitor erlang elixir rabbitmq system get free trial wombatoam page link thought might also interested go back blog,introducing telemetry arkadiusz gil need monitoring longrunning mantra beam world might misinterpreted merit software unexpected thing often viable choice crash start simply restarting part application sufficient understand cause error handle properly future release also need know error occurred affected customer enable thing need way introspect analyze behaviour runtime need monitoring telemetry new open source project aiming unifying standardising library application beam instrumented monitored suite library developed last couple month erlang solution collaboration elixir core team contributor existing metric project exometer folsom served community well year would need yet another solution might start feel like popular comic strip design telemetry try cover every use case rather provides small simple interface instrumenting code allows anyone hook instrumentation point runtime enables modularity project like ecto plug need rely core library engineer building application use data exposed library monitoring system dive little bit deeper rationale behind telemetry design tree fallen forest core telemetry lie event event indicates something happened http request accepted database query returned result user signed event many handler attached performing specific action event published example event handler might update metric log data enrich context distributed trace becomes extremely convenient library emit telemetry event usually write web framework database client use existing package library provide instrumentation data via event code handle way suit need thing need implement handler attach application start example ecto since version publishes event database query could write handler log whenever total query time exceeds defmodule myappmonitoring require logger def logslowqueries event measurement metadata config systemconverttimeunit measurementstotaltime native millisecond loggerwarn query inspect metadataquery completed measurementstotaltime m end end end measurement metadata property single event telemetry event carry value handler need attached runtime example application start assuming ecto repo called myapprepo attach handler using code telemetryattach slowquerylogger myapp repo query noconfig specify name handler need unique across system event attaching function invoked time event emitted handler config passed last argument handler every invocation one around hear telemetry designed small performance footprint almost cost associated including even popular elixir library already used ecto plug coming phoenix soon telemetry requires single ets lookup event published handler executed synchronously process emitting event mean bottleneck single point failure whole library ecosystem apart core telemetry library provides interface emitting handling event built additional tool addressing common use case related monitoring telemetrypoller allows perform measurement periodically emit telemetry event include library project default poller process started publishing measurement related erlang vm like memory usage length run queue telemetrymetrics provides bunch function declaring metric based event example definition counter myapprepoquery mean want count many database query made ecto apart counter telemetrymetrics also defines aggregation sum last value sometimes referred gauge distribution also support multidimensional metric via tag unit conversion metric declared need fed reporter attache relevant event handler forward metric monitoring system choice runtime currently two reporter available hex one prometheus one statsd next telemetry core reached stable api right time including library user benefit exposed instrumentation data telemetry community run project without contributor able flourish encourage everyone telemetry active group contributor early day project would love part growth adoption want get involved integrate library telemetry build reporter telemetrymetrics give u feedback apis documentation currently improving performance core well extending polishing poller metric weare also working making existing reporter performant stable next big thing planned metric dashboard phoenix imagine generating new phoenix project basic dashboard metric served endpoint without setting external system telemetry allows u much near future monitor erlang elixir rabbitmq system currently using erlang elixir rabbitmq stack get full visibility system wombatoam find get free trial wombatoam page link thought might also interested go back blog
118,Lobsters,elixir,Elixir programming,Thoughts On Elixir: Pros And Cons Of The Most Popular Tool For High-Load Dev,https://habr.com/en/post/449522/,thought elixir pro con popular tool highload dev,spotlight ivan elixir becoming popular core advantage technology alternative elixir tool drawback elixir could describe case using elixir provides maximum result advice starting use elixir technology one study get running faster,elixirphoenix achieving high rate adoption software development industry best use case language drawback using talked sergiy kukunin fullstack developer spotlight elixir expert find answer question ivan elixir becoming popular sergey elixir feature principle rarely met language also based erlang used building telecommunication network result highly reliable tool highload project proven time essential recent year hardware technological progress slowing performance one core cpu reached physical limit ghz thing manufacturer come increase performance hardware use core problem approach need software capable working multiple core parallel classic programming language poorly suited task talking multithreading say c know shared memory several thread may compete resource condition tough create reliable code highload project random race condition segmentation fault elixir effectively solving problem introducing new approach multithreading core advantage technology first essential characteristic language coming functional nature immutability created loaded data structure object functional language unable alter except recreating scratch one hand peculiarity lift entry threshold using elixir ca nt pick one part application try record something repeatedly end everything running hand make engineer plan app architecture thoroughly elixir virtual machine literally minios process memory space process get borrowing resource process send message another process control process message also functional language data structure transmitted process even network unlike approach used objectoriented language harder write elixir code due multiple restriction runtime applies take longer composing something using java however overall reliability application high alternative elixir similar approach coroutines used go language also python greenlets fiber ruby provide similar approach runtime robust fast available run developer decide run coroutines erlang handle tool drawback elixir elixir today productionready tool overall language ecosystem still bit young particular mean log stack overflow find answer possible question ruby example yes book course blog need continually conduct research experiment solve lot everyday task main drawback also harder test elixir apps unit test le helpful need focus integration one however remember almost elixir function clean make unit test simpler single output input could describe case using elixir provides maximum result real need supporting highloads million request processed app elixir tool bother using however elixir perfect solution real highload project may even write app using using elixir hottest part system always good idea age dynamic internet user expect high speed immediate response website especially contentrelated resource say online medium outlet lot concurrent connection thousand reader want receive news update instantly moving elixir make life whole lot easier personal experience one project nodejs web app capable maintaining connection one time moving elixir number grew change business logic smth result possible solely better efficiency language used elixir allows making thing unthinkable year ago like creating online game fully rendered serverside using web socket even example web snake game written elixir javascript code however developer understand silver bullet elixir give erlang virtual machine initially entitled translates new syntax oldyetgood compiler created ericsson late able understand perfect example timeproven technology combined new one open new possibility developer always constraint advice starting use elixir technology one study get running faster well syntax elixir thing common ruby language entirely different always good see symbol element used simplest thing use new elixircompatible webdevelopment framework popular web framework elixir phoenix definitely give try especially used using ruby rail simplify development still making app faster reliable
119,Lobsters,elixir,Elixir programming,MarkdownLive,http://markdown.dichev.io,markdownlive,markdownlive phoenix liveview github flavored markdown usage asterisk underscore asterisk,markdownlive project example markdown rendered serverside phoenix liveview modify text text area left see result rendered right side page interesting look browser developer tool notice section document edited rerendered sent back server github flavored markdown supported however prefer resource quick reference markdown syntax usage favorite feature quick note taking emphasis aka italic asterisk underscore strong emphasis aka bold asterisk underscore combined emphasis asterisk underscore strikethrough us two tilde scratch pretty cool huh useful feature code block unfortunately tab nt currently work inline code also easily create table tablesarecool allofthese elementsarecentered check documentation cool thing markdown phoenix liveview
120,Lobsters,elixir,Elixir programming,You may not need GenServers and Supervision Trees,https://pragtob.wordpress.com/2019/04/24/you-may-not-need-genservers-and-supervision-trees/,may need genservers supervision tree,written elixir forum hardly anyone ever highlight elixir forum thread genservers supervision tree process behaviour problem genservers supervision tree need time using genservers friend without even knowing ecto eco system take care jordan put bad ugly make code harder understand slower adopting elixir genserver adopting elixir chimed concurrency saša jurić point spawn spawn abstraction genstage flow broadway task agent learning little elixir otp guide book poolboy adopting elixir elixir action functional web development elixir otp phoenix programming phoenix designing elixir system otp final thought need genservers supervision tree start writing elixir application dimitar also came good thought hubert pointing like,thought people seem think genservers supervision tree elixirerlang world essential deterring people using language brewing mind quite time fact written elixir forum summary extended version including choice reply give visibility feel like talk much genservers etc people come elixir feel like need use really using elixir fear keep people elixir community seems complicated however write great application without ever writing emphasize lot library use phoenix ecto etc already supervision tree process standing shoulder giant truly still hear people say something tune still using like rail use genservers without need concrete reasoning something simple rail part let derail rail time fully parallel efficient huge boon mind feel like hardly anyone ever highlight programming elixir since never written production genserver supervision tree multiple application production multiple published library simply encounter problem eco system took care still felt somewhat inadequate everyone seem already talking also understandable unique solve hard problem lot learn share knowledge thought often really need genservers supervision tree head long time afraid voice maybe understand enough maybe need learn everyone always talk sure enlightenment come time soon finally nervously wrote aforementioned elixir forum thread nervousness went notch josé valim creator elixir somewhat hyper productive omnipresent liked post within minute creation also people really supportive hence happy share openly sorry delay lot going life mindful say need merely saying build significant great elixir application without writing genservers supervision tree course still topic worth learning genservers supervision tree process ever watched talk elixir erlang likely heard one killer feature erlang elixr give famed parallelism backed actor model reliability whole let crash restart known good state genserver supervisor behaviour showing process behave ship erlangotp problem genservers supervision tree genservers supervisor etc great technology help solve problem one thing special unique elixir erlang result lot conference talk blog post etc focus seems everyone want use big focus community sometimes feel like real elixirerlang programmer used mastered however need time least using framework like phoenix chance hidden detail course using genservers friend without even knowing phoenix run every request every channel process ecto pool database connection already parallelized need take care beauty saying standard situation eco system take care building relatively standard crud web application phoenix need using channel chat like application phoenix good course need really like jordan put agree time need use anything otp related really game changer make elixir great bad ugly like using genservers friend make everything instantly better quite opposite make code harder understand slower sometimes introduction process complicates code could simple interaction obfuscated bunch genserver call trying use concept also essentially grind application halt performance wise take example excellent adopting elixir also cover topic new developer team started building phoenix application always heard genservers could treated like microservices even tinier wisdom led push database access control genservers performance abysmal highenough load page took second render built bottleneck none existed defeated ecto connection pool access happened single process essence made easy create global mutable variable elixir essentially crippled single biggest advantage functional language gain whatsoever genserver adopting elixir provides guidance best use process model state accessed multiple process run multiple task concurrently gracefully handle clean startup exit concern communicate server especially highlight genservers used code organization robert virding one creator erlang also chimed response measured want quote full think important thing understand use properly concurrency problemsolutionsystem using genservers behaviour one way concurrency way tool like tool need used right way problem get right level concurrency suite problem solution problem much concurrency mean excess work real gain little concurrency mean making system sequential pointed many package like phoenix already provide pretty decent level concurrency suitable many type application least one intended automatically think case still understanding necessary work much concurrency need explicitly add unfortunately managed invisibly underneath many realise people agree general also say system benefit genserver supervision tree saša jurić point lot hand waving say genservers otps builtin building block building responsive service task nonresponsive one supervision tree builtin service manager like systemd upstart past year backend side experience worked small medium system needed technical approach also fairly extensive blog post topic reach tool spawn spawn end also expert genservers supervision tree said never wrote production one still learning still growing think knowing well give good basis make informed decision use abstraction came elixir parallelism need genservers right elixir core community good providing easy use solution write fully parallel program without write genservers supervision tree genstage flow broadway somewhat importantly couple builtins like task something parallel easily agent share state process want geocode pick drop address shipment parallel wait finished say pickuptask taskasync fn geocode pickupaddress end dropofftask taskasync fn geocode dropoffaddress end geocodedaddresses enummap pickuptask dropofftask fn task taskawait task end learning although saying need write application without fine fascinating interesting topic make better programmer without ever writing supervision tree even said education key know reach couple book recommend knowledge little elixir otp guide book personal favorite author take writing implementation poolboy starting simple one showing shortcoming extending building complicated supervision tree get reasoning go along see feature level complexity needed fascinating read adopting elixir cover many aspect mentioned especially good use concept use interesting read overall consider get company elixir elixir action saša jurić one knowledgeable people think topic hence quoted significant part book dedicated second edition came earlier year also date functional web development elixir otp phoenix build simple game first simple function develop genserver interface supervisor wire phoenix app good introduction especially good showing solid debugging work programming phoenix introductory book wish everyone writing phoenix application read first also cover thing done certain way author framework give unique perspective also aforementioned information already parallelized etc also includes pretty cool use case supervised genserver getting suggestion external service ranking designing elixir system otp shaping great resource genservers supervision tree otp general read yet james bruce pragprog trust plus read early praise already final thought well need genservers supervision tree start writing elixir application go write application play fun call elixir programmer still learn otp expand mind know look encounter problem supervision tree could help discussing elixir forum dimitar also came good thought maybe otp pull people help discover nice thing came otp stayed functional programming community think make clearer use genservers might actually harmful course conference talk use distributed system etc cool every give talk business succeeded writing fairly standard phoenix application complicate thing saying learn genservers know use lastly disagree want scream teach error way technically web server phoenix cowboy use genservers supervision tree normal http request handling thing similar functionality though still hold true need roll thanks hubert pointing correctly mention new edition elixir action specific cowboy process include thought closing paragraph thanks go saša hubert dimitar like like loading related
121,Lobsters,elixir,Elixir programming,"Elixir protocols, how do they work? the erlang perspective",http://marianoguerra.org/posts/elixir-protocols-how-do-they-work-the-erlang-perspective.html,elixir protocol work erlang perspective,size protocol elixir struct warianoguerra http keybaseiomarianoguerra,start creating new project learn elixir protocol mix new learn module learn cd learn note using erlang elixir never coded elixir searched elixir protocol found official documentation example size protocol added liblearnex file added call hello function try ended looking like defmodule learn moduledoc documentation learn doc hello world example iex learnhello def hello learnsizesize asd learnsizesize learnsizesize end defprotocol size doc calculates size length data structure def size data end defimpl size bitstring def size string bytesize string end defimpl size map def size map mapsize map end defimpl size tuple def size tuple tuplesize tuple end end compiled project mix compile opened elixir shell iex wrote little script decompile beam file erlang warning elixir flavored erlang ahead f filelibwildcard builddevlib beam result beamlibchunks f abstractcode ok abstractcode ac result code erlprettyprformat erlsyntaxformlist ac outpath stringreplace f beam erl filewritefile outpath code end result tree build â dev â lib â learn â consolidated â â elixircollectablebeam â â elixircollectableerl â â elixirenumerablebeam â â elixirenumerableerl â â elixiriexinfobeam â â elixiriexinfoerl â â elixirinspectbeam â â elixirinspecterl â â elixirlearnsizebeam â â elixirlearnsizeerl â â elixirlistcharsbeam â â elixirlistcharserl â â elixirstringcharsbeam â â elixirstringcharserl â ebin â elixirlearnbeam â elixirlearnerl â elixirlearnsizebeam â elixirlearnsizebitstringbeam â elixirlearnsizebitstringerl â elixirlearnsizeerl â elixirlearnsizemapbeam â elixirlearnsizemaperl â elixirlearnsizetuplebeam â elixirlearnsizetupleerl â learnapp result seems consolidates protocol consolidated folder put module ebin protocol implementation named like protocol plus type handle also clear elixir module prefixed elixir also declare protocol inside module protocol belongs module case full qualified name protocol elixirlearnsize let start exploring code generated inspecting main module wrote cleanup unneeded code example module elixirlearn export hello elixirlearnsize size asd elixirlearnsize size elixirlearnsize size see calling function protocol implies calling desired function consolidated module protocol let see elixirlearnsize module module elixirlearnsize export implfor implfor case implfor nil orelse false erlang error elixirprotocolundefinederror exception protocol elixirlearnsize value end size implfor size structimplfor nil implfor struct erlang isatom structimplfor implfor erlang istuple elixirlearnsizetuple implfor erlang ismap elixirlearnsizemap implfor erlang isbitstring elixirlearnsizebitstring implfor nil protocol module elixirlearnsize protocol function size protocol consolidated true protocol impls consolidated elixirmap elixirbitstring elixirtuple exported function protocol simple thing asks implfor function module know handle given argument call module function size implfor size implfor call argument handle case value nt known implementation case raise exception elixirprotocolundefinederror otherwise return module name start checking argument elixir struct underneath map well known key struct contains type struct atom implfor struct erlang isatom struct call struct type argument structimplfor example struct implement protocol implementation simple structimplfor nil start trying find implementation non protocol type mostly erlang type try match using guard check type none match return nil like implfor erlang istuple elixirlearnsizetuple implfor erlang ismap elixirlearnsizemap implfor erlang isbitstring elixirlearnsizebitstring implfor nil got module handle protocol function type let see implementation elixirlearnsizebitstring size string erlang bytesize string elixirlearnsizemap size map erlang mapsize map elixirlearnsizetuple size tuple erlang tuplesize tuple got basic call dispatch sequence let try adding two structs implement protocol see work added two structs liblearnex module defstruct name john age defmodule user defstruct name john age end added call function def hello learnsizesize asd learnsizesize learnsizesize learnsizesize user age name john learnsizesize learn age name john end implemented protocol size structs defimpl size learn def size learn learnage end defimpl size user def size user userage end compiled mix compile inside iex pasted script let see changed hello world function look like hello elixirlearnsize size asd elixirlearnsize size elixirlearnsize size elixirlearnsize size age name john struct elixirlearnuser elixirlearnsize size age name john struct elixirlearn confirms elixir structs map special struct key checking generated file new file user struct elixirlearnusererl struct defined inside elixirlearnerl module code relevant struct nt anything specific protocol implement module elixirlearnuser export struct struct elixirlearnuser age name john struct elixirenum reduce struct elixirlearnuser age name john fun map update end almost code inside elixirlearnerl struct show struct two constructor one without argument return struct default value field one merges argument default value let see changed consolidated protocol module structimplfor elixirlearnuser elixirlearnsizelearnuser structimplfor elixirlearn elixirlearnsizelearn structimplfor nil struct type return module protocol implemented let see implementation elixirlearnsizelearnusererl size user case user age erlang ismap erlang error badkey age age end elixirlearnsizelearnerl size learn case learn age erlang ismap erlang error badkey age age end summary elixir protocol compiled module whose content consolidated dispatch logic logic created getting defimpl statement adding function clause function target type elixir struct clause function target type type function implfor return module protocol implementation provided type protocol function asks module via implfor call given argument guessing module indirection must allow hot code reloading protocol implementation type independently without requiring also reloading protocol consolidation structimplfor function destructure map nt see trace dynamic dispatch case module loaded protocol implementation known consolidation time need research extra guess logic struct field get age field case learn age erlang ismap erlang error badkey age age end may elixir allows call struct method without parenthesis look field first function name second entirely sure since elixir knowledge basically non existent question correction warianoguerra account http keybaseiomarianoguerra
122,Lobsters,elixir,Elixir programming,Why should every process be supervised?,https://medium.com/@derek.kraan2/why-should-every-process-be-supervised-4fbd39c495c6,every process supervised,elixir programmer day elixir programmer night independent software consultant moose code bv,elixir programmer day elixir programmer night independent software consultant moose code bvfollow
123,Lobsters,elixir,Elixir programming,Fighting the Bloat! SSH Support in Pleroma,https://blog.soykaf.com/post/ssh-support-in-pleroma/,fighting bloat ssh support pleroma,gopher support release age bb bb,pretty much one year ago started fighting typical web javascript bloat adding gopher support wildly successful release heard call debloating biggest complaint gopher support inability post today taking step making pleroma bb time traveller century might remember time internet age bb technology long forgotten bb bulletin board system program someone used run computer would make possible people call literally modem read send message chat general social thing popular people got huge phone bill dialed much reason use social network today friend one big advantage bb format comparison htmljs textonly markup image virtual machine needed subsidize ram industry know probably actual modem home server attached one next best thing number dial ssh server see log existing account password enjoy super high speed modern pipe textonly interface check home timeline post something even reply useful really sure rinpatch fix actually run server well still development try right checking bb branch gitlab server follow instruction docsconfigmd running bb time hack planet
124,Lobsters,elixir,Elixir programming,Operable Erlang and Elixir,https://www.youtube.com/watch?v=OR2Gc6_Le2U,operable erlang elixir,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature fred hebert operable erlang elixir code beam sf youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature fred hebert operable erlang elixir code beam sf youtube
125,Lobsters,elixir,Elixir programming,Function/Method look up in Elixir/Ruby,https://dev.to/edisonywh/functionmethod-look-up-in-elixirruby-622,functionmethod look elixirruby,pragmaticstudio course dad dad dad dad dad dad retweeted matz dig doc source code source code suspiciously named elixir forum solution conclusion recommended,preface ruby dev learning elixir love compare learning elixir back know ruby think really strengthens understanding language today want talk functionmethod look article prompted learning genserver pragmaticstudio course highly recommend mentioned genserver inject default implementation function define manually default function want override define function current module signature name arity got thinking elixir look function definition make possible jump elixir let first look method lookup ruby work dad dad dad dad dad dad actually blogged retweeted matz actually idea much actually mean still going wear like badge honor ruby method lookup chain literally summarized one method call ancestor foo classnew fooancestors lookup path instance method foo object kernel basicobject fooclassancestors lookup path class singleton method read blog learn class module object kernel basicobject see entire method lookup chain ruby fact ancestor defined basicobject call fooancestors asks implement ancestor foo object kernel basicobject yes work know want inject function ruby make sure newly injected function first method get found lookup defining ancestor anywhere basicobject ruby able ancestor elixir nt really concept ancestorsinheritance really happening time stop guessing decided try example defmodule parent defmacro using opts quote def injected parent end end end end defmodule child use parent def injected child end end expected behavior overriden try run file iex lookupexs following warning message pop warning clause match previous clause line always match weird warning let try actually run iex childinjected parent surprise well surprise kinda ruined saw warning message running childinjected return instead decided dig doc find doc nt really tell much apart fact genserver inject function already knew want know doc nt help next source code like language elixir open source could easily dive source code see something suspiciously named defoverridable hunch might want proof hypothesis quick google defoverridable sent post elixir forum written man josé valim solution post found use defoverridable would mean update code following defmodule parent defmacro using opts quote def injected parent end defoverridable injected end end end defmodule child use parent def injected child end end run iex childinjected child voilà work perfect conclusion post josé clarified defoverridable also went say defoverridable recommended fact moving towards optionalcallback mark method optional along enhancement impl compiler use make sure child implement function also interesting thing learned recommend read post comment understand little query literally answered first line post would really nice managed find first place nt went source code would nt known keyword look thus wo nt land post still interesting journey one point thought elixir inheritance like ruby heh also title technically incorrect elixir really function lookup look current module
126,Lobsters,elixir,Elixir programming,How did I build a serverless offline button with AWS and Elixir?,https://pattern-match.com/blog/2019/03/13/how-did-i-build-a-serverless-offline-button-with-aws/,build serverless offline button aws elixir,http patternmatchcombloghowdidibuildaserverlessofflinebuttonwithaws,http patternmatchcombloghowdidibuildaserverlessofflinebuttonwithaws
127,Lobsters,elixir,Elixir programming,Phoenix LiveView pre-release code is now public,https://github.com/phoenixframework/phoenix_live_view,phoenix liveview prerelease code public,phoenix liveview install elixir official announcement learning installation installation guide hexdocs requirement compatible liveview requires erlangotp make liveview unique scalable platform browser support m edge contributing code conduct contributing,phoenix liveview phoenix liveview enables rich realtime user experience serverrendered html install elixir machine create first liveview app two step mix archiveinstall hex phxnew mix phxnew demo live official announcement news phoenix team liveview learning see existing comprehensive doc example get speed installation currently two method installing liveview project require stability recommended install using installation guide hexdocs want use latest feature follow instruction given markdown file requirement although liveview support elixir compatible erlangotp liveview requires erlangotp make liveview unique liveview server centric longer worry managing client server keep thing sync liveview automatically update client change happen server liveview first rendered statically part regular http request provides quick time first meaningful paint addition helping search indexing engine liveview us persistent connection client server allows liveview application react faster user event le work done le data sent compared stateless request authenticate decode load encode data every request liveview first announced many developer different background got inspired potential unlocked liveview build rich realtime user experience believe liveview built top solid foundation make liveview hard replicate anywhere else liveview built top elixir programming language functional programming provides great model reasoning code liveview change time building top scalable platform liveview scale well vertically small large instance horizontally adding instance allows continue shipping feature user join application instead dealing performance issue liveview application distributed realtime liveview app push event user event happen anywhere system want notify user best friend connected easily done without singleline custom javascript extra external dependency liveview performs diff tracking whenever change value server liveview send client value changed drastically reducing latency amount data sent wire achievable thanks elixir immutability ability treat code data liveview separate static dynamic part template first render page phoenix liveview render sends whole template browser new update modified dynamic content resent alongside diff tracking make liveview sends byte every update instead sending kilobyte every user interaction would detrimental user experience finally liveview used many developer company around world helped u close gap feature set make sure liveview ready prime time example find latency simulator allows developer simulate application behave slow connection livecomponents help developer compartmentalize template state event handling reusable bit essential large application live navigation enriches link redirects load minimum amount content user navigate page finegrained control handling client event dom patching rate limiting testing tool allow write confident test suite without complexity running whole browser alongside test word liveview provides rich feature set great developer user experience browser support current chrome safari firefox m edge supported support available following polyfills npm install save prefix asset mdnpolyfills urlsearchparamspolyfill formdatapolyfill childreplacewithpolyfill classlistpolyfill webcomponentstemplate shimkeyboardeventkey corejs note shimkeyboardeventkey polyfill also required m edge assetsjsappjs import mdnpolyfillsobjectassign import mdnpolyfillscustomevent import mdnpolyfillsstringprototypestartswith import mdnpolyfillsarrayfrom import mdnpolyfillsarrayprototypefind import mdnpolyfillsarrayprototypesome import mdnpolyfillsnodelistprototypeforeach import mdnpolyfillselementprototypeclosest import mdnpolyfillselementprototypematches import mdnpolyfillsnodeprototyperemove import childreplacewithpolyfill import urlsearchparamspolyfill import formdatapolyfill import classlistpolyfill import webcomponentstemplate import shimkeyboardeventkey import corejsfeaturesset import socket phoenix import livesocket phoenixliveview contributing appreciate contribution liveview please see phoenix code conduct contributing guide running elixir test mix depsget mix test running javascript test cd asset npm run test automatically run test file changed npm run testwatch j contribution welcome please include updated privstaticphoenixliveviewjs pull request maintainer update part release process
128,Lobsters,elixir,Elixir programming,GRiSP 2 – Erlang and Elixir on metal,https://www.kickstarter.com/projects/peerstritzinger/grisp-2,grisp erlang elixir metal,funding period,funding period feb apr day
129,Lobsters,elixir,Elixir programming,Building a devOps/CI/CD Pipeline,https://github.com/joeyrosztoczy/golden-path,building devopscicd pipeline,tutorial devops denver elixir meetup talk cover week content minute introduce practical abstraction needed build entire devopscicd pipeline want releaseready template remotely deployed gigalixir http sectiongettingstarted http gigalixirreadthedocsioenlatestmainhtml gettingstartedguide http gigalixirreadthedocsioenlatestmainhtml howtocreateanapp http gigalixirreadthedocsioenlatestmainhtml howtoprovisionafreepostgresqldatabase want follow along build step step distillery http http http,note somethings working get stuck etc feel free file issue even better pr wo nt super timely crunch time project march periodically check cheer tutorial devops denver elixir meetup talk cover week content minute introduce practical abstraction needed build entire devopscicd pipeline abstraction tool choice provide fullyfunctional pipeline also allow engineer deep dive whatever particular area pipeline interested without losing benefit full integration abstract release distillery build verification tool compiler credo dialyzer exunit coverall ci server hosted circleci free tier cloud management machine gigalixir free tier libcluster time talk hot code swap real distribution worth talking environment replication app specific template though want releaseready template remotely deployed gigalixir clone project git clone http githubcomjoeyrosztoczygoldenpathgit cd goldenpath final setup current master branch test project dev server thing get wild install dependency mix depsget create migrate database mix ectosetup install nodejs dependency cd asset npm install start phoenix endpoint mix phxserver manually verify build mix verifybuild setup free circleci account http sectiongettingstarted setup free gigalixir account http gigalixirreadthedocsioenlatestmainhtml gettingstartedguide create gigalixir app http gigalixirreadthedocsioenlatestmainhtml howtocreateanapp create free postgresql db http gigalixirreadthedocsioenlatestmainhtml howtoprovisionafreepostgresqldatabase deploy app via gigalixir remote git push gigalixir master verify deployment gigalixir log goldenpath assuming added ssh key kick observer gigalixir p observer goldenpath select remote node inspect want follow along build step step clone git clone http githubcomjoeyrosztoczygoldenpathgit cd goldenpath start right spot git checkout test project dev server thing get wild install dependency mix depsget create migrate database mix ectosetup install nodejs dependency cd asset npm install start phoenix endpoint mix phxserver distillery going help u perform grunt work building erlang release currently dependency added project first run distillery provided command mix releaseinit project root creating rel directory relconfigexs script use directory store awesomeness runtime configuration application configuration parameter erlang vm command run remotely seeding etc see build verifcation task update review pr http see configuration circleci able launch project review http launch remote deployment via gigalixir use clusterbased tool like observer review http
130,Lobsters,elixir,Elixir programming,Achieving 100k connections per second with Elixir,https://stressgrid.com/blog/100k_cps_with_elixir/,achieving connection per second elixir,minute stressgrid ranch cowboy ranch report pull request proof concept multisupervisor ranch establish new connection blog post bash script presentation linux kernel patch multisupervisor ranch proof concept application raw conclusion discussion lobster discussion hacker news,http rely lower level connectionoriented protocol namely tcpip tl protocol provide reliable delivery correct order data chunked multiple packet tl also includes encryption authentication http client need open connection send request efficiency connection likely reused sending subsequent request ensure case using http client set connection keepalive header http keep connection alive default web browser maintain warm connection minute servertoserver connection usually kept alive much longer websocket protocol built top http allows explicit closure underlying http connection mean performancewise measuring request per second get lot attention connection per second usually latter one two order magnitude lower former correspondingly benchmark use longliving connection simulate multiple request device however scenario assumption hold true example lowpower iot device afford maintain active connection sensor could wake establish connection server send payload request receive acknowledgment response close connection go back sleep workload connectionpersecond requestpersecond rate would article look scaling elixir handle connection per second workload consists device simply opening tcpip connection waiting second closing connection test consists three phase rampup minute sustained load rampdown following stressgrid script represents workload delay tested ranch socket acceptor pool heart cowboy web server ranch possible implement server tcpip tslbased protocol make benchmark specific http used ubuntu kernel sysctld override seen used erlang instance run test used stressgrid twenty generator ranch first test used unmodified ranch connection rate graph show clear breaking point connection per second point connection latency grows causing rate peak connection per second another good way observing bottleneck effect percentile latency minute mark latency jump singledigit millisecond second understand bottleneck need take quick dive architecture ranch ranch maintains pool acceptor enable throughput handling new connection default ranch start acceptor test set number cpu core also performed test acceptor set number cpu core negligible difference behavior make possible server accept new connection high degree parallelism socket accepted passed newlystarted connection process however connection process started single connection supervisor supervisor becomes primary suspect search bottleneck test theory modified test server report message queue length indeed observed message percentile starting minute mark good news ranch maintainer well aware problem pull request proof concept introduces acceptorsupervisor pair multisupervisor ranch acceptorsupervisor pair longer point contention path creating new connection within ranch verify collected similar report total message queue length connection supervisor percentile stay early minute mark percentile latency jump second breaking point connection rate graph le pronounced remains connection per second hit another bottleneck understand bottleneck need understand tcpip implemented inside linux kernel client want establish new connection sends syn packet server receives syn place new connection syn queue report synrecv state connection stay synrecv state moved accept queue userland case accept function remove connection accept queue connection becomes established cloudflare blog post detailed explanation mechanism created bash script record number connection synrecv state test around minute number connection quickly reach maximum syn queue length set netcoresomaxconn sysctl parameter overflowing syn packet get dropped client back resend syn packet later result percentile latency saw earlier modified ranch able accept higher degree parallelism accept function get invoked single shared listener socket turn linux kernel experience contention come invoking accept listener socket group engineer google discussed issue lock contention suboptimal load balancing presentation also estimate maximum connection per second rate around hardware furthermore proposed linux kernel patch introduced soreuseport socket option make possible open many listener socket port causing socket loadbalanced accepting new connection multisupervisor ranch soreuseport find soreuseport socket option would help created proof concept application ran multiple ranch listener port soreuseport set using raw setops option set number listener number available cpu proof concept measured number connection synrecv state test number never get close meaning longer dropping syn message percentile latency confirms finding remains consistently low throughout test zooming percentile latency measure millisecond also observed much better cpu utilization resulted le contention fairer load balancing accepting new connection finally connection per second rate reach network latency available cpu resource contributing next bottleneck conclusion analyzing initial test result proposing theory confirming measuring modified software able find two bottleneck way getting connection per second elixir ranch combination multiple connection supervisor ranch multiple listener socket linux kernel necessary achieve full utilization machine target workload discussion lobster discussion hacker news
131,Lobsters,elixir,Elixir programming,Embedded Elixir with Nerves,https://www.youtube.com/watch?v=IVCQvcCEjkU,embedded elixir nerve,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature greg mefford embedded elixir nerve code beam sto youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature greg mefford embedded elixir nerve code beam sto youtube
132,Lobsters,elixir,Elixir programming,Unit and Integration Testing In Elixir with Multiple Environments,https://spin.atomicobject.com/2018/10/22/elixir-test-multiple-environments/,unit integration testing elixir multiple environment,phoenix mox library using mox configure dependency test defining new mix environment adding new test environment config file separating test environment clunky approach following technique borrowed ecto umbrella project wrote module named mixfilehelpersex final thought,year ago learning properly unit test phoenix application using mox library strategy adopted side project involves adding module dependency module want unit test using mox configure dependency test approach great preserving good unit test hygiene using explicit intramodule contract always simplest one major hurdle encountered since writing post figuring use unit integration test sane way may seem like easy task module dependency get configured compilation runtime dependency applicationgetenv myapp mydependency dependency evaluated compilation use changing environment runtime long story short best solution found define new environment category testing need specifically define different mix environment configure corresponding file config directory defining new mix environment main goal able run mixenvintegration mix test run integration test correct environment configuration run mixenvintegration mix test phoenix project asis receive error module loaded could found default mixfile load testingrelated module mixenv set anything test adding new test environment fix start opening mixex notice couple function clause specifically match test work new integration environment going loosen constraint using function guard first add attribute somewhere near top module testenvs test integration next find line begin defp elixircpaths test change clause defp elixircpaths env env find dependency used test environment mox change test testenvs config file run mixenvintegration mix test test still run see something like fileerror could read file yourdirectorymyappconfigintegrationexs file directory configconfigexs load extra config file based mix environment fix simply adding file config named integrationexs use mixconfig importconfig testexs two testing environment differ mox configured correctly config myapp servicemodule myapptherealservice config file provided elixir phoenix use importconfig bottom dynamic configuration import happens first override enough configuration run integration module dependency separating test environment run mixenvintegration mix test test run however probably pas configured module dependency way compatible existing unit test okay though want able run unit test integration environment vice versa next step run right test depending mix environment order let dig mixfile return keyword list one key testpaths change key value testpaths mixenv add function defp testpaths integration testintegration defp testpaths testunit move test right directory testunit testintegration viola run mix test get exact output making change run mixenvintegration mix test recompile project new environment run test add new testing directory side note way thing actually put unit test inside lib directory directly adjacent file module testing module named exampleex put exampletestexs directory requires changing testpattern key inside mixfile project definition testexs big deal clunky approach setting mixenv run test little awkward let add custom mix task testall testunit testintegration testunit testintegration implement two function following technique borrowed ecto def runintegrationtests args testwithenv integration args def rununittests args testwithenv test args def testwithenv env args args ioansienabled color args else nocolor args ioputs running test mixenv env re systemcmd mix test args iobinstream stdio line env mixenv tostring env re systematexit fn exit shutdown end end end want implement acceptance nonfunctional test environment reuse go ahead run mix clean delete cached build artifact run mix testall see project get compiled twice test environment neat umbrella project wrote module named mixfilehelpersex defines anything could reduce redundancy across mixfiles mixfile begin codeloadfile mixfilehelpersex import alias module mixfiles executed application loaded final thought like approach seems like module dependency configurable runtime possible run test asynchronously module implementation would change unpredictably might make ci run bit slower since compile app testing environment experience testing elixir multiple configuration share story comment
133,Lobsters,elixir,Elixir programming,Introducing the Erlang Ecosystem Foundation,https://codesync.global/media/introducing-erlang-ecosystem-foundation/,introducing erlang ecosystem foundation,,thursday evening keynote code beam sf hear newly formed erlang ecosystem foundation talk jose valim peer stritzinger fred hebert miriam pena francesco cesarini sharing journey goal foundation waited erlang ecosystem foundation goal grow support diverse community around erlang elixir ecosystem encouraging continued development technology open source project based onaround runtime language
134,Lobsters,elixir,Elixir programming,Locality-sensitive Hashing in Elixir,https://underthehood.meltwater.com/blog/2019/02/25/locality-sensitive-hashing-in-elixir/,localitysensitive hashing elixir,wellresearched problem space exlsh challenge detail elixir erlang used industry similarity hashing simhash spiritfingers exlsh githubcommeltwaterexlsh lsh nutshell technique simhash article moz unicode normalization figure configurability making exlsh faster fprof flamegraph binary patternmatching similar way tail recursion order appear closing hexpm hexdocspm github,team built solution mine stream online article realtime insight customer component logic could dramatically simplified could assume never receives nearduplicates article deduplication identical document simple detection nearduplicates ie thing slightly different complex wellresearched problem spaceto solve problem ended building localitysensitive hashing library elixir read find built opensourced exlsh challenge detailone component mine stream news article online publication solution work better process story every time get reprinted several outlet component built using elixir functional language built top battletested erlang ecosystem hence needed nearduplicate detection solution work well elixirthe usual solution used industry called localitysensitive hashing lsh technique also known similarity hashing charikar hash similarity hash simhash reviewed lsh library available elixir one found called simhash target another usecase comparison short string like usernames url etc anticipated running lot experiment finetune deduplication rate needed configurability provided simhash another library called spiritfingers similar configurability limitation faster implementation simhashduring internal hackathon built lsh implementation elixir dubbed exlsh open sourced library githubcommeltwaterexlsh thing need fast localitysensitive hashing elixir might good choice youread want learn hashing algorithm really care made faster lsh nutshella hash function map large input space case online news article small output space usually fixedlength sequence bit hash function usually referred oneway easy compute output possible reconstruct input hash due property hash function mostly employed cryptography wellknown hash function optimized generation different output even similar input producing collision possible collision occurs two nonidentical input result hash output contrary cryptographic hash localitysensitive hash produce similar output similar document optimizes collision output space small enough lsh regularly generates collision similar document remove nearduplicates stream using simple lookup sliding window advanced technique exista common algorithm compute localitysensitive hash called simhash article moz describes detail focus implemented first input text normalized involves unicode normalization downcasing removal punctuationnormalized input tokenized ie split word characterstokens combined shingle ngrams retain order appearance input care order skip step setting shingle width filtered userprovided function use stoplist eg article common wordsevery shingle hashed using hash function eg recap small change input yield big change hash hash converted bit vector representation every set bit becomes every zero bit becomes shingle hash vector added one vector integersthe sum vector converted bit negative position set others set width vector hash function hence collision probability get higher smaller hash high low stepbystep visualization localitysensitive hash algorithmconfigurabilitythe key feature exlsh configurability every deduplication usecase set requirement hash size collision probability etc exlsh allows define input preprocessed normalization tokenization filtering shingling hash algorithm used iex lorem ipsum dolor sit exlshlsh cryptohash shingling bagofwords iex lorem ipsum dolor sit exlshlsh cryptohash also provide two handy helper function run preconfigured lsh long short text use document iex lorem ipsum dolor sit exlshwordwiselsh oeahahksgbawgqeagccaeg use short string usernames url slug iex username exlshcharwiselsh making exlsh fasterafter using library production discovered nearduplicate detection put significant load cpu understand function spends cycle used one erlang profiling tool fprof elixir build tool mix provides command run fprof write script benchexs text lorem ipsum dolor sit exlshlsh text profile mix profilefprof benchexs yielding result result comparable flamegraph function sorted much time cost including function call acc column interesting part column show much time function spent running body calling others hotspot ran time spending m instruction let look def sumbinaries size size size size size size size size binrest bitstring aggrest sumbinaries binrest aggrest end def sumbinaries function receives binary representation shingle hash list integer bitwise aggregation see figure function par leftmost byte hash individual bit using binary patternmatching deconstructs first eight bitcounters similar way add every set bit subtracting every unset bit delegate rest byte hashaccumulator via tail recursionthe cost recursion erlangelixir lower nonfunctional language java considering patternmatching involved zero experimented parsing bit time gave u slightly faster result indicated pattern match bit per recursion would gain performance however writing pattern matching manually even bit cumbersome barely readable def sumbinaries size size size size size size size size size size ba size bb size bc size bd size size bf size binrest bitstring agga aggb aggc aggd agge aggf aggrest agga ba aggb bb aggc bc aggd bd agge aggf bf sumbinaries binrest aggrest end decided generate case even bit programmatically using macro designing macro untrivial still learning see source call macro main module exlshbitmacrovectorreducer end elixir test pattern matching function clause order appear module start widest leverage wider matcher optimization need one invocation first clause per shingle instead original version match second clause use resulting call total per shingle instead realistic benchmark brought number recursion dataset resulted speedup le time spent computing lsh benchmarked exlsh simhash former faster approximately factor closingin meanwhile deployed updated faster exlsh production run service kubernetes using autoscaling cpu work pretty well u far exlsh available hexpm doc hosted hexdocspm looking solve deduplication problem similar give exlsh try question feature request feel free reach file issue github
135,Lobsters,elixir,Elixir programming,The Curious Case of BEAM CPU Usage,https://stressgrid.com/blog/beam_cpu_usage/,curious case beam cpu usage,benchmarking go v elixir v node beam virtual machine busy waiting microstate accounting msacc burstable performance instance option cowboy test stressgrid vmargs conclusion discussion lobster,benchmarking go v elixir v node discovered elixir running beam virtual machine much higher cpu usage go yet responsiveness remained excellent reader suggested busy waiting may responsible behavior turn busy waiting beam optimization ensures maximum responsiveness essence waiting certain event virtual machine first enters cpuintensive tight loop continuously check see event question occurred standard way handling let operating system kernel manage synchronization way waiting event thread get opportunity run however event question happens immediately entering waiting state coordination kernel wasteful interesting side effect busy wait approach cpu utilization reported operating system becomes misleading since kernel waiting even implemented busy waiting figure cpu utilization result busy waiting beam certainly confirm theory beam busy waiting contributing high cpu utilization benchmarking test reran test modified virtual machine modification enable extra microstate accounting running configure build withmicrostateaccountingextra parameter used msacc collect microstate accounting minute sustained phase connection test aws instance average thread realtime u accumulated system runtime u average scheduler runtime u thread alloc aux bifbusywait checkio async aux dirtycpusche dirtyiosched poll scheduler thread emulator ets gc gcfull nif async aux dirtycpusche dirtyiosched poll scheduler thread port send sleep timer async aux dirtycpusche dirtyiosched poll scheduler stats reveal two utilized thread type poll scheduler poll thread idle checking io state scheduler thread spend emulator running code busy waiting theory confirmed true utilization fact lower cpu utilization reported o another side effect busy wait approach occurs machine fully dedicated running beam case nonbeam kernel thread may receive unfairly low slice cpu time addition running beam cloud burstable performance instance busy waiting may result spending unnecessary cpu credit alleviate beam virtual machine set option regulate amount busy waiting done vm option sbwt sbwtdcpu sbwtdio set none disable busy waiting main scheduler dirty cpu scheduler dirty io scheduler respectively important question whether effect responsiveness busy waiting disabled find ran test limited use case serving http request cowboy web server test run test used stressgrid loadtesting framework generator stressgrid monitor cpu utilization generator avoid skewed result due generator oversaturation test generator stayed cpu utilization used synthetic workload consisting client device client device open connection sends request millisecond one server handle request sleeping millisecond simulate backend database request return kb payload without additional delay result average connection lifetime second average load request per second order compare beam behavior different condition ran test target instance chose instance type following assumption would allow meaningful headroom cpu capacity let virtual machine run without stress virtual machine would nearly exceed cpu capacity would sufficient cpu capacity handle workload causing virtual machine run stress instance type ran test without busy waiting disable busy waiting added following line vmargs sbwt none sbwtdcpu none sbwtdio none looking request per second see handle full target workload request per second becoming saturated request per second busy wait setting effect metric hand busy wait setting show significant impact cpu utilization graph instance type enabling busy waiting cause cpu saturated disabling busy waiting cause cpu utilization scale workload get detailed picture also collected two latency metric along corresponding distribution characteristic time open connection time http response header instance show similar result responsiveness meaningful difference respect busy wait setting latency metric collected instance confirm beam virtual machine working stress latency standard error increasing yet see meaningful difference enabled disabled busy waiting conclusion test found beam busy wait setting significant impact cpu usage highest impact observed instance available cpu capacity time observe meaningful difference performance vms busy waiting enabled disabled must note use case limited serving http request cowboy web server conceivable different scenario would noticeable difference probably busy waiting introduced beam first place running http workload cowboy dedicated hardware would make sense leave waiting place running beam o kernel shared software make sense turn busy waiting avoid stealing time nonbeam process would also make sense use busy waiting running burstable performance instance cloud discussion lobster
136,Lobsters,elixir,Elixir programming,Benchmarking Go vs Node vs Elixir,https://stressgrid.com/blog/benchmarking_go_vs_node_vs_elixir/,benchmarking go v node v elixir,cowboy http gitlabcomstressgriddummies connection test connection test methodology stressgrid conclusion discussion lobster discussion hacker news,benchmark test compare three web application node elixir cowboy subjecting synthetic workload first later connection simulate generic web application client server behavior devised following synthetic workload client device open connection sends request millisecond one server handle request sleeping millisecond simulate backend database request return kb payload without additional delay result average connection lifetime second average load request per second per device first test set target simulate device aws instance vcpus gib ram second test set target simulate device aws instance vcpus gib ram correspondingly target load request per second test run consisted rampup target device count load minute sustained target device count load finally rampdown back test take hour complete metric collected two source first collected following metric client device time open connection time sending request receiving http header corresponding response time receiving http header receiving entire http body metric aggregated client device histogram retain distribution characteristic addition summary metric total number open connection average request per second collected second source metric target server collected network cpu utilization used ubuntu kernel sysctld override seen test webservers go version node version erlang cowboy ranch source code test application available http gitlabcomstressgriddummies connection test test test webservers achieved target connection count go elixir mostly keeping target load request per second node due latency see later maxing slightly request per second time open connection averaged singledigit millisecond mostly across three subject exception go hiccup rampup phase time receive request header includes artificial delay millisecond randomization go elixir similar reflecting delay addition constant network latency story node different observe adding latency immediately followed big jump latency latency deviation minute run rampup hit request per second time receive request body averaged singledigit microsecond sustained phase go node elixir similar inbound network utilization similar three test application sustained phase mb per second make one request around byte outbound network utilization closely correlated request per second node somewhat lagging behind sustained phase around mb per second mean every payload byte protocol overhead cpu utilization thing get interesting node application utilized least amount cpu time achieved maximum cpu utilization still rampup phase seen go elixir demonstrated similar performance characteristic perspective yet elixir achieved result significantly higher cpu utilization connection test test go elixir reached target connection count node peaked connection go elixir also able keep sustained target load request per second node maxed request per second second rampup phase connection node became severely overloaded connection taking singledigit second open go elixir remained low singledigit millisecond open connection hiccup node overloaded average time receive request header grew second go elixir time receive request header remained around millisecond notably elixir maintained nearlyconstant performance throughout entire test average slowed millisecond reaching connection time receive request body remained singledigit microsecond distribution similar test likely mean testing client side network utilization grew proportionally test go elixir peaked mb outbound network gigabit per second mean wanted achieve workload would come close saturating gb link node peaking target workload also showed network utilization corresponding handled load cpu utilization confirms finding test go efficient using cpu would headroom application computeintensive elixir nearly saturated core delivering surprisingly consistent performance node exhausted scalability limit utilizing singledigit percent available cpu resource methodology run test used stressgrid framework generator device generator device stressgrid monitor cpu utilization generator avoid skewed result due generator oversaturation test generator stayed cpu utilization target generator instance placed single vpc two availability zone using internal ip network communication approach tried simulate typical behavior load balancer ondemand instance test cost around test cost around including data transfer conclusion goal benchmark analyze go node elixir exhibit observed behavior instead wanted quantify behavior reader familiar internal working system reflect strong weak side reader already using one system planning migrate one another hope provide backofthenapkin guideline help capacity planning also welcome suggestion improve benchmarking approach discussion lobster discussion hacker news
139,Lobsters,elixir,Elixir programming,Nested data structures with functional lenses,https://yapee.svbtle.com/nested-data-structures-with-lens,nested data structure functional lens,http hexpmpackageslens http enwikipediaorgwikifold higherorderfunction http hexdocspmlensreadmehtml http githubcomobroklens,march concept going describe far new however found good elixir library implemented wrote one http hexpmpackageslens familiar lens probably find anything new post go use library still great lens think like elixir getinupdatein steroid case getinupdatein describe path single value narrow exception accessall lens allows describe path many value get update one function call fact lens lens compatible getinupdatein also note say update mean functional sense create new datastructure mostly except part updating example use lensfilter like accessall focus certain element import integer data lens lensfilter getin data lens updatein data lens neat thing lens use function lens compose complex lens simplest example lensseq applies first lens second one sequence behaves similarly listing many key getinupdatein call return lens result composed example import integer data item lenskey focus given key map lens lensseq lenskey item lensfilter getin data lens updatein data lens item another useful composition function lensboth generalisation lensmultiple focus argument lens focus example import integer data b lens lensseq lensboth lenskey lenskey b lensfilter getin data lens updatein data lens b bigger example let imagine devised kind structure represent mathematical expression represents number x x le theoretical may seem writing kind parser might end something similar let say would like validate allowed operation used expression allow roll sleeve type following function def allowedoperators operator enummember operator allowedoperators allowedoperators end def allowedoperators true far good let add another function one substituting value variable expression evaluated def substitute operator variable value operator substitute variable value end def substitute variable variable value value def substitute value value finally function evaluate expression def eval operator eval eval case operator end end def eval value value wrong picture look right angle turn small part code actually dealing function supposed enummember operator def substitute variable variable value value case operator end rest function traverse expression structure might also noticed bug one traversal substitute go right branch tree somehow traversal provide changing part would also make le likely make bug one case one approach would write traversal function take expression action perform recursively call subexpressions expression action calling action subexpression fine although might work bit complicated need different kind traversal full generality need fold http enwikipediaorgwikifold higherorderfunction want propose use lens instead create composable description traversal used implement case need def subexpressions lensmatch fn lensmultiple lensseq lensat subexpressions lensseq lensat subexpressions lensroot lensroot end end expression x getin expression subexpressions ioinspect x x x introduces new concept lensmatch pass datastructure given choice function us lens returned function lensat focus given index list tuple lensroot focus whole datastructure high level first clause lensmatch implement recursive branch traversal second clause traverse leaf notice structure visited order partwhole function lens follow convention useful implementing eval using reimplement operation follows def allowedoperators expression getin expression subexpressions enumfilter match enummap fn op op end enumall enummember end def substitute expression variable value updatein expression subexpressions fn variable value end end def eval expression updatein expression subexpressions fn b b b b b b b b end end still ugliness especially allowedoperators see traversal logic almost completely moved function use composition feature talked create another lens based subexpressions focus operator def operator subexpressions lenssatisfy match lensat end lenssatisfy little bit like lensfilter instead always acting enumerable refines previous lens focus item return true filter focused composed lens also rely fact function lens come variant lensat equivalent lensseq lensat providing natural way sequence hand simplify implementation allowedoperators like def allowedoperators expression getin expression operator enumall enummember end hope short introduction convinced try lens project check full documentation http hexdocspmlensreadmehtml suggestion issue want contribute visit repo http githubcomobroklens kudos kudos
141,Lobsters,elixir,Elixir programming,Elixir v1.8 released,https://elixir-lang.org/blog/2019/01/14/elixir-v1-8-0-released/,elixir released,custom struct inspection time zone database support faster compilation performance improvement improved instrumentation ownership summing release note distillery work feature already started keynote elixirconf u install section getting started guide,elixir come many improvement infrastructure level improving compilation time speeding common pattern adding feature around introspection system custom struct inspection elixir provides derivable implementation inspect protocol nutshell mean really easy filter data data structure whenever inspected example imagine user struct security privacy sensitive information defmodule user defstruct id name age email encryptedpassword end default inspect user via inspect user include field cause field email encryptedpassword appear log error report etc could always define custom implementation inspect protocol case elixir make simpler allowing derive inspect protocol defmodule user derive inspect id name age defstruct id name age email encryptedpassword end user structs printed remaining field collapsed user id name jane age also pas derive inspect except case want keep field default exclude time zone database support elixir elixir added four type known calendar type work date time time date naivedatetime without time zone datetime time zone last version added many enhancement calendar type datetime module always evolved slower pace since elixir provide api time zone database elixir defines calendartimezonedatabase behaviour allowing developer bring time zone database defining explicit contract time zone behaviour elixir extend datetime api adding function default elixir ship time zone database called calendarutconlytimezonedatabase handle utc calendar related improvement include addition faster compilation performance improvement due improvement compiler made last year elixir compile code faster average yet another release able reduce compilation time provide joyful development experience everyone compiler also emits efficient code range check guard x z charlists interpolation foo bar baz working record via record module finally eex template got share optimization emitting compact code run faster improved instrumentation ownership caller task module one common way spawn lightweight process perform work concurrently whenever spawn new process elixir annotates parent process ancestor key information used instrumentation tool track relationship event occurring within multiple process however many time tracking ancestor enough example recommend developer always start task supervisor provides visibility allows u control task terminated node shuts code done invoking something like tasksupervisorstartchild mysupervisor taskspecification mean although code one invokes task actual parent task would supervisor supervisor one spawning would list supervisor one ancestor task relationship code task lost elixir track relationship code task via caller key process dictionary aligns well existing ancestor key therefore assuming tasksupervisor call code call supervisor spawn task mean store following relationship code supervisor ancestor task caller task spawned directly code without supervisor process running code listed ancestor caller small feature powerful allows instrumentation monitoring tool better track relate event happening system feature also used tool like ecto sandbox ecto sandbox allows developer run test concurrently database using transaction ownership mechanism process explicitly get connection assigned without caller every time spawned task query database task would know caller therefore would unable know connection assigned often meant feature rely task could tested concurrently caller figuring relationship trivial test using full power machine summing really proud release usual brings many improvement infrastructure level improvement designed feedback community many different company using elixir production full list change available release note one last major feature planned upcoming elixir version addition mix release elixir streamlining experience provided package like distillery mix release developer bundle vm compiled code single directory packaged sent production glad say work feature already started keynote elixirconf u talked next five year elixir much emphasis put community elixir designed extensible language therefore work language meant reduce time seen last two release trust community continue building solid foundation bringing new challenge ecosystem taking language new domain check install section get elixir installed read getting started guide learn turn
143,Lobsters,elixir,Elixir programming,"Property-Based Testing with PropEr, Erlang, and Elixir",https://ferd.ca/property-based-testing-with-proper-erlang-and-elixir.html,propertybased testing proper erlang elixir,propertybased testing proper erlang elixir propertybased testing basic book introduction propertestingcom book hypothesis,propertybased testing proper erlang elixir today publishing new book propertybased testing proper erlang elixir third book second one selfpublished back wrote blog post titled propertybased testing basic intended start short series introductory blog post explaining propertybased testing however soon started mapping content wanted cover found would lot needed would need frameworkspecific since lot propertybased testing automating away lot boring stuff get solid automated test short blog post ideal medium explains book today maybe year half part time free time spent book one year first draft maybe one year half adapting editing pragprog standard along various review since book introduction available online quote explaining decided write finished first book learn erlang told never something distressing spending month year work writing book spending bit free time find putting aside project hobby rewriting text close dozen time reach point even done tired writing topic chose write knew waiting ever wanted write another book decided anyway truly believe propertybased testing something amazing worth learning using fact part reason wanted write book wanted use propertybased testing project work online generally bad idea introduce technology one person team know work better compromise spend time effort writing book never using propertybased testing team know bring project hopefully feel learning worth time well feel making content accessible everyone important one aspect publishing book want negotiate one able keep free copy beer available online copy though book prior edited contains raw content nonedited reviewed missing stuff one critical part going editing hardtounderstand stuff inconsistent terminology unclear explanation plain confusing content pointed fixed text often restructured shuffled around logical book writing process pragprog also added elixir translation code chapter erlang due elixir tooling limitation time writing targeted property want see old site head propertestingcom although recommend book learn get copy book mostly start ground assuming got base knowledge erlang elixir testing experience matter much long done unit testing since found easier compare regular test done property better highlight difference tdd wo nt critical nt need amazing testing either build conceptual level exactly property write one got syntax part place challenging part think property know generate good data set able write good unit test property second section book put practice toy project one see use traditional unit test use property best one see could apply testdriven development tdd approach propertytesting discovering project requirement rest section helping debug property generator shrinking really exciting stuff called targeted propertybased testing latter fully unique proper framework show incredible promise last section book cover stateful testing modelbased approach sound fancy kind making abstract highlevel description system compare sequence operation system according model let write terse amazingly powerful integration system test framework use unit test short book bring knowing nothing property testing able test unit multiple component smooth curve try avoid highly complex description often associated propertybased testing aside got hypothesis objectively friendly text one friendliest resource get property testing think propertybased testing worth learning enough keep draft available free actually pay keep adfree would encourage anyone interested dive course also believe commercial version book much better gone editing review process get copy likely nicer experience well
144,Lobsters,elixir,Elixir programming,"Introducing Whistle, a different approach to building interactive web apps in Elixir",https://moboudra.com/whistle-interactive-web-apps-with-elixir/,introducing whistle different approach building interactive web apps elixir,liveview erlang maintaining million persistent elixir elm architecture tea elm ish web framework top elixir program elm program elixir counter program long running process websockets initialization function program first spawned websocket phoenix channel state program socket parameter update function aka reducer session state client sent message difference program state session state connected client shared client representation world player id view virtual dom websockets browser connect program use case cowboy websocket handler wrapping note shoot dm,day first found redux everyone seemed talking isomorphic javascript code could run client server got thinking whether would possible move reducer server communicate message current state client via networkthis way could without much difficulty apps like real time game chat sort soft real time application require persistent internet connectionmuch later discovered elm interestingly enough created redux inspired creating elm seemed get everything right arguable simple programming model built top robust language made making client side application fun least week ago phoenix liveview announced seemed almost impossible javascript actually seemed much easier ditching javascript elixir insteaderlang proven capable maintaining million persistent connection time elixir language functional enough able something similar elm architecture tea attempt implementing elm ish web framework top elixir server let start simple program break piece defmodule examplecounterprogram use whistleprogram def init params ok end def authorize state socket params ok socket end def update increment n state session ok state n session end def update decrement n state session ok state n session end def view state session htmldiv htmlbutton click increment htmltext tostring state htmlbutton click decrement end end program running two different connected clientswhat program defmodule examplecounterprogram use whistleprogram end first call program conceptually similar elm program different lot way thing make elm robust nonexistent elixir let crash philosophy nt translate really well tea either adjust programing model accordinglythe program main module everything related counter app belongs herea program long running process life server receive multiple client connection via websockets interact render ithere simplified diagram illustrate function module work together client update state render viewupdate view loopinitialization functionsdef init params ok end first function see function take parameter return initial state program process called program first spawned like authorize state socket params ok socket end authorize called websocket connection request access program similar join callback work phoenix channel function refuse give access specific client client joined receive view update able send message programthis function receive current state program socket contains information client connection parameter sent client example could send authorization token verify authorize must return tuple updated socket initial client session data passed everything else case empty mapthe update function aka reducer def update increment n state session ok state n session end def update decrement n state session ok state n session end update function receives message program state session state client sent message return updated program state updated session statewhat difference program state session state difference session state belongs connected client would store thing like user id preference ui state particular user basically anything concern current user program state shared client connected running programin case number stored program state mean connected client see number see previewthey exist application common state shared example making game program state could store representation world session would store player id way know player message came update function able run logic whether player desired actionthe viewdef view state session htmldiv htmlbutton click increment htmltext tostring state htmlbutton click decrement end view function called every time current state change return virtual dom diffed broadcasted via websockets clientbefore sending dom patch client whistle scan event handler attribute wire browser get sent directly update function something else following def update changesearch text state session ok state session search text end def view state search search htmldiv htmltext searching search htmlinput type text input changesearch end example whistle listens input event javascript call function first argument value input input handler plain message tuple function receives event data return actual messagehow browser connect program whistle way mounting program browser dom similar phoenix channel work would make counter actually work div id target div script import whistle whistle let target documentqueryselector target let socket whistleconnect w windowlocationhost w socketon open function socketjoin counter function counter countermount target script example opening connection socket handler listening w route mount program counter target div whistle automatically start rendering current view keep view change happen afterthis define route program defmodule exampleprogramrouter use whistlerouter match counter examplecounterprogram end like phoenix also receive parameter route unique route spawn different program instance example could make counter user add simple authentication defmodule exampleprogramrouter use whistlerouter match counter userid examplecounterprogram end defmodule examplecounterprogram use whistleprogram def init userid userid ok userid userid count end def authorize state socket userid userid stateuserid userid ok socket else error counter end end end use case whistle work great making small component mounting existing web application whistle need cowboy websocket handler good go imagine program could serve entire application different page little example def update navigate newroute state session ok state session route newroute end def view state route htmldiv htmltext welcome homepage htmla click navigate shop go shop end def view product product route shop htmldiv htmltext shop htmla click navigate back homepage renderproducts product end def view state session htmldiv htmltext found end make great making prototype apps ok requiring constant internet connection everything work message need implement json api tedious work come itand program end bunch function always organize program part different function module example defp layoutview main state session htmldiv header state session main footer state session end defp match state session state websiteprogramhomepageviewview session layoutview state session end defp match shop product product session product websiteprogramhomepageviewview session layoutview state session end defp match state session htmldiv htmltext found end def view state session route route match route state session end obviously example basic work illustration purpose work properly need hook browser history couple thing something yet figure wrapping upthis article turned longer expected still lot left talk expect post soonish planned feature thing cover next styling styled component first class cs virtual dom virtual dom dom patch stream worksession persistence client keep state refresheserror handling network loss recoverykeeping state updated across distributed nodesinitial rendering via plain http seonote something still nt time properly look actual viability serve lot client course hold million connection elixir added overhead update loop diffing dom every update every client something look future lot optimization done herethis project fun develop winter holiday current state currently working private repository lacking proper documentation bit robust enough yet looking open following weeksi really looking forward hear people think also feel free shoot dm want help way
145,Lobsters,elixir,Elixir programming,Binary pattern matching in Elixir with PNG parsing example,https://zohaib.me/binary-pattern-matching-in-elixir/,binary pattern matching elixir png parsing example,binary pattern matching creating binary pattern match byte byte bit bit parsing png binary format gist png parser japanese translation mathshun resource,dealing binary data always pickle oop language pattern matching fundamental elixir making function much descriptive pleased see pattern matching limited tuple list etc extended binary data well make easy write parse binary protocol elixir post take look binary pattern matching write simple parser png binary format binary pattern matching creating binary let start basic elixir represent binary number number range number exceeds range get wrapped around become want define multiple binary number let say byte number separate creates byte number binary translates might thought want write value greater would default number byte long change size defining binary defined size see size size bit define arbitrary number bit construct binary number according size translate usually protocol byte order hard deal make easy deal arbitrary size binary protocol try iex might see number printed string elixir string binary see binary represented string otherwise fall back printing binary number pattern match pattern matching similar define binary b result assigning b like defining binary specify size thing pattern matching size byte long value becomes leave size consider byte long want parse first bitsbytes store rest arbitrary byte length another variable let say binary protocol header first byte data rest binary extract information follows iex header size data binary iex header iex data iex header size data binary iex header iex data see specifying binary end tell elixir whatever remaining assign data work remaining data multiple bit data arbitrary bit length add bitstring instead pattern look like header size data bitstring matching arbitrary length done end pattern anywhere else something like header binary data size work another way defining binary size byte length header binary size data binary binary size mean byte length ie bit static bytebit binary format also match follows iex myformat header size data binary myformat iex header iex data iex myformat header size data binary myformat iex header iex data parsing png binary format let first take quick look png binary format look like first byte containing information png number bracket number bit data static binary start png file length ihdr width height bit depth color type compression method filter method interlace method crc png composed multiple chunk first part chunk format length chunk type data length size crc give description png binary format look like contains first part start png file containing information image followed multiple chunk chunk follow pattern png formed going extract information image file put struct elixir let see pattern match first part length size ihdr width size height size bitdepth colortype compressionmethod filtermethod interlacemethod crc size chunk binary describing format look like elixir take care everything see chunk end rest data pattern match chunk format chunk binary bitstring png conforms byte length arbitrary bit length let see pattern match chunk format length size chunktype size chunkdata binary size length crc size chunk binary interesting thing matched length pattern used pattern well elixir pattern matching use assigned variable pattern following thats able extract chunkdata based length final code look like defmodule expng defstruct width height bitdepth colortype compression filter interlace chunk def pngparse length size ihdr width size height size bitdepth colortype compressionmethod filtermethod interlacemethod crc size chunk binary png expng width width height height bitdepth bitdepth colortype colortype compression compressionmethod filter filtermethod interlace interlacemethod chunk pngparsechunks chunk png end defp pngparsechunks length size chunktype size chunkdata binary size length crc size chunk binary png chunk length length chunktype chunktype data chunkdata crc crc png png chunk chunk pngchunks pngparsechunks chunk png end defp pngparsechunks png png chunk enumreverse pngchunks end end use iex run fileread pathtopngfilepng expngpngparse spit information extracted png nt need fear binary format anymore go ahead crack open binary information using pattern matching awesomeness gist png parser japanese translation post thanks mathshun resource
146,Lobsters,elixir,Elixir programming,Sketches of Elixir,https://blog.zdsmith.com/posts/sketches-of-elixir.html,sketch elixir,sketch elixir nim member rail core team phoenix frameio technically possible lfe joxa,sketch elixir friend least respect rare breed elixir programmer never written ruby never professional erlang programmer cut teeth python began working python erlang language learned one looked excuse write addition nim would come little later would also able finagle production makespace impression elixir first several year passing acquaintance erlang ruby syntax never ended writing ruby already happy erlang syntax fairly simplistic understanding elixir language root popularity seem anything value better worse first thing many people mention erlang come syntax unfamiliar confusing least controversial love ruby hand vastly popular erlang significant population find erlang syntax eccentric ruby conventional pleasing hand many reason recommend beam otp erlang runtime system concurrent programming functional programming vastly mainstream might erlang first developed steady stream objectoriented andor web application programmer ruby otherwise taking interest erlang beam would make sense programmer coming ruby background would find elixir palatable mark ruby frame reference elixir creator member rail core team influence manifest several area part visible outside syntax also much greater emphasis programming web including railslike web framework phoenix see much need elixir seemed solution problem mention sort misguided purist attitude towards whole thing year erlang experience back new elixir programmer seemed arriviste maybe tourist barging setting conference new concurrent ruby heralded next big thing erlang ignored even sure enough express opinion part language arriviste discussion forum one frequented josé valim preternaturally patient bdfl elixir language someone posted something along line deal elixir learn instead erlang responded something along line erlang different syntax learn real thing memory josé reply something like bit reductionist also macro embarrassed know josé going see response even know macro elixir fact telling memory looking back actually josé said quote directly think breaking many confidence give brief rundown feature josé cited distinct aside macro early erlang lazy collection robust structured data structs better tooling incl testing framework mix telling remember thinking well sure macro erlang parse transforms know use macro weird used much anyway macro guy fact still use macro much today hand part reply remember part lazy collection structs tooling use constantly started working frameio august many reason really exciting opportunity one almost entire backend application written elixir long time thinking cool day get write erlang living much chauvinist see chance write elixir fulltime modulo defends writing elixir fulltime several month better worse fullyconverted elixir programmer like believe understand language much better also think better understand place beam firmament wider realm programming language programmer erlang background ruby background might even somewhat unusual position comment actual value proposition elixir language erlang ruby syntax erlang robust useful standard library tooling thing ruby syntax elixir complete red herring far superficial least consequential element language like ruby syntax dislike ruby syntax really matter learn move disappears almost immediately perhaps first thing noticed coming elixir erlang base semantics almost identical almost every element erlang language preserved wholesale elixir seen almost entirely series goody piled top reassuring erlanger lose intuition make good code second thing discover reluctant erlangtoelixir convert standard library matter two quality neither one simple coddling rubyists deal quirk erlang standard library indexing inconsistent naming argument first aspect specific module pure elixir innovation relatively obviously wellconsidered big one mentioned stream struct stream lazy collection module lovely precisely nothing unique elixir hood one imago got kind protocol macro elixiry thing presented user simply exactly sort allpurpose highly functional library could want erlang standard library structs baked language struct syntax based map structs often seem result kind oostyle datamethods object expect python would never see erlang tradeoff get certain amount compiletime check attribute access static guarantee might thing would willing trade away erlang datatype minimalism second aspect given opportunity greenfield entire standard library top everything get erlang already turn implement pretty elegant feature instance make sure object function first argument position every single function making possible introduce pipe operator quite simply fucking love pipe relatively speaking extremely assignment elixir functional immutable programmer encouraged syntactically think code series data transformation chained together programmer rewarded extremely terse expressive time scarily close point free structure make debugging rearranging refactoring straightforward reduces parenthesis noise big win le erlangy arbitrary reason distrust erlang syntax make easier write better code third thing discover maybe new syntactic sugar kind nice use keyword argument example elixir approximate pythonstyle positional named function argument f x ztrue syntax f x z true exactly kind unnecessary imposition rubyist trope lookout realize actually sugar extremely idiomatic erlangism tagged value x z true precisely equal x z true existing erlang convention passing optional parameter function easier type read sort thing end quite reassuring sometimes elixir gotten heat read blog post talk phoenix microservices way people talk node air hype untroubled confidence new best way build web apps seems come reading blog post suffering building many system new upandcoming technology always carry penumbra thought leadership startup marketing masquerading howto blog post fact creator language seem understand erlang idiom well tread heavily possible reflect essential erlang imagine could extend took upon design several layer expressiveness top otp model much work elixir ecosystem almost elixir application built otp application model gen concept even extended new behaviour like genstage course simplicity flatness erlang nothing elixir traded away protocol using macro elixir many new form code reuse polymorphism possible idiomatic erlang mean many place magic imported module expanded macro thing obvious reading code said enormously happy working elixir experience writing elixir pleasure better foundation beam otp fact working elixir fulltime renewed interest entire beam ecosystem elixir demonstrated bone erlang valuable applicable enough serve foundation programming language flavor elixir programmer treated ecumenical view entire beam erlang standard library well erlang code path available transparently called elixir expand relationship direction calling elixir code erlang technically possible quite convenient chucking module file src make compiled elixir code transparently available erlang programmer matter lfe programmer far go making tool like mix functionally equivalent far get towards truly languageagnostic workflow running otp application module written lfe elixir erlang get point love see come elixir language community got wonderful momentum right lot interest lot new contributor thoughtful motivated core team opportunity work towards totally integrated beam ecosystem
147,Lobsters,elixir,Elixir programming,Fibonacci Algorithms in Elixir Part 2,https://stratus3d.com/blog/2018/12/24/fibonacci-algorithms-in-elixir-part-2,fibonacci algorithm elixir part,another look algorithm time complexity last post wrote various fibonacci implementation unwind said lobster response rewriting algorithm implementation rosetta code popular implementationdave thomas function generates list fibonacci number fastest benchmarking source file result initial run four subsequent run conclusion original algorithm resource,another look algorithm time complexity last post wrote various fibonacci implementation elixir timed implementation generating list first n fibonacci number compared performance characteristic implementation based unwind said lobster response decided revisit fibonacci implementation elixir going update implementatios used last blog post use erlang process store previously computed fibonacci number benchmark implementation fibonacci implementation see much process sped thing rewriting algorithm needed process algorithm store computed fibonacci number chose create single generic genserver could spawn algorithm testing implementation settled fairly straightforward thing special genserver code allows caller specify server want use necessary multiple process running different instance genserver one implementation testing need different fibstore server algorithm different need make sure store fetch fibonacci number correct server defmodule fibstore use genserver def dofib name number fibfun case get name number nil result fibfun number put name number result result result result end end defp get name number genservercall name get number end defp put name number value genservercall name put number value end def maybestart name case genserverstartlink module name name ok pid ok error alreadystarted pid ok end end genserver callback def init ok end def handlecall get number state reply mapget state number state end def handlecall put number value state reply ok mapput state number value end end next needed update existing function use new genserver fetching storing value previous implementation fib function performed actual computation avoid modifying lot code added new function named dofib call existing fib function computation fibonacci number already computed stored genserver instance three new implementation implementation updated implementation fib clause generating number first two fibonacci sequence invokes ensures reuse already computed number one otherwise invoke compute store number defmodule myfib def fibonacci number fibstoremaybestart module enumreverse fibstoredofib module number end def fib def fib def fib number number x fibstoredofib module x yall end end rosetta code much way changed rosetta code algorithm invokes computing fibonacci number us precomputed number exist fibstore process otherwise invokes compute fibonacci number note unlike implementation one must recompute everything generating new number sequence example generating fifth number would able reuse cached fibstore process could make reuse precomputed number without changing way function work defmodule rosettacodefib def fibonacci number fibstoremaybestart module enummap number fn n fibstoredofib module n end end def fib def fib def fib n fib def fib prv prv def fib prvprv prv n next prv prvprv fib prv next end end popular implementationdave thomas implementation benefited fibstore caching precomputed number remains similar original implementation invokes computing number due recursive nature function call made every number must computed implementation able use precomputed number starting point computing new number unlike rosetta code implementation defmodule thomasfib def fibonacci number fibstoremaybestart module enummap number fn n dofib n end end def fib def fib def fib n dofib dofib defp dofib number fun fibstoredofib module number fun end end function generates list fibonacci number fastest bet implementation would still perform better others sure others would fastest rosetta code algorithm able leverage fibstore caching much others already fairly fast algorithm benchmarking reused benchmarking code first blog post see source file benchmarking code since new algorithm maintain state performance first run differ performance subsequent run decided would run benchmark capture performance initial run would run benchmark four time measure performance subsequent run first blog post result initial run ran benchmark capture performance state time microsecond number rosetta code dave thomas mine four subsequent run first run ran benchmark algorithm four time average run time shown table microsecond number rosetta code dave thomas mine comparison average run time original algorithm list size rosetta code dave thomas mine conclusion looking data table clear dave thomas algorithm benefited new process caching computed number surprising due increasing number recursive call original algorithm used computing large number clear run time time complexity original algorithm exponential process caching place time complexity longer exponential take time figure would guess new dave thomas algorithm process caching linear time complexity rosetta code algorithm really benefit new process caching performance characteristic remain run nearly time slower algorithm benefit process caching either ran time slower original algorithm even though process cheap erlang vm local message fast clear overhead caching data separate process taking toll algorithm sending message cheap eventually time take process scheduled receiving message add data cached algorithm must send receive least message every recursion needed compute final number even number already computed two message needed fetch number two original algorithm performed well keep precomputed number process memory reusing necessary caching reduces arithmetic operation needed subsequent call even subsequent call overhead sending receiving two message greater cost computing list fibonacci number least first fibonacci number sequence come generating list first n fibonacci number original algorithm still seems fastest algorithm tested algorithm designed ground specifically generating list first n fibonacci number sequence think take away code written specific task may outperform code general purpose resource
148,Lobsters,elixir,Elixir programming,SpawnFest 2018 Winners were Announced,https://spawnfest.github.io/winners,spawnfest winner announced,,tweet spawnfest status event
149,Lobsters,elixir,Elixir programming,Optional Notes and Exact Pitches in Chord,http://www.petecorey.com/blog/2018/12/17/optional-notes-and-exact-pitches-in-chord/,optional note exact pitch chord,elixirpowered chord project voice leading distance fingering distance lead sheet supporting optional note module supporting exact pitch function talked previous article pitch class final thought check entire chord project github,currently elixirpowered chord project lot really cool thing generate huge number guitar chord given set note want included chord also computes voice leading distance fingering distance chord let u map ideal chord progression functionality awesome missing key feature would bring next level traditionally musician quickly learn song help lead sheet lead sheet consists melody laid set chord musician interpret play chord given melody way make sense player listener want chord able generate possible interpretation lead sheet giving u chord progression include optional note specific melody note supporting optional note may surprising hear often time many note make chord entirely optional example playing chord made root chord third fifth major seventh usually acceptable omit fifth chord fifth usually serf add harmonic stability root note necessary convey color chord listener ability mark note optional drastically expands possible set chord generate given set note optional note need generate possible chord include note possible chord include merge result together let update chordvoicing module within chordvoicing module function take set note return list possible note set spread across string guitar build chord note set really collection note want play example trying play optional fifth note set might look like root third seventh root third seventh root root third seventh third root third seventh seventh root third seventh fifth root third seventh fifth root root third seventh seventh seventh seventh notice smallest note set set three required note also note first three required note every possible permutation every possible note chord required optional note included implement fairly easily function let start filtering provided set note required note requirednotes enumfilter note fn optional note false true end assume optional note keyword tuples optional first element actual note second value require note simply bare note value next let filter note list optional note optionalnotes enumfilter note fn optional note true false end finally let get list together possible note optional required included allnotes enummap note fn note note note note end put duck row generating possible note set fairly straight forward know every note set start set required note mean length note set range length length required note number string guitar length requirednotes also know set required note remaining space note set filled every permutation possible note allowing repetition permutationgenerate allnotes length length requirednotes true loop set value combine result list comprehension come final list note set length length requirednotes tail permutationgenerate allnotes length length requirednotes true requirednotes tail end supporting exact pitch built note set need translate actual chord chordvoicing module help function take single note note set find possible location fretboard note played talked previous article building complete fretboard filtering sieving note fretboard note trying play original code decided provided targetnote matched note given fret index string looked something like rem note targetnote string index else nil end pitch class note rem note match targetnote add current string fret list tuples returned function solution assumes note note set pitch class value looking c targetnote match octave c find across fretboard modify solution support exact pitch minimal effort assume exact pitch passed targetnote parameter like pitch class plain number add fallback check condition check exact equality cond rem note targetnote string index note targetnote string index true nil end pitch class current note match targetnote untouched value note still might example looking specifically middle c condition would match exact pitch higher lower octave c final thought chordvoicing module support building chord note set include optional note exact pitch one step closer modeling lead sheet interesting aside started refactor noticed original implementation completely wrong sure going mind wrote first version returning small subset possible note set equipped new implementation chord generating many time number possible chord u play sure check entire chord project github stay tuned update experiment
150,Lobsters,elixir,Elixir programming,SpawnFest repos made public,https://twitter.com/spawnfest/status/1074983265566646272,spawnfest repos made public,,detected javascript disabled browser would like proceed legacy twitter yes
151,Lobsters,elixir,Elixir programming,spawnfest/alpheidae,https://github.com/spawnfest/alpheidae,spawnfestalpheidae,join github today sign file permalink alpheidae running development mumble demonstrationtesting snaphots configuring server ranch ssl todos future work useful reading topic resource reload reload,spawnfest project unique possible dismiss join github today github home million developer working together host review code manage project build software together sign file permalink failed load latest commit information type name latest commit message commit time alpheidae minimal mumble voice chat server written elixir running development make sure following installed elixir compiled erlangotp openssl mumble greater run following gereate set self signed key start server mix depsget mix generatekeys mix run nohalt connect port demonstrationtesting get mumble client ubuntu higher get snaphots get dependency mix depsget generate server key mix generatekeys start server mix run nohalt new terminal start new mumble instance mumble connect instance server default localhost port mute instance click little microphone icon make reddisabled unmute one instance talk hear talking send message chat room watch show instance rightclick one instance send private message watch show instance instance doubleclick channel name user change channel observe instance configuring server edit configdevexs valid key key description welcometext text sent user connect server maxbandwith max bandwith used audio calculation channel list channel server socketoptions ranchssl option todos future work udp support channel link acls permission system client certificate authentication better channel configuration web interfaceinbrowser audio better deafeningmuting support server viewer support useful reading spawnfest project unique possible topic resource perform action time signed another tab window reload refresh session signed another tab window reload refresh session
152,Lobsters,elixir,Elixir programming,"Phoenix.LiveView: Interactive, Real-Time Apps. No Need to Write JavaScript",https://dockyard.com/blog/2018/12/12/phoenix-liveview-interactive-real-time-apps-no-need-to-write-javascript,phoenixliveview interactive realtime apps need write javascript,programming model serverrendered scale morphdom full source reduced complexity optimal data transfer error recovery battletested foundation liveview think elixirconf keynote loc clientside application going away next dockyard,phoenix liveview exciting new library enables rich realtime user experience serverrendered html liveview powered application stateful server bidrectional communication via websockets offering vastly simplified programming model compared javascript alternative modern javascript tooling enables sophisticated client application often come extreme cost complexity maintainability common class application rich experience needed full singlepage application otherwise overkill achieve bit required rich interaction applies broad usecases including simple realtime update clientside style validation immediate feedback autocomplete input go far realtime gaming experience liveview fill gap challenge possible serverrendered application sneak peek capable application developer need write single line javascript create kind experience write test code single language elixir let find programming model live view share functionality regular serverside html view used writing write template code render function generates html client said live view go enabling stateful view support bidrectional communication client server live view react event client well event happening server push rendered update back browser effect share similar interaction rendering model many clientside library exist today react ember implemented theromstat display temperature control programming model could illustrated follows live view start life stateless render controller sends html client regular http request even javascript disabled endusers crawler alike receive html expected http request live view connects server upgraded stateful process awaits event client state change server like many clientside framework time callback change view state render reinvoked update applied browser dom process repeat long user visiting page let check thermostatview detail defmodule demowebpagecontroller use demoweb controller def thermostat conn liverender conn demowebthermostatview end end defmodule demowebthermostatview use phoenixliveview import calendarstrftime def render assigns l div class thermostat div class bar mode phxclick togglemode mode span strftime time r span div div class control span class reading val span button phxclick dec class minus button button phxclick inc class plus button div div end def mount session socket connected socket processsendafter self tick ok assign socket val mode cooling time calendarlocaltime end def handleinfo tick socket processsendafter self tick noreply assign socket time calendarlocaltime end def handleevent inc socket noreply update socket val end def handleevent dec socket noreply update socket val end def handleevent togglemode socket noreply update socket mode fn cooling heating heating cooling end end end live view mount check see statically rendered connected back server connected send ourself tick message every second trigger handleinfo callback used handle message within server update time current time next use phxclick binding containing event name template binding emit client event handled callback receive event increment decrement temperature simply update socket state likewise receive togglemode event simply update mode assign flipped setting callback change socket state liveview detects change call updated assigns push result browser let see action serverrendered scale heard year serverrendered html thing past rich application besides fast application render entire template server every change fear liveview shatters misconception often sends le data equivalent clientrendered application thanks josé valim excellent work liveeex template language embedded elixir capable computing diffs able send part page changed never send static part template initial render allows browser receive static dynamic part mount dynamic part changed update browser receives update dynamic part page computes html static cache performs minimal dom patch morphdom enables minimal update network minimal update dom achieve compiling template code block execute dynamic part template conditionally let see action another liveview example simple realtime image editor full source dom inspector highlight area dom updated see even imageview updating width resolution browser onchange event patch minimal bit dom changed displayed width image tag width likewise view javascript console debug logging enabled see despite server calling function every change data sent wire minimal dynamic value required update page amazing get even better though instead sending dynamic value change liveview send updated dynamic value changed see action end clip toggle image background color send unchanged width viceversa optimization allow u match singlepage application payload size see next example reduced complexity optimal data transfer one enjoyable aspect liveview little code required accomplish feature versus javascript code tooling related server code accomplish task many case also match singlepage application term data transfer case send le data equivalent spa one common usecase illustrates well autocomplete input would otherwise require javascript server http fetch endpoint encoding logic client template code loc total liveview defmodule demowebsearchview use phoenixliveview def render assigns l form phxchange suggest phxsubmit search input type text name q value query list match placeholder search loading readonly datalist id match match match option value match match option end datalist result pre result pre end form end def mount session socket ok assign socket query nil result nil loading false match end def handleevent suggest q q socket bytesize q word systemcmd grep w q usrsharedictwords noreply assign socket match stringsplit word n end def handleevent search q q socket bytesize q send self search q noreply assign socket query q result loading true match end def handleinfo search query socket result systemcmd dict query stderrtostdout true noreply assign socket loading false result result match end end example dictionary search autocomplete suggestion taking advantage datalist tag used browsernative autocomplete requires polyfill safari demonstration simply shell grep using system builtin word dictionary trigger suggestion update simply add phxchange suggest parent form executes handleevent suggest callback every keystroke callback job update socket assigns new match new match exist invoked client receive render minimal diff seen likewise phxsubmit trigger handleevent search callback shell dict command line dictionary since dict make remote network call word lookup async operation sending message update assigns loading state picking search query message familiar handleinfo callback perform fetch update socket assigns search result loading state guessed call sends value changed shockingly small amount code compared required support singlepage application even ideal circumstance likewise inspect data wire keystroke see liveview match equivalent handwritten client application data transfer send dynamic value final representation ui display case send le data even optimized client templated application another benefit fact liveview powered phoenix channel websockets providing le latency ajax triggered http request often used autocomplete suggestion ajax would overhead http request response work server authenticate every request etc stateful reduce latency server work emitting json payload would comparable handwritten json response future version send even le data using binary erlang term format cut payload size half example like error recovery battletested foundation liveview sits atop erlang battletested foundation building stateful application handling failure thing go wrong using battletested primitive phoenix live view builtin error handling recovery even customize ui error state without touching single line javascript thanks phxerror phxdisconnected class automatically applied template let see action imagining introduce following bug thermostatview def handleevent inc socket socketassignsval raise boom noreply update socket val end let see recovers one defining lesson elixir erlang process crash restarted known good state see action thermostat soon view crash server see error loading state applied client via phxerrorand phxloading cs class next quickly see client reestablish thermostatview process server known good initial state client becomes avaiable continued interaction beauty platform error recovery idea apply well distributed system client uis user never left unrecoverable error state due bug stateful system build elixir recover known good condition continue liveview think thanks elixir power phoenix legendary microsecond response time erlang otp stateful foundation liveview perfectly suited render template handle callback high load frequency covered detail elixirconf keynote showing rainbow animation powered server let see something interactive liveview phxkeypress phxkeyup phxkeydown event even liveview powered game viable option example featurecomplete snake game loc requires zero userland javascript see action clientside application going away much liveview shine type use case covered always place code running client certain usecases experience demand zerolatency well offline capability javascript framework like react ember etc shine example javascript engineer dockyard working fortune company offlinecapable requirement since employee field limited connectivity add complexity easily justified given clear business requirement fortunately great client framework option come kind experience building desktoplike feature next google doc competitor offlinecapable web application javascript framework enable need otherwise need bit rich interaction realtime validation autocomplete multistep form even simple game liveview fantastic choice also offer saving payload size compared javascript framework alternative namesize minified liveviewjs vue react react ember liveviewjs morphdom much lighter j framework framework baseline still need ship applicationspecific j often add supporting j library reactrouter redux friend get feature parity next close initial release wait see kind application community build liveview next step building testing tool similar phoenixchanneltest allow testing live view client interaction purely elixir without browser also shipping liveview generator allow bootstrapping crud uis like existing phxgenhtml generator fully realtime outofthebox stay tuned dockyard digital product agency offering exceptional user experience design full stack engineering web app development custom software ember elixir phoenix service consulting training
153,Lobsters,elixir,Elixir programming,Building a JSON API in Elixir with Phoenix 1.4,https://lobotuerto.com/blog/building-a-json-api-in-elixir-with-phoenix/,building json api elixir phoenix,rail json api elixir phoenix read introduction fluid svgs vuejs api vuejs api quickstart guide new vuejs project wrong jwts tutorial json api prerequisite install elixir erlang elixir asdf install postgresql postgresql rest client rest client api postman advanced rest client axios axios cors cli create new apionly phoenix application generate app file myphoenixjsonapi myapp myphoenixjsonapilib myappex myapp create development database postgresql start development server phoenix livedashboard json error debugerrors false true timestamps microsecond resolution user schema user account generate module account context user schema account user user email passwordhash hash password saving bcrypt add user libmyappaccountuserex password bcrypt fix test password testmyappaccounttestexs createuser updateuser configtestexs user endpoint generate new json endpoint account user fix test password create couple user iex repl using iex iex using curl adding seed data simple authentication verify password signin endpoint signin signin controller function signin define signinjson view test signin endpoint curl good credential bad credential session save authentication status session renewal guest authenticated session fixation phoenix protect resource authentication pipeline plug amazing phoenix ftw fix test add missing test endpoint testing curl cooky curl cors configuration api frontend cors crossorigin resource sharing cors corsica corsplug corsica cors http devops note devops bonus section github repository customize json response format project file elixir builtin code formatter elixir use different port phoenix server development visual studio code extension elixir elixirls exercise reader rest db useful link curl learning,rail background tired looking outdated incomplete tutorial build json api using elixir phoenix read friend introduction found mainly two type tutorial one write scoped focused tutorial full stepbystep tutorial scoped focused tutorial used explain technique like one fluid svgs vuejs full stepbystep tutorial used teach new tech stack going zero fully working prototype without skipping step best practice bakedin presenting best library available given task really like tutorial take holistic approach generate new phoenix api app easy enough need pas nowebpack nohtml mix phxnew tutorial creating small fully operational json api web application recommend take look vuejs frontend complement api quickstart guide new vuejs project create new apionly phoenix application html j stuff create user schema hashed password storing plain text password database wrong create user endpoint get list create delete user cors configuration use frontend run another port domain create sign endpoint session based authentication cooky interested auth jwts check tutorial basically tutorial wish available trying learn implement json api elixir phoenix prerequisite install elixir start installing erlang elixir using asdf version manager version manager best practice development environment install postgresql postgresql default database new phoenix apps good reason solid realiable well engineered relational db rest client might need get rest client try api endpoint two popular one seem postman advanced rest client tried say liked least chrome app incarnation one display cookie info send declared variable post request today deprecated google chrome extension using web frontend library like axios developer tool enough go axios forget pas configuration option withcredentials true allow client send cooky along cors request could use good curl work really well show test endpoint cli create new apionly phoenix application generate app file terminal mix phxnew myphoenixjsonapi app myapp module myapp nohtml nowebpack binaryid command see myphoenixjsonapi name directory created application see myapp used file directory inside myphoenixjsonapilib eg myappex find myapp used everywhere main module app example libmyappex defmodule myapp moduledoc myapp keep context define domain business logic context also responsible managing data regardless come database external api others end create development database created new db user installing postgresql add credential configdevexs configtestexs execute cd myphoenixjsonapi mix ectocreate drop database dev environment mix ectodrop like drop database test environment need mixenvtest mix ectodrop start development server terminal mix phxserver visit http bask glory beautifully formatted error page worry though adding json endpoint soon enough phoenix livedashboard visit http version see awesome json error rather see html page whenever error instead receive json response set debugerrors false configdevexs restart server config myapp myappwebendpoint debugerrors false visiting http yield error detail found force json api development mode need think deal json error start need info want see html error page change debugerror setting back true time stop development server hit ctrlc twice timestamps microsecond resolution second enough want timestamps resolution modify configconfigexs file like config myapp ectorepos myapprepo generator binaryid true add support microsecond database level avoid configure every migration file config myapp myapprepo migrationtimestamps type utcdatetimeusec configures endpoint config myapp myappwebendpoint url host localhost user schema generating new user schema inside account context context cool serve api boundary allow better code organization application generate module account context user schema mix phxgencontext account user user email string unique isactive boolean account module name user module name user db name follows field definition open migration file generated previous command privrepomigrations time stamp createusersexs make change email null add passwordhash string field defmodule myapprepomigrationscreateusers def change create table user primarykey false add id binaryid primarykey true add email string add email string null false add passwordhash string add isactive boolean default false null false timestamps run new migration mix ectomigrate want read info generator execute mix help phxgencontext hash password saving add new dependency mixexs defp deps bcryptelixir end bcrypt use hash user password saving store plain text inside database fetch new app dependency mix depsget add next line end configtestexs config bcryptelixir logrounds add configuration option configdevexs configprodexs used testing speed process decreasing security strength specific environment add virtual field user schema meaning corresponding field database add following change libmyappaccountuserex defmodule myappaccountuser schema user field email string field isactive boolean default false field password string virtual true field passwordhash string timestamps add support microsecond app level specific schema timestamps type utcdatetimeusec end doc false def changeset user attrs user cast attrs email isactive validaterequired email isactive cast attrs email isactive password validaterequired email isactive password uniqueconstraint email putpasswordhash end defp putpasswordhash ectochangeset valid true change password password changeset change changeset bcryptaddhash password end defp putpasswordhash changeset changeset end end notice call definition changeset run function changeset happens valid password key hash using bcrypt otherwise pas changeset running bcrypthashpwdsalt hola iex mix would result something like strange looking string end saved database instead plain text password fix test run test project mix test right fail test user valid data creates user myappaccounttest match failed code assert ok user user accountcreateuser validattrs right error action insert change email email isactive true error password ca nt blank validation required data valid false stacktrace test change made user schema easily fixed adding password attribute needed testmyappaccounttestexs defmodule myappaccounttest describe user alias myappaccountuser validattrs email email isactive true updateattrs email updated email isactive false invalidattrs email nil isactive nil validattrs email email isactive true password password updateattrs email updated email isactive false password updated password invalidattrs email nil isactive nil password nil def userfixture attrs ok user defmodule myappaccounttest user end def userwithoutpassword attrs userfixture attrs password nil end test return user user userfixture user userwithoutpassword assert accountlistusers user end test getuser return user given id user userfixture user userwithoutpassword assert accountgetuser userid user end defmodule myappaccounttest end test invalid data return error changeset user userfixture user userwithoutpassword assert error ectochangeset accountupdateuser user invalidattrs assert user accountgetuser userid end take opportunity verify password createuser updateuser defmodule myappaccounttest assert ok user user accountcreateuser validattrs assert useremail email assert userisactive true assert bcryptverifypass password userpasswordhash end test invalid data return error changeset defmodule myappaccounttest assert ok user user accountupdateuser user updateattrs assert useremail updated email assert userisactive false assert bcryptverifypass updated password userpasswordhash end test invalid data return error changeset mix test yield error mix test finished second test failure randomized seed commented config line configtestexs test would run like mix test finished second test failure randomized seed would take time user endpoint generate new json endpoint generate json endpoint user since already account context user schema available pas nocontext noschema option mix phxgenjson account user user email string password string isactive boolean nocontext noschema fix test try run test see error test index list user myappwebusercontrollertest undefinedfunctionerror function undefined private code conn get conn routesuserpath conn index test update user render user data valid myappwebusercontrollertest undefinedfunctionerror function undefined private code conn put conn routesuserpath conn update user user updateattrs complaining missing function add following line libmyappwebrouterex resource user usercontroller except new edit declaring resource router make helper available controller libmyappwebrouterex defmodule myappwebrouter scope api myappweb pipethrough api resource user usercontroller except new edit end end still test complain fix need change something libmyappwebviewsuserviewex defmodule myappwebuserview end def render userjson user user id userid email useremail password userpassword isactive userisactive id userid email useremail isactive userisactive end end sending password attribute inside response since sending password endpoint need remove password password password updated password line testmyappwebcontrollersusercontrollertestexs defmodule myappwebusercontrollertest assert id id email email isactive true password password isactive true jsonresponse conn data end defmodule myappwebusercontrollertest assert id id email updated email isactive false password updated password isactive false jsonresponse conn data end last couple error add new clause libmyappwebcontrollersfallbackcontrollerex like defmodule myappwebfallbackcontroller putview myappweberrorview render end def call conn error ectochangeset conn putstatus unprocessableentity putview myappweberrorview render end end test fine mix test finished second test failure randomized seed create couple user launch iex app environment available within iex mix akin well known rail console way repl app environment launch dev server time iex mix phxserver convenience using iex start iex type myappaccountcreateuser email asd asdcom password qwerty using curl curl available terminal create new user api endpoint using something like curl h contenttype applicationjson x post user email emailcom password password http remember restart server since made change router adding seed data sometimes want predefined data available application seed data come phoenix already defined file privreposeedsexs add couple user record ioputs adding couple user myappaccountcreateuser email emailcom password qwerty myappaccountcreateuser email emailcom password asdfgh execute file mix run privreposeedsexs four user available local database asd asdcom emailcom emailcom emailcom simple authentication verify password add function libmyappaccountex verify password defmodule myappaccount def changeuser user user userchangeset user end def authenticateuser email password query u user uemail email query repoone verifypassword password end defp verifypassword nil perform dummy check make user enumeration difficult bcryptnouserverify error wrong email password end defp verifypassword user password bcryptverifypass password userpasswordhash ok user else error wrong email password end end end signin endpoint add new signin endpoint libmyappwebrouterex defmodule myappwebrouter scope api myappweb pipethrough api resource user usercontroller except new edit post userssignin usercontroller signin end end signin controller function finally add signin function libmyappwebcontrollersusercontrollerex defmodule myappwebusercontroller sendresp conn nocontent end end def signin conn email email password password case myappaccountauthenticateuser email password ok user conn putstatus ok putview myappwebuserview render signinjson user user error message conn putstatus unauthorized putview myappweberrorview render message message end end end please note view module inside myappweb module inside myapp define signinjson view libmyappwebuserviewex add defmodule myappwebuserview def render userjson user user id userid email useremail isactive userisactive end def render signinjson user user data user id userid email useremail end end libmyappweberrorviewex add defmodule myappweberrorview def templatenotfound template assigns error detail phoenixcontrollerstatusmessagefromtemplate template end def render message message error detail message end end try brand new signin endpoint test signin endpoint curl start server mix phxserver development server started send request good credential curl h contenttype applicationjson x post email asd asdcom password qwerty http receive data user email asd asdcom id bad credential curl h contenttype applicationjson x post email asd asdcom password right password http get error detail wrong email password awesome move session add plug fetchsession api pipeline libmyappwebrouterex defmodule myappwebrouter pipeline api plug accepts json plug fetchsession end scope api myappweb save authentication status modify signin function libmyappwebcontrollersusercontrollerex defmodule myappwebusercontroller case myappaccountauthenticateuser email password ok user conn putsession currentuserid userid configuresession renew true putstatus ok putview myappwebuserview render signinjson user user error message conn deletesession currentuserid putstatus unauthorized putview myappweberrorview render message message session renewal good practice renew session whenever upgrade guest state authenticated state help preventing session fixation attack putsession currentuserid userid configuresession renew true seems like phoenix already session even explicitly call configuresession renew true protect resource authentication modify libmyappwebrouterex defmodule myappwebrouter pipeline api plug accepts json plug fetchsession end pipeline apiauth plug ensureauthenticated end scope api myappweb pipethrough api resource user usercontroller except new edit post userssignin usercontroller signin end scope api myappweb pipethrough api apiauth resource user usercontroller except new edit end enables livedashboard development want use livedashboard production put defmodule myappwebrouter livedashboard dashboard metric myappwebtelemetry end end plug function defp ensureauthenticated conn opts currentuserid getsession conn currentuserid currentuserid conn else conn putstatus unauthorized putview myappweberrorview render message unauthenticated user halt end end end see added new pipeline called apiauth run request new ensureauthenticated plug function also created new scope api block pipe request api apiauth order protect endpoint resource user truly amazing way define stuff phoenix composability ftw fix test obviously myappwebusercontroller test broken authentication implemented modification needed testmyappwebcontrollersusercontrollertestexs defmodule myappwebusercontrollertest alias myappaccount alias myappaccountuser alias plugtest createattrs email email defmodule myappwebusercontrollertest password updated password invalidattrs email nil isactive nil password nil currentuserattrs email current user email isactive true password current user password def fixture user ok user accountcreateuser createattrs user end def fixture currentuser ok currentuser accountcreateuser currentuserattrs currentuser end setup conn conn ok conn putreqheader conn accept applicationjson ok conn conn currentuser currentuser setupcurrentuser conn ok conn putreqheader conn accept applicationjson currentuser currentuser end describe index test list user conn conn test list user conn conn currentuser currentuser conn get conn routesuserpath conn index assert jsonresponse conn data assert jsonresponse conn data id currentuserid email currentuseremail isactive currentuserisactive end end defmodule myappwebusercontrollertest user fixture user ok user user end defp setupcurrentuser conn currentuser fixture currentuser ok conn testinittestsession conn currentuserid currentuserid currentuser currentuser end end mix test finished second test failure randomized seed add missing test add test function open testmyappaccounttestexs defmodule myappaccounttest user userfixture assert ectochangeset accountchangeuser user end test authenticates user user userwithoutpassword assert error wrong email password accountauthenticateuser wrong email assert ok authenticateduser accountauthenticateuser useremail validattrspassword assert user authenticateduser end end end add test signin endpoint testmyappwebcontrollersusercontrollertestexs defmodule myappwebusercontrollertest end end describe sign user test return user good credential conn conn currentuser currentuser conn post conn routesuserpath conn signin email currentuseremail password currentuserattrspassword assert jsonresponse conn data user id currentuserid email currentuseremail end test return error bad credential conn conn conn post conn routesuserpath conn signin email nonexistent email password assert jsonresponse conn error detail wrong email password end end defp createuser user fixture user user user mix test finished second test failure randomized seed endpoint testing curl cooky restart server try request protected resource like apiusers curl h contenttype applicationjson x get http c cookiestxt b cookiestxt get error detail unauthenticated user pay attention extra c cookiestxt b cookiestxt params enable cooky curl turn give u session support login curl h contenttype applicationjson x post email asd asdcom password qwerty http c cookiestxt b cookiestxt get data user email asd asdcom id try requesting protected resource curl h contenttype applicationjson x get http c cookiestxt b cookiestxt see data email asd asdcom id isactive false email emailcom id isactive false email emailcom id isactive false email emailcom id isactive false great success cors configuration need configure plan api frontend different domain know cors look crossorigin resource sharing cors said two option prefer corsica feature configuring cors request want le strict libray try corsplug add dependency mixexs defp deps corsica end fetch new dependency mix depsget add corsica libmyappwebendpointex plug myappwebrouter defmodule myappwebendpoint plug plugmethodoverride plug plughead plug plugsession sessionoptions plug corsica origin http allowcredentials true allowheaders contenttype log rejected error invalid warn accepted debug plug myappwebrouter end used single string origin accept list list composed string andor regular expression case rule accept cors request vuejs frontend us axios http request development server go port default devops note since guide already long extracted devops related section guide find bonus section github repository checkout code tutorial customize json response libmyappwebviewserrorviewex defmodule myappweberrorview def render assigns error detail endpoint found end def render assigns error detail internal server error end end format project file elixir builtin code formatter formatterexs file root directory content importdeps ecto phoenix input ex ex priv seedsexs config lib test ex ex subdirectory priv migration invoke mix format format whole project according default elixir formatting rule use different port phoenix server default running mix phxserver serve application port make port configurable development environment configdevexs modify line http port config myapp myappwebendpoint http port systemgetenv port bind app different port starting say mix phxserver iex mix phxserver visual studio code extension elixir recommend going elixirls pretty date many advanced feature check exercise reader task could try hand take account isactive attribute trying login implement apiuserssignout endpoint usercontroller make resty extract signin signout functionality usercontroller onto controller maybe call sessioncontroller usercontrollersignin sessioncontrollercreate usercontrollersignout sessioncontrollerdelete implement db support session implement apime endpoint new mecontroller serve kind ping endpoint check user still logged return currentuser information adjust create test new functionality useful link curl learning long one folk
154,Lobsters,elixir,Elixir programming,Language package managers: mix vs cargo,http://txti.es/wzic4,language package manager mix v cargo,create project cargo rust mix elixir application run project cargo rust mix elixir get help cargorust mixelixir build configuration cargorust mixelixir addon command cargorust mixelixir indepth write mix task project command cargorust mixelixir also define mix task module integrating language mixelixir hook rustler build rust nif used elixir cargorust cmake gcc mozjs conditional dependency cargorust mixelixir version specifier mixelixir elixir version specifier cargorust rust package workspace v umbrella project txti,action mix cargo create project mix new app app path cargo new bin path run project iex mix mix run nohalt mix phoenixserver cargo run get help mix help cmd cargo cmd help build configuration mixexs cargotoml project command mix command na global addon command mix archiveinstall package cargo install package integrating language compiler plus special case erlang rebar buildrs create project cargo rust create cargo project important switch flip bin pas cargo generate hello world example main function set generate executable otherwise generates template library single cargo project binary library though cargo nt provide easy way generate template cargo compile library compile binary library linked difference cargo project binary library two cargo project combo project occupies folder mix elixir mix project otp application erlang doc define otp app like otp application denotes component implementing specific functionality started stopped unit reused system reality otp application might actually define process starting op otp application even supervision tree may may usable standalone program http server used elixir apps cowboy otp application otp apps specify require running work interact sending receiving message cowboy process cowboy essentially act app user interface beyong otp application usable standalone program may also usable library app either way example mix project depend borsng hexpm application interact process inside otp app build release deploy new combined application even though intended use standalone one instance erlang vm without reverse http proxying disclaimer nt actually tried run project cargo rust cargo run args basically always maybe want specify cargo run example example args still runnable rust application unixwindows executable long short get ugly window service actually c library let worry mix elixir debugging probably going run like iex mix least plain app phoenix app need run iex mix phoenixserver remember said could extend hexpm building elixir project depends feasible hexpm app grab http port wire directly router two thing phoenix default starting phoenixbased otp app start http server changed production config file need anyone depending switch back config file way nt need use iex iex start erlang debugger equivalent mix run nohalt elixir expression mix phoenixserver get help cargorust cargo new help mixelixir mix help new build configuration cargorust toml file toplevel cargotoml file servo elixir user recognize similar quot umbrella project quot see similarity difference workspace member quot portscef quot quot portsgeckolib quot quot portsservo quot quot supportandroidbuildapk quot profiledev codegenunits profilerelease optlevel uncomment profile linux debug true lto false mixelixir mix configuration elixir module contain elixir code want run code load toplevel config file borsng time wrote borsng also umbrella project though nt defmodule borsngmixfile use mixproject def project name quot borsng quot appspath quot apps quot buildembedded mixenv prod startpermanent mixenv prod deps deps sourceurl quot http githubcomborsngborsng quot homepageurl quot http borsnggithubio quot doc main quot hacking quot extra quot hackingmd quot quot contributingmd quot quot readmemd quot dialyzer flag quot wnounused quot quot werrorhandling quot quot wraceconditions quot end defp deps dogma quot gt quot dev runtime false dialyxir quot gt quot dev runtime false distillery quot gt quot runtime false edeliver quot gt quot runtime false exdoc quot gt quot dev end end popular joke particularly floating around ruby v java thread equally applicable build definition written language author must hate language bit gross oversimplification couple reason fact rust slow compile make writing data structure like language impractical nt much bug language tradeoff writing software rewrite mixexs file haltingproblem hazard impossible fully general case software like dependabot support nonturingcomplete subset language bother using actual language addon command cargorust like git cargo passed command command nt recognize shell cargocommand cargo addons executables name start cargo mixelixir mix extended elixir archive zip compiled beam code mix load call right command run mean mix addons must written elixir erlang something else talk exchange mix addons access internal tooling mix already indepth write mix task project command cargorust cargo nt seem support project task project task way project dependency add command language package manager example cargo supported project task ran cargo dieselmigrate project depended diesel orm would perform migration right run cargo install dieselcli installing diesel cli globally sortof fake example cargo run example mycommand unfortunately nt carry dependency using feature way nt intended used mixelixir project declare command mixexs file simple way bake directly mixexs defp alias mytask amp end defp mytask ioputs quot hello world quot end also define mix task module hook mix help separate code configuration integrating language mixelixir mix downloads archive build check mixexs rebarconfig rebarconfig shell rebar otherwise load mixfile work configuration one thing though want write mixexs specifies compiler source file example hook rustler build rust nif used elixir rustler compiler shell cargo course compiler rustler mixcompilers mix suck typical erlang library work hexpm still bunch package exist wrap corresponding c library cargorust specify buildrs cargotoml file cargo compile shell building rest rust project buildrs dependency use canned build script like cmake gcc package ideally cargo would able pull c dependency build like mix erlang dependency rebar cmake probably popular c build system run window without unix emulation layer run platform window cmake nt accompanying package repository cargo package like mozjs nothing shim c libaries build system conditional dependency cargorust use option conditional compilation rust using entry target key target cfg window dependency winhttp quot quot target cfg unix dependency openssl quot quot target cfg targetarch quot quot dependency native path quot quot target cfg targetarch quot quot dependency native path quot quot also dependency given certain specific crate builddependencies used buildrs devdependencies used test devdependencies tempdir quot quot builddependencies cc quot quot mixelixir mix special syntax build environmentspecific dependency much like cargo though dev dependency cargo closer test dependency mix dev dependency mix like target cfg debugassertions dependency rust def deps credo quot gt quot dev test end also add dependency regular conditionals def deps ostype winapi quot gt quot else end version specifier mixelixir elixir version specifier define following operation version requirement based exactly semver requirement description equivalent must install version exactly install version higher equal regard breaking change cargorust rust semver package also based semver us different notation elixir requirement requirement description equivalent must install version exactly install version higher equal regard breaking change workspace v umbrella project principle feature identical cargo workspace allow define single project dependency compilation fetching get shared produce multiple crate case uploaded one crate cratesio made dependency except nt go upgrade dance pull change mix umbrella project allow define single project dependency compilation fetching get shared produce multiple otp application case uploaded one application hexpm made dependency except nt go upgrade dance pull change practice difference way otp application run using umbrella project elixir allows break project part deployed separately hand nonworkspace cargo project still allowed produce multiple executable deployed separately rust application often distributed anyway workspace usually either used either entirely keep circular dependency control facilitate incremental compilation txti
155,Lobsters,elixir,Elixir programming,AtomVM: how to run Elixir code on a 3 $ microcontroller,https://medium.com/@Bettio/atomvm-how-to-run-elixir-code-on-a-3-microcontroller-b414773498a6,atomvm run elixir code microcontroller,atomvm run elixir code microcontroller atomvm astarte ble lora nerve grisp blink led elixir hardware dev board software espidf cmake zlib gperf compiling flashing atomvm board configured fred dushin blogpost http githubcombettioatomvmgit compiling flashing elixir code portability supported hardware platform specific code kept library built library contributing fork github good first issue help wanted future,atomvm run elixir code microcontrolleratomvm tiny portable virtual machine allows beam code run microcontrollers le ram atomvm production ready yet might set house fireso mean word flash atomvm get elixirerlang code running itwhyi work full time astarte open source iot platform written elixir also use several embedded board work fun working board realized could interesting use cool concept behind elixir embedded hardware started atomvmso let focus spec moment connectivity builtin ethernet ble wifi bgn several dev board additional lora chipcpu dual core mhzmemory kib sram builtin flash usually mibpower µa deep sleep currenterlang elixir really good handling network packet network connectivity running concurrent process dual core dealing fault embedded software need reliable writing testable software early testing developing way better debugging real hardware enabling rapid development arduino selling point otp designed run low end devicesfor instance already two great project allow elixir code run embedded device nerve grisp however order run need linux powered embedded board raspberry pi nerve custom board mib ram grisp atomvm try overcome limitation design enables elixir development low end device like try use smallest possible amount memory design thanks trick executing code place flash memory usually memory mapped feature left implemented others planned optional instance floating point support might needed use case like also arbitraryprecision integer might needed deviceslast least also standard library stripped save precious flash memoryhow blink led elixirblinking led hello world program physical computing start wait second starting make sure required component hardware dev board led possible buy one le case board onboard led led cable breadboardsoftware erlangotp otp also fine elixir compiler fine espidf cmakezlib devel filesgperfcompiling flashing atomvm boardjust connect board make sure idfpath point espidf directory espidf sdk already configured using macos fred dushin made excellent blogpost git clone http githubcombettioatomvmgit cd atomvmatomvm cd make cd compiling flashing elixir codeblinkex compiled using elixirc elixirc blinkexonce compiled elixirblinkbeam actual compiled modulehowever elixirblinkbeam enough need packed together required module avm fileatomvm cd libsestdlibatomvmlibsestdlib erlc erlatomvmlibsestdlib cd exavmlibatomvmlibsexavmlib elixirc gpioexatomvmlibsexavmlib cd atomvm cmake atomvm cd toolspackbeamatomvmtoolspackbeam makeatomvmtoolspackbeam cd atomvm toolspackbeampackbeam blinkavm pathtoelixirblinkbeam libsestdlib beam libsexavmlib beamatomvm idfpathcomponentsesptoolpyesptoolesptoolpy chip port baud defaultreset hardreset writeflash u flashmode dio flashfreq flashsize detect blinkavmfor sake clarity outofsource build shouldportability supported hardwareright nix system board supported however atomvm designed easily portable platform specific code kept library porting atomvm new operating system new hardware fairly simple atomvm core built library embedded bigger projectatomvm also really dependency requires libc function optional zlib librarysupport platform forthcoming including welcome fork github send pull request good first issue issue good starting point also help wanted issue skilled developer one window port new issue welcome aswell feel free open find bug miss featurethe futuremore feature coming near future fun map better error handling multi core support complete garbage collector rewritefurther development planned implemented future like remote shell support hot code swapping clustering course also post story atomvm soon stay tuned
156,Lobsters,elixir,Elixir programming,Battleship Elixir: Json sunk my Float,https://medium.com/@davelucia/battleship-elixir-json-sunk-my-float-dc3df46447db,battleship elixir json sunk float,query field cast float postgrex rfc ecto fragment jsonbset function,due new design requirement needed migrate nested jsonb field integer float attempting pretty straightforwardquery row tablecast value integer floatupdate row databasethe update pseudocode look something like query r mytable fragment number rmeta select r query repoall enummap repoupdateall everything work great point row update something unexpected happens field cast float number like properly converted remained eff let jump repl figure happens hardcode iex meta putin metanumber model ectochangesetcast meta meta meta repoupdate force true iex repoone r mytable select rmeta rid number point thinking found bug ecto postgrex maybe even postgres appears number divisible cast hardcoding seem work maybe found edge case let go postgres directly see replicateoutlinedev update mytable set meta number id outlinedev select meta card id meta number directly using sql give behavior looking point inclined think bug somewhere elixir land chatting michal muskala elixir slack bit found problemin order convert elixir map json ecto must encode value different value look like encoded jsoniex jasonencode number ok number iex jasonencode number ok number iex jasonencode number ok number notice encoded according rfc json rfc valid encoding rfc state parse value specify storagepostgres make decision store integer value jsonb field elixir chooses store float due mismatch try store value float postgres cast back integerso solution unfortunately postgres behaving according spec try leveraging ecto fragment jsonbset function set value directly even storage problem outlined alternatively change number something else first eg le ideal solution trick postgres changing value way want
158,Lobsters,elixir,Elixir programming,Permutations With and Without Repetition in Elixir,http://www.petecorey.com/blog/2018/11/12/permutations-with-and-without-repetition-in-elixir/,permutation without repetition elixir,ongoing chord project permutation base case building permutator simplifying special form list comprehension without repetition,hacking away ongoing chord project ran situation needed generate possible permutation length k given list element repetition element list allowed figured would excellent opportunity flex elixir muscle dive possible solution base case let get ball rolling defining permutation module hold solution function accepts list element value k defmodule permutation def withrepetitions list k end start defining base case function first list empty want return list first element empty list def withrepetitions k k def withrepetitions list note returning possible permutation empty list possible zerolength permutation list list possible permutation case building permutator come interesting case list k workable value def withrepetitions list k end start mapping every element list use element head new klength permutation building list enummap fn head end value head want calculate n length subpermutations list concatenate subpermutations head list withrepetitions k enummap fn tail head tail end point result function list list permutation every head returning list klength permutation starting head really want singly nested list permutation found reduce list list permutation need append list permutation every value head together enumreduce order permutation lexical order assuming initial list sorted wanted final set permutation reverse order could switch order concatenation enumreduce could use accomplish thing enumreduce simplifying special form pattern nested mapping consolidating result flat list result fairly common pattern run writing functional code common fact elixir includes special form specifically designed make kind computation easier handle behold list comprehension def withrepetitions list k head list tail withrepetitions list k head tail end single line functionally equivalent original function tell u starting list comprehension every value head every value tail build new permutation head tail result list comprehension simply list permutation without repetition trying find permutation repetition element list allowed would solve similar problem repetition allowed turn solution fairly straightforward generate set subpermutations tail value simply pas list without current value head def withoutrepetitions list k head list tail withrepetitions list head k head tail end level permutation remove current value head preventing reused future subpermutations fantastically convenient previously computed value list comprehension like head used subsequent value iterate
160,Lobsters,elixir,Elixir programming,How many functions do you have in your Erlang/Elixir VM?,https://medium.com/erlang-battleground/code-server-erlang-elixir-6faa86206f70,many function erlangelixir vm,going interactive embedded code path boot script system principle inspectinteger inspectalgebra inspectopts inspect,going usual better try understanding challenge boot erlang vm try figure happeningi jump straight answer instead erlang dynamic code loading doc point code server load code according code loading strategy either interactive default embedded interactive mode code searched code path loaded first referenced embedded mode code loaded startup according boot script described system principlesalright mystery solved new function appear evaluate list comprehension second time loaded right needed evaluate first list comprehension print resultlet see observation match hypothesis fun let elixir first let see behavior experienced iex iex length codeallloaded export f mmoduleinfo f f f length codeallloaded export f mmoduleinfo f f f excellent let see function new one actually since module loaded ie code server load individual function load entire module need let see module new one need start new vm course m codeallloaded length m newms codeallloaded m inspectinteger pathtoelixirinspectintegerbeam inspectalgebra pathtoelixirinspectalgebrabeam inspectopts pathtoelixirinspectoptsbeam inspect pathtoelixirinspectbeam iex new module others one required print screen
161,Lobsters,elixir,Elixir programming,Stubbex - stub and validate with ease,https://github.com/yawaramin/stubbex,stubbex stub validate ease,validate ease selfinitializing fake guide emphasis simplicity concurrency request precision installation http githubcomyawaraminstubbexreleases note configuration example http hash stubbex cookie scenario developer workflow deploy warning editing existing stub http hexdocspmfilesystemreadmehtml stubbing nonexistent endpoint warning http templating response embedded elixir example elixir standard library injecting json response validating stub contract testing json schema validation json schema note limitation,validate ease stub server like mountebank wiremock purpose automatically save response real endpoint use going forward whenever try hit stub endpoint also interpolate response template stub control validate saved stub real response word stubbex set martin fowler call selfinitializing fake guide set stubbex apart opinion three thing emphasis simplicity stubbex philosophy everything little configuration zero config every stub server come across requires configuration file http command unittest framework tell stubbex requires configuration try right thing call real endpoint need replay existing stub whenever validation large subset stub single command want set stub manually place stub file format stubbex expects right location explained however also take advantage stubbex initial recording ability edit alreadyexisting stub file service nt written yet concurrency stubbex designed massively concurrent take advantage elixir phoenix framework erlang system handle concurrent incoming request efficiently note since project new tested yet benchmark theory able start single stubbex server hit many different test ci build automatically fetch save reply response related concurrency another huge benefit stubbex brings table thanks implementation stack faulttolerance send bad input different discus section common short truly unforeseen catastrophic failure stubbex recover every error immediately ready handle next request request precision mean stubbex store responds request using pertinent information contained request like method get post etc url query parameter request header request body get save give response complete precision stub number different host endpoint specific request installation either compile run stubbex using local installation elixir download latest prebuilt release tarball release page http githubcomyawaraminstubbexreleases example say download stubbexnnnosxtargz unpack src mkdir stubbex cd stubbex srcstubbex tar xzf stubbexnnnosxtargz note moment uploading binary latest release macos plan release os point configuration stubbex certain configurable option read startup system environment port mandatory port number stubbex refuse start without stubbexcertpem optional path root http certificate may needed making http request default etcsslcertpem stubbexstubsdir optional path stubbex keep stub directory default stubbextimeoutms optional numeric value long stubbex wait request response millisecond default minute stubbexoffline optional boolean value whether stubbex record new stub default false true stub call end needing record new stub fail show client side internal server error example suppose want stub response json placeholder url http first start stubbex srcstubbex binstubbex foreground send request src curl userid id title delectus aut autem completed false notice completely mechanical translation real url stub url probably guess work prefix remove stub url make pretty easy configure real testqaetc endpoint check srcstubbexstubs subdirectory new directory structure stub file take look srcstubbex le url http response statuscode header stub stored predictable location stubsprotocolhostpath hashjson prettyprinted viewing pleasure hash notice file name stub json encoded hash request detail method get post etc url query parameter header body five detail uniquely identify request endpoint stubbex us hash look correct response request nt fetch save next time requestaddressable file name allows stubbex pick correct response stub call without open parse stub file effectively us filesystem index data structure stubbex cookie scenario implicit assumption indeed stubbex basic assumption unique request exactly one response example get cart request always return exact response example user add item cart realworld server use sessionmanagement mechanism like cookie track user current state stubbex thing set stubbex cookie every response exactly equal hash request parameter app respect setcookie header sends server cooky set including stubbex cookie establish audit trail every request response example would work client log stubbex response generated log request c get cart ie cookie header client respect server cooky response generated get cart request c add item cart response generated add item request c get cart effectively scenario session established chain stubbex cooky config special command idiomatic http state management mechanism stubbex immutable well least way git store requestresponse pair deterministically get exact response every request right otherwise identical request like get cart developer workflow use stubbex part dev workflow first need running stubbex instance easiest way get running shown alternatively might deploy stubbex shared internal server warning mean expose outside world use development testing across multiple developer machine ci build next set qatest config app point base url every service call stubbex eg http would use development stack normal configuration management system serious networked app likely already separate endpoint configured qa prod case switch qa endpoint stubbed version shown run app qa config let stubbex automatically capture replay stub stub available iterative development test suite run long use qa config editing existing stub stubbex cache nontemplated ie static stub memory period time default ten minute serve response fast possible might like edit existing stub immediately see changed response stubbex automatically clear cache stub edit delete stub help iterative development note linux bsds need install inotifytools make instant edits work see http hexdocspmfilesystemreadmehtml detail stubbing nonexistent endpoint sometimes need stub response endpoint nt actually written yet manually naming placing stub file right directory would pain fortunately stubbex automatically generates stub file even endpoint nt exist example send following request curl stubbex try get response see ca nt put stub file right name right place implemented status empty body srcstubbex le url http bla response statuscode header body edit stub put whatever response need keep going warning nt use postman browserbased tool make request stubbex purpose setting stub later use may add additional header beyond control stubbex response matching mentioned sensitive exact request header example see http fiveyear old issue wherein postman sends additional header request want set stub beforehand hit stubbex app best use tool like curl sends request exactly specify write stub file hand way le fun templating response template response stub file stubbex immediately pick change stub start serving onthefly evaluated response template named like hashjsoneex embedded elixir file contain valid elixir language expression well refer request parameter template like edit favourite text editor insert valid markup according rule eex example stub default body like body n userid n id n title delectus aut autem n completed falsen set todo automatically completed past body n userid n id n title delectus aut autem n completed datetimeutcnow year n use useragent header part todo title body n userid n id n title user agent header stubbexheadervalues useragent listfirst n completed falsen get response curl command example see completed attribute set true assuming year past todo title user agent eg result depending markup put place request parameter available following name url string querystring string method string header list pair string key header name string value get value stubbexheadervalues useragent lowercase syntax note return list header value http header may duplicated probably want get first value listfirst shown body string many useful data manipulation function elixir standard library used part eex template course addition normal feature expect language like arithmetic looping branching logic etc recommend taking look embedded elixir link fiveminute crash course template markup may thinking get stub first place start editing simple let stubbex record first hitting real fake endpoint add eex file extension stub json file insert whatever markup need note stubbex nt cache template stub response might change dynamically every request eg might inject current time response injecting json response careful putting markup especially json stub templated stub passed interpolation engine eex decoded jsonencoded string elixirnative data structure example miss escaping template stub body json properly get runtime error stubbex look like error genserver terminating poisonsyntaxerror unexpected token position h poison json decoder module case forgot escape doublequotes around body json attribute stubbex misinterpreted result safely escape jsonencoded string response use stubbexstringify function template tag body stubbexstringify userid id title thing completed false basic structure body elixir string expression elixir string expression injected final response templating engine stubbexstringify normal elixir function call triple doublequotes used initial escaping doublequotes json body b get rid leading whitespace fact leading whitespace every line triplequoted string left closing triplequote removed validating stub trouble static stub get date guard happening one option make someone responsible keeping stub file uptodate contract testing might actually also delegate responsibility stub upkeep service stub corresponding service provider obviously work reach agreement service provider bare minimum would zip provider stub periodically throw wall let figure still conforming requestresponse expectation tough sell stubbex provides convenience validate stub example validate stub json placeholder todo id endpoint use send following request srcstubbex curl stubbex reply colorized diff suitable display terminal validate json placeholder todos send srcstubbex curl validate json placeholder stub send srcstubbex curl however stubbex nt support validating stub higher level error try think reasonable balance trying delegate validating stub service provider would worry stub tip validating long response helpful pipe output le r understand show colour srcstubbex curl le r json schema validation sometimes nt practical validate entire response body real server response might differ greatly request case still valuable know whether shape response match expect stubbex allows validate shape response specifying json schema stub workflow would look similar stubbex workflow start sending normal stub request app may already done rename stubspathtohashjson file stubspathtohashjsonschema tell stubbex use json schema validation stub put response expected json schema object stub responsebody field example schema todos show url http response body schema http title todo description reminder type object property userid type integer id type integer title type string completed type boolean required userid id title completed note due specific schema validation library stubbex us schema must versioned draft finally actual validation run usual validation command srcstubbex curl response body green ok indicate schema validation succeded simulate validation error try changing completed attribute type string rerun validation response body red description error path erroring attribute limitation enough test right run stubbexstubsdirtest mix testwatch stale continuous iterateandrun cycle benchmark right
162,Lobsters,elixir,Elixir programming,16 Things I learnt using the BEAM,https://www.youtube.com/watch?v=pR_2289p19w,thing learnt using beam,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature thing learnt using beam erlang solution webinar youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature thing learnt using beam erlang solution webinar youtube
164,Lobsters,elixir,Elixir programming,Phoenix Framework 1.4.0 release candidate,https://elixirforum.com/t/phoenix-1-4-0-rc-0-released/17182,phoenix framework release candidate,phoenix released phxnew hex archive milligram note local ssl development mixtasksphxgencert faster development compilation dockyard post new development page usersocket connection info deprecated transport macro new presence javascript api webpack programming phoenix book programming phoenix book special thank plataformatec enhancement bug fix phxnew installer deprecation javascript client,phoenix released phoenix release ship exciting new feature notably support improved development experience faster compile time new error page local ssl certificate generation additionally channel layer internals receiveced overhaul providing better structure extensibility also shipped new improved presence javascript api well elixir formatter integration routing test dsl phxnew hex archive mix phxnew archive installed via hex simpler versioned installation experience grab new archive simply run mix archiveuninstall phxnew mix archiveinstall hex phxnew new generator also use milligram favor bootstrap support classless markup generation result nice looking default allow generated markup much easily customized individual cs requirement note existing phoenix application continue work elixir new phxnew archive requires elixir thanks release cowboy phoenix support single line change mixexs simply add plugcowboy deps phoenix run cowboy adapter local ssl development browser require connection ssl request otherwise fallback http request aid local development ssl phoenix includes new phxgencert task generates selfsigned certificate http testing development see mixtasksphxgencert doc information faster development compilation development compilation speed improved thanks contribution plug compiletime change read detail dockyard post new development page page development list available route originating router example usersocket connection info highly requested feature access underlying transport information using phoenix channel release provides usersocket callback provide connection information peer ip address host information xheaders http request websocket longpoll transport deprecated transport macro part channel overhaul deprecated transport macro favor providing transport information directly socket call endpoint updating easy making following change appwebchannelsusersocketex transport websocket phoenixtransportswebsocket transport longpoll phoenixtransportslongpoll checkorigin appwebendpointex socket socket myappwebusersocket socket socket myappwebusersocket websocket true list option longpoll checkorigin new presence javascript api new backwards compatible presence javascript api introduced resolve race condition well simplify usage previously multiple channel callback presencestate presencediff event required client dispatched presencesyncstate presencesyncdiff function interface unified single onsync callback presence object track channel callback state example let presence new presence roomchannel presenceonsync consolelog user online presencelist id name name webpack mix phxnew generator us webpack asset generation instead brunch development experience remains javascript go assetsjs cs go assetscss static asset live assetsstatic interested j tooling nuance continue pattern using webpack need optimal j tooling benefit webpack sophisticated code bunding dead code elimination programming phoenix book programming phoenix book beta available pragprog includes latest change titled book consider relatively future proof continue minor version release special thank would like specially thank loïc hoguin work cowboy allowing u provide firstclass experience would also like thank bram verburg contributed local ssl certificate generation crossplatform dependencyfree cert generation additionally would like thank josé valim plataformatec work channel layer overhaul provides extensible foundation going forward always provided stepbystep instruction bringing apps speed please report issue issue tracker find u elixirlang elixir slack elixir forum question full list change changelog found happy hacking enhancement phxnew update ecto deps release ecto including phoenixecto phxnew import ecto formatterexs new project phxnew use ecto ectosql new project deps phxnew use plug new plugcowboy dependency cowboy adapter phxgenhtmljsonschemacontext support new ecto usec datetime type phoenix add replace poison jason json encoding new project endpoint add support endpoint macro accepts direct configuration websockets longpoll endpoint support mfa function checkorigin config custom origin checking endpoint add new phoenixerrorrender instrumentation callback endpoint log configured url instead raw ip booting endpoint webserver endpoint allow custom keyword pair passed socket connectinfo option router display list available route debugger error page router raise duplicate plug pipethrough scope controller support partial file downloads offset length option controller add additional security header putsecurebrowserheaders xcontenttypeoptions xdownloadoptions xpermittedcrossdomainpolicies controller add override default url generation pulled endpoint configuration logger add whitelist support filterparameters logger configuration via new keep tuple format socket add new phoenixsocketconnect instrumentation socket improve error message missing socket mount endpoint logger log call user socket connect presence add presencegetbykey fetch presence specific user codereloader add reloadableapps endpoint configuration option allow recompiling local dependency channeltest respect user configured exunit assertreceivetimeout macro assertion bug fix add missing formatterexs hex package proper elixir formatter integration phxgencert fix usage inside umbrella application phxnew revert routesstaticurl app layout favor original routesstaticpath phxnew use phoenixlivereload fix hex version error phxgenjsonhtml fix generator test incorrectly encoding datetimes phxgencert fix generation cert inside umbrella project channel fix issue websocket transport sending wrong contentlength header response router fix forward alias failing expand within scope block router fix regression router compilation failing escape plug option phxnew installer generate new elixir child spec therefore new apps require elixir use webpack asset bundling deprecation controller passing view deprecated favor endpoint handler option endpoint deprecated favor adapter socket deprecated transport specified endpoint transport transport system seen overhaul drastically simplified previous mechanism building transport still supported deprecated please see phoenixsockettransport information javascript client add new instancebased presence api simplified synchronization callback accept function socket channel params dynamic parameter generation connecting joining fix race condition presence diff arrives state immediately rejoin channel socket reconnect faster recovery reconnection fix reconnect caused pending heartbeat
165,Lobsters,elixir,Elixir programming,10 Lessons from Decade with Erlang,https://medium.com/erlang-battleground/erlang-lessons-fe800c51af4f,lesson decade erlang,higherorder construct sumorest higherorder construct higherorder construct build one article erlang solution opaque data structure hernán describes spanish opaque data structure test driven development module export mylists incrementally test driven development metatesting inakos borrowed hernán part test continuous integration process issue far easier dialyzer xref elvis constantly consistently katana test module includelib mixin export test speed test smoothly fast article behavior understanding behavior define one tool tool erlangotp avoid reinventing wheel article pluralsight debugging debugger debug trace ton article dimitris zorbas redbug recon engage community monika cole join community help mailing list erlang slack meetup near fun zen erlang enjoy amazing language beamolympics serpent spawnfest,higherorder constructserlang language pretty simple type keywords set basic operation building block huge system totally learn understand wellbut also learn build abstraction top think thing like higherorder function list comprehension otp behavior library like sumorest others encapsulate shared knowledge make life developer easier removing repetitive part letting focus specific stuff need systemthings like message passing receive recursion list parsing xml manually etc scarcely used large system instead use proper library framework syntax eg otp list comprehension xmerl etc find writing similar thing consider abstracting generic piece libraryuse higherorder construct library framework tool instead building everything scratch higherorder construct yet build onefind article wrote erlang solution blogopaque data structuressoftware development hernán describes spanish seen process building computable model reality particularly early stage development designing systemthose model include representation entity exist real world oop one would use object functional language like haskell would use type erlang pretty narrow set type principle allowed define onesso combine type represent entity instance using tagged tuples record etc get messy pretty quicklythat recommend using opaque data structure instead od module opaque exported type logic needed manage expose functional interface others consume without worrying internal representation typesuse opaque data structure represent entitieslearn topic two talk gave one codebeam sf driven developmentthis particular erlang tdd great methodology create software general go virtue say erlang make working tdd easyfor instance example assignment provide student teaching recursion module mylistsexport test mylists runlength mylists runlength mylists runlength b mylists runlength mylists runlength b okthat module compiles thanks dynamic nature erlang compiler blame function defined try run c mylists ok mylists mylists test exception error undefined function mylists function mylists mylistserl line go pure tdd fashion prompted define nowsee easy complex system tool like common test work exactly like function using patternmatching determine test pass failsin mind excuse work way building system erlangdevelop system incrementally using test driven developmentmetatestingmetatesting inakos borrowed hernán practice writing test validate particular property code instead behavior word idea check code tool like dialyzer xref elvis etc part test continuous integration processesif start using dialyzer xref elvis project spend lot time trying detangle cryptic meaning dialyzer warning never wrong warning emitted dialyzer mean bug somewheredialyzer may warn problem emits warning confusing may mean issue somewhere maybe warning reported something fixnow deciphering dialyzer found run first time codebase ten thousand line code challenging run dialyzer code first day keep code warningfree whenever get warning something changed far easier debuguse dialyzer xref elvis project constantly consistentlystart using tool soon start developing systemkatana test explained link make extremely easy use common test need add suite like one fact one usually first suite add projectsmodule yourmetasuite includelib mixerincludemixerhrl mixin ktnmetasuite export initpersuite config application yourapp config endpersuite oktest speedlarge system tend even larger battery test good practice go generally run test least every pull request andor every deploythat good kept unattended large battery test start making everyday development cycle longer longer goal test completeness ie covering much functionality system possible test balanced test speed easy thing dokeep test running smoothly fastin article find useful technique achieve balancebehaviorsbehaviors live core otp yet time people struggle come oop land probably somebody already told behavior like interfaceswhile generally true hide lot complexity sometimes lead false belief needlessly complicate codeinvest time understanding behavior use work define use onesbehaviors great powerful yet extremely simple learn unlock whole potential article wrote back erlang behave around themtoolserlangotp come many useful somewhat hidden gem help everyday life erlang developer boost productivity learn use themfrom erlang userdefault dbg xref observer checked sys module erlang et many hidden gem make life easierlearn tool erlangotp already provides work better avoid reinventing wheelyou find thing article wrote pluralsightno debuggingcoming oop world one first thing tried use started working erlang debugger turn great idea dealing concurrent distributed programming languagedon get wrong debugger work really well powerful mostly help debugging sequential code debugging big system application cumbersome bestdo debug inspect trace insteadon hand erlangotp come ton tool make tracing inspecting system easier find several article dimitris zorbas top one provided erlangotp amazing library like redbug reconengage communitythis easily common advice ever gave anybody asks erlang engage communitythe community huge know first name monika cole pointed long ago proactive always helpfulwhen start working erlang uncommon feel lost many thing new others unique someone never used language since main benefit erlang experienced build large system initial step challenging everyone community know thing helpjoin community hesitate ask helpjoin mailing list join erlang slack find u irc find meetup near youhave fun important lesson fact might end building massive highreliable backend system erlang seem really serious mean fun erlang designed faulttolerance concurrency mind day allows worry le thing interesting aspect building zen erlangenjoy time working amazing language besides want play erlang test knowledge language beamolympics challenge friend game build team win awesome prize spawnfest
167,Lobsters,elixir,Elixir programming,Living the Simple Life with Recursive Parsing and Serialization,http://www.petecorey.com/blog/2018/09/24/living-the-simple-life-with-recursive-parsing-and-serialization/,living simple life recursive parsing serialization,massive refactor elixirpowered bitcoin full node project bitcoin network message problem protocol manipulating binary bitcoin protocol common substructure function taking advantage substructure dry c type composing substructure special case rough edge final thought entire project github,pushed massive refactor elixirpowered bitcoin full node project considerably simplifies parsing serialization bitcoin network message big fan solution landed wanted share key insight switch recursive solution subcomponent every message handle parsing serialization obviously devil detail let dive problem took refactor handling parsing serialization bitcoin network message entirely manually every message define function implement corresponding protocol every field within message manually parsed serialized using elixir various binary manipulation operation example netaddr message would parsed using technique def parse binary ok time rest parsetime binary ok service rest parseservices rest ok ip rest parseip rest ok port rest parseport rest ok netaddr time time service service ip ip port port rest end end defp parsetime time rest binary ok time rest defp parsetime binary error badtime defp parseservices service rest binary ok service rest defp parseservices binary error badservices defp parseip ip binarysize rest binary ok ip rest defp parseip binary error badip defp parseport port rest binary ok port rest defp parseport binary error badport fantastic practice manipulating binary within elixir scalable solution simply many message bitcoin protocol implement time consuming way many message share common substructure implementation would need repeated throughout project daunted task implementing function every message protocol peertopeer vocabulary decided needed better solution taking advantage substructure mentioned many bitcoin message share common substructure instead dooming tedious repetition realized repeated structure actually blessing dry god could architect implementation way offloads responsibility parsing serializing shared substructure parsing serialization implementation toplevel message could substantially simplified could take notion substructure even many way type primitive compose together build protocol message substructure substructure example c type commonly used define unsigned integer throughout protocol various message actually substructure single field specific parsing serialization rule could implement struct corresponding function like defmodule defstruct value nil def parse value rest binary ok value value rest end similarly could reverse process serialize newly parsed defimpl bitcoinnetworkprotocolserialize def serialize value value value end composing substructure parsing serialization rule built baselevel substructure like primitive type build upon work done composing substructure together complex structure example netaddr really sixteen byte binary representing address time service ip port respectively write netaddr struct complete function call function primitive substructure defmodule bitcoinnetworkprotocolnetaddr defstruct time nil service nil ip nil port nil alias bitcoinnetworkprotocol binary netaddr def parse binary ok time rest binary ok service rest rest ok ip rest binaryparse rest ok port rest rest ok netaddr time time service service ip ip port port rest end end serializing netaddr structure even easier simply build list field want serialized order want serialized map list function defimpl bitcoinnetworkprotocolserialize bitcoinnetworkprotocolnetaddr def serialize netaddr netaddrtime netaddrservices netaddrip netaddrport bitcoinnetworkprotocolserializeserialize end left elixir binary represents entire serialized netaddr structure heavy lifting best part solution repeatedly build top substructure addr message composed varint list netaddr substructure substructure way special case rough edge general case solution work beautifully special case rough edge need smooth first rough edge come parsing serializing fixedsize binary example within netaddr structure need parse sixteen byte wire interpret byte ip address instructed netaddr parser calling second argument binary module function accepts optional second argument let u specify exactly many byte want parse incoming binary defmodule bitcoinnetworkprotocolbinary def parse binary size binary binarysize size rest binary binary ok binary rest end end notice return primitive elixir binary rather struct intentional decision make serialization much easier defimpl bitcoinnetworkprotocolserialize bitstring def serialize binary binary end another special case need handle made apparent need parse serialize list thing perfect example appears code need parse addr structure composed varint number netaddr structure ok count rest varintparse binary ok addrlist rest arrayparse rest value count ok addr count count addrlist addrlist rest like special behavior associated array module function take binary parse number thing want parse function parse individual thing defmodule bitcoinnetworkprotocolarray def parse binary count parser parse binary count parser end function call private function build accumulator parsed thing parsed sufficient number thing return accumulated list defp parse rest parser list ok enumreverse list rest nonbase case function simply applies function binary appends resulting parsed thing list thing defp parse binary count parser list ok parsed rest parser binary parse rest count parser parsed list end result function return primitive elixir list struct make serialization fairly straight forward defimpl bitcoinnetworkprotocolserialize list def serialize list list enummap join def join piece piece enumreduce fn piece binary binary binary piece binary end end simply map list thing concatenate newly serialized piece together remember back netaddr serialization example notice using list primitive serialization protocol whole time awesome final thought struggled refactor good week ultimately happy solution landed complex original solution term number moving part much scalable mentally manageable solution one originally working system turn attention interesting piece building bitcoin full node processing block expect article digging topic future meantime check entire project github get handson feel refactor recursive parsing serialization solution ultimately landed
168,Lobsters,elixir,Elixir programming,Game of Life in Elixir and Scenic,https://forvillelser.vorce.se/posts/2018-09-18-game-of-life-in-elixir-and-scenic.html,game life elixir scenic,new talk mr multerer scenic repo golex getting started scenic getting started guide grid proof cell primitive processing quil animation slow fixed input faster twitter wrapping golux,seeing boyd multerer talk scenic opengl backed ui framework elixirerlang following progress year elixirconf got new talk mr multerer even impressive polished demo importantly scenic repo went public knew wanted build something simple get familiar framework yesterday came brilliant idea add graphical view old elixir game life golex golex one first elixir project conceived back elixir still beta hipster cred cloned project built ran text based simulation worked like charm code looked modular enough build graphical view top getting started scenic pretty straightforward clear instruction macos getting started guide take long looking sample app clicking around created new scene looked one clue proceed grid decided start drawing grid gameoflife scene get foot wet first attempt alias scenicgraph alias scenicprimitives width height cellsize grid graphbuild primitivesline width stroke white primitivesline cellsize width cellsize stroke white primitivesline cellsize width cellsize stroke white already old three line write function since heard computer good executing repetitive task second attempt def buildgrid graph width height spacing horizontal enumreduce height graph fn acc scenicprimitivesline acc spacing width spacing stroke white end enumreduce width horizontal fn x acc scenicprimitivesline acc spacing x spacing x height stroke white end end graphbuild buildgrid width height cellsize pushgraph better actually found bug function writing post proof beautiful output cell since grid drawing painless eager get cell board turned also quite easy stared different primitive bit expecting something like rect x width height like processing quil found instead really clear translate rect first thought let go quad get shit done def cellgraph graph golexcell alive false graph def cellgraph graph golexcell position x alive true xp x cellsize yp cellsize scenicprimitivesquad xp yp xp yp cellsize xp cellsize yp cellsize xp cellsize yp fill white end couple thing going first pattern matching make really clear simply ignore dead cell alive cell need calculate grid show xp yp naming hard etc obviously need call function every single cell world def worldgraph graph golexworld cell cell enumreduce cell graph fn cell acc cellgraph acc cell end end world golexrandomworld get new world golex graphbuild worldgraph world buildgrid width height cellsize pushgraph living cell grid great except game still suck need make move animation sure bunch way really liked idea making scene send message fixed interval would trigger world update rerender achieve reach erlang toolbox find also used scenic demo figured updating scene second start conservative enough clue expectation slowfast scenic golex would handle message implement standard otp stuff timersendinterval worldtick def handleinfo worldtick state newworld golexworldtick stateworld graphbuild worldgraph newworld buildgrid width height cellsize pushgraph noreply state world newworld end slow one second update interval turned quite conservative enough update looked bit dodgy good measured long took stuff took bit second scenic really slow course golex function naive fixed worry performance could lower timer interval lot input part fun game life seeing different starting condition play adding way restart game fresh world would cool simple left click board maybe bit confused first implement kept trying use wrong component scene component generate event case need deal lower level input nice way understand event available handle add def handleinput msg state ioinspect msg label handleinput noreply state end scene way every time input event happen see look handle mouse left click release pattern matched like def handleinput cursorbutton left release inputcontext state ioputs generating new world newworld golexrandomworld div width cellsize div height cellsize noreply state world newworld end def handleinput msg state noreply state need handle event voilà new world left mouse click faster section came getting feedback mr multerer twitter happens performance switch cell drawing quad rects percentilequads µs rects µs rects translation bit faster quad probably better memory wise although actually verified note number gathered small sample size tick type measured time took update game life world render scenic wrapping turned fun way get know scenic least little bit look forward promising framework code using rect instead quad additional control golux
171,Lobsters,elixir,Elixir programming,To Pipe or Not to Pipe,https://www.erlang-solutions.com/blog/to-pipe-or-not-to-pipe.html,pipe pipe,pipe pipe pipe referential transparency fault tolerance mix distillery configuration module attribute general erlangsolutionscom go back blog,pipe pipe joseph yiasemides material post based one recent talk code beam stockholm elaborates covered topic though small part mean program elixir something stumble across often warrant post second instalment elixiroverload series time place one elixir loved piece notation pipe always best case really hinder readability case much aid look like know variant introduction pipe perhaps expression collection successive work performed various enum function like take look elixir script require integer enumfilter enummap ioinspect important aspect easy miss first clear subject expression initial range intermediate collection working many successive transformation perform together clear subject successive transformation one recipe good pipe usecase pipe also brings home referential transparency way traditional notation simply value comment substituted pipeline source code point without changing behaviour program require integer enumfilter enummap ioinspect case see pipe full utility structure might liken method chaining socalled oo language might familiar u plugconn structure time expression involves abstract datatype plugconn function transform return updated plugconn rather enum higherorder function still perform successive transformation structure conn plugconnputrespcontenttype textplain plugconnsendresp hello leaf u question traditional notation best answer clear subject expression transformation want perform transformation question juggle intermediate data expression lend traditional notation case include mathematical formula readingwriting file socket io formula one example mathsqrt kernelabs x mathpow x arithmetic rule precedence well known expected thus need read understand whatever calculating true sort operator expression including common arithmetic boolean list operator pipe case would awkward hinder readability go following example alias gentcp tcp ok socket tcpconnect host port binary packet passive ok tcpsend socket data ok response tcprecv socket tcpclose socket course middle ground choice pipe traditional notation make little difference common case piping value different type successive transformation want write program vertically opposed horizontally pipe good choice avoid superfluous variable want nest function application compare contrast following two definition def total x x keywordvalues enumsum end def total x enumsum keywordvalues x end total type length value conclude pipe great expressive power much aid readability used appropriately however case use opposite likely traditional notation expressive case course subjective matter thought subject help u make elixir syntactic construct would like thank panayiotis yiasemides studnicki claudio ortolina szymon mentel arkadiusz gil szymczyszyn agnieszka gawda zofia polkowska nasreen abuhunaina help writing post liked post might also like three elixiroverload series coincide elixir architecture session alchemy series written fault tolerance taken granted mix distillery configuration particular module attribute course find u social medium reach general erlangsolutionscom comment go back blog
174,Lobsters,elixir,Elixir programming,Using Facades to Simplify Elixir Modules,http://www.petecorey.com/blog/2018/09/03/using-facades-to-simplify-elixir-modules/,using facade simplify elixir module,sometimes project problem project solution define function module enter delegate macro name facade gang four design pattern,common trend see elixir project module tend become large sometimes large necessarily issue go deep seated heuristic building software chord project started get complex repeatedly found reaching pattern keep module size complexity still maintaining friendly approachable api let dig example problem chord module heart chord project using chord generate guitar chord voicing generate possible fingering given voicing even calculate distance various chord voicing fingering conceivable lot functionality live directly chord module example want able ask even convert chord chord chart problem piece functionality come along nontrivial implementation put function chord module implementation would likely live chord module well mind would quickly turn chord unmaintainable mess better way solution turn better way like better way turn solution problem obviously simple let use function example rather defining function implementation within chord module create chordvoicing module define function defmodule chordvoicing def voicing note notesinchord nil end chordvoicing module entirely concerned act generating chord voicing given set note however still want functionality available chord module accomplish simply need write function match signature module pass call straight chordvoicing module defmodule chord def voicing note notesinchord nil chordvoicingvoicings note notesinchord end continue pattern creating new module implement feature chordfingering chordrenderer flesh chord module wire convenience function actual implementation defmodule chord def voicing note notesinchord nil chordvoicingvoicings note notesinchord def tostring chord chordname nil chordrenderertostring chord chordname def fingering chord chordfingeringfingerings chord end beautiful enter delegate using pattern might make mistake passing argument first function head function implementation module done thankfully elixir give u way prevent mistake defmodule chord defdelegate voicing note notesinchord nil chordvoicing defdelegate tostring chord chordname nil chordrenderer defdelegate fingering chord chordfingering end using defdelegate macro define interface function chord module point function head implementation module elixir automatically wire delegated function together preventing mindless developer mistake creeping codebase name previous example chord module essentially acting facade wrap hide complexity chordvoicing chordfingering chordrenderer module use term facade loosely reallife use facade pattern honestly classic gang four design pattern carry baggage like think let go transition world functional programming another le weighty way think chord api module sole purpose act application programming interface within application would call kind pattern
175,Lobsters,elixir,Elixir programming,BEAM Bytecode Optimization Traps and Pitfalls,http://blog.erlang.org/opt-traps-and-pitfalls/,beam bytecode optimization trap pitfall,brief introduction beam assembly language zerobased optimizing code final straw delayed sub binary creation conclusion ssabased new ssabased intermediate format,august björn gustavsson back summer holiday blog change track start series blog post static single assignment ssa first installment set scene post follow looking trap pitfall one fall trying optimize beam assembly code brief introduction beam assembly language look beam code following function foo tag ok unoptimized beam code look like function foo line location funcinfo atom atom foo test istuple test testarity gettupleelement gettupleelement test iseqexact atom tag put atom ok put return putlist nil move atom functionclause line location extfunc erlang concentrate part code actual work test istuple test testarity gettupleelement gettupleelement test iseqexact atom tag put atom ok put return cause functionclause exception explain instruction test istuple test instruction test whether condition true next instruction executed otherwise branch failure label condition tested instruction istuple whether operand tuple operand register first argument function contain tuple execution continue failure label mean failure label code label cause functionclause exception test testarity testarity instruction test whether first operand must tuple size given second operand first operand second operand failure label previous instruction gettupleelement gettupleelement two instruction executed previous instruction established contains tuple arity gettupleelement take three operand first source tuple second zerobased index tuple third operand register element tuple stored note failure label fail first gettupleelement instruction fetch first element tuple store register second gettupleelement instruction fetch second element store register test iseqexact atom tag iseqexact test instruction test whether content exactly equal atom tag execution continue failure label concludes function header next instruction body function build ok tuple testheap instruction ensures sufficient free space heap construct term first operand first say following instruction need word heap tuple header word followed element tuple element need heap word total sufficient room heap testheap instruction garbage collection find fresh heap space second operand second number x register value must preserved garbage collection mean live value put atom ok put three instruction build tuple putting tagged pointer tuple return return function return value value optimizing code testing term tuple certain size specific atom first element common operation think record therefore beam machine istaggedtuple instruction work instruction using instruction code test istuple test testarity gettupleelement gettupleelement test iseqexact atom tag put atom ok put return rewritten like test istaggedtuple atom tag gettupleelement put atom ok put return nice reduction code size execution time however optimization safe consider instruction second say x register live namely clearly live removed gettupleelement instruction assigned value value undefined passing undefined register value garbage collector kind bug could take week track fact probably future blog post kind bug two tool born result bug reluctantly order make optimization safe must keep gettupleelement instruction assigns test istaggedtuple atom tag gettupleelement gettupleelement put atom ok put return another possibility case would assign empty list called nil beam assembly language test istaggedtuple atom tag move nil gettupleelement put atom ok put return however simple example another optimization actually allow compiler remove assignment test istaggedtuple atom tag gettupleelement put atom ok put return testheap gettupleelement instruction swapped note number live register adjusted testheap instruction instead general though compiler might abandon optimization keep instruction assigns register avoiding feeding garbage collector undefined value final straw development otp realized reached limit improving optimization operates beam assembly language particular wanted make optimization called delayed sub binary creation applicable circumstance turned would hard impossible substantially improve optimization working beam assembly language apart problem leaving undefined register illustrated previous optimization example also complexity traversing analyzing beam instruction beam instruction set designed optimizerfriendly conclusion tried show example one hardest part working beam code register allocation already done instruction may garbage collection testheap already added early year decided introduce new intermediate format alleviate problem optimizing beam code close enough beam code allow lowlevel optimization istaggedtuple optimization described blog post register allocation done testheap similar instruction added also regular make easier traverse optimization decided make new intermediate format ssabased next blog post revisit example blog post see look like new ssabased intermediate format
180,Lobsters,elixir,Elixir programming,Algorithmically Fingering Guitar Chords with Elixir,http://www.petecorey.com/blog/2018/08/13/algorithmically-fingering-guitar-chords-with-elixir/,algorithmically fingering guitar chord elixir,find voicing best voice leading another chord calculating fingering sixelement array fret played possible finger sieve sieve eratosthenes choosing sieving result ted greenestyle doublestops next voice leading elixir levenshtein distance entire project github,last time wrote using elixir generate possible voicing given guitar chord find voicing best voice leading another chord great several issue conflating idea musical distance physical distance calculating optimal voice leading taking playability progression generating account address issue need know voicing possible given chord also voicing played need generate possible fingering given guitar chord voicing sound like fantastic excuse flex elixir muscle calculating fingering start journey calculating possible fingering given guitar chord creating new elixir module chordfingering new function defmodule chordfingering def fingering chord end high level plan attack computing possible fingering fairly straight forward given chord sixelement array fret played like nil nil want attach possible fingering played fret choose possible finger turn sieve subsequent impossible finger recursively repeat get possible fingering perform necessary cleanup final function make step fairly explicit def fingering chord chord attachpossiblefingers chooseandsieve cleanup possible finger sieve dive deeper solution take detour talk computing fingering solution take inspiration sieve eratosthenes clever technique calculating prime number basic idea sieve choice made used filter future unwanted result bring back situation imagine trying play minor chord fifth fret minor chord start fingering chord placing second finger low note know use first finger note chord first finger would wrap sneak second finger reach note essentially impossible ca nt use first finger anywhere choosing use second finger fifth string fret sieve possibility using first finger remaining note think also sieve possibility reusing second finger finger reused unless forming bar doublestop adjacent fret remaining set possible finger remaining note finger three four recursively picking another possible finger another string applying sieving rule come entire set possible finger choosing sieving meat algorithm life function take initial chord complete possible finger fingering argument default empty list defp chooseandsieve chord fingering fingering argument used hold finger choice chord choose function expects element chord twoelement tuple first element fret played second element set possible finger could chosen play fret helper function transforms initial chord expected structure defp attachpossiblefingers chord enummap chord implementation recursive start implementation defining base case base case triggered chord empty point handled every note chord need return fully constructed fingering defp chooseandsieve fingering fingering enumreverse listtotuple soon see chosen finger appended onto fingering reverse order list reorient string lastly turn fingering list tuple safely resulting list fingering without losing grouping flattened function map final list convert tuple back array defp cleanup fingering enummap fingering moving base case time start thinking simple handle situation next element chord list unplayed string nil add fingering list designate played finger nil recursively call remaining chord defp chooseandsieve nil possiblefingers chord fingering chooseandsieve chord nil nil fingering similarly next element chord open string recursively call passing remaining chord set finger appended open string played finger nil defp chooseandsieve possiblefingers chord fingering chooseandsieve chord nil fingering case actually needing finger note situation becomes complicated case next element chord fret set possiblefingers map possiblefingers appending finger fret list fingering sieving nowimpossible possiblefingerings remaining note chord recursively calling function newly sieved chord newfingerings defp chooseandsieve fret possiblefingers chord fingering possiblefingers enummap fn finger newfingerings fret finger fingering chord sievechord newfingerings chooseandsieve newfingerings end listflatten helper function map note left chord update possiblefingers tuple element sieve fingering deemed impossible play placing recent finger defp sievechord chord fingering chord enummap fn fret possiblefingers fret sievefingers possiblefingers fret fingering end helper function make real decision behavior fingering algorithm function fairly straight forward simply reject possiblefingers considered bad badfinger helper function defp sievefingers possiblefingers fret fingering enumreject possiblefingers badfinger fret fingering badfinger function run fingerfret combination four rule used algorithm determine finger choice impossible culled possiblefingers set defp badfinger fret finger fingering enumany fretabovefingerbelow fret finger fingering fretbelowfingerabove fret finger fingering samefinger fret finger fingering impossiblebar fret finger fingering rule violated finger rejected first two rule check possible finger would need stretch already placed finger respectively defp fretabovefingerbelow fret finger newfret newfinger fret newfret finger newfinger defp fretbelowfingerabove fret finger newfret newfinger fret newfret finger newfinger third rule verifies finger used twice unless performing bar doublestop adjacent fret defp samefinger fret finger newfret newfinger finger newfinger fret newfret finally need prevent impossible bar bar would mute note played lower fret defp impossiblebar fret finger fingering newfret fingering enumfilter fn fret finger fret newfret end enummap fn fret finger finger end enummember finger result implemented fingering algorithm let try example start calculating possible fingering minor chord using example fingering suggestion listed string nil nil chordfingeringfingerings enummap enumjoin nn ioputs fingering minor chord awesome first suggested bar difficult play practice ted greenestyle doublestops manageable second third suggestion would normally reach another interesting example open g major shape chordfingeringfingerings enummap enumjoin nn ioputs fingering g chord first fingering suggestion make sense get closer end list suggestion increasingly difficult play think ever able play fingering impossible play fingering human explain difficult play able come general rule add rule set would prevent kind fingering suggested point rather algorithm present potentially impossible fingering overaggressively prune possible fingering result set next previous article voice leading elixir mentioned conflating idea musical distance physical distance term voice leading really care optimizing chord progression musical distance guitar player also want consider physical distance set chord musical distance given starting chord want choose chord lowest physical distance physical distance mean literally fret distance also difficult transition one chord another need slide one finger easy need lift replace three finger sliding fourth calculate physical distance chord unless know fingering chord question know potential fingering given chord compute modified levenshtein distance fingering two chord cool done able take starting chord optionally starting fingering find best voicing landing chord term voice leading ease playability sure check entire project github stay tuned
181,Lobsters,elixir,Elixir programming,Wallaby needs a new maintainer,https://keathley.io/elixir/wallaby/2018/08/10/wallaby-is-looking-for-new-maintainers.html,wallaby need new maintainer,click redirected,click redirected
182,Lobsters,elixir,Elixir programming,Custom Infix Functions in Elixir (2016),https://www.rodneyfolz.com/custom-infix-functions-in-elixir/,custom infix function elixir,custom infix function elixir rodney folz math moduleshim getting started guide kernel module doc source code article parsing source code elixir parsed yecc elixirparseryrl josé valim elixirlangtalk thread pipespect rodneyfolz twitter comment,custom infix function elixir published sat feb pst rodney folz writing math moduleshim elixir mean need write test deal float particular need know two float really really close equal even though might equivalent test look like test add assert sum end test asin assert asin assert asin end pas mix test finished second load test test failure might look like magic especially tried failed write custom infix function past like implemented nearlyequal test doc equalityish test float nearly equal spec number number boolean def x nearlyequal x end defp nearlyequal x end right regular function definition infix operator use infix operator define way elixir sadly use custom symbol name infix hopefully fourteen infix operator enough satisfy deep dive case let look source code another infix operator like builtin addition operator first need find defined getting started guide give u hint kernel module also operator like function like defined automatically imported available code default ok promising let check kernel module doc hmm really helpful u however link source code maybe looking spec number number number def left right erlang left right end answer start notice kernel module implement already using leftopright form mean define infix function like one kernel defined spec number inf number stringt def left inf right ioputs left infix right end compilation error file libopsex syntaxerror syntax error elixir anonymous darn would nice custom infix function worked trying way define infixbydefault operator prefix function def left right ioputs left op right end work fact compile error try define regular way iex mix compilation error file libopsex syntaxerror syntax error elixir anonymous guess elixir parser generally support infix notation instead infix operator kernel specialcased let validate hunch finding elixir parsed information however found getting started guide instead brief google search elixir parser led interesting article parsing source code elixir near end article author mention elixir parsed using method discussed article want another example wait think one ever heard elixir programming language nice language built atop erlang virtual matching focused concurrency fault well parsed yecc jackpot let check source elixirparseryrl file linked quote see get left right stabopeol left nonassoc captureopeol left inmatchopeol right whenopeol right typeopeol right pipeopeol right assocopeol right matchopeol left oropeol left andopeol left compopeol left relopeol left arrowopeol left inopeol left threeopeol right twoopeol left addopeol left multopeol nonassoc unaryopeol left dotcallop left dotop nonassoc atopeol nonassoc dotidentifier elixir operator predefined parser since parse step happens elixir bootstrapped way u define operator code would either modify elixir parser directly recompile elixir satisfied one fourteen unused operator posted excited tweet discovery josé valim reached confirmed unused operator deliberately included exactly use case summary elixir infix operator specialcased parser kernel module implement anything special syntaxwise implement behavior unused operator parser know create new infix operator without recompiling elixir source wait searching around infix operator worked came across elixirlangtalk thread discussed overriding builtin kernel module operator one special thing kernel defines original implementation operator redefine operator first unimport inside module new implementation operator say module called myop call function myop import use operator import kernel except import myop b trick used pipespect library automatically ioinspect every stage pipe import kernel except defmacro first rest end since monkeypatching language redefining kernel builtin operator may break expectation elixir code used care used fascinating example predictable regular elixir also find rodneyfolz twitter please enable javascript view comment
183,Lobsters,elixir,Elixir programming,Configuring multiple endpoints in Phoenix Framework,https://pattern-match.com/blog/2018/06/19/multiple-endpoints-in-phoenix/,configuring multiple endpoint phoenix framework,http patternmatchcomblogmultipleendpointsinphoenix,http patternmatchcomblogmultipleendpointsinphoenix
184,Lobsters,elixir,Elixir programming,Voice Leading with Elixir,http://www.petecorey.com/blog/2018/07/30/voice-leading-with-elixir/,voice leading elixir,elixir programming language rendering chord chord chart elixir ansi color code io list chord distance brute forced voicing midi note midi note midi note putting together final thought future work ted greene archive youtube page definitely check two ted book chord chemistry modern chord progression github,play quite bit guitar free time thing practicing lately improving voice leading chord voice leading refers individual note voice within chord move transition another chord often want little movement possible keep transition sounding jarring unless going jarring example play way neck probably want follow played towards nut instead like find another voicing physically musically closer chord knowing voice lead chord usually requires vast knowledge fretboard huge chord vocabulary lot practice need computer elixir programming language let use elixir chug possible chord find best voice leading rendering chord start talking recruiting computer help u find best voice leading chord take detour talk guitar chord work break basic guitar six string attached piece wood chord set note played simultaneously across number string different note played string pressing fret along neck given definition simplest way represent chord using elixir data structure probably six element list tuple chord represented array nil nil thickest string thinnest playing anything first string nil playing g next string next string f next string b next string nothing thinnest string nil make life easier come way displaying chord guitaristfriendly manner one common option displaying guitar chord chord chart kick thing let write chordrenderer module function take chord return unicodebased chart provided chord defmodule chordrenderer def tostring chord chordname end end first thing need find reach chord lowest fret used chord highest min max chord enumreject nil enumminmax use elixir filter unplayed string use easily find lowest highest fret used chord next iterate every set fret within range chord render row using helper function max max min enummap rowtostring min chord chordname fret chart render minimum number row even chord take one fret vertical space iterate either max min depending value larger mean always render least four row fret diagram also want intersperse horizontal fret line row fingered note row fret enumintersperse bright black n using elixir ansi color code color fretboard line dark grey color building final string io list rather single concatenated string using ansi color code need format convert resulting nested list structure string returning function ioansiformat iochardatatostring helper function fairly straight forward simply render left gutter row fret potential fingering right gutter defp rowtostring offset base chord chordname leftgutter offset base offset enummap chord frettostring base offset rightgutter offset chordname helper function render lowest fret used chord first line chart defp leftgutter fret bright yellow stringpadleading fret otherwise render spacer defp leftgutter similarly helper function either render optional chordname first line chord chart defp rightgutter chordname yellow chordname empty string defp rightgutter render chord passing chordrenderertostring nil nil ioputs fully colored glory chord rendered new module chord distance roughly approximate good voice leading two chord counting number fret finger move changing chord call distance two chord simplest term chord good voice leading minimal distance write function computes distance chord might able generate possible voicing find voicing lead best let say fret moved single string equal one unit distance adding removing note string also count single unit distance using heuristic let write new chord module function calculates distance two chord chord equal zero distance def distance chord chord otherwise distance two chord sum distance individual fretted note string def distance freta resta fretb restb distance freta fretb distance resta restb first chord note fretted string next chord add one unit distance def distance nil fret visa versa def distance fret nil otherwise string fretted note distance moved string number fret two chord string def distance freta fretb ab freta fretb manually calculate distance chord nil nil different voicing may know chorddistance nil nil nil nil chorddistance nil nil nil nil according heuristic second voicing much better voice leading first voicing great still limited knowledge fretboard know two voicing chord best absolutely brute forced voicing last piece puzzle write function generate possible voicing given chord across neck guitar possible voicing example easily find voicing best voice leading chord let start creating new function chord module def voicing note end function accepts array number representing note want chord example wanted voicing chord call c e g b number correspond lowest set midi note ranging first thing want calculate possible note set spread across guitar string note allnotesets chord fewer note number string want play number note repeated illustrate imagine want play four note using six string guitar obviously four string playing c e g b two string play helper function calculates list possible note set using handwaving combinatorics unfortunate list comprehension def allnotesets note length length note base combinationcombine note min length length note extension combinationcombine note length length note base extension end end end enumreduce enumreduce end next function need take possible note set build possible chord using set note enummap helper work recursively building possible chord made possible note provided note set def buildchords noteset chord nil nil nil nil nil nil chord start looking first note provided note set find occurrence note across string guitar using helper note allnotes next filter note string already used current chord construction enumfilter fn string fret enumat chord string nil end finally take note insert current chord check stretch chord chord span five fret deem impossible play filter obviously oversimplification especially higher fret otherwise recursively call passing newly updated current chord remaining set note note set enummap fn string fret newchord listreplaceat chord string fret min max newchord enumreject nil enumminmax fn end max min buildchords rest newchord chord else chord end end helper function work accepting abstract value note looking c optional midi note tuning string optional number fret neck want look note def allnotes targetnote string fret end construct two dimensional list midi note neck across fretboard fretboard fret fret enummap string fret built fretboard filter note specific note looking loop every row fret every string fretboard enumwithindex enummap fn row index row enumwithindex enummap fn note string end end note encounter check rem note equal targetnote replace current note value stringindex tuple used building guitar chord rem note targetnote string index else nil end otherwise replace current note nil next flatten multidimensional fretboard representation filter nil value leaving u set note looking found fretboard perfect let try listing first three voicing chord new helper find chordvoicings enumtake enummap enummap cool putting together helper finished put piece together let start calculating possible voicing chord chordvoicings next let map voicing build tuple first element distance chord second element generated voicing enummap chorddistance nil nil let sort list distance chord first element tuple effectively sorting distance enumsort best option voicing top list let take first three enumtake map voicing chord chart renderer enummap fn distance chord chordtostring chord end finally let join three chart together newlines print result enumjoin nn ioputs generated voicing voicing recommended software sound fairly nice much nicer first voicing using way neck third voicing definitely interesting flavor something never would reached without help software glad know final thought future work many many final thought project tell incredibly excited kind thing currently working improving distance heuristic raise many interesting question exactly voice leading optimize player listener thanks guitar work chord wildly different section neck may close musically algorithm filter chord far many way conflating voice leading chord playability chord want also working optimizing voice leading entire chord progression might guess much expansive problem generated chord progression lastly interested kind thing highly recommend check ted greene guitar work ted opinion one true master guitar put serious work perfecting voice leading skill check ted greene archive archive youtube page definitely check two ted book chord chemistry modern chord progression uploaded entire project github curious see source entirety check obviously kind thing tool chord transition progression generated chord module suggestion starting place fullyfleshed music said tool already given many new idea shown many interesting chord never would reached without shown
185,Lobsters,elixir,Elixir programming,Building a Better Receive Loop,http://www.petecorey.com/blog/2018/07/23/building-a-better-receive-loop/,building better receive loop,inprogress elixirbased bitcoin node original receive loop erlang module taking advantage payload length follows specific format final thought check github karl seguin elixir slack group,putting quite bit time past week overhauling refactoring inprogress elixirbased bitcoin node part overhaul turned attention receiving packet connected peer way handling incoming packet overly complicated greatly simplified taking advantage bitcoin protocol packet structure let go old solution dig improved original receive loop bitcoin node us erlang gentcp module manage peer peer communication originally using gentcp active mode mean incoming packet delivered node elixir process form tcp message def handleinfo tcp port data state end tcp streaming protocol guarantee made content message single message may contain complete bitcoin packet partial packet multiple packet combination handle ambiguity bitcoin protocol deliminates packet sequence magic byte reach magic sequence know everything received point constitutes single packet previous receive loop worked maintaining backlog incoming byte recently received sequence magic byte every time new message received would append incoming byte backlog chunk binary sequence packet could handled individually message rest chunk staterest data case handlemessages message state error reason state disconnect reason state rest rest state noreply state rest rest end solution work quite moving piece maintain backlog recently received byte also build functionality split stream byte individual packet defp chunk binary message case messageparse binary ok message rest chunk rest message message nil message binary end end thankfully better way taking advantage payload length every message sent bitcoin protocol follows specific format first four byte every packet reserved network magic byte next twelve byte reserved name command sent across network next four byte hold length payload sent followed four byte partial checksum payload twenty four byte found head every message sent across bitcoin peertopeer network followed variable length binary payload representing meat potato command carried relying structure greatly simplify receive loop using gentcp passive mode setting active false incoming tcp packet delivered current process message instead ask packet using blocking call requesting packet even specify number byte want receive incoming tcp stream instead receiving partial message unknown size ask gentcp next byte stream ok message gentcprecv socket next parse received message byte request payload size byte socket ok size size messageparse message ok payload gentcprecv socket size parse handle payload knowing guaranteed single complete bitcoin command sent across peertopeer network final thought go solution outlined example receiving command like verack zero byte payload asking zero byte actually return available byte tcp stream complication included still think new solution superior old solution maintaining continually chunking ongoing stream byte pulled network eager see full detail new receive loop check github also like thank karl seguin inspiring improve bitcoin node using technique posted message elixir slack group prefixing tcp message length easily determine many byte receive length prefix every message byte two recvs ok length recv socket timeout ok message recv socket length timeout one line comment opened mind realization bitcoin protocol already overcomplicating process receiving message thanks karl
186,Lobsters,elixir,Elixir programming,Dark Corners of Erlang and Elixir Tracing,https://pattern-match.com/blog/2018/06/01/erlang-tracing-what-we-can-and-what-we-cannot-trace/,dark corner erlang elixir tracing,http patternmatchcomblogerlangtracingwhatwecanandwhatwe trace,http patternmatchcomblogerlangtracingwhatwecanandwhatwe trace
187,Lobsters,elixir,Elixir programming,All For Reliability: Reflections on the Erlang Thesis,https://dockyard.com/blog/2018/07/18/all-for-reliability-reflections-on-the-erlang-thesis,reliability reflection erlang thesis,chris mccord phoenix making reliable distributed system presence software error mistake inevitable handling worst case since failure one process must corrected another process separate machine erlang us mechanism failure process property le reliability performance meet evidence reliability elsewhere cited subject debate performance described ease scheduling small erlang process v larger operating system process joked conference talk continued optimized,ask elixir developer got u interested language many say concurrency wanted make program faster making use core desire big part elixir exists creating elixir josé valim trying make rail threadsafe found frustrating remembered thinking future going many core needed better abstraction one working ruby rail going cut decided study language see study led erlang built elixir run erlang virtual machine similarly chris mccord wanted use websockets rail apps struggled create scalable solution ruby heard whatsapp using erlang get million connection single machine kind blew mind looking getting maybe hundred connection rail app got mccord interested erlang elixir went create elixir main web framework phoenix known submillisecond response time massively scalable websocket support personally worked travel search engine needed lot ondemand concurrent work written language made difficult learned elixir job though adopt knew tool want use future although call concurrencyoriented programming language erlang cocreator joe armstrong cite speed main reason creation phd dissertation making reliable distributed system presence software error purpose title reliability fascinating many erlang therefore elixir attribute direct consequence designing reliable mistake inevitable paper armstrong talk challenge team faced writing telephone switching system first needed write complex system several million line program code might team many hundred programmer varying experience level requirement demanding market pressure encourages development deployment system large number complex feature often system deployed interaction feature well understood lifetime system feature set probably changed extended many way constraint way could produce perfect software yet something approaching perfection required telephone call important emergency turn phone system night maintenance telephone system need continuous operation many year typically le two hour downtime year quite problem imperfectlywritten system get nearperfect result armstrong put central problem addressed thesis problem constructing reliable system program may contain error handling worst case solving problem armstrong make harder considering worst case hardware failure imagine perfectlywritten program running computer burst flame lot failure process recover ceasing exist one armstrong address situation simply guard failure entire computer need two computer specifically first computer crash failure noticed second computer try correct error might mean example creating new process elsewhere replace one died see first interesting property erlang made run system span multiple machine needed reliability even better since failure one process must corrected another process separate machine erlang us mechanism failure failure handled via monitor link way one process react failure another supported directly vm mechanism foundation supervision tool pattern otp fact erlang vm go far make hardware failure look like software failure process monitoring process b process b dy process notified happens whether process b divide zero loses connectivity dy fire last two case distress call faked vm loses contact process b armstrong say reason coercing hardware error make look like software error want two different method dealing want one uniform mechanism combined extreme case hardware error failure entire processor lead idea handling error occurred place system process property consider two process mentioned running separate machine certain thing sure share memory physically separated nice failing process corrupt memory process watching communicate passing message succeed fail independently separation analogous firewall construction firewall wall two part building keep fire spreading maximallysafe house would firewall around every room chair bed house impractical erlang system process boundary like firewall failure cost almost nothing uniformity firewalllike characteristic true whether two process run separate machine process machine share memory communicate passing message separate machine armstrong noted erlang process isolation perfect one process allocates inordinate amount memory atom example could crash erlang vm machine including process improve reliability several property needed first message must asynchronous armstrong say isolation implies message passing asynchronous process communication synchronous software error receiver message could indefinitely block sender message destroying property isolation second process must lightweight safety increased dividing system process want run lot creating quickly ondemand third process must take turn armstrong say concurrent process must also timeshare cpu reasonable manner cpubound process monopolise cpu prevent progress process ready run like operating system erlang vm us preemptive multitasking le mean process get fixed amount time use cpu process finished turn paused sent back line another process get turn also paused waiting read file get network response way erlang vm support nonblocking io well nonblocking computation get applied automatically sequentiallooking code reliability performance meet might noticed last two point reliability also performance concern two related imagine system handling large number small task call web request whatever come large task happens system overall performance take dive reliable call get dropped web request time reliable system must perform consistently logic behind erlang vm multitasking absolute term frequent taskswitching waste little time making performance suboptimal benefit performance consistent small task continue completing quickly large task get processed little time garbage collection work way although erlang immutable data mean lot garbage created divided tiny heap across many process process dy memory freed gc needed longrunning process gc performed concurrently stop world pause collect garbage entire system gc barrier consistent performance evidence reliability effort toward building reliable system armstrong tried find well several erlangbased system worked interviewed maintainer analyzed source code examined bug report armstrong elsewhere cited ericsson switch example nine nine reliability uptime describes switch designed carrierclass nonstop operation system duplicated hardware provides hardware redundancy hardware added removed system without interrupting service software able cope hardware software failure since system designed nonstop operation must possible change software without disturbing traffic system thesis treat nine nine figure uncertain evidence longterm operational stability system also collected systematic way ericsson information longterm stability system came powerpoint presentation showing figure claiming major customer run node system reliability though figure obtained documented particular figure subject debate however armstrong investigation seemed indicate erlang system examined indeed extremely reliable software system case study reliable people operating system inclined think errorfree case indeed software error occur runtime error quickly corrected nobody ever noticed error occurred performance recap erlang vm give u pursuit reliability lightweight sharednothing process communicate via asynchronous message builtin mechanism process react failure process ability quickly spawn large number process run multiple machine efficient contextswitching concurrent garbage collection wonder armstrong call erlang concurrencyoriented programming language feature created mainly reliability make easy write concurrent program scale horizontally across core computer write program using process message vm take care tricky part running scheduler per core giving process turn moving process scheduler balance throughput power consumption tiny process make easier armstrong described ease scheduling small erlang process v larger operating system process packing huge big rock container difficult pouring sand container really easy think process like little grain sand think scheduler like big barrel fill filling barrel sand pack nicely pour work course erlang vm pretty fast armstrong joked conference talk take program want go thousand time faster wait ten year go thousand time faster solved want million time faster wait twenty year problem solved erlang really fast today waited long time erlang created telephone switch handled many ten thousand people interacting simultaneously armstrong implied rode wave everincreasing chip speed even continued optimized onceacceptable speed became truly formidable wave passed future performance concurrency take advantage write concurrent program armstrong thesis correct concurrencyoriented programming also key reliability awfully nice get time
188,Lobsters,elixir,Elixir programming,Headache free setup of Elm 0.18 with Phoenix 1.3 using Brunch 2,http://petergao.com/2018/07/18/using-elm-with-elixir-phoenix-brunch.html,headache free setup elm phoenix using brunch,latest elm elixir phoenix brunch installing updating elixir next step asdf github page installing updating phoenix next step phoenix preinstall guide tl dr postgresql note installing updating elm next step creating new phoenix project installing configuring elmbrunch action performed within directory project filepaths directory given relative creating hello world elm app troubleshooting tip wrapping,endtoend tutorial getting setup latest elm elixir phoenix brunch minimum headache plenty great tutorial past version elm elixir phoenix course lesson largely still applicable phoenix directory structure thing shifted around little bit fresh introduction getting moving target play nicely together oh monkey around webpack everything purely phoenixway brunch unwieldy configs monkeying around cryptic webpack config parameter let jump installing updating elixir skip next step latest elixir already installed get anything ground need install elixir highly recommend installing elixir using version manager asdf manage erlang runtime necessary compile run elixir elixir platform one unified tool detail installing asdf available github page clean slate asdf installing erlang elixir quite simple may need install dependency erlang runtime system prior installing erlang see http asdf pluginadd erlang asdf pluginadd elixir asdf install erlang latest version writing double check newest version asdf listall erlang asdf install elixir notice check asdf listall elixir older version erlang elixir want update updating erlang elixir version asdf trivial operates exactly except perform two pluginadd step asdf install erlang latest version writing double check newest version asdf listall erlang asdf install elixir notice check asdf listall elixir installing updating phoenix skip next step latest phoenix already installed installing phoenix go phoenix preinstall guide tl dr need hex elixir package manager postgresql nodejs yet install asdf well prerequisite installed installing phoenix one command away mix archiveinstall http githubcomphoenixframeworkarchivesrawmasterphxnewez older minor release phoenix ie update local phoenix package already absolute latest version use note phoenix changed mix task name phoenix phx installing updating elm skip next step latest elm already installed installing elm npm installed piece cake updating similarily easy run yep easiest step whole process far thanks elm creating new phoenix project dependency installed create new phoenix project like mix phxnew phoenixwithelm create new folder named phoenixwithelm current working directory prompt u install default nodejs dependency phoenix brunch build tool one unless reason defer installing dependency need eventually respond e installing configuring elmbrunch need third party node package called elmbrunch plugin brunch performs elm compilation u whenever save elm file asset directory action performed within asset directory project filepaths directory given relative asset start add elmbrunch line packagejson file section devdependencies elmbrunch dependency added elmbrunch packagejson file need install everything gone well far need put final touch elmbrunch configuration race still inside asset directory time edit brunchconfigjs plugins section see babel sole default plugin section plugins babel use compiler vendor code ignore vendor want extend section include elmbrunch plugin configs section plugins babel use compiler vendor code ignore vendor elmbrunch required set elm file containing main function elm make handle elm dependency relative elmfolder mainmodules elmmainelm optional specified mainmodules compiled single file merged outputfolder outputfile elmjs optional add parameter passed elmmake makeparameters warn bare minimum configs necessary compile elm app config flag available documented elmbrunch repository want make additional change path section add elm list watched path path dependency current project directory watch watched static cs j elm vendor configuration creating hello world elm app config setup one last thing create elm directory asset make elm file within using favourite text editor create save mainelm bare minimum content module main exposing import html exposing main p text hello world let boot phoenix server turn start brunch watch job compile mainelm file cd still inside assetselm back project root mix phxserver compiled elm file found projectroot privstaticjselmjs default change location name compiled file brunchconfigjs file wished one last thing need check hello world elm code add layout file get loaded page load add line libpropertyspeculationwebtemplateslayoutapphtmleex script src staticpath conn jselmjs script go right existing script pointing jsappjs everything place able hit browser see phoenix app greeting screen make sure elm app actually loaded open inspector plunk line j elmmainembed documentgetelementsbyclassname logo immediately see word hello world overlap phoenix logo banner huzzah prof elm app loaded onto page successfully mounted troubleshooting tip running issue make sure elm directory created projectroot asset wrapping congratulation point brunch setup compile change made elm code real time long brunch watcher running autorun whenever phoenix server started app template updated load elmjs file noticed brunch watcher selfexits restart brunchconfigjs modified phoenix running necessitating entire server reboot know way around love hear contact info footer please reach let review finalized directory structure asset priv asset cs elm put elm source elmstuff elm package dependency go j nodemodules static vendor priv gettext repo static cs image j compiled elm get output elmjs list focus two main directory filter directory
189,Lobsters,elixir,Elixir programming,"Ping, Pong, and Unresponsive Bitcoin Nodes",http://www.petecorey.com/blog/2018/07/09/ping-pong-and-unresponsive-bitcoin-nodes/,ping pong unresponsive bitcoin node,elixirpowered care unresponsive node one hundred twenty five peer node detecting slow connection detecting unresponsive node ensuring constant stream message final thought,last piece lowhanging fruit required finish connectivity inprogress elixirpowered bitcoin node implement system detect unresponsive peer connection prune list active peer inactive peer removed current system automatically connect new peer take place several potential solution building kind timeout system weighing pro con back mind several week think come relatively simple elegant solution tackle problem minimal technical mental overhead let dive care unresponsive node current state bitcoin node connect one hundred twenty five peer node assume node fully functioning active part bitcoin peertopeer network receive message message dwindle time assume network much tell u assumption lead trouble continue persist connection unresponsive node conceivable eventually every node connected become unresponsive reason another point bitcoin node dead water unable send receive information unable fetch additional peer reestablish place peertopeer network point course action would restart node try robust detecting slow connection instead proactive pruning unresponsive node set peer first piece low hanging fruit go adding timeout call gentcpconnect iptotuple stateip stateport option applicationgetenv bitcoinnetwork timeout node take long respond initial connection request case timeout set thirty second retry connection time ultimately remove node set peer detecting unresponsive node next step aggressively pruning peer list watch unresponsive node setting timeout every message receive peer receive another message certain cutoff time deem peer unresponsive break connection start adding call new helper function tcp info handler def handleinfo tcp port data state state refreshtimeout state end first time called schedule timeout message sent current process certain amount time reference timer stored process current state defp refreshtimeout state timer processsendafter self timeout applicationgetenv bitcoinnetwork timeout mapputnew state timer timer end subsequent call cancel existing timer create new one defp refreshtimeout state timer timer processcanceltimer timer refreshtimeout mapdelete state timer end need add callback handle scheduled timeout message def handleinfo timeout state disconnect timeout state end whenever receive timeout message simply kill current process effectively disconnecting associated peer ensuring constant stream message disconnecting peer receive message within certain period time thirty second case way guaranteeing receive message frequently new block transaction network guarantee receive regular periodic message need set pingpong loop every often send peer node ping message still responsive immediately respond pong peer ensure responsiveness sending ping already responding according woefully underdocumented bitcoin protocol send first ping send back verack message message sent prior verack mark node misbehaving risk disconnection defp handlepayload version state ok messageserialize verack sendmessage statesocket ok messageserialize getaddr sendmessage statesocket ok messageserialize ping ping nonce cryptostrongrandbytes sendmessage statesocket ok state else error reason error reason state end end sent ping expect receive pong reply receive peer pong response want schedule another ping sent short time future scheduling sendping message sent current process short interval defp handlepayload pong state processsendafter self sendping applicationgetenv bitcoinnetwork pingtime ok state end sendping handler sends another ping message completing pingpong cycle def handleinfo sendping state ok messageserialize ping ping nonce cryptostrongrandbytes sendmessage statesocket noreply state else error reason error reason state end end long pingtime reasonably le timeout always constant stream ping message keep timeout timer firing one peer ever fails send pong kill corresponding node process final thought far concerned wrap networking portion inprogress elixirbased bitcoin node project future turn attention actual gut bitcoin node processing block transaction point might also slap fancy user interface top node everything better great ui stay tuned
190,Lobsters,elixir,Elixir programming,Tensorflex: Tensorflow bindings for Elixir,http://www.anshumanc.ml/gsoc/2018/06/14/gsoc/,tensorflex tensorflow binding elixir,aim blog post tensorflow tensorflex iris dataset introduction computational graph iris dataset python code training simple model iris dataset link brief description happening python code extremely important understand operation need named crucial reusing graph later making prediction elixir moreover important remember input operation name well output operation name going referred feeding input data obtaining output elixir case name input operation output operation generating prediction elixir using tensorflex conclusion github,aim blog post blog post serf function tutorial using project working part google summer code called tensorflex tensorflex bridge tensorflow google machine learning framework follow work github starwatch repository help post first touch upon using python training saving model make predicitions saved model using tensorflex tensorflow tensorflex tensorflow google machine learning framework defacto standard training model making prediction industry academia along pytorch best way use tensorflow training model python c api also used generally cumbersome lowlevel needed moreover documentation tensorflow python api easy read understand tensorflex consist tensorflow binding elixir based tensorflow c api support making prediction saved model moment tensorflex used making prediction elixir trained model written python first half post cover using python training simple neural network model widely known iris dataset second half cover making prediction set input using tensorflex introduction computational graph computational graph form basis tensorflow work figure shown example computational graph evident graph consists set operation performed input provided graph tensorflow us graph describe architecture machine learning model save graph training prediction made performing set action read operation input provided moment therefore without much ado discus dataset used ml model python tensorflow code tensorflex iris dataset perhaps best known database found pattern recognition literature fisher paper classic field referenced frequently day see duda hart example data set contains class instance class refers type iris plant one class linearly separable latter linearly separable predicted attribute class iris plant attribute information sepal length cm sepal width cm petal length cm petal width cm class iris setosa iris versicolour iris virginica model downloaded csv file python code training simple model iris dataset code adopted original github repository entire code follow available example tensorflex repository link first step requires cloning tensorflex repository navigate examplesirisexample folder run example directly using python trainmodelpy command line brief description happening trainmodelpy python code first make required import read entire dataset csv file put feature x numpy array assign class label numpy vector last line code snippet shuffle data using nprandomchoice function assign shuffled value x xvalues yvalues respectively also important note read class label encode onehot variable neural network understand numeral value string import tensorflow tf import panda pd import numpy np tensorflowpythontools import freezegraph import o dir ospathdirname ospathrealpath file data seed nprandomseed seed tfsetrandomseed seed dataset pdreadcsv datasetcsv dataset pdgetdummies dataset column specie value list datasetcolumnsvalues dataset value nparray x dataset value x nparray x index nprandomchoice len x len x replacefalse xvalues x index yvalues index next separate entire data train test set since want feed input later elixir manually see result set test dataset size value also declare session variable used computation later define neural network architecture model seen consists following operation placeholder input datafeatures consist number row column corresponding feature placeholder class label corresponding input feature number row input column class onehot encoding two hidden layer node first set weight multipled input bias added product second set weight multiplied matrix sum obtained previous step second set bias added product obtained matrix sum passed softmax function obtain output softmax squash result value resemble probability although mathematically thus one see class predicted observing class highest numerical value output extremely important understand operation need named crucial reusing graph later making prediction elixir moreover important remember input operation name well output operation name going referred feeding input data obtaining output elixir case name input operation input output operation output testsize xtest xvalues testsize xtrain xvalues testsize ytest yvalues testsize ytrain yvalues testsize sess tfsession interval epoch xdata tfplaceholder shape none nameinput ytarget tfplaceholder shape none hiddenlayernodes tfvariable tfrandomnormal shape hiddenlayernodes tfvariable tfrandomnormal shape hiddenlayernodes tfvariable tfrandomnormal shape tfvariable tfrandomnormal shape hiddenoutput tfnnrelu tfadd tfmatmul xdata finaloutput tfnnsoftmax tfadd tfmatmul hiddenoutput nameoutput next define loss function used optimization algorithm minimizing loss function initialize session train model observe value loss minimized every subsequent epoch loss tfreducemean tfreducesum ytarget tflog finaloutput optimizer tftraingradientdescentoptimizer minimize loss init tfglobalvariablesinitializer sessrun init saver tftrainsaver print training model range epoch sessrun optimizer feeddict xdata xtrain ytarget ytrain interval print epoch loss sessrun loss feeddict xdata xtrain ytarget ytrain next snippet code extremely crucial save graph first save session graph definition pbtxt human readable format file required finally save graph required pb format using freezegraph function next line save file required store information regarding graph using save function lastly use freezegraph function convert file one single binary pb file file format required tensorflex load predefined graph elixir quick note running script make sure copy store obtained graphdefpb file data folder used load model tensorflex later tftrainwritegraph sessgraphdef dir graphpbtxt saversave sess dirgraph freezegraphfreezegraph dirgraphpbtxt false dirgraph output saverestoreall datagraphdefpb true last line code printing input data feature fed test dataset whether actual class label match predicted label seen neural network predicts correct label time verify tensorflex working use data input see prediction match trained model saved range len xtest print datapoint str xtest actual ytest predicted nprint sessrun finaloutput feeddict xdata xtest generating prediction elixir using tensorflex generate prediction test data tensorflex following need taken care make sure generated graphdefpb file running python script ensure cloning tensorflex repository also followed run section readme important thing consider code compile check install directory tensorflow erlangelixir somewhere unusual make change makefile accordingly everything working fine run iex mix console iex start first read graph definition model created python elixir see operation graph sanity check see input output operation listed follows iex ok graph tensorflexreadgraph graphdefpb cpu support instruction tensorflow binary compiled use avx fma ok reference iex tensorflexgetgraphops graph input matmul add relu output need create input output tensor input tensor first create matrix containing data value value test set dimension pas matrix function create input tensor output tensor since value populated prediction run need allocate tensor specifying dimension using iex invals tensorflexcreatematrix reference iex indims tensorflexcreatematrix reference iex ok inputtensor invals indims ok reference iex outdims tensorflexcreatematrix reference iex ok outputtensor outdims ok reference lastly need run session generate prediction runsession function used take argument graph definition input tensor output tensor name input operation output operation case mentioned name input operation input name output operation output thus done follows iex tensorflexrunsession graph inputtensor outputtensor input output output session might look bit unusual matrix row column expected value direct value obtained softmax function look closely see row three column one contain value close two contain value close thus value actually read compare value obtained python script run see prediction obtained exact match conclusion thus post served tutorial tensorflex tensorflow binding elixir keep updated development happening project watch star repository github feel free contact question feature request anshumanc dot gmail dot com nice day
191,Lobsters,elixir,Elixir programming,Limiting Peers with DynamicSupervisor Options,http://www.petecorey.com/blog/2018/06/18/limiting-peers-with-dynamicsupervisor-options/,limiting peer dynamicsupervisor option,posted article pointed handrolled solution elixir solution documentation option literally exactly handrolled solution refactoring final thought particularhabit,last month posted article using elixir dynamicsupervisor behavior recursively connect elixirbased node peer throughout bitcoin peertopeer network last part article talked could limit exponential growth set connected peer setting hard cap number process supervised dynamic nodesupervisor process went rigmarole building child process cap pointed could used dynamicsupervisor built maxchildren option accomplish thing handrolled solution implemented restriction number peer allow node connect within function def connecttonode ip port countpeers applicationgetenv bitcoinnetwork maxpeers dynamicsupervisorstartchild bitcoinnetworknodesupervisor id bitcoinnetworknode start bitcoinnetworknode startlink ip port restart transient else error maxpeers end end helper function simply call count number process supervised dynamic nodesupervisor bitcoinnetworknodesupervisor dynamicsupervisorcountchildren mapget active number active peer le specified number maxpeers allow connection otherwise return error tuple elixir solution read dynamicsupervisor documentation find pas maxchildren option digging elixir source see present maxchildren option literally exactly handrolled solution dynamic maxchildren handlestartchild child state dynamic dynamic else reply error maxchildren state end dynamic number process currently supervised supervisor le specified maxchildren add child otherwise return error tuple refactoring refactoring original solution make use maxchildren option largely consists removing original solution start gutting guard function def connecttonode ip port dynamicsupervisorstartchild bitcoinnetworknodesupervisor id bitcoinnetworknode start bitcoinnetworknode startlink ip port restart transient end mean also remove helper function simply need add maxchildren option dynamic supervisor start ok pid supervisorstartlink dynamicsupervisor name bitcoinnetworknodesupervisor strategy oneforone maxchildren applicationgetenv bitcoinnetwork maxpeers strategy oneforone limited set peer spinning bitcoin node low value maxpeers show nodesupervisor honoring limit final thought final thought really spend time reading elixir erlang documentation quite gem hidden plain sight would quite bit good know also like thank redditor pointed maxchildren option thanks particularhabit
192,Lobsters,elixir,Elixir programming,Elchemy,https://wende.github.io/elchemy/,elchemy,,type language elixir elm perk language string perk language case language elixir easy concurrency elm runtime error elchemy elchemy let write simple fast quality type safe code leveraging elm safety elixir ecosystem
194,Lobsters,elixir,Elixir programming,kvakvs/ErlangRT,https://github.com/kvakvs/ErlangRT,kvakvserlangrt,erlangrt runtime progress proof concept compiling rust cargo rustup editing code navigation reference material contributing license inspection,erlangrt runtime erlang replacement therapy attempt make erlang runtime beam emulator rust first attempt kinda know progress proof concept term library remaining progress external term format decoder encoder beam loader mostly done vm process vm loop opcodes basic bifs binary subbinaries binary heap binary opcodes test work running make test try run init produce output compiling source assumes erlang otp source git submodule otp stdlib preload beam file compiled ready makefile take care install latest rust cargo via rustup run make magic bash autocomplete see target support might like make run run executable test args whatever set developer expect show magical trick make doc build doc page targetdocerlangrt make test run test make build make buildrel build run debug release target respectively currently emulator expects preloaded beam module otp located otp git submodule makefile take care editing code navigation using strongly recommend intellij idea ce free version intellijrust plugin available repository tab inside intellij reference material contributing see contributingrst license inspection
195,Lobsters,elixir,Elixir programming,Generating Test Fixtures with Wireshark,http://www.petecorey.com/blog/2018/06/11/generating-test-fixtures-with-wireshark/,generating test fixture wireshark,inprogress elixirbased bitcoin node bitcoin protocol parsing serialization process wireshark generating fixture parsing fixture interpreting fixture testing serialization final thought lucid simple article binary fixture wireshark,inprogress elixirbased bitcoin node woefully lacking test front especially problematic considering finicky bitcoin protocol parsing serialization process test functionality without going mindnumbing process manually constructing packet test asserting par serializes expected thankfully wireshark support bitcoin protocol turn simple task let dig use wireshark generate binary fixture bitcoin packet test explore test using elixir generating fixture wireshark support bitcoin protocol box make process generating test fixture incredibly simple create binary fixture given bitcoin packet need follow three step step one fire wireshark start capturing network interface set bitcoin display filter filtering bitcoin packet step two start bitcoind watch packet roll bitcoin packet wire step three notice wireshark tease bitcoinspecific portion every matching tcp packet receives packet exported right clicking bitcoin protocol breakdown choosing export packet byte high level packet information byte exporting represent entire packet come wire parsing fixture saved handful packet like test start process incorporating test suite let assume saved exported packet testfixtures folder within project let also assume want start testing version packet interesting packet able parse far let make new versiontest test module lay boilerplate defmodule bitcoinnetworkprotocolversiontest use exunitcase alias bitcoinnetworkprotocol alias bitcoinnetworkprotocol message version end next add test test par version payload end first thing need load data exported version packet binary assert ok packet fileread testfixturesversionbin use elixir read content versionbin file assert receive ok tuple containing binary content file new packet assignment next parse binary like within node call assert ok message messageparse packet assert receive ok tuple resulting message data exported wireshark relates specifically version packet expect list remaining unparsed binary data empty parsed message compare resulting version struct found messageparsedpayload predefined expected version struct assert equal assert messageparsedpayload version version come know content versionbin packet without manually parsing byte byte interpreting fixture wireshark come rescue addition letting u export bitcoin packet raw binary wireshark also let u inspect parsed content bitcoin packet go back version packet wireshark capture file open bitcoin protocol section see complete breakdown high level message metadata also specific information sent along version message filtering bitcoin packet use information construct predefined version struct top test version version version service timestamp recvip recvport recvservices fromip fromport fromservices nonce useragent startheight solid test version parsing functionality testing serialization test serialization version packet much like tested parsing functionality let start adding new test versiontest module test serializes version struct end start using load binary fixture using parse resulting binary assert ok packet fileread testfixturesversionbin assert ok message messageparse packet rather comparing messageparsedpayload predefined version struct instead serialize call compare newly serialized version message payload binary assert protocolserialize messageparsedpayload messagepayload version serialization code working correctly return binary identical version portion packet exported wireshark final thought like give huge shout lucid simple article binary fixture wireshark huge inspiration well written article highly recommend check like indepth exploration using wiresharkgenerated binary fixture worth kind testing already resulted positive return investment shortly implementing test noticed version struct incorrectly serializing message resulting strange behavior noticing node using test guide able quickly fix implementation three cheer testing
196,Lobsters,elixir,Elixir programming,Be Careful Using With in Tests,http://www.petecorey.com/blog/2018/06/04/be-careful-using-with-in-tests/,careful using test,tweeted trap fell writing seemingly simple test using elixir special form test false positive fix better fix,last week struck chord elixir community tweeted trap fell writing seemingly simple test using elixir special form based reaction tweet thought good idea explore went wrong could prevented test test question fairly simple let imagine looked something like test foo equal bar ok foo dofoo ok bar dobar assert foo bar end end using destructure result call function call next asserting foo equal bar return anything ok tuple expect pattern match fail causing test fail running test see pass function must working expected false positive unfortunately operating faulty assumption reality function actually look like def dofoo ok def dobar error asdf returning error tuple ok tuple test expecting test still passing going easy forget least apparently expression fails pattern match throw error instead immediately return unmatched value test expression returning unmatched error asdf tuple without ever executing block skipping assertion entirely assertion never given chance fail test pass fix fix broken test simple recognize problem expecting assignment throw error fail match one surefire way accomplish use assignment rather expression test foo equal bar ok foo dofoo ok bar dobar assert foo bar end error tuple returned function fail match ok tuple test fail also managed simplify test process fixing success better fix posting fix response original tweet michał muskała replied fantastic tip improve error messaging failing test currently test failure look like matcherror match right hand side value error asdf code ok bar dobar add assertion pattern matching assignment set receive better error message test foo still equal bar assert ok foo dofoo assert ok bar dobar assert foo bar end failing test read like match failed code assert ok bar dobar right error asdf still given information failure presented way easier read internalize leading quicker understanding test failing sure incorporate tip test thanks michał
197,Lobsters,elixir,Elixir programming,Implementing SSH tunnels in Elixir,https://medium.com/@Drowzy/implementing-ssh-tunnels-in-elixir-e7ad9d1af01a,implementing ssh tunnel elixir,introduction application connecting ssh server available type tunnel source note,introductionerlang otp includes ssh application thought would attempt implement ssh tunneling elixir similar define tunnel using opensshwith openssh one define local tunnel using following command ssh nnt l user forward traffic word connect nnt option tell ssh run command redirect null stdin allocate tty possible run command tunnel l local bind address reverse also possible specifying r option even work socket ssh nnt l varlibmysqlmysqlsock user writing post alongside implementation sort recollection implemented gist part correct full source found hereconnecting ssh serverwe define module simple connect create connection ssh server libsshtexsince calling erlang host string binary need encoded charlisthere using username password authentication well allowing user interaction option requiring interaction fail connection attempt lot option available fine grained control u option sufficethe ssh application need started try connect server mixexsdef application extraapplications logger ssh endand try iex ok pid sshtconnect host user ubuntu password ok pid work ready start implementing tunnel type tunnelsthere two kind tunnel interested indirecttcpip allows u client connect ip port using ssh server directstreamlocal allows u connect unix domain socketdirecttcpip forwarding part erlang sshapplication past since removed however implement using sshconnectionhandler source function used internally creating channel instance reference look like sshconnection openchannel connectionhandler channeltype channelspecificdata initialwindowsize maxpacketsize timeout connectionhandler pid receive sshconnectchanneltype type message u either dirrecttcpip directstreamlocal opensshcom channelspecificdata messag construct message format belowinitalwindowsize initial tcp window sizemaxpacketsize max allowed packet sizeand directtcpip message format byte sshmsgchannelopenstring directtcpip sender initial window maximum packet sizestring host port connectstring originator ip originator portwe define function sshtexlibsshtexon line create message translating directtcpip message format binary due excellent bit syntax read basically original message format specificationsince host field variable size length prepended note sshmsgchannelopen sender channel field part message set internally sshconnectionhandleropenchannelif interested reading binary pattern matching think article good job explaining itthe type directtcpip defined module attribute remember since calling erlang application need represented charlist instead string maxwindowsize set specified maximum packet lengthall implementation must able process packet uncompressed payload length byte le total packet size byte le including packetlength paddinglength payload random padding mac iniwindowsize trickier since know impact setting value low high set since pretty sure seen set somewhere go thatif call successful receive open channel use channel connection pid call send data forwarded ip let try sending raw http message iex ok pid sshtconnect host user ubuntu password ok pid iex data get rnrn iex open ch sshtdirecttcpip pid open iex sshconnectionsend pid ch data handle data returned connection receive block iex receive sshcm data ch data ioputs data endendwe receive message using receive block creating channel inside process genserver instance receive using callback def handleinfo sshcm data ch data state ioputs received data length data noreply state endnote say required something actually responding forwarded ip otherwise fail vm setup private ip nginx running port
198,Lobsters,elixir,Elixir programming,versilov/matrex - A blazing fast matrix library for Elixir/Erlang with C implementation using CBLAS,https://github.com/versilov/matrex,versilovmatrex blazing fast matrix library elixirerlang c implementation using cblas,matrex http gitlabcomsdwolfzexperimentaltreemasterexlearn benchmark comparison numpy numpy matrex comparison pure elixir library example linear regression mnist digit jupyter notebook visualization installation macos ubuntu window choosing blas use access behaviour math operator overloading usage example enumerable protocol saving loading matrix example nan infinity creating matrex logo mnist letter,matrex fast matrix manipulation library elixir implemented c native code highly optimized cblas sgemm used matrix multiplication example vectorized linear regression time faster octave single threaded implementation also memory efficient work large matrix billion element size based matrix code http gitlabcomsdwolfzexperimentaltreemasterexlearn benchmark comparison numpy macbook pro ghz core gb ram operation performed matrix filled random number run benchmark bench folder python numpybenchpy mixenvbench mix bench command numpy benchmark iteration average time logisticcost msop npdivide b msop npadd b msop sigmoid msop npdot b msop matrex benchmark iteration average time logisticcost msop par divide b msop faster add b msop faster sigmoid msop faster dot b msop slower comparison pure elixir library slaughter innocent actually macbook pro ghz core gb ram dot product matrix library opssec compared matrex matrex matrix slower numexy slower exmatrix slower dot product matrix library opssec compared matrex matrex k graphmath k slower matrix k slower numexy k slower exmatrix k slower transposing matrix library opssec compared matrex matrex exmatrix slower matrix slower numexy slower example complete example matrex library work linear regression mnist digit jupyter notebook visualization matrex implement inspect protocol look nice console even draw heatmap matrix console animation logistic regression training matrex library matrix heatmaps installation package installed adding matrex list dependency mixexs def deps matrex end macos everything work box thanks accelerate framework encounter compilation error fatal error cblash file found make sure xcode commandline tool installed xcodeselect install error still resolved macos mojave run open restore usrinclude usrlib macos error solved export cpathlibrarydevelopercommandlinetoolssdksmacosxsdkusrinclude cincludepathlibrarydevelopercommandlinetoolssdksmacosxsdksystemlibraryframeworksaccelerateframeworkframeworksveclibframeworkheaders mix compile ubuntu need install scientific library package compile sudo aptget install buildessential erlangdev libatlasbasedev window definitely work window need makefile installation instruction please contribute choosing blas use help matrexblas environment variable choose blas library link take value blas default atlas openblas noblas last option mean compile c code without external dependency work anywhere c compiler place mix clean matrexblasnoblas mix compile access behaviour access behaviour partly implemented matrex iex matrexmagic matrex iex even iex matrex also several shortcut getting dimension matrix iex row iex size calculating maximum value whole matrix one row calculating onebased index maximum element whole matrix row math operator overloading matrexoperators module redefines kernel math operator defines convenience function write calculation code natural way used great caution suggest using inside specific function increased readability using matrex module function especially one two operation one call time faster usage example def lrcostfunops matrex theta matrex x matrex lambda params isnumber lambda turn original operator import kernel except import matrexoperators import matrex row h sigmoid x theta l one size theta set j log h log h lambda l theta grad x h theta l lambda scalar j grad end function coded module method call time faster def lrcostfun matrex theta matrex x matrex lambda params isnumber lambda row h matrexdotandapply x theta sigmoid l matrexones theta row theta col matrexset regularization matrexdottn l matrexsquare theta matrexscalar kernel lambda j matrexdottn matrexapply h log matrexsubtract matrexdottn matrexsubtract matrexapply matrexsubtract h log matrexscalar fn nan nan x x regularization end grad x matrexdottn matrexsubtract h matrexadd matrexmultiply theta l lambda matrexdivide j grad end enumerable protocol matrex implement enumerable kind enum function applicable iex enummember true iex enumcount iex enumsum function exist enum matrex preferred use matrex version beacuse usually much much faster ie x matrix time faster respectively enum counterpart saving loading matrix saveload matrix native binary file format extra fast csv slow especially large matrix matrex csv format compatible gnu octave csv output use exchange data two system example iex matrexrandom matrexsave randmtx ok iex matrexload randmtx matrex iex matrexmagic matrexdivide matrexeye matrexsave nancsv ok iex matrexload nancsv matrex nan infinity float special value like nan inf live well inside matrix loaded saved file getting elixir transferred nan inf neginf atom beam accept special value valid float iex matrexeye matrex iex n matrexdivide matrexzeros matrex nan nan nan nan nan nan iex n inf iex n nan creating matrex logo mnist letter iex matrexlogo matrexload idx accessget matrexlistofrows enumreduce fn x sum add x sum end matrexreshape matrextranspose matrexresize matrexheatmap
199,Lobsters,elixir,Elixir programming,Spreading Through the Bitcoin Network,http://www.petecorey.com/blog/2018/05/21/spreading-through-the-bitcoin-network/,spreading bitcoin network,going dynamic dynamic supervisor back started adding node uncontrolled growth like default limit bitcoin core client final thought mastering bitcoin,previously beefed elixirbased bitcoinnodeinprogress use connection behavior better manage connection peer node robustly connect single peer node let broaden horizon connect multiple peer let refactor node use dynamic supervisor manage collection connection start recursively connecting node bitcoin peertopeer network going dynamic connection bitcoin peer node currently managed bitcoinnetworknode process manage collection process new dynamic supervisor called bitcoinnodesupervisor let create new supervisor defmodule bitcoinnetworknodesupervisor use dynamicsupervisor def startlink dynamicsupervisorstartlink module name module end def init dynamicsupervisorinit strategy oneforone end end code largely boilerplate nodesupervisor initiate oneforone strategy supervision strategy currently available dynamic supervisor also important note like dynamic supervisor nodesupervisor start without child back started next go bitcoinnetworkapplication supervisor replace bitcoinnetworknode child specification specification new dynamic supervisor supervisorstartlink dynamicsupervisor strategy oneforone name bitcoinnetworknodesupervisor strategy oneforone application successfully started nodesupervisor child go ahead add node process child new dynamic supervisor dynamicsupervisorstartchild bitcoinnetworknodesupervisor id bitcoinnetworknode start bitcoinnetworknode startlink applicationgetenv bitcoinnetwork ip applicationgetenv bitcoinnetwork port restart transient simply moved bitcoinnetworknode child specification old supervisor child list dropped call really trying connect node boilerplate confusing intention let create new function bitcoinnetwork module called take node ip address port add child nodesupervisor manages connection node def connecttonode ip port dynamicsupervisorstartchild bitcoinnetworknodesupervisor id bitcoinnetworknode start bitcoinnetworknode startlink ip port restart transient end replace mess callback application module call new function bitcoinnetworkconnecttonode applicationgetenv bitcoinnetwork ip applicationgetenv bitcoinnetwork port much nicer clear application start creates new dynamic supervisor nodesupervisor connects bitcoin node specified application configuration point back feature parity original onenode solution really managed add supervisor layer supervision tree new supervision tree adding node equipped function new dynamic node supervisor ready rapidly expand network known bitcoin node node process currently listening incoming node address one function defp handlepayload addr addrlist addrlist state log bright received green length addrlist reset bright peer ok state end connect additional peer node mapping node address addrlist new function enummap addrlist bitcoinnetworkconnecttonode let clean bit adding another function head function accepts single netaddr struct parameter def connecttonode netaddr ip ip port port connecttonode ip port simply map list netaddr structure receive addrlist variable enummap addrlist beautiful application fire connects initial bitcoin peer node receives node list peer spawn dynamically supervised process attempt connect peer peer successfully connect return list peer repeat process many peer uncontrolled growth point bitcoin node happily spreading bitcoin peertopeer network introducing peer ten thousand node however level connectivity might overkill node need way limiting number active peer connection configurable value start implementing limit adding maxpeers configuration value configexs config bitcoinnetwork maxpeers let start limit one hundred twenty five connection like default limit bitcoin core client next make new function bitcoinnetwork module count number active peer connection fairly straight forward thanks function dynamicsupervisor module def countpeers bitcoinnetworknodesupervisor dynamicsupervisorcountchildren mapget active end next function wrap call check reached maxpeers limit countpeers applicationgetenv bitcoinnetwork maxpeers dynamicsupervisorstartchild bitcoinnetworknodesupervisor else error maxpeers end every time receive peer try connect function first check exceeded maxpeers limit defined application configuration bitcoin node limit pool peer maximum one hundred twenty five connection final thought elixir dynamic supervisor breeze work made possible easily quickly scale pool peer one ten thousand connection blink eye bitcoin node working way bitcoin peertopeer network actually anything need spend time future figuring process incoming block transaction maybe point even able send transaction mine new block sound like dust mastering bitcoin finish remaining chapter
200,Lobsters,elixir,Elixir programming,Rethinking app env,http://www.theerlangelist.com/article/rethinking_app_env,rethinking app env,state live reconfiguration context conflation post config script execution time move execution config script runtime configuring runtime consolidating service configuration consolidating system configuration configuring phoenix endpoint deepmerge supporting runtime configurability library app env support runtime configuration final thought,app env use elixir doc state otp provides application environment used configure application experience app env moderately complex system typically contain following thing thing system configuration thing system configuration thing modified runtime affect system behaviour thing modified runtime affect system behaviour thing vary across different mix environment thing vary across different mix environment thing essentially code eg mfa triplet key implicitly connected module word app env tends degenerate bunch keyvalues arbitrarily thrown place article try reexamine way use app env closely related elixir cousin config script configexs friend propose different approach configuring elixir system idea present might sound heretical warn upfront point writing personal opinion community standard approach suggested elixir core team however keep open mind might find idea might lead nice benefit better organized configuration code complete flexibility fetch configuration data arbitrary source much le bloat config script app env long road ahead u let kick live reconfiguration technically speaking app env mechanism allows u keep application specific data memory data visible process app process change data hood app env data sits publicly accessible ets table named actab semantics ets really good let see simple example suppose need run periodic job want support runtime reconfiguration simple implementation could look like defmodule periodicjob use task def startlink arg taskstartlink defp loop config applicationfetchenv mysystem periodicjob processsleep keywordfetch config interval ioputs keywordfetch config message loop end end notice particular fetching periodic job parameter app env every step loop allows u reconfigure behaviour runtime let try iex defmodule periodicjob end iex applicationputenv mysystem periodicjob interval timerseconds message hello world iex supervisorstartlink periodicjob strategy oneforone hello world sec hello world sec let reconfigure system iex applicationputenv mysystem periodicjob interval timerseconds message hi world hello world sec hi world second later hi world second later example able reconfigure running system without restarting also worth noting thing system running production either via remote iex shell using observer tool important point live reconfiguration work code cache app env data local variable instead refetches configuration every iteration give u runtime configurability contrast piece data fetched app env changing runtime affect behaviour system let see example suppose writing web server want configure via app env simple plugbased code could look like defmodule mysystemsite behaviour plug def childspec arg scheme http plug module option port applicationfetchenv mysystem httpport end end let say http port initially set start system try reconfigure dynamically changing port iex applicationputenv mysystem httpport unsurprisingly affect behavior system system still listen port force change need force restart parent supervisor parent supervisor process case app env fetched invoked parent initializing plug example site theoretically dynamically reconfigured quite clumsy need intimate knowledge code reapply app env setting practical intent purpose port app env setting constant begs question app env value constant affect runtime behaviour keep app env first place one layer indirection justified somehow possible reason would varying configuration different mix envs dev test prod consolidating system configuration single place dependency library requires third scenario avoided believe first two app env config script far perfect understand let look config script issue context conflation suppose need use external database system say postgresql database want work via ecto scenario common enough even phoenix default generate ecto repo configuration invoke mix phxnew devexs config mysystem mysystemrepo adapter ectoadapterspostgres username postgres password postgres database mysystemdev hostname localhost poolsize testexs config mysystem mysystemrepo adapter ectoadapterspostgres username postgres password postgres database mysystemtest hostname localhost pool ectoadapterssqlsandbox prodsecretexs config mysystem mysystemrepo adapter ectoadapterspostgres username postgres password postgres database mysystemprod poolsize get different database configuration dev test prod prodsecretexs file gitignored freely point local database without fear compromising production committing production secret first glance look great varying configuration different mix envs way running prodcompiled version locally however approach without issue one minor annoyance since commit prodsecretexs repo every developer team populate manually big issue bit clumsy ideally development setup would work box important issue production setup running system otp release strongly advise need host secret file build server production server want manage separate staging server us different database need somehow juggle multiple secret configs build server separately compile system staging production approach becomes unusable deploying system client premise case aircloak brief description system see post scenario development team know configuration parameter system admins access code elixirerlang knowhow therefore config script really work let take step back root cause mentioned problem setting different db parameter different mix envs conflating compilation runtime context view mix env devtestprod compilation concern determines variation compiled version example dev might configure auto code recompiling reloading prod turn likewise dev test might disable system service eg fetching twitter feed use fake replacement however mix env assume anything execution context want able run prod compiled version locally local verification benching example likewise assemble otp release prod addition running production box want run staging server using separate database scenario easily handled config script follows config script good fit specifying difference different execution context config script execution time better way specify difference use external configuration source say o env externally supplied file kv etcd let say decided keep connection parameter o env configuration code could look like configexs config mysystem mysystemrepo adapter ectoadapterspostgres username systemgetenv mysystemdbusername password systemgetenv mysystemdbpassword database systemgetenv mysystemdbdatabase hostname systemgetenv mysystemdbhostname configure variation devtestprodexs set different o env var target machine compile prod version run different box using different database however lead another problem current elixir config script evaluated compilation runtime using otp release assemble separate build server practice recommend reallife project simply fly today env parameter retrieved compilation runtime end problem admittedly elixir team plan move execution config script runtime mean issue solved future however need fetch data external source json file etcd instance change help essentially chickenandegg problem app env value need resolved apps started even runtime config script need run dependency eg json decoder etcd client loaded consequently need fetch value using dependency library config script place thing config script evaluated soon worst case evaluated compilation build server best case evaluated dependency started contrast service system repo endpoint process started way later sometimes even conditionally consequently config script often force fetch config value much sooner moment actually need configuring runtime given issue outlined strong opinion connection parameter external service belong config script configure connection previously required trickery luckily ecto phoenix recently added explicit support runtime configuration shape callback one way could configure database connection params defmodule mysystemrepo use ectorepo otpapp mysystem def init arg appenvdbparams ok keywordmerge appenvdbparams dbconfig defp dbconfig hostname osenv mysystemdbhost username osenv mysystemdbuser password osenv mysystemdbpassword database osenv mysystemdbname end defp osenv name case systemgetenv name nil raise o env name set value value end end end approach moved retrieval connection params runtime repo process starting ecto first read app config configured config script invoke fill blank big gain running runtime application starting dependency already started therefore freely invoke systemgetenv jasondecode etcdclientget anything else suit purpose consolidating service configuration one issue code difficult use different database test environment could worked around systemputenv call placed testhelperexs however approach fly source truth file etcd instance really want ability bypass o env check test environment enforce database name different way config script give convenient solution problem could provide database name testexs testexs config mysystem mysystemrepo database mysystemtest adapt configuration code defmodule mysystemrepo use ectorepo otpapp mysystem def init arg appenvdbparams ok keywordmerge appenvdbparams dbconfig appenvdbparams defp dbconfig appenvdbparams hostname osenv mysystemdbhost username osenv mysystemdbuser password osenv mysystemdbpassword database keywordgetlazy appenvdbparams database fn osenv mysystemdbname end end end fix problem solution leaf lot desired point database configured different config script repo module personally find quite confusing grasp database configuration particular mix env need consider least three different file configexs mixenv ex repo module source file make matter worse config file bloated unrelated configuration eg endpoint setting database configuration could even dispersed throughout config shape configexs config mysystem mysystemrepo ten hundred line later config mysystem mysystemrepo let consider even use config script first place already pulled database parameter repo parameter still config script reason convenient encode variation mix envs config script put stuff desired mixenv ex good go however never get something nothing pay writing convenience sacrificing reading experience understanding database configuration becomes much harder better reading experience would entire database configuration consolidated one place since need determine parameter runtime place encode variation different mix envs luckilly fairly simple light touch elixir metaprogramming defp dbconfig database dbname end mixenv test defp dbname mysystemtest else defp dbname osenv mysystemdbname end code somewhat elaborate consolidated explicit code clearly state test env database name forced particular value ie configurable contrast previous version vague constraint leaf room mistake renaming repo module forget update config script might end running test dev db completely mess data worth noting ever invoke mixenv compilation either module level ie outside named function inside unquote expression mix available runtime even mixenv possibly give meaningful result remember mix env compilation context get runtime dislike ifelse noise last attempt introduce simple helper macro defmacrop envspecific config quote unquote keywordgetlazy config mixenv fn keywordfetch config else end end end defp dbconfig database envspecific test mysystemtest else osenv end notice change semantics compiled code since envspecific macro invoking make compiletime decision inject one code another constant value function call example test environment code osenv executed even make compiled version consequently freely invoke anything want json decoding fetching etcd example executed runtime desired mix env added bonus envspecific macro requires value specified current mix env else setting macro complain compile time value provided summarize touch metaprogramming achieved feature parity config script moved retrieval parameter runtime consolidated repo configuration expressed variation mix envs clearly stronger guarantee shabby consolidating system configuration one frequent argument app env config script allow u consolidate parameter system single place supposedly config script become goto place refer want see aspect system configured however soon want configure external service database left two choice shoehorn configuration config script move configuration runtime first case need resort sort improvisation make work soon need support multiple execution context ride fun might consider abandoning otp release completely run iex mix prod imo bad idea take advice go leaf second option system parameter retrieved runtime point config script cease single place system parameter defined bad thing though honest think config script poor place consolidate configuration anyway first config script tend quite noisy contain sort data including thing part system configuration consider following configuration generated phoenix config mysystem mysystemrepo adapter ectoadapterspostgres database adapter really configurable thing change say mysql everything magically work opinion unless explicitly worked support scenario fail spectacularly therefore adapter parameter system hence belong aside aircloak due nature system database adapter configurable parameter however configured ecto adapter rather particular setting specific system setting affect system work database internal variation way complex supporting different database required lot work beyond passing one ecto adapter needed support scenario invested effort make happen need need invest effort database adapter system configuration parameter theory change practice another example config bloat config mysystem mysystemwebendpoint rendererrors view mysystemweberrorview accepts w html json pubsub name mysystempubsub adapter thing configuration parameter theory could construct scenario need configurable case yagni parameter library system hence add bloat config script app env another problem config script tend populated arbitrary way personal sentiment content becomes function arbitrary decision made different people different point time best developer make sensible effort keep thing feel like system configuration config script often content config script determined demand library default established code generator convenient ability vary value across different mix envs summary place supposed consolidated system configuration contain thing system parameter thing system parameter let take step back consider even want consolidated system configuration one reason could make easier developer find parameter system need determine database connection parameter http port logging level open config script find personally hard time accepting argument first configuration imo naturally belongs place us interested db connection parameter first look repo module want know endpoint parameter look endpoint module approach also make easier grasp configuration read config script spammed bunch unrelated data neither care moment hold together head contrast read consolidated repo config isolation easily understand important reason system config consolidation assist administration external administrator people might access source code maybe fluent elixir consult code discover system parameter however reason stated feel config script suffice task mentioned database connection parameter likely part config script complete consolidation already lost addition external admins fluent elixir could problem understanding elixir script especially dynamic plan assisting administration consider using well understood external configuration source ini env json file kv etcd app env needed config script suffice anyway likely end variation configuration style proposed performed runtime reallife example system building aircloak running client premise configured client administrator access secret access source code facilitate administration fetch system parameter json file provided administrator explicitly carefully cherry picked parameter belong system configuration everything else implementation detail cause bloat config consequence know exactly piece data provided configuration validate config file schema fail fast key name misspelled data right type configuring phoenix endpoint let take look involved example blog powered phoenix endpoint completely configured runtime therefore endpointrelated config piece following config erlangelist erlangelistwebendpoint reason need empty config phoenix requires endpoint parameter provided defmodule erlangelistwebendpoint def init key phoenixdefaults ok erlangelistwebendpointconfigconfig phoenixdefaults end since lot parameter significant variation different mix envs decided move code another module separate plug chaining configuration assembly function look like def config phoenixdefaults phoenixdefaults deepmergedeepmerge commonconfig deepmergedeepmerge envspecificconfig configurehttps end starting default value provided phoenix apply common setting envspecific setting finally http specific tuning needed due auto certification let encrypt note deep merge since env specific setting might partially overlap common one since afaik deep merging available elixir resorted deepmerge library common config determines parameter vary mix envs defp commonconfig http compress true port rendererrors view erlangelistweberrorview accepts w html json pubsub name erlangelistpubsub adapter end notice http port hardcoded reason mix envs host machine always particular value constant config parameter production request arrive port however configured outside elixir using iptables forward port port allows run elixir system nonprivileged user since variation different envs significant use envspecific macro trick instead opted plain mixenv based switch case mixenv dev defp envspecificconfig dev parameter test defp envspecificconfig test parameter prod defp envspecificconfig prod parameter end complete version seen consolidation allows find complete endpoint configuration single place something case config script clearly see difference dev test prod without needing simultaneously look three different file bunch unrelated noise worth repeating code feature parity config script particular dev testspecific parameter make prodcompiled version supporting runtime configurability fun experiment also added bit runtime configurability allows change behaviour system without restarting anything site running keep aggregated usage stats see read count per article implemented quick dirty way using erlangtermtobinary storing data file use separate file day system periodically deletes older file relevant code sits erlangelistusagestats module also responsible configuration configuration specifies often inmemory data flushed disk often cleanup code invoked many file preserved cleanup relevant piece configuration code defmodule erlangelistusagestats def startlink arg initconfig end defp initconfig applicationputenv erlangelist module config defp config flushinterval envspecific prod timerminutes else timerseconds cleanupinterval envspecific prod timerhours else timerminutes retention end end like endpoint repo configuration encapsulated relevant module however since want support dynamic reconfiguration explicitly storing config app env start process finally ever access parameter directly invoking applicationfetchenv see without caching value variable therefore changing app env setting runtime affect future behaviour system result style configuration config script become lightweight configexs config logger console format time metadata level messagen metadata userid config erlangelist erlangelistwebendpoint devexs config logger level debug console format level messagen config phoenix stacktracedepth testexs config logger level warn full app env erlangelist app small consisting mostly parameter affect runtime behaviour system iex applicationgetallenv erlangelist erlangelistusagestats flushinterval cleanupinterval retention erlangelistwebendpoint includedapplications library app env sometimes dependency require app env setting provided need use config script example logging level logger application best configured config script logger actually support runtime configuration could set logger level app start callback however point app starting dependency already started setting might applied late thus configuration best done config script also many library erlang elixir one needlessly require parameter provided via app config library author cautious opting interface case plain functional interface take option function parameter suffice alternatively well could support callback similarly ecto phoenix invoke init callback function allowing client provide configuration runtime case requiring app config best choice good example aforementioned logger scenario far often plain functional interface superior option besides keeping thing simple giving maximum flexibility user also able better document enforce parameter type via typespecs also like caution keeping code reference config script mfa atom implicitly tied module compiled code accident waiting happen rename module forget update config thing break lucky break abruptly test silently work prod might face sort strange issue hard troubleshoot library author try enforce user set foobar app env key define module name rarely good approach ever occasional case eg module need provided via app config good example plugging custom log backends logger situation common think hard making choice case taking function callback module via parameter better option final thought impression elixir project tend overuse config script app env reason likely historic far remember even pure erlang library frequently required least promoted app envs particular technical reason feel overuse amplified elixir config script admittedly convenient simplify writing process also make easy add bloat app env consequently end config script describe complete system configuration frequently contain thing configuration since executed compile time config script cause lot confusion work need fetch parameter source o env even elixir team manages move config execution runtime still likely limited offer fetching source etcd external file json ini require different solution opinion better approach drive configuration retrieval runtime place actually need fetch site configuration endpoint module repo configuration repo module separate different configuration concern consolidate parameter naturally belong together importantly shift configuration retrieval runtime giving much higher degree flexibility keep mind app env another data storage central place config parameter storage pro con use accordingly read data app env startup need app env first place copying data o env app env skip app env always read o env instead need cache parameter avoid frequent roundtrips external storage consider using dedicated ets table caching library cachex since app env value changed runtime limit app env usage piece data used change system behaviour even case likely better without config script define configuration data place used common kv store dependency requires app env startup best option provide via config script use config script case much smaller easier grasp feel library needlessly requires app env setting contact maintainer see improved careful using config script vary behaviour different mix envs achieve effect bit elixir metaprogramming help consolidate configuration keep thing system parameter outside app env config script keep mind mix function invoked runtime mixenv meaning runtime make distinction compile time execution context compile mixenvprod compiled production version version run production box prod compiled code easily invokable dev box staging machine consequently variation execution context variation compilation context thus belong configuration script mechanism relying mixenv finally want consolidate system parameter assist external administrator consider using well understood format env ini json file storage etcd cherry pick parameter relevant leave one implementation detail keep configuration check make possible validate startup final parting gift recommended reading happy configuring
201,Lobsters,elixir,Elixir programming,Beefing Up our Bitcoin Node with Connection,http://www.petecorey.com/blog/2018/05/14/beefing-up-our-bitcoin-node-with-connection/,beefing bitcoin node connection,connection behavior starting point module opted take advice use function connection without connecting full specification map connecting connect couple option limiting retries disconnecting connect final thought check complete code github,left bitcoin adventure building barebones bitcoin node connects another peer node network elixirbased node able connect peer connection fragile best problem initial connection version messaging would leave application dead water thankfully way beefing resilience elixir node today refactoring bitcoin node use james fish connection behavior rather basic genserver behavior ship elixir implementing behavior node give u robustness connection process along option reconnect peer node case failure let get starting point dive refactoring bitcoin node use new connection behavior go change made simplify bitcoinnetworknode module previously every message parsed incoming tcp packet assembled bitcoinnetowkrprotocolmessage struct cast back current node process process message hindsight solution overly complicated weighted boilerplate message passing overhead instead opted take advice use function handle incoming message def handleinfo tcp port data state message rest chunk staterest data case handlemessages message state error reason state stop reason ok state noreply state rest rest end end assembled message structs passed helper function return either error tuple ok tuple current node updated state processing received message filter invalid message run remaining message helper function pas function new parsedpayload field hold parsed structbased representation inbound bitcoin message defp handlemessages message state message enumfilter enumreducewhile ok state fn message state case handlepayload messageparsedpayload state error reason state halt error reason state ok state cont ok state end end end notice using give call opportunity modify state node next message processed run problem handling parsed payload immediately exit reduction returning halt tuple main benefit refactor come simplicity method ping handler look like refactor defp handlepayload ping state ok messageserialize pong sendmessage statesocket ok state else error reason error reason state end end use pattern matching listen bitcoinnetworkprotocolping message receive ping serialize send pong back peer node anything go wrong sending response return error tuple beautiful connection without connecting connection behavior specialization genserver behavior intended used represent connection external resource mirror entire api standard genserver add two additional callback u implement probably guessed two callback used connect disconnect external resource start using connection behavior application need add dependency mixexs file defp deps connection end next start genserver connection conversion replacing use genserver behavior new connection behavior wholesale replacing genserver connection throughout bitcoinnetworknode module defmodule bitcoinnetworknode use connection def startlink ip port connectionstartlink module ip ip port port rest end connection behavior superset genserver behavior node still run like used given change let try mix could start application bitcoinnetwork exited bitcoinnetworkapplicationstart normal exit exception raised argumenterror module bitcoinnetworknode given child supervisor implement uh oh connection behavior implement callback like old genserver behavior application longer like child specification shorthand using bitcoinnetworkapplication supervisor bitcoinnetworknode applicationgetenv bitcoinnetwork ip applicationgetenv bitcoinnetwork port fix fleshing child specification full specification map bitcoinnetworkapplication module id bitcoinnetworknode start bitcoinnetworknode startlink applicationgetenv bitcoinnetwork ip applicationgetenv bitcoinnetwork port restart transient change bitcoin node run like used connecting connect far refactor exciting bitcoin node still work added new functionality let change fleshing callback provided connection behavior start sketching callback within module def connect info state end within callback handle behavior associated connecting external resource may remember previously handled callback let start migrating code function first step connecting peer node establish tcp connection gentcpconnect iptotuple stateip stateport option next step sending initial version message establishing communication peer sendmessage message socket thing go well say successfully connected peer bitcoin node case connection behavior dictate return ok tuple new state process ok socket gentcpconnect iptotuple stateip stateport option ok sendmessage message socket ok mapputnew state socket socket end however something go wrong couple option either return stop tuple kill current process similar previous functionality node alternatively return backoff tuple instructs connection behavior retry connection behavior specified timeout let try reconnecting peer node something go wrong need add else block return backoff tuple else backoff state failed connection attempt bitcoin node retry connection one thousand millisecond limiting retries new connection retry logic work beautifully almost work well fact try connect nonexistent bitcoin peer node see node attempt reconnect end time let limit number retry attempt node make give adding retries field initial state initial value def startlink ip port connectionstartlink module retries end also add maxretries module attribute indicate many retries want node attempt maxretries next modify backoff tuple returned callback increment retries returned state map backoff mapput state retries stateretries lastly add new function head detects reached maximum number allowed retries reach limit want return stop tuple kill current process def connect info state retries maxretries stop normal state end beautiful bitcoin node stop attempting connect peer node three failed attempt waiting one second disconnecting connect revamped connect peer node need consider happen event disconnect node callback return disconnect tuple connection behavior call callback decide next course action several option handling disconnection callback return connect tuple attempt reconnection immediately similarly return backoff tuple delay reconnection specified timestamp alternatively return noconnect tuple keep current process alive attempt reconnect peer node lastly callback return stop tuple immediately terminate bitcoin node process start connecting node future loss single node big deal losing peer part life unfortunately mind detect disconnect simply close tcp connection return stop tuple callback def disconnect state ok gentcpclose statesocket stop normal state end next handling result call deal error slightly differently instead returning stop tuple receive error handling one message instead return disconnect tuple case handlemessages message state error reason state disconnect reason state rest rest state noreply state rest rest end drop u callback given reason disconnect final thought refactor involved quite moving piece end final product cleaner simpler robust piece software change positioned nicely move forward expand bitcoin node project found sure check complete code github get cohesive view done next time start expanding network node recursively connecting neighboring node receive peer node stay tuned
202,Lobsters,elixir,Elixir programming,Reversing BIP-39 and the Power of Property Testing,http://www.petecorey.com/blog/2018/05/07/reversing-bip39-and-the-power-of-property-testing/,reversing power property testing,implemented previous haiku miner byte mnemonic using elixir encoding algorithm wordlist choice laying groundwork module previous article decoding mnemonic putting solution test streamdata library support encoding data sixteen thirty two bit underspecified encoder specification tightening encoding process final thought check entire project github pierre martin elixir slack group github issue solution problem,recently asked would go reversing encoding algorithm implemented previous used build haiku miner implementing reverse algorithm seemed straightforward first quickly led rabbit hole showed powerful propertybased testing read asking highly recommend check first article series byte mnemonic using elixir full rundown encoding algorithm quick summary encoding algorithm intended convert arbitrary set byte easily memorizable sequence word algorithm go something like byte want encode append partial checksum end byte map every eleven bit chunk resulting binary onto wordlist choice devil detail see laying groundwork write reverse encoding algorithm need lay initial groundwork module built previous article single public function function generated random set byte converted mnemonic def generate entropy attachchecksum mapontowordlist end moving forward separate encoding functionality entropy generation test encoding algorithm independently data simplify testing final solution def generate encode generateentropy end def encode data data attachchecksum mapontowordlist end clarity sake also renamed function generateentropy great function encodes given binary set add new function revers process return binary data decoded given mnemonic def decode mnemonic end decoding mnemonic highlevel process reversing algorithm decoding mnemonic binary look something like map word mnemonic back binary separate appended partial checksum encoded data verify appended checksum match actual checksum data sound like plan first step decoding mnemonic function convert encoded mnemonic wordlist back binary first map word onto index wordlist next convert index elevenbit binary reduce list binary single concatenated binary dataandchecksum mnemonic enummap enumfindindex wordlist fn w w end enumreduce fn n acc acc bit n end left originally encoded data concatenated variablelength partial checksum know variablelength checksum length originally encoded data given also know length originally encoded data length dataandchecksum concatenated checksum fill remaining space totalsize bitsize dataandchecksum datasize div totalsize checksumsize totalsize datasize know structure dataandchecksum pull individual piece care using binary pattern matching data bitssize datasize partialchecksum bitssize checksumsize dataandchecksum fantastic left verify partialchecksum provided match calculated checksum provided data binary checksum match return ok tuple containing decoded data otherwise return error tuple explaining situation data bit partialchecksum bit attachchecksum data ok data else error badchecksum end given binary mnemonic wordlist retrieve original binary putting solution test built function need test encoding decoding process working expected testing encoderdecoder pair perfectly suited propertybased testing use streamdata library test solution set new test module scaffold new property test mnemonic encoder defmodule use exunitcase use exunitproperties property encodes decodes mnemonic end end property trying test given binary equal encoded mnemonic decoded back binary test fairly easily streamdata know algorithm support encoding data sixteen thirty two bit allowed size ent bit given generate stream random binary fall within size range check data binary minlength maxlength end next generate mnemonic randomly generated data binary assert decoded mnemonic match original data mnemonic data assert mnemonic ok data go well test pas underspecified encoder unfortunately thing rarely go planned new test seems run several successful iteration encodedecode assertion ultimately fails thankfully streamdata shrink failing test much possible give u failing input property encodes decodes mnemonic failed generated value successful run clause data binary minlength maxlength generated assertion failed code assert mnemonic ok data left error badchecksum right ok intense debugging session realized nothing wrong function instead problem encoder specification clearly state addition bit length length binary data encoded must also multiple thirty two bit mnemonic must encode entropy multiple bit ignoring requirement result issue generating appending partial checksum result data loss decoding procedure accommodate requirement let update property test truncate generated binary nearest thirty two bit check byte binary minlength maxlength bitstotruncate byte bitsize rem size bitstotruncate data bit byte mnemonic data assert mnemonic ok data end test pass expected tightening encoding process function work passed correct data probably good idea assume developer know constitutes good data instead let refactor enforce length requirement outlined specification let update function head assert data binary assert length fall one hundred twenty eight two hundred fifty six bit assert length bit multiple thirty two def encode data isbinary data bitsize data bitsize data rem bitsize data ok data attachchecksum mapontowordlist end requirement hold return encoded data wrapped ok tuple otherwise need return error tuple second function head def encode error invaliddata wrapping result ok tuple break test need fix check byte binary minlength maxlength bitstotruncate byte bitsize rem size bitstotruncate data bit byte ok mnemonic data assert mnemonic ok data end also add property test ensure invalid binary encoded mistake first test short binary rejected property reject short binary check bit integer size bit data bit binary maxlength assert data error invaliddata end end next test long binary rejected property reject long binary check bit integer byte binary minlength data byte binary size bit assert data error invaliddata end end finally test misaligned binary binary length align thirty two bit rejected property reject misaligned binary check data bitstring minlength maxlength data bitsize rem assert data error invaliddata end end perfect fully confident encodedecode solution final thought seemingly simple task threw rabbit hole definitely expect grateful experience showed handson way powerful propertybased testing without randomly generated test case think would recognized issue encode function like see encoderdecoder source entirity sure check entire project github like thank pierre martin bringing topic reversing algorithm talking elixir slack group filed github issue solution problem highly recommend check approach fleshed solution
203,Lobsters,elixir,Elixir programming,Why I’m Co-organizing The Big Elixir Conference,https://medium.com/the-big-elixir/why-im-co-organizing-the-big-elixir-5700e63e1b06,coorganizing big elixir conference,thing heard time time would agree organize conference elixirscript elixirconf conference get excited rubyconf clojure sync eric normand would agree organize conference together big elixir team big elixir new orleans november hope join u,creating conference hard take lot time energy planning certain kind crazy want create conference thing heard time time would agree organize conference let go back time using elixir year already created package interacted community elixir first programming language bothin february started working elixirscript time later year cfp second elixirconf came wanted apply afraidi presented front meetups never conference mentioned joe elli coorganizer big elixir convinced apply applying presentation accepted presented elixirscript elixirconf also first real programming conference attended left energized even greater thing elixir thanks joe pushing apply gratefulin got lot offer speak conference turned downnot want fear flying ironically married exflight attendant something want work made hard take certain opportunity privilege travel around world meet awesome people kept chained fear friendly skiesthat fear actually planted seed big elixirnew orleans lot conference even technology conference many programming conference technology conference come tend focus business entrepreneurship tech anything kind conference important want conference want attend kind growing software engineering community want attendconferences get excited aboutconferences like rubyconf last year met chatted rubyconf attendee hour great hereconferences like clojure sync eric normand organized hosted volunteer sat talk clojure developer genuinely enjoyed conference excited clojure sync going continue herejazzcon vueconf kind experience enjoy new orleans deserves themso would agree organize conference simply put enjoy talking like minded people elixir like flyingand creating programming conference new orleans help grow tech community joe want dowe may decided organize conference become real nicky mast joined u expertise organizing conference engine make thing runtogether big elixir team big elixir new orleans november hope join u
204,Lobsters,elixir,Elixir programming,Leibniz is a pure Erlang/Elixir math expression parser and evaluator,https://github.com/saulecabrera/leibniz,leibniz pure erlangelixir math expression parser evaluator,leibniz installation usage documentation example todo license,leibniz leibniz pure erlangelixir math expression parser evaluator installation defp deps leibniz end usage documentation leibniz provides two core functionality evaluating valid math expression evaluating valid math expression given context example evaluating simple math expression leibnizeval ok evaluating math expression given context leibnizeval foo foo ok leibnizeval baz error value expected following dependency baz todo license mit
206,Lobsters,elixir,Elixir programming,The Erlang Runtime System,https://happi.github.io/theBeamBook/,erlang runtime system,,list sort list seq erlang list sort erlang list redbug done timeout
208,Lobsters,elixir,Elixir programming,Calling Elixir from Erlang,https://joearms.github.io/published/2017-12-18-Calling-Elixir-From-Erlang.html,calling elixir erlang,,
209,Lobsters,elixir,Elixir programming,Wunderscan: Giving a Broken Barcode Scanner New Life,http://bcarrigan.com/2018/04/20/wunderscan/,wunderscan giving broken barcode scanner new life,reverse engineering posting wunderlist upc lookup upc database wunderlist post feeding pi nerve building hardware writing software wunderscan github link project level supporting code main loop genserver project enclosure hub summary service page,actually plan project rather found scrap exchange local reuse center found nice looking scanner might find grocery store kiosk ripped connector unlabeled wire hanging bit hardware gore thing exists labelled sale quick search revealed originally retailed thought great use would keep near pantry spice snack could scan item would get posted shopping list figured would try reverse engineer else fails scrap laser motor longer post go entire process strap reverse engineering able locate datasheet scanner find us serial connection send data normally would connector frayed end wiring diagram start finding power connection part reverse engineering really luck anything run risk frying part connect power improperly set power supply tried following thing find power cable using bbroygbvgw color scheme used resistor match wire pinouts work start trying wire based likely color code instance black brown ground red orange power wound working though know logic thought turned orange line brown ground part powered working left finding transmit line used oscilloscope part found scanning item looking signal long wire found able receive upc code scanner simply sends ascii representation upc code followed rn character would make parsing message easy posting wunderlist wife use wunderlist grocery shopping next step project figure post item information shared grocery list consists two part converting upc number item name oz making request wunderlist information upc lookup upc lookup upc database looked like best choice since free tier would work low lookup count add upc label item service also easy use simply sign account search using following url scheme get http apiupcdatabaseorgproduct upccode apitoken return product error none could found wunderlist post next posting wunderlist first step getting api token done right developer web interface creating new application use wunderlist creating oauth token account token client id application start making request order create item first need find id list item added using following api point get http xaccesstoken access token xclientid client id return list list point find one want searching result looking desired title grab id desired list post made using post http xaccesstoken access token xclientid client id body listid id last step title title upc lookup feeding pi tie together need program following listens upc code coming serial connection upon receipt upc code query upc database shown product name error determined post wunderlist could potentially used particle lowpower embedded device wanted try nerve project way write embedded software using elixir raspberry pi zero w chosen compute module scanner could placed anywhere house still connect building hardware hardware project pretty simple feed barrel connector scanner raspberry pi connect raspberry pi level converter serial line conversion need happen us different voltage raspberry pi serial communication see oscilloscope screenshot serial signal versus signal writing software software side working nerve general think deserves post article let high level overview project code first code found following link wunderscan github link talk code three section project level supporting code main loop project level project level import required library setup system variable tell nerve build software unlike working standard raspberry pi environment raspbian pythoncc flash operating system raspberry pi copy program file nerve build root image boot application even set project allow ssh firmware push allowing compile everything pc push new copy entire root system ssh device take manual raspberry pi configuration picture sudo raspiconfig command wpasupplicantconf placement manually changing file set pi replaced nerve configuration wonderful setting new raspberry pi run application one favorite thing working nerve feed secret software compile time using config file consider following pas api key using environmental variable computer compiling code config nervesnetwork default ssid systemgetenv nervesnetworkssid psk systemgetenv nervesnetworkpsk keymgmt stringtoatom keymgmt config scanner wunderlistaccesskey systemgetenv wunderlistaccesskey wunderlistclientid systemgetenv wunderlistclientid upcdatabaseaccesskey systemgetenv upcdatabaseaccesskey listname scanned grocery normal raspberry pi project running raspbian language choice would likely need manually ssh send key manually type using keyboard nerve simply compile flash image done supporting code call supporting code simply high level apis written abstract upc database query wunderlist interaction used httpoison make request poison decode json example code show request find id list wunderlist given title list def findlistid title http httpoisonget authheaders processresponse title end def processresponse ok httpoisonresponse body body title poisondecode body enumfind fn listitem mapget listitem title title end mapfetch id end def processresponse error error defp authheaders xaccesstoken applicationgetenv scanner wunderlistaccesskey xclientid applicationgetenv scanner wunderlistclientid end elixir idiomatic return tuple error code instead raising error thus api return one three way ok id error httpoisonerror error let u match return calling code making handling error natural part program writing response applicationgetenv scanner listname scannerwunderlistapifindlistid case response ok id id error error loggererror errorreason nil error loggererror key found nil end main loop unlike loop loop language elixir erlang use process supervised system high level system robustness piece python code crash application exit likely need operating system restart elixir process crash supervisor automatically restart relevant process without o intervention make style writing program different style grown really enjoy main loop using genserver behavior implement step shown section start initializing serial port http client polling see internet connected yet def init port start nerve port beginserial port start httpoison httpoisonstart start polling ethernet available send self ethernetcheck ok id nil end defp beginserial port ok pid nervesuartstartlink nervesuartopen pid port speed active true nervesuartconfigure pid framing nervesuartframingline separator rn pid end starting serial port active mode cause send message every time receives string setup callback genserver fire every time receive data write code query upc code post wunderlist def handleinfo nervesuart pid barcode id id check barcode todotitle case scannerupcdatabaseapilookup barcode ok productmap getbestname productmap barcode barcode error barcode end post item scannerwunderlistapicreatetodo id todotitle loggerinfo got info barcode posted item todotitle keep state constant noreply id id end seen problem upc retrieval simply post error message instead product name project enclosure printed simple design first one feature held multiple part together assembly used fusion modeling began modeling individual component finding common one like raspberry pi online moved component around ample space wired figured secure place raspberry pi screwed post using heatset insert power connector small clearance simply glued place scanner sits inner wall held place outer wall high enough cavity beneath easily fit wire whole thing includes fillet cutout neatly display scanner printer went hub get design printed final result look great summary fun project got learn nerve designing printed enclosure also inexpensive part list totaling le complex design unlikely others find particular scanner possible use scanner serial protocol device already come handy several time remind u pick spice run hope enjoyed post always feel free contact question looking build something similar company could use help launching embedded product like run fullstack connected device consulting firm build great product client information please check service page
210,Lobsters,elixir,Elixir programming,Connecting an Elixir Node to the Bitcoin Network,http://www.petecorey.com/blog/2018/04/23/connecting-an-elixir-node-to-the-bitcoin-network/,connecting elixir node bitcoin network,implementing nut bolt bitcoin protocol elixir andreas antonopoulos mastering bitcoin elixir programming language constructing genserver genserver supervising genserver working ip hello bitcoin network erlang building version message version message binary modifier bitcoin protocol specification version network address variable length string composing message additional metadata message sent sending version previously implemented module processing response helper receiving verack verack message receiving version getaddr message receiving address network address addr message variable integer staying alive final thought future work let know,writing implementing nut bolt bitcoin protocol elixir developed rough understanding bitcoin work fundamental level bitcoin peertopeer network thing make block propagation possible always felt like mysterious black box bitcoin white paper wave hand implementation network even andreas antonopoulos mastering bitcoin skim implementation detail building networkready bitcoin node true working network completely tangential working bitcoin still find extremely interesting since first started diving world bitcoin development wanted build simple node connects network elixir programming language give u fantastic tool implement server peertopeer network let see far take u constructing genserver since first foray bitcoin peertopeer network stick simple goal let lay list thing like accomplish create maintain connection single bitcoin node fetch count list node peer goal help inform u architecture final solution since attempting connect single bitcoin node able model node nicely single genserver start creating new module bitcoinnetworknode house new genserver defmodule bitcoinnetworknode use genserver end next tell node bitcoin peer node want connect passing tuple target node ip port def startlink ip port genserverstartlink module ip ip port port end lastly pas ip port along function within map simply log intention connect specified node def init state ip ip port port bright connecting bitcoinnetworkiptostring ip port log end helper function add extra debug information log output us inject color log defp log message bright black inspect self reset message ioansiformat ioputs end supervising genserver sketched basic shape spawn instance bitcoinnetworknode genserver application start modify callback application entry point module bitcoinnetworkapplication create oneforone supervisor supervises single instance bitcoinnetworknode genserver def start type args supervisorstartlink bitcoinnetworknode applicationgetenv bitcoinnetwork ip applicationgetenv bitcoinnetwork port strategy oneforone end pulling ip port bitcoin node trying connect application configuration set value configexs file config bitcoinnetwork ip config bitcoinnetwork port assume trying connect testnet bitcoin node running port address changed point node bitcoin network working ip might noticed initial logging statement made call function application configuration specified ip address node connecting binary bitcoin network support address expects address represented binary form sent across network convenience represent ip address application sixteenbyte binary binary difficult work create helper function bitcoinnetworkip module make easier handle first need see ip address peer node connecting need way transforming ip address binary string see def tostring binary binary binarybintolist enumchunkevery enummap enummap enumjoin end erlang tool use manage tcp connection expect ip address form eightelement tuples rather binary handle conversion u def totuple binary binary binarybintolist enumchunkevery enummap enummap listtotuple end freely shift base binary representation string tuple form need log address connect node hello bitcoin network spin application point see log statement bitcoinnetworknode genserver attempting connect local bitcoin node first run application unfortunately nothing actually happening let fix first step communicating bitcoin node connecting bitcoin protocol play tcp use erlang gentcp manage tcp connection peer node callback let add call connect specified ip port ok socket gentcpconnect bitcoinnetworkiptotuple ip port binary active true specifying binary option connection mean want incoming packet delivered binary rather list byte also specifying connection active mean incoming message sent current process message need handle callback aside pattern matching ok tuple work fine robust solution would gracefully handle connection failure failing connect bitcoin node fairly common occurance connected node add resulting socket process state return callback ok mapputnew state socket socket spin application go well actually connected bitcoin node building version message opening tcp connection bitcoin node get u far initially node connect acknowledge presence send version message message act handshake introduces new node let create bitcoinnetworkprotocolversion struct represent version message defmodule bitcoinnetworkprotocolversion defstruct version nil service nil timestamp nil recvip nil recvport nil fromip nil fromport nil nonce nil useragent nil startheight nil end next create bitcoinnetworkprotocol protocol defines function use protocol establish serialization interface implemented network structure representation defprotocol bitcoinnetworkprotocol def serialize end start creating implementation function version struct defimpl bitcoinnetworkprotocol bitcoinnetworkprotocolversion def serialize version versionversion versionservices versiontimestamp protocolserialize versionnetaddr service versionservices ip versionrecvip port versionrecvport binary protocolserialize versionnetaddr service versionservices ip versionfromip port versionfromport binary versionnonce protocolserialize varstr value versionuseragent binary versionstartheight end end using little binary modifier specify field encoded little endian format specified bitcoin protocol specification also including serialized binary subtypes version network address versionnetaddr variable length string varstr structure implemented similarly version struct corresponding implementation composing message fleshed version module corresponding implementation generate serialized version binary protocolserialize version version service however quite ready send across network peer node first need wrap serialized binary additional metadata message sent let create new struct called bitcoinnetworkprotocolmessage represent metadata defmodule bitcoinnetworkprotocolmessage defstruct magic nil command nil size nil checksum nil payload nil end define implementation function transforms struct properly encoded binary def serialize message command command payload payload applicationgetenv bitcoinnetwork magic binary stringpadtrailing command binary bytesize payload binaryencodeunsigned messagechecksum payload binary payload binary end magic field fourbyte binary used delineate packet send bitcoin network since connecting testnet bitcoin node need use byte sequence specific testnet config bitcoinnetwork magic helper function doublehashes input return first four byte resulting hash def checksum payload checksum binary payload hash hash checksum end message module implementation everything need construct networkready version message protocolserialize message command version payload protocolserialize version version service fine repetition without let write function message module simplifies thing bit def serialize command payload protocolserialize message command command payload protocolserialize payload end protocol shine defined implementation every type structure send across network serialize passing without needing know type let use simpler interface generate networkready serialized version message messageserialize version version version service beautiful sending version constructed version message want send peer node left send callback node construct serialized message binary send peer node call helper function ok messageserialize version version version service timestamp ossystemtime second recvip ip recvport port fromip fromport nonce binarydecodeunsigned cryptostrongrandbytes useragent elixir rule startheight sendmessage socket function simply print message sent us send peer node provided socket defp sendmessage message socket printmessage message bright yellow gentcpsend socket message end lastly us previously implemented hexdump module print hex dump message sent defp printmessage data color output data hexdumptostring color n output n ioansiformat ioputs data end start application node genserver connect peer bitcoin node send version message inspecting sent version message processing response everything go well peer node receives initial version message send message response order receive response peer node implement callback node genserver listens tcp message process incoming binary unfortunately processing incoming tcp message sightly complicated seems tcp streaming protocol guarantee made single message delivered per packet entire message delivered single packet multiple message may arrive smooshed single packet single message may spread across multiple packet combination two might occur accommodate need build buffer every packet receive peer node parse full message running buffer completed use field called rest genserver state represent message buffer initially set callback ok state mapputnew socket socket mapputnew rest next add callback process incoming packet sent peer bitcoin node def handleinfo tcp port data state rest rest end process incoming message first prepend rest data received peer node pas binary data function called message rest chunk rest data helper function recursively par fullyformed message buffer return message along remaining unparsed binary defp chunk binary message case messageparse binary ok message rest chunk rest message message nil message binary end end function essentially opposite message module implementation given properly formed binary return fully populated message struct along unparsed trailing binary data def parse binary magic command binarysize size checksum payload binarysize size rest binary binary ok message magic magic command command binarybintolist enumreject binarylisttobin size size checksum checksum payload parsepayload command payload rest else nil end end message binary incomplete return nil function return accumulated list message list received message structs filter incorrect checksum using helper asynchronously cast rest processing message enumfilter enummap genservercast self finally return callback updating rest unused trailing binary data accumulated noreply state rest rest receiving verack got system place receive parse message sent peer node good position handle reply initial version message whenever bitcoin node receives version message send verack message response node process response parse verack message message struct command value verack asynchronously cast message need set callback listen def handlecast message command verack state bright got green verack reset bright log noreply state end receive verack message simply log received spin application see node connect peer node send version message receive verack response verack response receiving version way sent version message peer node peer node send version message node want confirm connection send back verack message reply like version message listen verack message adding new callback pattern matching commnand def handlecast message command version state ok messageserialize verack sendmessage statesocket ok messageserialize getaddr sendmessage statesocket noreply state end time rather logging received message two two thing first construct send verack message next send followup getaddr message instructs peer node send u peer connected neither verack message getaddr message contains actual content call simply set command message send empty payload receiving address finally peer node receives request address start sending back collection network address block wrapped addr message add callback listen message time pull binary payload parsed message struct def handlecast message command addr payload payload state end know payload represents addr message need write method bitcoinnetworkprotocoladdr module transform binary addr struct def parse binary ok varint value count rest varintparse binary ok addr count count addrlist binary binarysize rest ok netaddr rest netaddrparse binary netaddr end else nil end end first parse count variable integer message use binary list comprehension transform every thirty byte remaining binary network address structs finished return final addr struct fully populated count addrlist parse addr message sent peer node fulfill second goal back callback print many peer node received current peer node ok addr addrparse payload bright received green length addraddrlist reset bright peer log noreply state fire application node exchange versionverack handshake node ask list peer address getaddr message peer node respond one thousand known peer receiving peer address awesome staying alive accomplished second goal still completely satisfied first order node stay connected peer node need respond ping message prove still alive able receive message let add one last callback listen ping def handlecast message command ping state bright got green ping reset bright sending yellow pong reset bright log ok messageserialize pong sendmessage statesocket noreply state end familiar receive ping message peer log received message send empty pong message response bitcoin node stay connected peer node indefinitely responding occasional ping receiving occasional collection peer address final thought future work behemoth post hope idea technique simple enough follow along tried break thing splitting related topic prior article still quite bit ground cover get node running got several followup article planned near future including extending node map bitcoin network recursively connecting every node discovers distant plan building fully operational bitcoin node verifies incoming block potentially mine new block guessed yet incredibly excited project interested exploring bitcoin elixir let know
211,Lobsters,elixir,Elixir programming,What efficient pattern matching looks like at the bytecode level,https://dockyard.com/blog/2018/02/27/what-efficient-pattern-matching-looks-like-at-the-bytecode-level,efficient pattern matching look like bytecode level,intellij elixir beam chunk code tab map checking efficient pattern matching additional resource beam wisdom beam file format parser decompiler opcodes operation name genoptab,looking disassembled view module defmodule eextestwebuserview use eextestweb view end intellij elixir beam chunk code tab thought something wrong string inliner bsmatchstring call seemed missing prefix letter template name ormhtml instead formhtml ndexhtml instead indexhtml etc since bsmatchstring directly label looked back find jump came label selectval call label block selectval valuetolabel argument map integer label first saw thought number weird bitpacking bitstring match state looking ascii table matching label first character template name used selectval decimalcharlabelsuffix label jumped selectval match checking rest string match selectval generated label block group clause rendertemplate generated phoenixtemplatebeforecompile theory beam make pattern matching efficient general find prefix matched selectval corollary see selectval bytecode getting mostefficient pattern matching branching pattern check implemented separate bytecode instruction might make sense rearrange clause affect semantics see selectval pop generated bytecode sure compiler optimization pas enough prove clause rearranged get selectvals clause immediately next code written map bsmatchstring match suffix known template name keep referring label faillabel label give argument string instead check map argument looking elixir phoenixtemplate x used second argument two clause appear match order label label compiler using efficient istaggedtuple bytecode check module module template instead grab value gettupleelement iseqexact test istaggedtuple exists handle common either type ok value error reason record iseqexact appear label block check two template parameter line elixir code value since iseqexact allows left right operand mean repeating variable twice pattern probably requires additional bytecode operation check verified yet label block show map equivalent istaggedtuple check single map key value constant need get value register getmapelements test constant iseqexact wonder fused operation istaggedmap would make checking conn plugconn struct guard pattern faster also appears move compiler trace x already proved hold eextestwebuserview used moved x templateraisetemplatenotfound call code shown start x template x assigns x eextestwebuserview move source x destination x overwrite eextestwebuserview x template x assigns x assigns move source x destination x overwrites assigns x template x template x assigns move source eextestwebuserview destination x reloads eextestwebuserview litt literal table chunk x eextestwebuserview x template x assigns needed happen register rotation since bytecode operation done move eliminating reread litt would require using register x extra move long litt move cheaper register register move efficient checking efficient pattern matching want confirm compiler walking pattern match efficiently possible disassemble beam file check beginning function using selectval repeated usage variable pattern first stored separated register pairwise checked equality iseqexact although vm hundred x register call need argument starting x group move follow pattern match rearrange pattern register call argument position additional resource like learn beam format used beam wisdom beam file format guide development beam parser intellij elixir power decompiler beam chunk viewer shown screenshots opcodes operation name determined genoptab searching otp source code operation name
212,Lobsters,elixir,Elixir programming,Choosing Elixir's Phoenix to power a real-time Web UI,https://blog.wallaroolabs.com/2018/04/choosing-elixirs-phoenix-to-power-a-real-time-web-ui/,choosing elixir phoenix power realtime web ui,wallaroo hello wallaroo phoenix elixir deeper dive monitoring problem better performance phoenix channel transport channel utilizing phoenix channel million websocket connection flexible design channel tcp transport drawback phoenix channel benefiting elixir concurrency otp failing gracefully error handling elixir library let crash conclusion monitoring hub phoenix tcp transport,wallaroolabs working wallaroo highthroughput lowlatency elastic data processing framework nearly two year integral part development wallaroo application getting introspection performance characteristic several component application wallaroo application simplest form wallaroo application accepts incoming stream data process computation data optionally output result computation like much deeper dive wallaroo application structure suggest reading hello wallaroo blog post problem needed solve early deciding tooling would power metric monitoring system needed monitoring solution provide realtime update several step data message may take along way within wallaroo application looked various tool building metric monitoring system ultimately decided using phoenix modern web framework extension elixir tooling choice post take deeper dive monitoring problem phoenix elixir helped solve specific issue deeper dive monitoring problem provide context around problem needed solve want provide highlevel overview running wallaroo application monitored today currently running wallaroo application gather throughput latency metric component push call monitoring hub push instead poll ended choosing push metric gave u better performance important factor building highthroughput lowlatency application monitoring hub used intermediate step wallaroo application metric ui collect aggregate incoming metric message monitoring hub broadcast message listening client metric ui us information connected wallaroo application monitoring hub connect metric channel application display throughput latency metric information various component running wallaroo application diagram illustrate setup biggest problem needed address choosing tooling would allow u send receive message efficiently throughout architecture drove u phoenix channel abstraction phoenix channel phoenix channel based abstraction sending receiving message soft realtime sender broadcast message topic receiver subscribe topic get channel layered system transport layer channel layer others transport layer abstraction sits socket channel responsible handling incoming outgoing message client channel layer responsible communicating transport taking action incoming message biggest takeaway channel abstraction channel adhere specific protocol thus sender receiver anything implement communication via protocol utilizing phoenix channel ended utilizing phoenix channel communication layer wallaroo application monitoring hub metric ui metric topic exists handle incoming metric running wallaroo application application channel via subtopic metric channel responsible aggregating storing incoming metric message well creating new topic broadcast aggregated metric message aggregated metric message broadcasted via component channel component wallaroo application channel metric broadcasted via subtopic mapping component application name component name allows granular subscription wallaroo application metric channel listening client concurrency huge part happen thankfully elixir handle concurrency really well considering phoenix handle million websocket connection flexible design channel another key benefit channel flexibility design phoenix ship websocket longpolling transport layer channel provides api implemented add transport layer websockets perfect communication monitoring hub metric ui given industry standard realtime communication http provided little benefit communication wallaroo monitoring hub chose take advantage flexible design around transport layer create tcp transport communication wallaroo monitoring hub added bonus u able remove need http server within wallaroo handle metric message flexibility serializer channel also provided huge benefit u json default serialization option ended performance impact wallaroo switching binary protocol alleviated impact still able use json outgoing message metric ui additional benefit provided flexible design channel allowed u move forward quickly still maintaining functionality expected drawback phoenix channel although channel abstraction provided u lot benefit allowed quick development mention drawback run ended polluting shape outgoing metric message adhere protocol provided phoenix channel presented obviously sending message via json needed adhere following message structure topic metric myapp event metric payload ref null mean ever wanted send metric message another system work get work support one given time worst problem one know eventually address benefiting elixir would negligent u mention benefit gained phoenix written elixir familiar elixir dynamic functional language run erlang vm although immediately apparent first became invaluable pro choice phoenix concurrency since wallaroo designed highthroughput lowlatency framework metric monitoring system needed able handle many incoming metric message without becoming bottleneck impacting performance running wallaroo application due phoenix written elixir take full advantage otp framework set module standard designed help build concurrent application also utilizing otp along phoenix use otp able process store aggregate broadcast metric message without single process becoming bottleneck failing gracefully reasonable expectation something go wrong communicating system whether something like receiving completely wrong message message wrong format needed way handle type scenario without monitoring hub completely falling apart two scenario needed monitoring hub handle error expected error would cause thing crash dealing error expected wrong message type unprocessable message etc easy use okerror tuples guard scenario michal muskala wrote great blog post error handling elixir library want look technique used scenario technique allowed u move forward without processing message beyond point failure without causing halt rest incoming message scenario ran unexpected error felt best follow let crash motto erlang known helped ensure unexpected failure propagate way back socket level cause backup incoming message thus become bottleneck wallaroo conclusion end happy benefit provided phoenix elixir power metric monitoring system channel abstraction exceeded need allowed rapid development system monitoring hub phoenix tcp transport layer open source feel free take look codebases give feedback like
213,Lobsters,elixir,Elixir programming,Speed up data access in Elixir,https://medium.com/learn-elixir/speed-up-data-access-in-elixir-842617030514,speed data access elixir,speed data access elixir accessing map two time slower accessing keyword list time slower time slower time slower tuples benchmark repository github warning,speed data access elixirworking data structure straightforward predictable day erlang time getting exactly expectelixir different beast allows way work map list keyword list turn performancewise radically different othersfirst nice graph access time depending structure size come explanation raw data benchmarking code end articleaccess time structure size elementsaccess time structure size elementsaccessing mapsthere way access map elixir using pattern matching fastest key value mapmap foo bar foo foovalue mapusing pattern matching case function clause head fast using mapfetch slower mapfetch slower match value also creates extra tuplemap foo bar ok foovalue mapfetch map foo using access module much slower map foo bar foovalue map foo obscure nonintuitive behavior elixir coming programming language immediately recognize notion keyindex access probably use itin elixir allow much example addressing updating element map show next article come huge cost two time slower pattern matchingaccessing keyword listserlang elixir turn use list name tuples pas around option introduction map erlang feasible way data structure dynamic propertieskeywordlist foo bar compact formkeywordlist foo bar list accessing element requires scan find necessary element access speed n expected really use keyword list couple element using custom function speedup lookup fastest know keyword list using limited value may want faster lookup function get value keyword listdef kwlistaccess kwlist key defaultnil case kwlist h v v h v v h v v h v v keywordget kwlist key default endend using keywordget slow time slower using custom functionkeywordlist foo bar foovalue keywordget keywordlist fooyou also supply default value keywordget list foo default case key found list using access module slowest story map access module great provide extra functionality time slower compared custom function time slower compared keywordgetkeywordlist foo bar foovalue keywordlist foo tuplesi cover tuple access v map list article tuples blazingly fast little bit le flexiblehow benchmarkclone repository github runmix bench benchaccessvsmapfetchvsmatchexswarning using modern computer o constantly change processor speed order save energy keep cool quiet great every day work terrible benchmark running benchmark manually set processor fixed speed example debian instruction show current settingsgrep sysdevicessystemcpucpu cpufreqscalinggovernornumber test name mean much element tested structure uncomment line element mapkwlistetcbaseline function call without processing done see much function call cost benchfellamatch test key value lookup mapmapfetch call mapfetch map kwgetunroll manually unrolled function lookup keyword list element big switch keywordgetkwget call keywordget keyword listaccesskw kwlist index callaccessmap map index callso see least time slower manual know flaw microbenchmarks also optimization real code based input significant speed ups access module nice slow case map matching function head fastest
214,Lobsters,elixir,Elixir programming,Hex Dumping with Elixir,http://www.petecorey.com/blog/2018/04/09/hex-dumping-with-elixir/,hex dumping elixir,exploration bitcoin peertopeer network hex dump calling system elixir elixir way signal end data sending expected eof signal dragon erlang erlang solution major security issue going safe route erlang elixir final thought check github,recently written exploration bitcoin peertopeer network context elixir application exploration caused get upclose personal binary data serialize parse packet byte level visual person wanted way inspecting binary constructing sending decided hex dump would best way visualize packet followed odyssey finding implementing safe fast process printing hex dump arbitrary untrusted binary data within elixir application calling system first instinct implementing hex dump method within application implement made sense leverage existing hexdump command line utility living system specially wanted render packet hexdump c command c flag includes ascii rendering byte dumped version u unfortunately calling hexdump within elixir application proved challenging first expected trying call system command reflexively reach elixir function unfortunately hexdump relies input byte either stdin file let pas argument system command data stdin use build hex dump another option would write packet temporary file use instruct hexdump load dump byte file relying temporary file seems like poor choice logging utility would called hundred thousand time per minute work maybe use elixir port directly unfortunately pipe binary data directly hexdump using port way signal end data sending expected eof signal without signaling end byte stream closing port leave u without data show work dragon third option solving problem dig deeper tool belt pull big gun port limitation context erlang give u exactly need output echo binarybintolist data hexdump c oscmd use evaulate shell command including composition command strung together pipe redirections case command us echo pipe binary hexdump c function expects shell command form character list use erlang inject binary data directly echo argument however solution major security issue depending source data binary potentially giving outside source free reign run shell command machine considering hex dump intended log packet received external source bitcoin peertopeer network catastrophically bad idea need find another solution going safe route ultimately decided safest fastest solution problem simply build hex dump utility pure elixir general idea behind hexdump tool simple every line display current byte count hex followed two chunk eight byte rendered hex followed sixteen byte rendered together ascii character great chance flex elixir muscle let implement function within new hexdump module defmodule hexdump def tostring data isbinary data todo implement tostring end def tostring data kernelinspect data end want run hex dump algorithm binary data guard first function head isbinary guard data binary simply return result order work easily data binary let convert list byte chunk line sixteen byte data binarybintolist enumchunkevery want divide line sixteen byte two group eight fewer byte enough byte create second group append empty list fill place enummap enumchunkevery enummap fn b b end left list line within line list two eight byte grouping use index outer list calculate render many byte dumped far need attach list enumwithindex finally map line function transforms line tuple string join resulting list string newlines enummap enumjoin n function helper accepts tuple eight byte part current line index return string representation current line def linetostring part index end first job build current byte count hex byte count need padded least eight character count index kernel binaryencodeunsigned case lower stringpadleading next map eight byte part line render byte part hex converting binary using erlang rendering base sixteen elixir next join character part space pad result twenty three character using byte part enummap fn byte byte enummap fn byte byte binaryencodeunsigned case lower end enumjoin stringpadtrailing end ascii component line rendered similar way want divider middle ascii rendering flatten eight byte part map byte function convert printable string byte fall convert string otherwise return ascii part listflatten enummap fn byte case byte byte true byte false end end enumjoin flatten byte count two byte part ascii representation single list join together two character whitespace separating component count byte ascii listflatten enumjoin safely use new hexdump module safely quickly create hex dump string binary packet encountered application hexdumptostring ioputs version u final thought adventure moral story using tool resource available fantastic right situation said important always aware downside potential cost using existing solution sometimes rolling solution right choice case using command line version hexdump would horrendously insecure likely le performant implementing solution interested full source hexdump module created article check github
215,Lobsters,elixir,Elixir programming,benchee is now called bunny!,https://pragtob.wordpress.com/2018/04/01/benchee-is-now-called-bunny/,benchee called bunny,edit april fool joke bunny remain functional benchee bunny special day hexpm true courage eating food numerous occasion frequently occurring bunny picture gifs benchee pull request could hint personal look like,edit april fool joke however bunny remain functional implemented thing wrapper around benchee unless completely break api see coming remain functional continue reading cute bunny picture time benchee take next step evolution one prime benchmarking library going forward benchee called bunny al like naming change waited special day announce special naming change better day announce something named bunny easter sunday available hexpm think abstraction really going offer u flexibility going need future development approach wanted get api right true courage also exactly subtle dropping hint naming change coming described benchmarking bunny eating food numerous occasion bunny function try eat input fast frequently occurring bunny picture even gifs benchee pull request could hint also eating best yum yum like benchmarking bunny still work lot like benchee however expose better expressive api pleasure know bunny run like good old benchee bunny also sleep hop eat jump come personal bunny assistant help benchmark list enumtolist mapfun fn end bunnyeat flatmap fn enumflatmap list mapfun end mapflatten fn list enummap mapfun listflatten end tobi speedy githubbunny mix run sampleseatexs bunny take care operating system linux cpu information intel r core tm cpu number available core available memory gb elixir erlang benchmark suite executing following configuration warmup time parallel input none specified estimated total run time benchmarking benchmarking name ip average deviation median flatmap k μs μs μs mapflatten k μs μs μs comparison flatmap k mapflatten k slower bunny done hard work bunny need sleep bit though clearly better benchmarking library waiting go get bunny also look like like loading related
216,Lobsters,elixir,Elixir programming,Building Mixed Endian Binaries with Elixir,http://www.petecorey.com/blog/2018/03/19/building-mixed-endian-binaries-with-elixir/,building mixed endian binary elixir,bitcoin protocol reference client fantastic technical description protocol structure first attempt elixir default big endian byte order elixir binary special form faster second attempt set benchmark evadne wu using big little modifier modifier type final thought module,never much reason worry endianness binary data working elixir project part everything within application internally consistent everything pulled external source converted machine native ordering several layer abstraction tend work blissful ignorance came end found using elixir construct packet conforming bitcoin peertopeer network protocol bitcoin protocol bitcoin protocol tcpbased protocol used bitcoin node communicate peertopeer ad hoc network realworld specification protocol defined whatever reference client difficult tease code thankfully bitcoin wiki maintains fantastic technical description protocol structure used throughout protocol mishmash endianness wiki explains almost integer encoded little endian many field like checksum string network address port expected big endian netaddr structure excellent example endianness confusion time service expected little endian encoded port field expected big endian encoded build elixir first attempt first attempt constructing netaddr binary structure create netaddr function accepts time service ip port argument return binary final structure correct mixedendian order def netaddr time service ip port end manually constructing binary elixir default big endian byte order mean need convert time service little endian byte order adding final binary first attempt endian conversion create helper function would take binary transform list byte using binarybintolist reverse list byte transform back binary using binarylisttobin return result def reverse binary binary binarybintolist enumreverse binarylisttobin end could pas time service needed transform binary first thankfully easy elixir binary special form example convert time four byte bit big endian binary reverse create corresponding little endian representation reverse time using helper create final netaddr binary time reverse binary service reverse binary binarydecodeunsigned ip port work room improvement faster second attempt research discovered set benchmark several different technique reversing binary elixir thanks evadne wu realized could significantly improve performance packet construction process replacing slow listbased solution solution leverage optional endianness argument def reverse binary binary binarydecodeunsigned little binaryencodeunsigned big end improvement still happy solution using function meant transform number binary reversing ultimately concatenating final binary nested binary structure awkward confusing asking guidance twitter elixirlang account reached sage advice using big little modifier big little modifier binary special form modifier much like bitstring binary type used specify resulting endianness coercing integer float value binary example replace call reversing time service binary final binary concatenation simply appending big final size time service binarydecodeunsigned ip port awesome much easier understand elixir default big endian format manually constructed binary hurt explicit know ip port big endian encoded let mark way time service binarydecodeunsigned ip port beautiful final thought continually amazed quantity diversity quality tooling ship box elixir erlang even come something niche lowlevel binary manipulation elixir tool top notch want see complete example endian conversion code shown article check bitcoinnetworkprotocolnetaddr module new bitcoinnetwork project github
217,Lobsters,elixir,Elixir programming,Designing scalable application with Elixir: from umbrella project to distributed system,https://medium.com/matic-insurance/designing-scalable-application-with-elixir-from-umbrella-project-to-distributed-system-42f28c7e62f1,designing scalable application elixir umbrella project distributed system,umbrella project pro con time start worrying encapsulation end interface module end end scale distributed system rpc erlang distribution protocol fitmodel end end end modelsinterface node end test end rpc end end datasets true model true test modelsinterface true utils true espec test end distributed task false temporary oneforone end end end test end end datasetsinterface tasksupervisor datasetsinterface node end end datasetsinterface model protocol ok end erlang erlang cowboy plug espec test end match dispatch remote ok end end http limiting concurrency poolboy local poolboy oneforone end end ok end ok ok reply end end fitmodel end poolboy infinity poolboy end end conclusion,general three level code organization elixir project service level obvious way split complex system separate elixir application datasets model utils context level break responsibility inside particular service implementing context module datasetsfetchers datasetscollections implementation level particular module define datastructures function datasetsfetchersaws datasetsfetcherskaggle umbrella project pro consas mentioned main advantage using umbrella project code one place run together development test environment may play around whole system important write integration test test component altogether important early stage project development time project already split relatively independent part ready scalingcompare approach many programming language usually start monolith project try extract part separate application starting microservice approach tremendously complicates development processbut time start worrying encapsulation may noticed idea including apps main application dependency good right elixir language enough construction proper encapsulation module function public private add another project dependency module available call public function naive implementation zillow data fitting themain application look like defmodule mainzillow def rffit datasetsfetcherszillowdata utilspreprocessingnormalizedata modelsrffitmodel endendwhere datasetsfetchers utilspreprocessing modelsrf module different application freedom thoughtless using module another application couple service turn system back monolith two side still want part project accessible development test need somehow forbid crossapplication couplingthe way creating convention function one application may used another one best way extracting public function separate interface modulesinterface modulesinterfacesthe idea move public application function function called application separate module example datasets application special interface module fetchers function defmodule datasetsinterfacesfetchers alias datasetsfetchers defdelegate zillowdata fetchers defdelegate landsatdata fetchersendin simple implementation interface module delegate function call corresponding module future decided extract run datasets application another node module main part communication logicdoing application rewrite mainzillow module def rffit datasetsinterfacesfetcherszillowdata utilsinterfacespreprocessingnormalizedata modelsinterfacesrffitmodelendgenerally speaking convention want call function another application must interface modulethis approach still allows easy development testing creates set simple rule protect code tight coupling creates basis future scaling scale distributed systeminterface applicationsimagine data processing become timeconsuming decide run model separate node need remove model inumbrella true dependency run application another nodeif run elixir console iex mix main application folder access model application module anymore iex modelsinterfacesrffitmodel data undefinedfunctionerror function undefined module modelsinterfacesrf available code model application still inside umbrella project run main application accessible model module function exist another node run application onlybut know beam vm designed distributed application many way access code run another machine rpcit easy run function remote node using erlang rpc module rpc us erlang distribution protocol communication nodesone may reproduce simple experiment run themain project sname main option one terminal tabiex sname main mixand model project another tab iex sname model mixnow run calculation iex main rpccall model modelsinterfacesrf fitmodel data struct modelsrfcoefficient b data data change need make project utilize approach idea simple need add one application project implement communication logic modelsinterfacemodelsinterface config lib modelsinterface modelsinterfaceex lmex rfex mixexthis thin layer help main access modelsinterface function couple small module duplicate function interface module defmodule modelsinterfacerf def fitmodel data modelsinterfaceremotecall modelsinterfacesrf fitmodel data endendthis module call function implementation remotecall modelsinterface module defmodule modelsinterface def remotecall module fun args env mixenv doremotecall module fun args env end def remotenode applicationgetenv modelsinterface node end defp doremotecall module fun args test apply module fun args end defp doremotecall module fun args rpccall remotenode module fun args endendthe module get node location configuration remote procedure call might see environment specific implementation doremotecall allows simplify testing process discus laterthe next quick refactoring replace modelsinterfaces modelsinterface done forget add modelsinterface application dependency main applicationdefp deps datasets inumbrella true model inumbrella true test modelsinterface inumbrella true utils inumbrella true espec test endagain left model dependency test environment allows making direct call application test environmentthat able access model via iex console iex main modelsinterfacerffitmodel data struct modelsrfcoefficient b data data let summarize change new simple interfacing application still code one place still test passed distributed tasksdirect remote procedure call useful need simple synchronous interface another application want effectively run asynchronous code remote node better choose distributed taskselixir specific tasksupervisor used dynamically supervise task supervisor start inside remote application supervise task execute code let use distributed task accessing datasets application first need add tasksupervisor child datasets application supervisor defmodule datasetsapplication moduledoc false use application import supervisorspec def start type args child supervisor tasksupervisor name datasetstasksupervisor restart temporary shutdown opts strategy oneforone name datasetssupervisor supervisorstartlink child opts endendthe datasetsinterface module separate interfacing application defmodule datasetsinterface def spawntask module fun args env mixenv dospawntask module fun args env end defp dospawntask module fun args test apply module fun args end defp dospawntask module fun args tasksupervisorasync remotesupervisor module fun args taskawait end defp remotesupervisor applicationgetenv datasetsinterface tasksupervisor applicationgetenv datasetsinterface node endendso use asyncawait pattern difference task spawned remote node supervised remote supervisor name location supervisor set configuration file config datasetsinterface tasksupervisor datasetstasksupervisor node model trick test environment protocolsrpc distributed task builtin erlangelixir abstraction allow communicate using elixir term without additional serialization deserialization need communicate application written elixir need common approach http protocolas example let implement simple http interface utils application first thing need new utilsinterface application utilsinterface module similar structure modelsinterface look like defp doremotecall module fun args ok resp httpoisonpost remoteurl serialize module fun args deserialize respbody endfor example used simple erlang termtobinary binarytoterm serialization defp serialize term erlangtermtobinary term defp deserialize data erlangbinarytoterm data utils project need http server listen external request used cowboy plug thisdefp deps cowboy plug espec test endthe plug module responsible handling request defmodule utilsinterfacesplug use plugrouter plug match plug dispatch post remote ok body conn plugconnreadbody conn module fun args deserialize body result apply module fun args sendresp conn serialize result endendit deserializes module fun args tuple function call sends result back clientand forget start plug via cowboy server utils applicationchildren plugadapterscowboychildspec http utilsinterfacesplug port please note good practice call function directly deserialized data simplify example real world need sophisticated approach limiting concurrency poolboythe last feature wan na describe post allows protect application resource overflowing imagine example model application use quite lot memory model fitting want limit number client want access model application create limited pool worker process interface level using poolboy librarypoolboy need started byapplication supervisor defmodule modelsapplication use application def start type args pooloptions name local modelsinterface workermodule modelsinterfacesworker size maxoverflow child poolboychildspec modelsinterface pooloptions opts strategy oneforone name modelssupervisor supervisorstartlink child opts endendyou may see poolboy option name supervisor worker module size pool maxoverflowthe worker module simple genserver call corresponding function defmodule modelsinterfacesworker use genserver def startlink opts genserverstartlink module ok end def init ok ok def handlecall module fun args state result apply module fun args reply result state endendand last change modelsinterfacesrf module instead function delegation spawn worker process inside pool defmodule modelsinterfacesrf def fitmodel data withpoolboy modelsrf fitmodel data end def withpoolboy args worker poolboycheckout modelsinterface result genservercall worker args infinity poolboycheckin modelsinterface worker result endendthat absolutely sure model application handle limited number requestsconclusionas conclusion wan na give recommendation start microservices beginning easy elixir umbrella projectuse context implementation module organize logic inside applicationthink carefully application interface allow direct call implementation function applicationswhen scaling distributed system place communication logic separate application use erlang distribution protocol communication beam applicationsi hope approach abstraction described article help write better code elixir hit enjoyed article hesitate contact question proposal wonderful week anton
219,Lobsters,elixir,Elixir programming,Elixir Deployment Tools Update - February 2018,https://dockyard.com/blog/2018/02/28/elixir-deployment-tools-update-february-2018,elixir deployment tool update february,distillery quick recap erlang source code script script development v production tooling task ecto migration task ecto migrator api discover migration shell context api configuration system configuration file configuration file error crash dump load start perfect union release elixir core better error better documentation looking forward distillery tl dr,time since hired dockyard start working deployment tool pretty quiet finally remedy today giving look planned year expect tool future plan based part experience distillery discussion elixir core team well feedback community general really excited thing headed time finished reading update hope quick recap better understand headed useful know come deployment elixir project always degree confusion really two different way could choose deploy application either otp release form mix project source code believe latter acceptable option reproducible open production host additional attack vector worse throw huge part otp design want deployment reproducible require minimum amount resource dependency take full advantage feature provided u erlangotp release fundamental piece design otp ever take time read erlang source code see pervasive short mean intended package together otp application run single unit release build extend lowlevel tooling runtime boot manages otp application example script defines load boot application startup used within without release release handler provides script describes upgrade one version application another vice versa manually reload module without release handler blunt instrument comparison carefully structured appup process load new code also ensures running process transitioned new code organized fashion lowlevel tool work concert one another release handler even change version runtime used middle upgradedowngrade process important understand fundamental release dismiss dismiss experience effort went design otp stood test time general deploying otp release preferred community always easy choice new language told use distillery build release want deploy end encountering issue struggle understand went wrong fix end asking deploy source code use mix run nohalt mix phxserver particularly coming scripting language deploying source code norm absolutely valid reaction situation want tool work tool build release thirdparty library written someone know top integrate seamlessly feature language well surprise people choose easiest path core team realizes untenable afford kind fragmentation pain spread infect aspect language fact already happened degree look many variation configuring library based environment variable see impact let take look see major issue facing u plan solving development v production tooling opinion biggest issue consolidating community around otp release discrepancy thing done development thing done ready go production due part fact two main development task rely iex mix mix run mix phxserver phoenix application founded otp release instead mix start runtime kernel stdlib started dynamically load start application based project definition found mixexs chooses unified mix task infrastructure provided mean handle configuration via configexs since mix could inject configuration application environment starting application time suspect josé concerned whether release supported concerned making sure tooling powerful intuitive later friction became apparent task mix task work within release simple reason mix designed work context typical mix project directory structure well required mix project definition mixexs aspect mix api mixenv also meaningless context release instead distillery provides facility executing custom command example binmyapp migrate command might thin shell script like usrbinenv bash releaserootdirbinmyapp command elixirmyappreleasetasks migrate result invoked context code loaded none application started effectively equivalent mix task problem reuse example ecto migration task instead use ecto migrator api implement similar functionality know application start discover migration variety small difference ecto would already solved could use mix task also read distillery shell context api aware thing like releaserootdir environment variable question migration huge issue practice able use mix production certainly presented friction particularly want expose variety custom command interacting running application dev prod ultimately end hacking something together wrap mix task around module actually implementing task use task dev invoke module via custom command prod ideal configuration erlang project traditionally rely system configuration file sysconfig configuring runtime rarely configuring application config file static call function fetch value environment variable type dynamic configuration expected performed application code elixir came scene introduced configuration file configexs unlike sysconfig dynamic effectively elixir script limited code willing write mix taking care starting application dependency could evaluate config file ensure everything pushed application environment access via fundamental issue take account elixir application would work otp release mix project mix longer charge choosing boot application instead job init boot script instructs runtime load start application order wrote initial tooling release elixir saw little choice translate mix config file sysconfig reading build time writing resulting datastructure erlang term format decision several implication implicitly change semantics configexs runtime config file build time config file requires usage changed use mechanism numerous fragmented variant prevents fetching something environment transforming prior setting config worse creates rift development production surfaced time deploy production confusing many good reason error speaking confusion another area see room significant improvement error occur early boot process erlang vm start number thing elixir even loaded even elixir charge boot process runtime give idea mean let take quick look runtime boot regardless whether release mix project ert erlang runtime system emulator written c get point call first piece erlang code system code found module function handful module preloaded emulator system bootstrap simply call command line argument passed runtime init load core nifs zlib erltracer others par argument set boot option begin evaluate instruction found boot script default boot script found erlang distribution startboot startcleanboot release provide instruction application contains file simply binary containing erlang term list tuples containing instruction like load apply others init remains running entire life vm shutdown initiated eg via crashing application requires node crash module responsible handling error unrecoverable error result crash dump written termination process early boot script instruction load start applicationcontroller module sent message init load start application order specified boot script module handle error loading starting application well error application crash generally print information error crash bubble init application started specifically boot instruction processed boot process complete reason sometimes get really ugly undecipherable error crash occur error handled early boot process elixir intercept print nicer format furthermore handled level guaranteed even erlang standard library fully available hardly module relied phase program effort made pretty print error instead dumped standard output raw form ever seen init terminating doboot error something failed init produced unrecoverable error example application release missing error hit inside applicationcontroller init sends message load application application controller crash could find application needed load init receive exit message application controller determine unrecoverable error occurred error would expect able print friendly message currently vareity error pain point error occur perfect union elixir evolved point need close gap issue friction early development language acceptable stage core tooling like really need rock solid well integrated mean need ensure mix embrace release fully provides necessary api write tool work context mix project context release thing mostly transparent author library mix task etc better understanding problem let take look planning fix release elixir core remove awkward transition development production really need development tooling built release cover short run iex mix mix run effectively equivalent binmyapp console binmyapp foreground always running release transition made development production making command generate run release enough though want mix config file work development production took current version release work made work way time mix config file would lose usefulness luckily come solution beautiful simplicity also frustrating right front long missed leveraging instruction boot script mix evaluate config file action taken give u best world longer need translate sysconfig configexs retains runtime semantics across development production caveat configuration option still need done via vmargs example kernel config setting loaded started elixir small price pay able fully support mix configuration supporting mix task complicated issue likely solved first pas make mix understands release think huge leap get point define mix task work release fundamentally always subset mix task designed working within mix project directory alongside source code important provide clear delineation need mix project proper error produced one try invoke task wrong context something continue conversation core team get closer release better error question better deal error still open one exploring approach may work involve making possible inject custom behaviour init applicationcontroller potentially taking role entirely supporting custom init applicationcontroller module former definitely desirable want model easily extend customize behaviour early phase without reimplement really critical work bottom line think get point error either readable even better presented format native project eg elixir project get elixirformatted error data rather erlangformatted work require coordination cooperation otp team realize spoken number people see room improvement high hope find solution work well community large better documentation major issue beginner quality style documentation around release current doc cover vast majority question one may poorly organized contain duplication broken smaller topic easier find come new structure doc likely carried forward elixir guide release core tooling already started working hope end march doc completely reworked ground way make far friendlier beginner veteran alike looking forward initial version release tooling mix relatively simple comparison distillery support console foreground mode daemon mode support hot upgradesdowngrades likely limited extension point ie pluginshooks said plan bring thing back form another quickly possible question deal crosscompilation example building macbook deploying digital ocean vm running debian much still open intent provide much detailed doc get started properly preparing deployment like rely primary solution near future always looking way make process smoother nerve project benefit toolchain yet convinced carry well nonembedded project keeping mind open though always welcome feedback topic distillery distillery continue primary release tooling near future planning port change distillery namely mix configuration support said release part mix distillery rewritten build top tooling extend needed turn needed better ideally get release mix distillery deprecated focus attention single path forward tl dr care stuff want know major stroke mix extended ability generate otp release mix run iex mix command modified use otp release mix configuration ie configexs fully supported mix task may supported future likely something later phase may see better error node crash depends external factor expect much better richer documentation next month commitment made expecting initial release tooling made available part elixir continue provide update moving forward monthly basis feel free reach feedback may
220,Lobsters,elixir,Elixir programming,The curious case of the query that gets slower the fewer elements it affects,http://engineering.liefery.com/2018/02/27/the-mysterious-query.html,curious case query get slower fewer element affect,ecto elixir database tool default timeout second yikes problem database view take long first attempt benchee time slower boom happened feature time slower combined index rescue multiple column used replacement leftmost index saving loading comparing previous run full html report combined index fastest input million location location location location query plan one thing one important thing takeaway always benchmark variety input,wonderful berlin winter day year ago thinking nothing evil bugsnag popped complained elixirdbconnectionconnectionerror took look immediately find made wonderful application crash turned timeout error ecto elixir database tool default timeout second query took longer yikes happened story happened went wrong made sure fixed problem application looking courier tracker get gps location courier road make available admins look websockets one important part soon look shipment last known location displayed exception raised lastcourierlocation latestcourierlocation courierlocationwithcourierids courierid repoone could innocent line take long remember query took second execute basically resolve def withcourierids query courierids islist courierids location query locationcourierid courierids end instead straight id myid check check inclusion list list courierid elixir side latestcourierlocation hand database view created follows create replace view latestcourierlocations select distinct courierid courierlocations order courierid time desc said get latest location given courier easy enough take long quick debugging showed took long misbehaving client submitting location way frequent rate time courier around million location database quite lot nothing cause database take long probably also good time mention running postgresql along ecto postgrex first attempt ok let make faster got know let write benchmark benchmarking done productionlike database minus sensitive data result translate production environment use benchee alias couriertracker repo courierlocation latestcourierlocation require ectoquery courierid courier million location db bencheerun db view fn latestcourierlocation courierlocationwithcourierids courierid repoone timeout infinity end withcourierids fn courierlocationwithcourierids courierid ectoqueryorderby desc time ectoquerylimit repoone timeout infinity end full custom fn courierlocation ectoquerywhere courierid courierid ectoqueryorderby desc time ectoquerylimit repoone timeout infinity end time warmup formatters html file benchmarksreportslatestlocationsinglehtml defines variant want benchmark db view withcourierids full customer along code measured measure specific id causing error also define warmup period second measurement time second defined job also say want output console well html format allows png export benchmark say tobi liefy projectslieferycouriertracker mix run benchmarkslatestlocationnoinputexs operating system linux cpu information intel r core tm cpu number available core available memory gb elixir erlang benchmark suite executing following configuration warmup time parallel input none specified estimated total run time min benchmarking db view benchmarking full custom benchmarking withcourierids name ip average deviation median withcourierids m m m full custom m m m db view m m m comparison withcourierids full custom slower db view slower say lot thing first mention system benchmark run interested cpu elixir erlang right result say apparently withcourierids full custom rock db view time slower wow case solved using nice visual representation html report make even clearer displayed many iteration could per second average bigger better standard deviation seems sort high would normal worst case performance still m seem good enough let switch current implementation db view performant one benchmark withcourierids commit push merge roll pat back one best performance improvement ever call day boom deploy bugsnag error start rolling look dbconnectionerrors benchmarked happening time argue reality let rollback change investigate happened taking look log find new error happened courier requesting location location fairly fe happen feature turned courier use app ok let write new benchmark time use wider range input luckily benchee u covered input feature benchmarlslatestlocationexs file alias couriertracker repo courierlocation latestcourierlocation require ectoquery use id courier certain amount location db input big million location location location location bencheerun db view fn courierid latestcourierlocation courierlocationwithcourierids courierid repoone timeout infinity end withcourierids fn courierid courierlocationwithcourierids courierid ectoqueryorderby desc time ectoquerylimit repoone timeout infinity end full custom fn courierid courierlocation ectoquerywhere courierid courierid ectoqueryorderby desc time ectoquerylimit repoone timeout infinity end input input time warmup formatters html file benchmarksreportslatestlocationhtml spare output system metric etc time around let look result divided input input big million location name ip average deviation median withcourierids m m m full custom m m m db view m m m comparison withcourierids full custom slower db view slower input location name ip average deviation median db view withcourierids full custom comparison db view withcourierids slower full custom slower input location name ip average deviation median db view withcourierids full custom comparison db view withcourierids slower full custom slower input location name ip average deviation median db view withcourierids full custom comparison db view withcourierids slower full custom slower seems like db view faster alternative everything million location little bit location faster alternative time slower full custom withcourierids get slower fewer location respective courier find going let get respective query fire postgresql shell explain analyze basically asking postgresql query planner precisely want get data seeing might find missing index data model hurt u get sql query one possibility would generate use let use iex query courierlocation ectoquerywhere courierid ectoqueryorderby desc time ectoquerylimit ectoquery c couriertrackercourierlocation ccourierid orderby desc ctime limit iex string args ectoadapterssqltosql repo query select id courierid location time accuracy insertedat updatedat courierlocations courierid order time desc limit iex ioputs string select id courierid location time accuracy insertedat updatedat courierlocations courierid order time desc limit ok take string printed copy paste psql console let first check full custom reformatted readability couriertracker explain analyze select id courierid location time accuracy insertedat updatedat courierlocations courierid order time desc limit query plan limit actual index scan backward using courierlocationstimeindex courierlocations actual filter courierid row removed filter planning time m execution time m row tell u us index time efficiently order courier location time get recent one given courier work brilliantly recent one recent one still scan whole table realize explains full custom slower fewer location lower chance hit recent location given courier basically withcourierids much db view differently couriertracker explain analyze select id courierid location time insertedat updatedat latestcourierlocations courierid query plan unique actual sort actual sort key courierlocationscourierid courierlocations time desc sort method external merge disk bitmap heap scan courierlocations actual recheck cond courierid integer heap block bitmap index scan courierlocationscourieridindex actual index cond courierid integer planning time m execution time m row biggest time investment sorting time without index postgresql performs scanning done index courierid likely go back way defined database view sort cheaper fewer location affected find efficiently case explaining faster compared full custom friend solution attempt seem use either index courierid index time way combine combined index rescue define index multiple column importat limiting index leftmost one usually scope courier make courierid left let migrate database defmodule couriertrackerrepomigrationslonglivethecombinedindex use ectomigration def change drop index courierlocations courierid drop index courierlocations time create index courierlocations courierid time end end combined index basically used replacement leftmost index courierid learned want scan based time safe drop know improved old result could run benchmark compare could use benchee new feature introduced saving loading comparing previous run easy use add save tag path locationbenchee configuration run run migration save result run migration set load locationbenchee benchmark load compare old result well given enough plain text read one day let go image detail including histogram raw runtime graph interest feel free check full html report suffice say full custom combined index fastest input result migration combined index annotated million location location location location query plan query plan changed use combined index might ask well go full custom couriertracker explain analyze select id courierid location time accuracy insertedat updatedat courierlocations courierid order time desc limit query plan limit actual index scan backward using courierlocationscourieridtimeindex courierlocations actual index cond courierid planning time m execution time m row look much like previous query plan save changed index name however notice instead filter courierid say index cond courierid index kicking one thing know time wrap already one important thing add index etc always wise also benchmark time take insert record database simple benchmark alias couriertracker repo courierlocation validlocation courierid location geopoint coordinate time bencheerun inserting location fn changeset courierlocationchangeset courierlocation validlocation repoinsert changeset end load insertionbenchee save tag old path insertionbenchee result name ip average deviation median inserting location old m m m inserting location m m m comparison inserting location old inserting location slower sameish difference could easily explained deviation good takeaway journey teach u end always benchmark variety input even think input definitely worst case knowing algorithm system often interesting worst case result might surprise surprised obviously also noticed slow query earlier using application performance monitoring back many good tool application never caused u problem however great tool take trusty benchmarking tool remember input nice comfortable errm application
221,Lobsters,elixir,Elixir programming,How I rented a nice place to live using Elixir and a Facebook Messenger chat bot,https://medium.com/@DFilipeS/how-i-rented-a-nice-place-to-live-using-elixir-and-a-facebook-messenger-chat-bot-836f79498c5c,rented nice place live using elixir facebook messenger chat bot,putting plan motion crunching html day long floki httpoison pipe operator enummap javascript java map data structure quantum cronlike notation finally facebook messenger chat bot get request validate application creating validating application card message distillery,putting plan motionfirst step creating new project decided create phoenix project umbrella project umbrella elixir way organizing project different standalone module depend way pretty straightforward use part project application also neat way separating component application organized reusable easy understand modulesmix phxnew umbrella rentbotphoenix pretty cool give u ready use project everything need basic functionality web application receiving responding request database configuration unit test documentationcrunching html day longthe real work started decided start web scraping one classified advertisement website see much effort needed get metadata needfirst needed know could reliably get page advertisement filter search also could programatically navigate multiple page result search site turn generally make search filter page pagination url parameter way needed get url parameter filter wanted page could increment get resulthttps wwwrandomwebsitecomarrendarapartamentoporto search search needed process html page quick search html parsing library elixir found floki floki par given html allows search desired dom element using regular cs selector needed html parsing library floki still need get html pas library used popular httpoison library allows make http request elixirwith every tool needed needed write function make http request website wanted pas html response floki find element every advertisement page one element get metadata turn pretty simple power elixir available librariesit almost look like pseudocode elixir give incentive write small descriptive function allow everyone quickly understand basic logic application case creating function called import page number argument first line function creating string base url page number using awesome pipe operator first give url created function called getpagehtml know function implemented make pretty good guess function make http request get html page urlit turn two line code function return body request case html requested pagethe next function pipe getdomelements also looking function name guess function html parsed search target element match cs selector remember input function output previous function pipe operator getpagehtml function returned html pagehow cool parse get dom element need one line code last function pipe extractmetadata function guess process dom element found somehow extract metadatathis function look complex analyze turn much simple look receive list dom element previous function getdomelements function iterate list element elixir enummap function normal mapping function similar would find javascript java element list applying transformation creating new list transformed element transformation creation regular elixir map data structure title url price image url available name provider website data came see helper function field except provider another search desired information given dom elementand list house rent feel shit getting donethe beauty code far minor change element search dom everything else website want searchwith next step find way schedule task run regularly check new entry website another quick search elixir library task scheduling found quantum quantum allows schedule recurrent task using cronlike notationin configuration file created new task scheduler provider website wanted search advertisement task configured every five minute run function importads given module rendbotwebtasksxyz given argument list argument page number start search see even function pretty simple analyze start logging console notify start task call import function built specifying page number want search condition returned list function empty list stop process otherwise take return list give processentries function naming important make code readable looking code guess processentries function processing list return new list entry newand course map entry list pass entry insertentry function function take entry first query database see entry already return nil otherwise insert entry database return final step processentries function filter nil value listgoing back importads function see new entry list zero element call notifysubscribers function continue importing process next page result wait subscriber anyway finally facebook messenger chat botcreating facebook messenger bot pretty straightforward application need two endpoint endpoint receive get request validate application another endpoint receive post request message botcreating validating application facebook developer platform also pretty easy painlessthe validation endpoint pretty easy implement need random string choosing verification token facebook developer app setting put verification token asked validate application facebook send get request verification token parameter one parameter hubchallenge parameter endpoint return value parameter responseas everything else elixir pretty easy thatas see code snippet use pattern matching right function parameter get need given parameter first line function get verify token project configuration file using compare verify token sent request match respond challenge parameter value status code otherwise request unauthorized pretty neat left handle post request message incoming bot context application bot listening specific test register user subscriber way store unique id created user interacting bot use send message back timewe iterate entry entry list part request parameter message check text super secret string subscribes user platform match save senderpsid identifies user message ignored receive generic message responseso id user interested notification go back notifysubscribers function saw import functionagain simple iteration subscriber one send card message given ad detailsand boom complete system working daily batch new apartment rentthe next thing create release using distillery create docker image application set run machine aws two hour dinner day decided try something new
223,Lobsters,elixir,Elixir programming,"Partisan is a flexible, TCP-based membership system for Erlang/Elixir",https://github.com/lasp-lang/partisan,partisan flexible tcpbased membership system erlangelixir,partisan,partisan partisan flexible tcpbased membership system erlangelixir partisan feature single node testing facilitated disterl control channel figuring port peer service operating message sent via tcp connection maintained cluster member failure detection performed tcp connection verified gossip round configurable fanout join gossip performed immediately instead wait next gossip round hyparview implementation partisan many available peer service manager full membership tcpbased failure detection partisanpluggablepeerservicemanager clientserver topology partisanclientserverpeerservicemanager hyparview hybrid partial view membership protocol tcpbased failure detection partisanhyparviewpeerservicemanager static topology partisanstaticpeerservicemanager
224,Lobsters,elixir,Elixir programming,Elixir on Google Cloud Platform and App Engine,https://cloud.google.com/elixir/,elixir google cloud platform app engine,google app engine flexible environment elixir runtime elixir phoenix cloud sql begin google cloud platform console enable google cloud sql admin api cloud console google cloud sdk initialize node download elixir install create new app run locally create new phoenix app http create test development database http phoenix ecto guide create production database cloud sql create cloud sql instance connect cloud sql instance cloud sql proxy install cloud sql proxy note documentation create migrate production database access production database app engine documentation enable release note distillery deploy application github page update application cleaning deleting project warning deleting individual service app engine version page stop next step elixir sample app engine documentation kubernetes engine compute engine,google app engine flexible environment easy way deploy apps infrastructure power google product using open source elixir runtime app written elixir phoenix framework running app engine minute tutorial help get started deploying phoenix app app engine create new phoenix application learn configure deploy update application also demonstrate connect postgresql database running cloud sql tutorial requires elixir phoenix later assumes already familiar basic phoenix web development also requires postgresql database installed local development workstation tutorial updated january cover phoenix distillery connecting ecto cloud sql database updated july cover change elixir distillery begin running tutorial take following step use google cloud platform console create new gcp project enable billing project enable google cloud sql admin api cloud console install google cloud sdk make sure initialize sdk set default project new project created version later sdk required earlier version installed may upgrade running gcloud component update yet installed elixir phoenix install elixir nodejs macos homebrew run brew install elixir node otherwise consult node download elixir install guide operating system install hex phxnew archive mix localhex mix localrebar mix archiveinstall hex phxnew create new app run locally section create new phoenix app database make sure run locally development already app deploy may use instead create new phoenix app run phxnew task create new phoenix project called hello mix phxnew hello answer tool asks want fetch install dependency go directory new application cd hello update development database setting configdevexs specify valid database user credential may also update database name resulting configuration may look something like configure database config hello hellorepo username myname password xxxxxxxx database hellodev hostname localhost poolsize create development database following command mix ectocreate run app following command mix phxserver compiles server run port visit http see phoenix welcome screen running locally workstation create test development database next populate simple development database verify phoenix app access create simple schema mix phxgenschema user user name string email string migrate development database mix ectomigrate add simple code show application access database querying number user record open libhellowebcontrollerspagecontrollerex rewrite index function follows def index conn params count hellorepoaggregate hellouser count id conn assign count count render indexhtml end also display value count adding template libhellowebtemplatespageindexhtmleex recompile run app mix phxserver visit http verify new code running log database add new row reload page verify count changed information using ecto access sql database see phoenix ecto guide create production database cloud sql section create production database using cloud sql fullymanaged database service providing postgresql mysql cloud already database hosted elsewhere may skip section may need ensure production configuration set connect database create cloud sql instance first create new database cloud create cloud sql instance named hellodb postgres database running following command gcloud sql instance create hellodb may choose region one closer location get connection name cloud sql instance running following command gcloud sql instance describe hellodb output look connection name connectionname field connection name format projectid computezone hellodb refer connection name connectionname throughout tutorial secure new database instance setting password default postgres user gcloud sql user setpassword postgres instancehellodb promptforpassword prompted enter password database connect cloud sql instance section learn connect cloud sql instance local workstation generally need often useful initial creation migration database well creating ad hoc database connection maintenance default cloud sql instance secured connect using standard psql tool must whitelist ip address security measure make challenging establish ad hoc database connection cloud sql provides command line tool called cloud sql proxy tool communicates database instance secure api using cloud sdk credential open local endpoint unix socket psql connect set cloud sql proxy perform following step install cloud sql proxy make sure cloudsqlproxy executable available environment path create directory tmpcloudsql cloud sql proxy create database connection socket may put different location need update command accordingly mkdir p tmpcloudsql start proxy telling open socket directory created cloudsqlproxy dirtmpcloudsql note run proxy foreground subsequent command need run separate shell prefer feel free background process instead proxy open socket directory tmpcloudsql connectionname point psql socket connect database instance test psql h tmpcloudsql connectionname u postgres learn using cloud sql proxy connect instance documentation create migrate production database next configure phoenix app point production database instance tell ecto create migrate database start cloud sql proxy already running previous section cloudsqlproxy dirtmpcloudsql configure production database configuration communicate socket opened running cloud sql proxy edit configprodsecretexs file include something like configure database config hello hellorepo username postgres password xxxxxxxx database helloprod socketdir tmpcloudsql connectionname poolsize remember replace connectionname database connection name include password set postgres user hardcode secretkeybase configprodsecretexs real application might want create different mechanism inject database password secret key base file keep thing simple tutorial use phoenix create migrate production database mixenvprod mix ectocreate mixenvprod mix ectomigrate stop cloud sql proxy finished access production database app engine app engine runtime also run cloud sql proxy make database available via unix socket app engine environment located directory cloudsql root file system prepare app deployment app engine edit configprodsecretexs file modify socketdir database setting point correct location app engine socketdir cloudsql connectionname remember replace connectionname database connection name information connecting database app engine available documentation note need run another ecto migration open another psql session local workstation temporarily revert socketdir tmpcloudsql phoenix talk local cloud sql proxy make sure change back cloudsql deploy app engine alternatively ability create directory cloudsql local workstation configure cloud sql proxy open socket instead avoid need revert socketdir enable release release elixir community preferred way package elixir erlang application deployment configure app create deployable release note also use distillery tool create release app distillery configuration mechanism somewhat different provided elixir builtin release choose use distillery sure adjust step accordingly initialize release configuration running mix releaseinit create rel directory containing several configuration file template examine edit wish default sufficient tutorial using distillery later corresponding command mix distilleryinit configure release mixexs project configuration add release section project function look like def project app hello add section release hello includeerts true includeexecutablesfor unix application runtimetools permanent version additional field end using distillery information appear file relconfigexs instead default created distillery sufficient particular make sure includeerts set true elixir runtime assumes ert included release prepare phoenix configuration deployment editing prod config file configprodexs particular set server true ensure web server start supervision tree initialized set port honor port environment variable recommend following setting start config hello helloendpoint loadfromsystemenv true http port system port checkorigin false server true root cachestaticmanifest privstaticcachemanifestjson alternatively using elixir later provide information runtime configuration file configreleasesexs deploy application deploy new app app engine create file called appyaml root application directory following content env flex runtime g elixirruntimeelixiryaml runtimeconfig releaseapp hello betasettings cloudsqlinstances connectionname configuration selects elixir runtime open source app engine runtime know build elixir phoenix application find information runtime github page configuration also tell runtime build deploy distillery release application hello finally configuration also informs app engine want connect cloud sql instance remember substitute connection name connectionname app engine respond creating unix socket needed connect database run following command deploy app gcloud app deploy first time deployed app engine project gcloud prompt region generally good idea choose region database minimize latency elixir runtime take care building application cloud including installing mix dependency compiling beam file even using webpack brunch build asset deployment also take minute requisition configure needed resource especially first time deploy deploy command completed run gcloud app browse see app running production app engine update application let make simple change redeploy open front page template libhellowebtemplatespageindexhtmleex editor make change html template run deployment command gcloud app deploy app engine elixir runtime take care rebuilding app deploying updated version migrating traffic newly deployed version view change live running gcloud app browse cleaning finished tutorial clean resource created google cloud platform wo nt billed future clean resource delete project stop individual service deleting project easiest way eliminate billing delete project created tutorial using gcloud run gcloud project delete yourprojectid yourprojectid google cloud platform project id warning deleting project following consequence used existing project also delete work done project ca nt reuse project id deleted project created custom project id plan use future delete resource inside project instead ensures url use project id appspotcom url remain available deleting individual service tutorial created cloud sql instance deployed app engine service stop two service delete cloud sql instance including database host run gcloud sql instance delete hellodb generally completely delete app engine service however disable consume resource cloud platform console go app engine version page make sure project selected necessary pull project selection dropdown top choose project created tutorial deployed service default make sure selected service dropdown select version wish disable click stop top page free google compute engine resource used app engine service next step elixir sample repository contains growing set sample elixir application ready deploy google cloud example communicating google apis elixir see app engine documentation information app engine feature including scaling health check infrastructure customization also try tutorial deploying phoenix application kubernetes engine compute engine
225,Lobsters,elixir,Elixir programming,Surfing on Lava – Feedback control & tuning the BEAM VM,https://medium.com/@GrindrLabs/surfing-on-lava-a61124bf7c7,surfing lava feedback control tuning beam vm,surfing lava stack since last talked warning sign system go bad good figuring rootset singleblock carrier erlang anger ert manual moment truth mhsbct multiblock carrier takeaway,surfing lavahow feedback control tuning beam helped u weather meltdownpatching stormby rafal studnicki simon zelaznyour stackwe run several erlang elixir service grindr among geopresence service moved forward bit since last talked nowadays handling much trafficthe soft realtime property erlang vm allow u set high standard service term tail latency maximum depending operation type usually expect response time m monitor closelywarning signswhen tail latency response time rise normal stable state level usually good early indicator something going wrong systemin november experienced occurrence tail latency going much higher usual event seemed unrelated change client server code abated couple hoursfig november anomalously high tail latency mysteriously came went note logarithmic scale system go bad goodright christmas mysterious hiccup state become new normalas automated deployment freeze mode holiday season decided put faith selfregulating capability system deploy change manuallyfig bad timesthe call protected feedback control wrapper keep track response time recent call throttle input way maintain target figure mean even though something system slowing particular response large factor average response time kept check regulatorif average metric shot high regulator mechanism would refuse fraction inbound call average fell appropriate levelsfig price paid stability controlled rejection request loadshedding figuring outwith holiday behind u dived launched favorite beam inspection tool systemmonitor fig session systemmonitorif something ruining system softrealtime property likely revealed starting system monitor waiting couple second alert come inin abbreviated session got information longgc long garbage collection happening one type process phoenix tracker made u think something going data process storing stateprocess heap clocked around megabyte enough cause slowdown sheer amount copying done gc time additionally process message queue empty meant large message structure contributing rootsetthe tracker process differ significantly process system heap size also different process consistently using kilobyte memory per process heap size allocated using called singleblock carrier see erlang anger chapter ert manual mean erlang vm call operating system extra memory whenever need adjust tracker heapsthis gave u hint perhaps de allocating memory directly system taking longer time usual perhaps infrastructure work conducted underlying hardware stack cloud made big iron allthe moment truthwe working hypothesis reproduce symptom laboratory condition even simulating production traffic memory allocation slowness seemed occur production presence cluster last recourse actually put skin game deploy change production test assumption realworld conditionswe gave bumping singleblock carrier limit shot goal force garbage collection particular process reuse memory multiblock carrier allocated upfront vm instead singleblock carrier way garbage collection tracker heap would require calling operating system remain within userland codemhsbct singleblock carrier threshold kb absolute singleblock carrier shrink threshold scaled proportionally mhlmbcs largest multiblock carrier size scaled proportionally fig emulator flag vmargsthe result immediately visible form drop subscription processing time effectively bypassed linux kernel managing large tracker heapsfig drop tail response time reconfiguring memory allocator erlang vm note logarithmic scalethe cost improvement one could expect increase memory usage since multiblock carrier much larger memory block inside le efficiently utilized leading higher memory fragmentation case memory consumption went approximately definitely price pay reducing tail latency two order magnitudefig memory usage changetakeawaysthe cloud computing environment full uncertainty sometimes understand root cause sometimes system underlying complexity opacity work maintain secret case described could plausibly attribute instability meltdown spectre mitigation work amazon hard evidence hard procurewhat end crucial helping u power holiday season builtin load regulator based principle feedback control load regulator treat entire system black box measuring average response time make difference part stack slowing application code vm code network hardware itselfby treating whole system black box able maintain uptime reasonable responsiveness face instability unknown origin additionally access erlang great introspection tool systemmonitor foremost among gave u good hint look concrete mitigation step
226,Lobsters,elixir,Elixir programming,Elixir v1.6 released,https://elixir-lang.org/blog/2018/01/17/elixir-v1-6-0-released/,elixir released,code formatter code formatter new task already fully formatted dynamic supervisor module new module attribute elixir adopts elixir home page allowed guard le obvious error prone release introduces iex improvement elixir mix xref hexpm project better compiler diagnostics flag task count based flame based summing release note previously announced streamdata library feature scheduled found issue tracker install section getting started guide,elixir includes new feature enhancement bug fix main feature release code formatter important improvement also found standard library mix build tool code formatter big feature elixir addition code formatter accompanying mix format task add automatic formatting project goal formatter automate styling codebases unique consistent layout used across team whole community code easier write longer need concern formatting rule code also easier read longer need convert style developer mind formatter also help new developer learn language giving immediate feedback code structure eas code review allowing team focus business rule code quality rather code style automatically format codebase run new mix format task formatterexs file may added project root rudimentary formatter configuration mix task also support flag ci integration instance make build pull request fail code formatted accordingly using checkformatted flag also recommend developer check favorite editor see already provides key binding mix format allowing file code snippet formatted without hassle elixir codebase already fully formatted contribution expected contain formatted code recommend existing codebases formatted step formatter correctly handle long line complex expression refactoring code breaking variable smaller function format lead overall cleaner readable codebases dynamic supervisor supervisor elixir responsible starting shutting restarting child process thing go wrong interaction supervisor happens supervisor module provides three main strategy oneforone restforone oneforall however sometimes child supervisor known upfront rather started dynamically example building web server request handled separate supervised process case handled supervisor module special strategy called simpleoneforone unfortunately special strategy changed semantics supervisor regard initialization shutdown plus apis expected different input would completely unavailable depending supervision strategy elixir address issue introducing new dynamicsupervisor module encapsulates old simpleoneforone strategy apis proper module allowing documentation api supervisor module focus main use case separate dynamicsupervisor module also make simpler add new feature dynamic supervisor new maxchildren option limit maximum number child supervised dynamically deprecated since attribute release also introduces two new attribute associated function definition deprecated since former mark function macro deprecated latter annotates version api introduced doc break collection chunk since deprecated use instead def chunk collection chunksize chunkevery collection chunksize end mix xref task also updated warn project call deprecated code definition marked deprecated module invokes warning emitted compilation effectively provides library framework mechanism deprecate code without causing multiple warning printed runtime without impacting performance note attribute yet available tool generate documentation functionality added elixir elixir adopts still recommend developer start annotating apis information already available tooling updated defguard defguardp elixir provides concept guard expression used alongside pattern matching select matching clause let see example straight elixir home page def drive user age age age code drive car end user age age matching user struct age field age guard since handful construct allowed guard situation check age equal multiple place extracting guard separate function would le obvious error prone address issue release introduces defguard isoldtodrive age age def drive user age age isoldtodrive age code drive car end iex improvement iex also got share improvement new code formatter allows u pretty print code snippet type specification improving overall experience exploring code terminal autocomplete mechanism also got smarter able provide context autocompletion example typing enum hitting tab autocomplete type enum contrast function typing b genserver hitting tab autocomplete behaviour callback finally breakpoint functionality added elixir improved support pattern matching guard example pattern match function call first argument atom foo may iex break somefunctioncall foo information see iexbreak mix xref mix xref task added elixir provides general information module file application depend release brings many improvement xref extending reach analysis helping developer digest vast amount data produce one addition includesiblings option given xref command inside umbrella project example find caller given module function application umbrella mix xref caller somemodule includesiblings graph command mix xref also output general statistic graph hexpm project would get mix xref graph format stats tracked file node compile dependency edge structs dependency edge runtime dependency edge top file outgoing dependency testsupportfactoryex libhexpmaccountsuserex libhexpmaccountsauditlogex libhexpmwebcontrollersdashboardcontrollerex libhexpmrepositorypackageex libhexpmrepositoryreleasesex libhexpmrepositoryreleaseex libhexpmwebcontrollerspackagecontrollerex libmixtaskshexpmstatsex libhexpmrepositoryregistrybuilderex top file incoming dependency libhexpmwebwebex libhexpmwebrouterex libhexpmwebcontrollerscontrollerhelpersex libhexpmwebcontrollersauthhelpersex libhexpmwebviewsviewhelpersex libhexpmwebviewsiconsex libhexpmwebendpointex libhexpmectochangesetex libhexpmaccountsuserex libhexpmrepoex mix xref graph also got onlynodes label option former asks mix output file name node without edge latter allows focus certain relationship get file depend libfooex mix xref graph sink libfooex onlynodes get file depend libfooex compile time mix xref graph label compile sink libfooex onlynodes get file libfooex depends mix xref graph source libfooex onlynodes limit statistic compile time dependency mix xref graph format stats label compile improvement help developer better understand relationship file reveal potentially complex part system improvement mix include better compiler diagnostics editor integration support slowest n flag mix test show slowest test suite new mix profileeprof task provides time based profiling complementing existing mix profilecprof count based mix profilefprof flame based summing full list change available release note many exciting change compiler enhancement better track dependency leading le file recompiled whenever change project overall faster compilation work elixir already started still welcome developer try previously announced streamdata library aim bring data generation propertybased testing elixir feature scheduled found issue tracker forget check install section get elixir installed getting started guide learn
227,Lobsters,elixir,Elixir programming,LambdaConf 2018: Call for Proposals,https://lambdaconf2018.dryfta.com/en/abstract-submission,lambdaconf call proposal,,event website either suspended unavailable use visitor attendee please contact event organizer correct link website dryfta support team
228,Lobsters,elixir,Elixir programming,Quaff that potion: saving $millions with Elixir and Erlang,http://tech.adroll.com/blog/dev/2018/01/08/quaff-that-potion-saving-millions-with-elixir-and-erlang.html,quaff potion saving million elixir erlang,quaff potion saving million elixir erlang erlangotp realtime bidding platform amazon kinesis dynamodb stream flow elixir background realtime bidding doubleclick ad exchange taboola secondprice ad targeting largescale machine learning stored dynamodb retargeting upperfunnel profile data system overview original design new design dynamodb stream aggregator kinesis stream processor implementation scalability robustness correctness enough erlang kinesis client library languageagnostic interface erlang multilangdaemon interface new opensource library erlmld opensource erlang library kinesis dynamodb stream processing erlmld beyond good erlang new opensource library exmld opensource elixir library kinesis dynamodb stream processing exmld erlmld flow elixirerlang sample processing code exmld impact conclusion flow http githubcomadrollerlmld http githubcomadrollexmld enjoy working largescale system roll u,quaff potion saving million elixir erlang written mike watters january slashed dynamodb cost using kinesis dynamodb stream erlangotp elixir implement global cache warming system present system two new opensource library processing kinesis dynamodb stream similar way using elixir erlang minute read adroll us erlangotp basis several internal product including realtime bidding platform running amazon erlangotp king robust highlyconcurrent soft realtime system article describes substantially reduced cost element realtime bidding platform dynamodb usage implementing global cache warmer using kinesis dynamodb stream written erlang later doubled performance component adapting use flow framework author elixir also present two new opensource library kind processing using elixir andor erlang background realtime bidding publisher website mobile app author want monetize inventory sell ad space buyer done using variety mean one programmatic auction conducted behalf publisher advertising exchange clearinghouse publisher integrated doubleclick ad exchange taboola inventory programmatic auction multiple interested buyer much time buyer notified exchange integrated whenever opportunity buy ad space occurs adroll currently participates well one million programmatic auction per second substantial part day addition supporting high request volume buyer must also respond quickly typically le hence auction may occurring resource web page video etc process loading response may include bid price maximum price buyer willing pay particular ad space shown specific user barring special circumstance highest bidder win auction may display ad space paying amount determined dynamic auction often secondprice ad targeting order bid auction ad space buyer need able determine much value particular impression adroll able value impression specific user combining largescale machine learning keeping profile billion user generally cooky know web mobile app inventory maintain period time set targetable user visited adroll site opted tracking segment could something like visited n page placed item shopping looked brown purchased profile set segment along timestamps certain information stored dynamodb retargeting product allows adroll customer show ad user previously visited site along restriction example customer could show brown promotion thursday friday pm pacific time user san francisco previously added shopping cart purchase plus general promotion similar user anywhere california excluding san francisco upperfunnel product allows customer show ad new likely act similar way existing desirable converting user would otherwise reachable via across web social medium facebook opportunity buy ad space present associated opportunity identifier user would see ad auction using identifier look profile data find ad relevant advanced machine learning model price real time set possible bid using ad profile data system overview described dynamodb effective source truth advertising profile data work well unfortunately also expensive order meet lowlatency requirement need replicate profile data globally aws region operate due design constraint could limit replication subset profile data scheme dynamodb cost dominated write capacity cost multiplied number region use original design access profile data bidding system initially implemented straightforward setup like following replicated globally perspective work like readthrough cache diagram box left represent user profile update occur constantly throughout day update written various dynamodb table every region separate data processing pipeline bidder instance seek obtain profile check local cache reading dynamodb recent cached data found used otherwise instance read dynamodb cache data next time described eventually created similar system allowing removal usage dynamodb one region cutting dynamodb cost large degree new design dynamodb bidding source truth profile data found actually need read time data user interest made reside cache increasing cached item ttl course alone would lead stale data inaccurate user targeting bid pricing could longlived cache data user also kept date need consult dynamodb time devised solution support set large r cache exists region region constantly receives depending set master table single region kinesis dynamodb stream natural choice workload dynamodb stream aggregator dataagnostic aggregator component observes update occur set relevant dynamodb stream batch update together replicates kinesis stream target region formerly dynamodb table master region kinesis stream processor target region operates kinesis stream reader cache writer component update longlived item set cache realtime bidding system fall back reading table master region relatively slow rare operation data missing cache incomplete writing back local cache using ca operation ensure consistency allowed u keep conceptual design multiple involved system still realizing substantial saving tolerate slower source truth data accurately cached longlived case implementation chief among concern designing system correctness bad data make good bidding decision robustness system bad missing data scalability need handle arbitrary volume data secondarily speed also consideration successful scalable proofofconcept used python elected implement complete solution using erlang building expertise area also good fit general type problem scalability essence scalability able efficiently apply repeatable formula arbitrary load realm software system erlangotp make easy set robust building block otp system comprised sharedalmostnothing sequential blocking process easily importantly behavior easily understood process independence enables arbitrary horizontal scaling contrast example deferredpromises asynchronous callback model common environment cumbersome concurrency sharedstate thread bring issue robustness erlangotp promotes robust system design supervision tree make simpletounderstand control flow process behavior process always part greater whole stuff crash burn knowing part system designed ground appropriate failure mode appropriate failing process may restarted supervisor somewhere system try correctness syntax design promotes succinct functional expression program avoids unnecessary defensive programming le code written mean le code read understood later fewer place bug hide enough erlang ensure correct ordered processing data abstract away handling detail like work distribution instance failure elected use existing javabased kinesis client library provided amazon kcl provides jsonbased languageagnostic interface multilangdaemon allows kinesis processing dynamodb stream processing using adapter done language environment without writing java code unfortunately kclmultilangdaemon expects driver resulting processing system emits event processor reacts launch one processor executable per owned stream shard effect processing make simple processing code need efficiently process thousand shard across multiple stream launching thousand beam node would wasteful partly defeat purpose using erlang also wanted manage kcl process erlang multilangdaemon interface erlang system pretty good network server turned problem around creating adapter launch multilangdaemon whose worker subprocesses become lightweight network client erlang node stream processed erlang node launch multilangdaemon subprocess port program subprocess configured launch netcatlike program socat shard processing program simply map stdinstdout back port node listening stream thus owned shard mapped independent erlang process genstatem state machine single node process concerned handling single stream record time deciding periodically checkpoint result look like give benefit using kcl result processing application similar javabased kcl processing application work multiple thread execution within single vm without requiring user write java code allows simple shard processor like minimal example module noisyworker behavior erlmldworker export includelib erlmldincludeerlmldhrl record state shardid count initialize opaque shardid state state shardid shardid io format p initialized shard p pn self shardid ok state ready state ok state processrecord state shardid shardid count count state streamrecord sequencenumber sn record io format p p got record pn shardid count record case count true ok state state count checkpoint sequencenumber sn false ok state state count count end shutdown state shardid shardid count count reason io format p p shutting reason pn shardid count reason case reason terminate ok checkpoint ok end new opensource library erlmld created opensource erlang library kinesis dynamodb stream processing erlmld using multilangdaemon also includes support compressed kplstyle record aggregation additional behavior turned common pattern usage library accumulating batch record flushing periodically allows even simpler shard processor definition module noisyflusher behavior erlmldflusher export includelib erlmldincludeerlmldhrl record state shardid buf init shardid opaque state shardid shardid addrecord state buf buf length buf error full addrecord state buf buf state record token ok state state buf token record buf flush state shardid shardid buf buf state kind processedtokens record list unzip buf io format p processing batch pn shardid record timer sleep nstate state state buf ok nstate processedtokens processor build batch record processed backpressure mechanism exists ensure record supplied fast processor handle batch full processor instructed flush ie perform batch work take arbitrary amount time flushing processor return opaque token corresponding successfullyprocessed record allows system periodically checkpoint highest contiguous completed record stream worker dy new one come online steal lease work might repeated none lost beyond good erlang arrangement described scalable work well processperownedshard model mean concurrency limited number stream shard processing system core processing stream shard least half computing resource wasted unless take special measure make simple processing code simple use case turn scale processing independently stream shard preserving approximate ordered cookie inorder processing simple processing code especially helpful iobound task like new opensource library exmld created opensource elixir library kinesis dynamodb stream processing exmld build erlang library erlmld used elixir erlangbased processing system make use flow framework set mapreducestyle processing pipeline inside beam instead set worker process handle single shard data shard owned current node feed pipeline sends data downstream set reducer arbitrary number reducer consistently handle partition key space ie record key hashed distributed among reducer reducer always receive record key approximate order erlangbased system elixir flowbased processing pipeline using flow framework shard worker longer directly process record instead feed record set mapper extract zero item processed item associated key used distribute among set reducer actual processing work work completed worker originated record notified checkpoint make progress shard configuration allows reuse existing processing code minor modification greatly increased concurrency unrelated number stream shard owned current node use arbitrary number mapper reducer help u io bound task processing occur independently cookie seen ordering event generally preserved single cooky within single worker different cooky elixirerlang sample processing code complete example using erlang processing code new elixir library concept used keep track status event processing support stream checkpointing provide backpressure see exmld doc detail real application actual supervision tree would used organization code would also apply elixir processing application using library module exmldexample export record state count includelib erlmldincludeerlmldhrl result call item extracted record seen streamname streamregion run erlmldprivdownloadsh running download needed jar start streamregion affect kcl state table name appname yourerlangkclapplication streamname yourstreamname ok stage elixirexmldkinesisstage startlink flowspec stage stage extractitemsfn fun use first extracted item element reducer partition key partitionkey elem fun state end processfn fun flowopts ok flowworker elixirexmld startlink flowspec producerconfig recordprocessor erlmldbatchprocessor recordprocessordata flushermod elixirexmldkinesisworker flushermoddata stage stage flushintervalms checkpointintervalms watchdogtimeoutms description streamname streamregion oncheckpoint fun kclappname appname streamname streamname streamregion streamregion streamtype kinesis would normally set via app env listenip loopback listenport appsuffix undefined initialposition latest idletime metricslevel summary metricsdimensions operation failovertime ignoreunexpectedchildshards false workerid undefined maxrecords maxleasetheft shardsynctime ok producersup erlmldsup startlink producerconfig ok stage flowworker producersup oncheckpoint description shardid io format p checkpointed pn description shardid function normally return list item processed record using kplstyle aggregation supported erlmld return singleelement list due definition partitionkey return first element partition key use distributing work among reducer example us record partition key extractitems struct elixirexmldkinesisstageevent stage stage worker worker event struct elixirexmldkinesisworkerdatum streamrecord r value case r heartbeat x x heartbeat streamrecord partitionkey k k stage worker r end value function used flow reducer accepts extracted item reducer state return updated state needed processing processevent key value state count c state case value stage worker streamrecord sequencenumber sn notify upstream stage disposition processing originating worker make progress checkpoint real application would done batch work completed status would vary based processing outcome workermap worker struct elixirexmldkinesisworkerdisposition sequencenumber sn status ok ok elixirexmldkinesisstage disposition stage workermap work return updated state io format p processing p seen p n self key c timer sleep state state count c heartbeat heartbeat used prevent stall worker waiting processing happen disposition returned io format p ignoring heartbeat eventn self state end impact using new arrangement existing erlang code doubled performance system snapshot happened stream delay metric deployed elixir flowusing version application following service degradation erlangonly system fallen behind entered unhealthy behind tip state scaled maximum size recovering quickly elixirusing version deployed gauge performance recovery stream processing delay fell cliff elixirusing version running since conclusion using erlang elixir able implement scalable system cut dynamodb cost using elixir glue code enabling use flow framework doubled performance previously erlangonly system minor modification also opensourced code using process highvolume kinesis dynamodb stream data erlang elixir enjoyed working system elixir firmly toolbox use future http githubcomadrollerlmld http githubcomadrollexmld enjoy working largescale system roll u
229,Lobsters,elixir,Elixir programming,Spawnfest Retrospective (Beamcraft),http://technology.customink.com/blog/2018/01/06/spawnfest-retrospective/,spawnfest retrospective beamcraft,spawnfest retrospective spawnfest server classic minecraft server client protocol game server map server went well communication client go well map attempt one attempt two still perfect,spawnfest retrospective year participated spawnfest two day hackathon focused around beam virtual machine judging finished felt appropriate time reflect architecture process submission submission server classic minecraft written elixir unlike current version version minecraft limited feature set supporting chat placing block moving fluid simplistic protocol availability open source client seemed like perfect project two day contest server unlike ruby c java elixir actor based language actor based language communication across boundary happens via message passing instead function call roughly equivalent service oriented architecture replacing network boundary service memory communication pattern lead highly concurrent software requires different way thinking high level server submitted three kind actor client protocol game server map server ranch socket acceptor pool would spin instance client protocol manage connection server client instance decoded message client passed game server game server sent update back client game server kept track connected client ensuring change map chat message player connection disconnection seen everyone server finally map server kept track update game map went well communication client actor model nice use project helped cleanly separate encoding decoding logic provided process id make tracking connected client simple also helped u avoid concurrency issue traditional approach multithreading suffer actor connected client game server needed validate input correct send message client actor logic involving speaking protocol contained client actor made game server much cleaner since work construct binary separate game server logic also good way keep track connected client free since actor assigned process id actor run game server needed keep mapping username player id process id made implementing whisper chat command despawning logged player trivial whisper server map target player username pid send chat message along get despawning working player logged server take process id disconnecting player released player id back pool broadcasted despawn message rest connected client importantly using actor based concurrency removed cognitive burden associated traditional threading approach need manage mutexes deal deadlock thing focus message structure runtime took care rest go well map getting performant way representing map proved challenge little understanding built sent client think see minecraft classic map made block get sorted x z matrix unsigned bit integer byte matrix represents corresponds type block index position world data sent client matrix converted one dimensional array byte header number element array added gziped sent chunk byte client largest map block mean take memory map data store one byte per block also needed ability update arbitrary block meant treated binary would lot work access update single block overcome implemented two version erlang term storage based map issue attempt one erlang term storage ets really appealing way deal map update provides key value table contain arbitrary element multiple storage option provides constant lookup logarithmic lookup time block map stored tuple like x z blocktype could update quickly little overhead two issue approach large memory needed build array send client block map required table feel best since using malloced c could get fiftieth pressing issue building array map data send client default ets table unsorted set meant process building array load term table memory sort key correct order concatenate value new array send array client largest map size ended sorting concatenating item proved slow switching storage option provide appreciable speed boost another solution needed attempt two good night sleep bit googling decided add runlength encoding map internal structure helped tremendously performance size unfamiliar runlength encoding rle lossless form compression store consecutive element single value number repetition mean could become since map data lot consecutive element compressing row column rle mean save lot space cut amount sorting need memory instead storing x z blocktype use z xrowcompressed mean sort item decompress concatenate entire row time rle approach proved good enough given time constraint one made final submission still perfect quite proud able get done two day still feel like area could make better given time gameserver ended large taste feel would cleaner split tracking player passing player change around chat message currently use send pas message back client would intention revealing public api provided clientprotocol encapsulate behavior map built gzip stream read ets table current list binary gzip process performant unhappy way fluid work feel like want treated player like thing live inside simpleoneforone supervisor outside small issue area want correct contest enjoyable time big thanks brujo rest organizer judge sponsor putting wonderful event
230,Lobsters,elixir,Elixir programming,Fast Full-text Search with Ecto and PostgreSQL,http://nathanmlong.com/2018/01/fast-fulltext-search-with-ecto-and-postgresql/,fast fulltext search ecto postgresql,mealthycom support substring match understand plural ignore accent search tag support ranking honor user preference perform search quickly solr postgres fulltext search good enough fantastic chainable ecto query materialized view trigger elixir code database view work advance refreshing materialized view trigger possible improvement rob sullivan john mosesman update post reference one make improvement approach,recently built fulltext recipe search feature using ecto postgresql mealthycom try check quick demo video thought interesting enough write mealthy permission search feature replaced simpler one needed support substring match example bu find recipe like vegan butternut squash soup search could used globally filter user saved recipe typed search term would confusing typing bu filtered everything continuing type butternut made recipe reappear understand plural example search strawberry strawberry return result ignore accent example search v saute return result search tag example search glutenfree return recipe tagged gluten free whether recipe title includes word support ranking example searching strawberry recipe strawberry title shown recipe merely tagged strawberry one ingredient honor user preference example vegetarian user searching burger meaty result filtered leaving match like vegan black bean burger perform search quickly everybody like speed especially important search every keystroke use case performance hit adding updating recipe ok done infrequently always staff substring match easy simple ilike query recipe title would accentagnostic pluralizationagnostic multitable search recipe tag slightly harder discussed using something like solr already using postgresql primary data store fulltext search capability enough task kept u add another dependency nt already understand function like totsvector really read postgres fulltext search good enough fantastic post tutorial reference post assume know relevant postgresql function honoring user preference meant context performing fulltext search chainable ecto query query condition like must vegetarian could also applied word fulltext search function take ectoquery return modified one getting search working noticed rather slow speed added materialized view trigger update view necessary may better way cover end elixir code first let take look elixir code behind recipe search searching thai chicken site end calling recipesearchrun query thai chicken query base ectoquery need narrowing match term comment code defmodule recipesearch import ectoquery def run query searchstring run query normalize searchstring end defmacro matchingrecipeidsandranks searchstring quote fragment select recipesearchid id tsrank recipesearchdocument plaintotsquery unaccent rank recipesearch recipesearchdocument plaintotsquery unaccent recipesearchtitle ilike unquote searchstring unquote searchstring unquote searchstring end end defp run query query defp run query searchstring recipe query join idandrank matchingrecipeidsandranks searchstring idandrankid recipeid orderby desc idandrankrank end defp normalize searchstring searchstring stringdowncase stringreplace gluten free glutenfree stringreplace dairy free dairyfree stringreplace sugar free sugarfree stringreplace meatless nomeat stringreplace vegetarian nomeat stringreplace rn stringreplace rt stringreplace r stringtrim end end function normalizes search string involves typical thing like discarding extra white space well domainspecific thing like treating gluten free glutenfree join subquery macro build subquery search recipesearch view matching recipe return recipe id rank take care unaccenting term looking fulltext match view document column well running alternative ilike search title substring match build query plaintotsquery mean special character like ignored string like thai chicken becomes thai chicken word must match initially subquery return id matching recipe something like id subquery nt let make use subquery rank joining subquery allowed order subquery rank better match term could appear first database view subquery selects recipesearch view pull together information recipe tag show materialized view proved faster module know could regular view simply encapsulates building document searching created recipesearch migration code like execute create extension exists unaccent execute create materialized view recipesearch select recipesid id recipestitle title setweight totsvector unaccent recipestitle setweight totsvector unaccent coalesce stringagg tagsvalueslug b document recipe left join recipestags recipestagsrecipeid recipesid left join tag tagsid recipestagstagid group recipesid support fulltext search create index recipesearch document using gin support substring title match ilike execute create index recipesearchtitletrgmindex recipesearch using gin title gintrgmops support updating concurrently create uniqueindex recipesearch id essentially say create materialized view one row row recipe row join tag recipe one big string squish title tag together one document weighting title important tag search purpose add index speed search using materialized view mean work advance would otherwise done query time testing sped search would expect larger difference number recipe increase however materialized view downside must explicitly refreshed else search return outdated result refreshing materialized view debated refreshing recipesearch timer seemed wrong couple way first often reason refresh nothing changed wasted effort second something change like refresh happen immediately whenever timer go thought set using trigger tell database whenever recipe tag recipestags change recipessearch need refreshed ecto migration code execute create replace function refreshrecipesearch return trigger language plpgsql begin refresh materialized view concurrently recipesearch return null end execute create trigger refreshrecipesearch insert update delete truncate recipe statement execute procedure refreshrecipesearch execute create trigger refreshrecipesearch insert update delete truncate recipestags statement execute procedure refreshrecipesearch execute create trigger refreshrecipesearch insert update delete truncate tag statement execute procedure refreshrecipesearch possible improvement code seems work quite well remaining downside recalculating entire materialized view one row need change bit wasteful nt seem likely become problem anytime soon however rob sullivan way john mosesman suggested way fix instead materialized view make recipesearch regular table instead rebuilding whole thing recipe tag change update recipesearch row specific recipe need like idea keep mind next time build feature like update found post reference one make improvement approach
231,Lobsters,elixir,Elixir programming,More Elixir Code Quality Tools,http://blog.mattgauger.com/2017/12/29/more-elixir-code-quality-tools/,elixir code quality tool,elixir code quality tool andrew summer elixir code quality tool list dependency see outdated dependency bundleraudit alias mix task mix doc wrapping get touch,written matt gauger december elixir code quality tool elixir community fastmoving always new thing learn andrew summer wrote mention tool cover elixir code quality tool blog post last post mentioned erlang observer gui erlang observer run small native app chart thing like memory used beam process count supervisor tree wobserver run web app show kind information browser best add plug phoenix plugbased web apps lot information available explore also api integrate build reporting graphing around list dependency mix clojure used lein deps tree see tree dependency clojure elixir use mix apptree task see tree dependency current application example mix apptree annotatex elixir logger elixir runtimetools guardian output truncated see outdated dependency mix outdated dependency always make known following mailing list cf important rather tool notify new version dependency ruby use gem outdated bundler outdated even install tool like bundleraudit elixir use task mix output table colorcoding fully reproduce try alias mix task several reason use task alias one rename longer task name something shorter task often run combine two task one alias run order help build workflow repeat step necessary setup time documented excellent mix doc wrapping thanks andrew summer suggestion hope find useful missed get touch love hear
233,Lobsters,elixir,Elixir programming,Elixir 1.6.0-rc.0 released,https://github.com/elixir-lang/elixir/releases/tag/v1.6.0-rc.0,elixir released,reload reload,perform action time signed another tab window reload refresh session signed another tab window reload refresh session
234,Lobsters,elixir,Elixir programming,Announcing Jason: a blazing fast JSON parser and generator in pure Elixir,https://elixirforum.com/t/announcing-jason-a-blazing-fast-json-parser-and-generator-in-pure-elixir/11030,announcing jason blazing fast json parser generator pure elixir,,two problem hipe one switching hipe beam expensive hipe generally much le tested developed outside otp team sometimes stability problem issue primarily many discourage use hipe said compiled hipe property test jason pas without issue certain hit bug going back first problem hipe long staying within hipe code fine switching beam hipe calling module compiled hipe hipecompiled module requires shuffling register serialising state expensive design jason compile main module hipe minimal amount switch especially true parser never switch jasondecoder module end final result efficient encoder call protocol nonstandard data type switch backandforth would occur really played could make sure encoder compiled hipe derived protocol implementation well mostly alleviate issue looked making hipe compilation easy option right definitely table could go something similar poison config jason nativedecoder true nativeencoder true combined config jason native true
235,Lobsters,elixir,Elixir programming,Elixir. Multiple processes. Basics.,http://whatdidilearn.info/2017/12/17/elixir-multiple-processes-basics.html,elixir multiple process basic,concurrency process use process basic functionality spawn process p id sending receiving message linking process keeping state previous article pull request wrapping,time go deeper get familiar concurrent programming elixir meet process learn need work concurrency concurrency ability execute several part instance program time way several application running time computer develop application run task concurrent way way instance running application also process said application consists process concurrency considered difficult topic programming language much simpler elixir process wikipedia page say computing process instance computer program executed contains program code current activity depending operating system o process may made multiple thread execution execute instruction concurrently thread process difference though long story short process share resource thread thread also subset process elixir concurrency based actor model mean process share data send receive message pretty much unlike programming language process elixir managed erlang vm make lightweight easy run thousand time use process elixir like many functional language stateless nature variable immutable order keep state somehow requires passing value function chain function together take web request example see roughly describe following stateless nature well user visit page browser sends request server server required stuff like querying database preparing view etc render page back user user open new page process starting case state kept database cooky etc different type application multiplayer game chat apps complicated keep state database place alike process become handy case thus use process need split work parallel want keep state process also communicate sending receiving message let take look work process elixir basic functionality let get simple hello world application generate running mix new helloworld tiny change application contains following function defmodule helloworld def hello ioputs hello world end end function print hello world screen helloworldhello hello world ok let try run separate process spawn process spawn new process function difference first function receives anonymous function argument second function receives module name function name atom list function argument iex spawn helloworld hello hello world pid iex spawn fn helloworldhello end hello world pid see function called got process identifier back mentioned process communicate using message sending receiving message let try send message one process process receive message send new message back first need update function start listening new message defmodule helloworld def hello receive pid name send pid ok hello name end end end use receive listening message use send message back receives destination first argument pid case message content second argument message type case using tuple easily match later guess also considered best practice elixir let fire interactive elixir check iex pid spawn helloworld hello pid iex send pid self message pid message iex receive ok msg msg end hello message first step spawning new process capture pid send message process passing pid calling process name case calling process iex pas pid iex session soon sent u message back need receive message great without leaving iex let try send second message iex send pid self second message pid second message iex receive ok msg msg end got handing iex session send message first time receives exit one respond second message fix behavior setting timeout receive specify timeout section iex pid spawn helloworld hello pid iex send pid self first message pid first message iex receive ok msg msg end hello process iex send pid self second message pid second message iex receive ok msg msg time end time first message received second message specify timeout one second got time message back one second cool least hanging anymore still want hello function handle multiple message would probably listen message defmodule helloworld def hello receive pid name send pid ok hello name hello end end end recursion friend received message respond back call hello function iex pid spawn helloworld hello pid iex send pid self first message pid first message iex receive ok msg msg end hello first message iex send pid self second message pid second message iex receive ok msg msg end hello second message iex send pid self third message pid third message iex receive ok msg msg end hello third message linking process let try break process sending unexpected result hello function function expect receive anonymous function iex self pid iex pid spawn helloworld hello pid iex send pid self fn error end pid function error process pid raised exception iex send pid self error pid error iex receive ok msg msg response end response iex self pid first call self capture pid parent process iex case spawn process usual pas anonymous function name result spawned process dy try send message process respond back call self one time show parent process want process know problem link using spawnlink function let take look following example iex self pid iex pid spawnlink helloworld hello pid iex send pid self fn error end error process pid raised exception interactive elixir press ctrlc exit type h enter help iex self pid iex pid compileerror undefined function time make process crash see linked parent process restarted see different pid process started keeping state beginning also mentioned use process keep sort state let get toy robot previous article apply knowledge get make stateful robot defmodule toyrobotstatefulrobot alias toyrobotstatefulrobot def place ok state toyrobotplace pid spawnlink fn listen state end processregister pid statefulrobot pid end def listen state receive report pid send pid state listen state move toyrobotmove state listen left toyrobotleft state listen right toyrobotright state listen end end def move send statefulrobot move def left send statefulrobot left def right send statefulrobot right def report send statefulrobot report self receive state toyrobotreport state end end end place robot capture position spawn new process using listen function function listens new message give order robot based message call passing updated position movement function send new message time report function sends message process receives back answer answer contains current position robot iex alias toyrobotstatefulrobot robot iex robotplace iex robotmove iex robotright iex robotmove iex robotmove iex robotmove iex robotreport east complete change find pull request github page wrapping know concurrency subject scary one always trying avoid elixir look like anymore see simple course beginning concurrency path see interesting stuff subsequent article
236,Lobsters,elixir,Elixir programming,All repos from spawnfest 2017 are public now,https://goo.gl/RfaLwJ,repos spawnfest public,search help section basic search repository search code search issue search user search,github search support variety different operation quick cheat sheet common search information visit search help section basic search search find repository cat star find cat repository greater star user defunkt get repository user defunkt tom location san francisco ca find tom user san francisco ca join extension coffee find instance join code coffee extension cat excludes result containing cat repository search repository search look project access github also filter result search find repository cat star find cat repository greater star user defunkt get repository user defunkt pug pushed pug repository pushed since jan nodejs fork find nodejs repository le fork jquery find jquery repository size kb gitx fork true repository search includes fork gitx gitx fork repository search return fork gitx code search code search look file hosted github also filter result search find repository install repo charlesprivaterepo find instance install code repository charlesprivaterepo shogun user heroku find reference shogun public heroku repository join extension coffee find instance join code coffee extension system size find instance system code file size greater example path doc find example path doc replace fork true search replace source code fork issue search issue search look issue pull request github also filter result search find encoding user heroku encoding issue across heroku organization cat open find cat issue open strange comment issue comment hard label bug hard issue labeled bug author mojombo issue authored mojombo mention tpope issue mentioning tpope assignee rtomayko issue assigned rtomayko exception created created since beginning exception updated last updated user search user search find user account github also filter result search find repository fullname linus torvalds find user full name linus torvalds tom location san francisco ca find tom user san francisco ca chris find chris user follower ryan repos find ryan user repository
237,Lobsters,elixir,Elixir programming,spawnfest/beam-craft -- Minecraft Classic server in Elixir,https://github.com/spawnfest/beam-craft,spawnfestbeamcraft minecraft classic server elixir,beamcraft introduction classicsharp client running server running client window classicsharp website mac o x linux classicsharp website wine useful link,beamcraft lobster introduction simple minecraft classic server written elixir compatable classicsharp client current test server live minecraftburnwillowsnet running server git clone http githubcomspawnfestbeamcraft cd beamcraft mix depsget mix run nohalt default server start port listens running client window use window release provided classicsharp website mac o x linux use mac o x linux release provided classicsharp website wine get asset first run launcher invoke client directly like wine classicalsharpexe username password ip port useful link
238,Lobsters,elixir,Elixir programming,Phoenix WebSockets Under a Microscope,https://zorbash.com/post/phoenix-websockets-under-a-microscope/,phoenix websockets microscope,phoenix previous post ruby microscope pat shaughenessy websockets rfc number generator application brunch phoenix phoenixpresence connecting websockets terminal wsta installation release page wsta wsta phoenixtransportswebsocket difference phoenixchannel documentation phoenix websocket wiring ranch cowboywebsocket ranchconnssup ranchlistenersup phoenix cowboy cowboy ranch cowlib parsing code announcement talk phoenixpubsub phoenixpubsub presence subscribing link link link publishing link link link link link link link link phoenix cowboy link link link gentcp phoenixendpointcowboywebsocket link link link subscribing debugging websockets essential recon recon conclusion submit pull request,codereading exploration post websockets side phoenix build upon tracing technique showcased previous post observe internals phoenix also feature trick commonly employ debug websocket related issue title nature post inspired marvellous book ruby microscope written pat shaughenessy websockets websocket protocol enables twoway communication client running untrusted code controlled environment remote host optedin communication code goal technology provide mechanism browserbased application need twoway communication server rely opening multiple http connection eg using xmlhttprequest iframe long polling conceptually websocket really layer top tcp following add web originbased security model browser add addressing protocol naming mechanism support multiple service one port multiple host name one ip address layer framing mechanism top tcp get back ip packet mechanism tcp built without length limit includes additional closing handshake inband designed work presence proxy intermediary source rfc one radical element phoenix ease productivity brings developing websocket application start creating simple application dive aspect phoenix understand inner working number generator application quickly build sample application start exploration leveraging excellent scaffolding task phoenix start exploration sample application assigns random integer connected client stream number socket preconfigured interval mix archiveinstall http githubcomphoenixframeworkarchivesrawmasterphoenixnewez mix phoenixnew number nobrunch noecto nobrunch option skip generating brunch related scaffolding none example require javascript noecto skip database related configuration module phoenix used example post design phoenix channel abstraction sending receiving message topic phoenixtransportswebsocket default transport mechanism others available even write may read documentation channel let code first channel creating webchannelsintegerschannelsex defmodule numbersintegerschannel use numbersweb channel def join number type params socket type w positive negative type type stringtoexistingatom socket socket assign number number type assign joinedat naivedatetimeutcnow send self update type ok socket end end def handleinfo update type socket socket pushupdate type defp pushupdate socket type processsendafter self update type push socket update number number type noreply socket end defp number positive erlanguniqueinteger positive defp number negative number positive end update webchannelsusersocketex file route channel defined defmodule numbersusersocket use phoenixsocket channel channel number numbersintegerschannel transport transport websocket phoenixtransportswebsocket def connect params socket ok socket end def id socket nil end two topic defined number positive streaming positive number number negative negative one may notice assigning joinedat attribute client convention come handy calculate long client connected realtime joinleave tracking phoenixpresence preferred start application using iex mix phoenixserver connecting websockets terminal server running initiate connection using wsta cli tool written rust follows unix philosophy letting pipe stream script file installation debian echo deb http downloadopensuseorgrepositorieshome etcaptsourceslistdwstalist aptget update aptget install wsta mac o x brew tap esphenwsta http githubcomesphenwstagit brew install wsta window ensure command prompt gnu library example git prompt run provided binary file find binary release release page wsta installed connect positive number topic using wsta w topic number positive event phxjoin payload ref output look like connected w topic number positive ref payload status ok response event phxreply topic number positive ref null payload number event update topic number positive ref null payload number event update topic number positive ref null payload number event update negative one wsta w topic number negative event phxjoin payload ref output look like connected w topic number negative ref payload status ok response event phxreply topic number negative ref null payload number event update topic number negative ref null payload number event update topic number negative ref null payload number event update notice wsta print disconnected stop streaming number around minute due default phoenixtransportswebsocket timeout configuration specifies timeout keeping websocket connection open last received data default make easier interact websockets development may set infinity difference may read phoenixchannel documentation function used send data connected client subtle difference broadcast event current subscriber broadcast event current subscriber given topic broadcast event subscriber given topic nt want use interested send update single client use instead phoenix websocket wiring supervision tree application following changed number ranch http acceptor process reduce clutter using following configconfigexs config number numbersendpoint url host localhost http acceptor secretkeybase somethingsecret rendererrors view numberserrorview accepts w html json pubsub name numberspubsub adapter connected websocket client supervision tree look like genserver hold socket assigns client created loop cowboywebsocket monitored cowboywebsocket handler turn spawned ranchconnssup supervised ranchlistenersup wildwest themed application module come socket push manage reach client following passage unravel important function call take place websocket connection established message pushed server client find hard catch why hows function call nt fret skip phoenix cowboy section cowboy default web server phoenix depends ranch handle tcp connection cowlib http protocol parsing utility function http parsing code cowlib especially interesting demonstration achieved using patternmatching â cowboy recently released support lot exciting change see announcement talk phoenix support way see code reference show phoenix us cowboy respond httphttps request phoenixpubsub phoenixpubsub application dependency phoenix handling distributed pubsub messaging presence order understand essential thing tied together trace framework data flow example client connects channel server message number broadcasted connected client take deep breath let probe â phoenix find go hood message reach recipient subscribing client join channel called build phoenixsocket pubsubserver set configured name pubsub setting endpoint sample application default numberspubsub signature connect endpoint handler transportname transport serializer params actual argument connect numbersendpoint numbersusersocket websocket phoenixtransportswebsocket phoenixtransportswebsocketserializer call following argument connect phoenixsocket assigns channel nil channelpid nil endpoint numbersendpoint handler numbersusersocket id nil joined false pubsubserver numberspubsub ref nil serializer phoenixtransportswebsocketserializer topic nil transport phoenixtransportswebsocket transportname websocket transportpid cowboywebsocket process phoenixchannelserver process started file libphoenixchannelserverex link defmodule phoenixchannelserver use genserver def join socket authpayload phoenixendpointinstrument socket phoenixchanneljoin params authpayload socket socket fn ref makeref phoenixchannelserver started case genserverstartlink module socket authpayload self ref ok pid receive ref reply ok reply pid ignore receive ref reply error reply error reason loggererror fn exceptionformatexit reason end error reason join crashed end end end def init socket authpayload parent ref socket socket channelpid self socketchannel numbersintegerschannel case socketchanneljoin sockettopic authpayload socket ok socket join socket parent ref ok reply socket join socket reply parent ref error reply send parent ref reply ignore error handling omitted end end defp join socket reply parent ref pubsubsubscribe socketpubsubserver sockettopic link true fastlane sockettransportpid socketserializer socketchannelintercepts send parent ref reply ok socket joined true end end called argument signature join socket authpayload actual argument join phoenixsocket assigns channel numbersintegerschannel channelpid nil endpoint numbersendpoint handler numbersusersocket id nil joined false pubsubserver numberspubsub ref nil serializer phoenixtransportswebsocketserializer topic transport phoenixtransportswebsocket transportname websocket transportpid callback invoked argument signature init socket authpayload parent ref actual argument init phoenixsocket assigns channel numbersintegerschannel channelpid nil endpoint numbersendpoint handler numbersusersocket id nil joined false pubsubserver numberspubsub ref nil serializer phoenixtransportswebsocketserializer topic transport phoenixtransportswebsocket transportname websocket transportpid ref call call argument signature subscribe server topic opts actual argument subscribe numberspubsub link true fastlane phoenixtransportswebsocketserializer file libphoenixpubsubex link defmodule phoenixpubsub def subscribe server topic opts isatom server isbinary topic islist opts call server subscribe self topic opts end subscription called server numberspubsub kind subscribe defp call server kind args kind module head etslookup server kind etslookup numberspubsub subscribe apply module kind head args end end numberspubsub named ets table following entry subscribe subscribe phoenixpubsublocal numberspubsub apply module kind head args case call file libphoenixpubsublocalex link defmodule phoenixpubsublocal called subscribe numberspubsub link true fastlane phoenixtransportswebsocketserializer also default poolsize def subscribe pubsubserver poolsize pid topic opts isatom pubsubserver local gc pid poolsize poolsforshard pubsubserver ok genservercall local monitor pid opts true etsinsert gc pid topic etsinsert true etsinsert local topic pid opts fastlane etsinsert phoenixtransportswebsocketserializer ok end end ended new entry table hopefully become clear post used done subscription part moving broadcast publishing one channel following example defmodule numbersintegerschannel use numbersweb channel def join number type params socket send self update type ok socket end end def handleinfo update socket broadcast connected client broadcast socket update number noreply socket end end called file libphoenixchannelserver link defmodule phoenixchannelserver called argument broadcast numberspubsub update number def broadcast pubsubserver topic event payload isbinary topic isbinary event ismap payload pubsubbroadcast pubsubserver topic broadcast topic topic event event payload payload end end call file libphoenixpubsubex link defmodule phoenixpubsub def broadcast server topic message isatom server istuple server call server broadcast none topic message defp call server kind args kind module head etslookup server kind apply module kind head args end end sample application following entry etslookup numberspubsub broadcast broadcast phoenixchannelserver numberspubsub apply module kind head args case call file link defmodule called broadcast phoenixchannelserver numberspubsub none phoenixsocketbroadcast event update payload number topic def broadcast fastlane servername poolsize frompid topic msg servername getmembers return numberspubsub registered process dobroadcast fastlane servername poolsize frompid topic msg end defp dobroadcast pid fastlane servername poolsize frompid topic msg islist pid localnode phoenixpubsubnodename servername enumeach pid fn pid ispid pid node pid node localbroadcast fastlane servername poolsize frompid topic msg servername nodename nodename localnode next called localbroadcast fastlane servername poolsize frompid topic msg pidortuple send pidortuple forwardtolocal fastlane frompid topic msg end ok end defp getmembers servername called phx numberspubsub servername end end next called file libphoenixpubsublocalex link defmodule phoenixpubsublocal called broadcast phoenixchannelserver numberspubsub none phoenixsocketbroadcast event update payload number topic def broadcast fastlane pubsubserver poolsize topic msg isatom pubsubserver dobroadcast fastlane pubsubserver shard topic msg ok end defp dobroadcast fastlane pubsubserver shard topic msg pubsubserver subscriberswithfastlanes topic shard return list tuples like pid pid phoenixtransportswebsocketserializer phoenixchannelserver process cowboywebsocket process call fastlanefastlane msg end end next called file libphoenixchannelserverex link defmodule phoenixchannelserver called fastlane phoenixtransportswebsocketserializer none phoenixsocketbroadcast event update payload number topic def fastlane subscriber broadcast event event msg enumreduce subscriber fn pid fastlanes cache pid cache pid nil cache send pid msg cache pid fastlanepid serializer eventintercepts cache read message interception http event eventintercepts send pid msg cache else case mapfetch cache serializer ok encodedmsg send fastlanepid encodedmsg cache error serializer phoenixtransportswebsocketserializer encodedmsg serializerfastlane msg fastlanepid cowboywebsocket process send fastlanepid encodedmsg mapput cache serializer encodedmsg end end end end end next message serialized sent cowboywebsocket handler process file libphoenixtransportswebsocketserializerex link defmodule phoenixtransportswebsocketserializer moduledoc false behaviour phoenixtransportsserializer alias phoenixsocketmessage alias phoenixsocketbroadcast doc translates phoenixsocketbroadcast phoenixsocketmessage def fastlane broadcast msg socketpush text poisonencodetoiodata message topic msgtopic event msgevent payload msgpayload end end message handled file libphoenixendpointcowboywebsocketex link defmodule phoenixendpointcowboywebsocket implementation websocket transport cowboy moduledoc false read cowboywebockethandler http behaviour cowboywebsockethandler connection plugadapterscowboyconn def websocketinfo message req handler state handlereply req handler handlerwsinfo message state end defp handlereply req handler reply opcode payload newstate reply opcode payload req handler newstate end end called argument websocketinfo message socketpush text topic ref null payload number event update message charlist format topic ref null payload number event update req httpreq port ranchtcp keepalive get localhost undefined socketwebsocket undefined undefined undefined websocketversion websocketcompress false waiting undefined false done undefined handler state phoenixtransportswebsocket channel channelsinverse serializer phoenixtransportswebsocketserializer socket phoenixsocket assigns channel nil channelpid nil endpoint numbersendpoint handler numbersusersocket id nil joined false pubsubserver numberspubsub ref nil serializer phoenixtransportswebsocketserializer topic nil transport phoenixtransportswebsocket transportname websocket transportpid finally called file libphoenixtransportswebsocketex link defmodule phoenixtransportswebsocket behaviour phoenixsockettransport def wsinfo socketpush encodedpayload msg state formatreply msg state end defp formatreply socketpush encoding encodedpayload state reply encoding encodedpayload state end end point may still evident return value manages send data socket demystified proceed next section phoenix cowboy number application started numbersendpoint supervisor started supervising following child supervisorwhichchildren numbersendpoint phoenixcodereloaderserver pid worker phoenixcodereloaderserver node nodemodulesbrunchbinbrunch watch stdin cd userszorbashdevopensourceblogexamplesnumbers pid worker phoenixendpointwatcher focus supervisor responsible http part application phoenixendpointserver pid supervisor phoenixendpointserver pid supervisor phoenixconfig pid worker phoenixconfig file libphoenixendpointserverex link defmodule phoenixendpointserver supervisor underlying handler moduledoc false use supervisor require logger def startlink otpapp endpoint opts supervisorstartlink module otpapp endpoint opts end def init otpapp endpoint handler endpointconfig handler return phoenixendpointcowboyhandler child scheme port http http config endpointconfig scheme handlerchildspec scheme endpoint default config otpapp port return ranchlistenersup numbersendpointhttp phoenixendpointcowboyhandler startlink http numbersendpoint ranchlistenersup startlink numbersendpointhttp ranchtcp maxconnections port cowboyprotocol env dispatch socket websocket phoenixendpointcowboywebsocket phoenixtransportswebsocket numbersendpoint numbersusersocket websocket plugadapterscowboyhandler numbersendpoint permanent infinity supervisor ranchlistenersup end supervise child strategy oneforone end end called phoenixendpointserver supervisor file libphoenixendpointcowboyhandlerex link defmodule phoenixendpointcowboyhandler behaviour phoenixendpointhandler require logger doc generates childspec used supervision tree def childspec scheme endpoint config scheme http applicationensureallstarted ssl end dispatch path socket endpointsockets transport module config sockettransports allow handler configured transport level handler config cowboy defaultfor module pathjoin path atomtostring transport handler module endpoint socket transport dispatch dispatch plugadapterscowboyhandler endpoint use putnew allow custom dispatch config keywordputnew config dispatch dispatch ref mfa type timeout kind module plugadapterscowboychildspec scheme endpoint config rewrite mfa proper error reporting mfa module startlink scheme endpoint mfa ref mfa type timeout kind module end defp defaultfor phoenixtransportslongpoll plugadapterscowboyhandler defp defaultfor nil doc callback start cowboy endpoint called http numbersendpoint ranchlistenersup startlink numbersendpointhttp ranchtcp maxconnections port cowboyprotocol env dispatch socket websocket phoenixendpointcowboywebsocket phoenixtransportswebsocket numbersendpoint numbersusersocket websocket plugadapterscowboyhandler numbersendpoint part env responsible livereloading omitted def startlink scheme endpoint f ref ref used ranch identify listener defaulting plughttp plughttps overridable user becomes case apply f ok pid loggerinfo info scheme endpoint ref ok pid error shutdown error eaddrinuse error loggererror info scheme endpoint ref failed port already use error error error error end end end next called file srcranchlistenersuperl link module ranchlistenersup behaviour supervisor export export spec startlink ranch ref nonneginteger module module ok pid called startlink ref numbersendpointhttp nbacceptors transport ranchtcp transopts maxconnections port protocol cowboyprotocol protoopts env dispatch socket websocket phoenixendpointcowboywebsocket phoenixtransportswebsocket numbersendpoint numbersusersocket websocket plugadapterscowboyhandler numbersendpoint startlink ref nbacceptors transport transopts protocol protoopts maxconns proplists getvalue maxconnections transopts option new listener kept ets table ranchserver setnewlisteneropts ref maxconns protoopts supervisor startlink module ref nbacceptors transport transopts protocol init ref nbacceptors transport transopts protocol acktimeout proplists getvalue acktimeout transopts conntype proplists getvalue connectiontype transopts worker shutdown proplists getvalue shutdown transopts childspecs ranchconnssup ranchconnssup startlink ref conntype shutdown transport acktimeout protocol permanent infinity supervisor ranchconnssup ranchacceptorssup ranchacceptorssup startlink ref nbacceptors transport transopts permanent infinity supervisor ranchacceptorssup ok restforone childspecs fetch even modify listener opts etslookup ranchserver opts numbersendpointhttp opts numbersendpointhttp env dispatch socket websocket phoenixendpointcowboywebsocket phoenixtransportswebsocket numbersendpoint numbersusersocket websocket plugadapterscowboyhandler numbersendpoint phoenixendpointserver supervise following child ranchlistenersup numbersendpointhttp pid supervisor ranchlistenersup child supervise ranchacceptorssup pid supervisor ranchacceptorssup ranchconnssup pid supervisor ranchconnssup ranchacceptorssup us start listening ranchtcp wrapper around gentcp set socket listen random port local host ranchacceptorssup start pool acceptor supervised process one wait infinity timeout accept connection listening socket connection established ranchacceptor transfer control socket connection supervisor receives message socket tcp connection established ranchconnssup start cowboyprotocol process using cowboyprotocol process started successfully ranchconnssup transfer control socket process receives message socket cowboyprotocol handler responsible receiving parsing message http protocol handle request executing layer middleware stack default stack contains cowboyrouter called cowboyrouterexecute httpreq port ranchtcp keepalive get localhost undefined socketwebsocket undefined undefined undefined host connection upgrade upgrade websocket secwebsocketversion secwebsocketkey origin http localhost connection upgrade undefined waiting undefined false waiting undefined listener numbersendpointhttp dispatch socket websocket phoenixendpointcowboywebsocket phoenixtransportswebsocket numbersendpoint numbersusersocket websocket plugadapterscowboyhandler numbersendpoint dispatch get socketwebsocket request phoenixendpointcowboywebsocket behaviour cowboywebsockethandler file libphoenixendpointcowboywebsocketex link defmodule phoenixendpointcowboywebsocket implementation websocket transport cowboy moduledoc false behaviour cowboywebsockethandler connection plugadapterscowboyconn alreadysent plugconn sent called transport http tcp http req httpreq port ranchtcp keepalive pid get localhost undefined socketwebsocket undefined undefined host connection upgrade upgrade websocket secwebsocketversion secwebsocketkey origin http localhost connection upgrade undefined waiting undefined false waiting undefined module opts phoenixtransportswebsocket numbersendpoint numbersusersocket websocket def init transport http req module opts transport tcp ssl conn connectionconn req transport try called case moduleinit conn opts ok adapter connection req args upgrade protocol module req args error adapter connection req shutdown req nostate end catch kind reason although performing call using call function properly handled error report mfa module call conn opts upgrade protocol module req error mfa kind reason systemstacktrace receive alreadysent ok ok end end end def upgrade req env module handler opts args req env module handler opts resume cowboywebsocket upgrade args end def resume module fun args apply module fun args error handling omitted end websocket callback called transport tcp req httpreq port ranchtcp keepalive get localhost undefined socketwebsocket undefined undefined host connection upgrade upgrade websocket secwebsocketversion secwebsocketkey origin http localhost upgrade websocket connection upgrade undefined websocketcompress false waiting undefined false waiting undefined handler args phoenixtransportswebsocket phoenixsocket assigns channel nil channelpid nil endpoint numbersendpoint handler numbersusersocket id nil joined false pubsubserver numberspubsub ref nil serializer phoenixtransportswebsocketserializer topic nil transport phoenixtransportswebsocket transportname websocket transportpid serializer phoenixtransportswebsocketserializer transportlog false timeout infinity def websocketinit transport req handler args ok state timeout handlerwsinit args ok cowboyreqcompact req handler state timeout end end phoenix respond switching protocol upgrade websocket connection upgrade secwebsocketaccept generated link concludes websocket handshake data transfer start twoway communication channel side independently send data successful handshake client server transfer data back forth conceptual unit referred specification message wire message composed one frame established websocket connection client phoenixjs see link push topic event phxjoin payload ref cowboywebsocket process control socket receives message mailbox decodes websocket protocol call follows phoenixendpointcowboywebsocketwebsockethandle opcode payload text topic event phxjoin payload ref req httpreq port ranchtcp keepalive get localhost undefined socketwebsocket undefined undefined undefined websocketcompress false waiting undefined false done undefined handler state phoenixtransportswebsocket channel channelsinverse serializer phoenixtransportswebsocketserializer socket phoenixsocket assigns channel nil channelpid nil endpoint numbersendpoint handler numbersusersocket id nil joined false pubsubserver numberspubsub ref nil serializer phoenixtransportswebsocketserializer topic nil transport phoenixtransportswebsocket transportname websocket transportpid called par message json call patternmatch event part message phxjoin finally call happens next already described subscribing section debugging websockets essential armed knowledge innerworkings phoenix common question answered use following code snippet caution production environment phoenix function used documented expensive private operation use prod getting list topic subscriber poolsize applicationgetenv number numbersendpoint pubsub poolsize poolsize enumflatmap phoenixpubsublocallist numberspubsub keep mind default poolsize getting subscriber topic poolsize applicationgetenv number numbersendpoint pubsub poolsize poolsize enumflatmap phoenixpubsublocalsubscribers numberspubsub pid getting subscriber topic across node assumption connected node member pubsub cluster poolsize applicationgetenv number numbersendpoint pubsub poolsize fun phoenixpubsublocalsubscribers numberspubsub rpcmulticall node nodelist enum flatmap poolsize fun pid pid pid pid pid pid pid pid pid pid pid pid pid pid pid nt like assumption use get actual node adapter node phx numberspubsub enummap autoverse autoverse getting socket state subscriber using pid previous example recongetstate phoenixsocket assigns channel numbersintegerschannel channelpid pid endpoint numbersendpoint handler numbersusersocket id joined true pubsubserver numberspubsub ref nil serializer phoenixtransportswebsocketserializer topic transport phoenixtransportswebsocket transportname websocket transportpid pid may well use always mind provide timeout sysgetstate pid getting subscription client ip address use ineti list tcp udp socket including erlang runtime system us well created iex number autoverse ineti port module recv sent owner local address foreign address state type inettcp stream inettcp stream inettcp stream inettcp stream inettcp stream let say interested subscription heuristic would get process spawned owner process socket owner pid link processinfo owner link link pid pid link pid owner pid pid pid alternatively use recontcp enumerate tcp port keep one matching ip peername searchip recontcp enummap enumfilter fn port case port type peername searchip true false end end enummap signal connected recon recon library dropped erlang project used assist devops people diagnose problem production node found recon indispensable tool regular debugging critical production issue handful websocket related trace attempt recon trace next subscription number phoenix app recontracecalls ets insert ets insert elixirphoenixtransportswebsocketserializer trace next subscription number phoenix app recontracecalls ets insert ets insert elixirphoenixtransportswebsocketserializer recongetstate phoenixsocket assigns channel numbersintegerschannel channelpid pid endpoint numbersendpoint handler numbersusersocket id nil joined true pubsubserver numberspubsub ref nil serializer phoenixtransportswebsocketserializer topic transport phoenixtransportswebsocket transportname websocket transportpid pid trace next call show return value recontracecalls getmembers returntrace getmembers phx elixirnumberspubsub distributed phoenix scenario get something like getmembers phx elixirnumberspubsub find hard build complex match spec hand try rough equivalent conclusion phoenix codebase interesting one lot learn really hope sharing quest understand explore phoenix beneficial others found mistake please submit pull request mention comment
239,Lobsters,elixir,Elixir programming,Maximizing HTTP/2 performance with GenStage,http://tech.footballaddicts.com/blog/maximizing-http2-performance-with-genstage,maximizing performance genstage,past quick primer multiplexing concurrent website faq apns maximizing performance genstage current implementation notification lake producer apns connection consumer performance robustness conclusion next step scalable,core feature forza football app push notification live match event apple moving push notification service wanted take advantage functionality new api provides maximize performance improve resource usage new platform end apple announced update apns apple push notification service api part update move communication order improve performance able deliver instant feedback client sending push notification month ago since rewriting push notification system wrote past decided use new api would prepared future eventual deprecation original api quick primer new version http brings many improvement keeping semantics one improvement multiplexing communication happens client server tcp happens one connection however one connection multiple stream stream similar request initiated opened lingo server client example browser client want load website server using first open connection direct mapping tcp connection server initiate one stream resource need load example one stream html content one stream per image one stream cs document one javascript code make great different stream single connection concurrent given time many stream open one connection exact number stream open time negotiated client server life connection many feature improvement concurrent stream single connection one need know rest article want information website faq great resource start apns new api apple released us single connection send multiple push notification first client example server application life open connection apn server connection used send theoretically unlimited amount notification advised keep connection open unless send notification burst time day client need send notification open stream connection send post request stream apn server reply stream right away close stream interaction similar one request per notification performance much better single shared underlying connection one connection enough apple advises simply open many connection distribute load notification maximizing performance send million notification day mostly happen big burst example goal scored match two big team since notification send timesensitive need send many smallest possible amount time first quickanddirty approach took simply use one apns connection send notification kept connection open time problem appeared soon prototype implementation putting terrible performance aside caused single sink single connection handling fundamental characteristic limit stream open time call limit max concurrent stream current max concurrent stream limit apple negotiates concurrent stream sending notification say would open stream stream would freed time open stream would get error apple server telling u opening many stream one requirement never go max concurrent stream limit time however wanted maximize performance connection using much possible case mean strive many stream open time ideally number concurrent open stream always close tried achieve improve singleconnection approach using many connection alive time distributing notification connection problem approach distributing notification connection fair way connection processing notification different speed caused many reason like scheduling connection usage ended situation connection striving keep notification send connection would idle traced design problem using push pattern pushing notification connection without considering state connection first solution came mind starting use pull approach connection would express availability connection would get fair amount notification send based state usage looked problem recognized pattern many event come system notification send user need forward event another system push notification apple platform need ratelimit event keeping number open stream limit need consumer apns connection pull data pending notification based availability requirement naturally drew u genstage elixir library provides abstraction stage producer consumer exchange data ratelimited pullingoriented way decided wanted rewrite handling notification top genstage able take advantage feature moving implementation genstage felt none existing client erlang elixir would satisfy performance reliability requirement anything else wrote custom optimized client use project current implementation current implementation separate service http api receives notification send different provider like apns apple gcm google http api keep several connection apns open around responsible ratelimiting open stream spreading event notification open connection service genstage life architecture look like notification lake request contain multiple notification send come http api first step take temporarily store notification call lake play word around big pool apnslake genstage producer hold bounded queue notification send use bounded queue backpressure mechanism notification come handle process handle http request queue notification single apnslake process thought first step multiple lake well found performance great way holding adding lake process simplified version apnslake code look something like defmodule apnslake use genstage def init boundedqueuesize state pendingdemand queue boundedqueuenew boundedqueuesize producer state end triggered manually http api def handlecall sendnotifs notifs state case boundedqueueinmany statequeue notifs ok queue event state dispatchdemand queue statependingdemand reply ok event state full reply error full state end end defp dispatchdemand state pendingdemand dispatch event either pending demand satisfied go run event end end code could let genstage handle buffering event demand using genstage internal buffer instead explicit bounded queue however genstage internal buffer drop event get filled afford lose event send notification manual implementation bounded queue tighter control behaviour queue becomes full case reply error full http api act accordingly example retry later reply error http client client retry later pushing responsibility retrying apns connection apnslake genstage producer push event apns connection apnsconnection process genstage consumer connection maximum demand event exactly maximum number concurrent stream conceptually logical thing would initially ask event one notification stream ask one event time stream closed practice work optimally asking one event time would mean producer consumer would exchange many message ending degrading performance instead buffer demand make connection wait small number stream case free ask producer number event consumer never asks maxconcurrentstreams currentlyopenstreams event total number concurrently open stream go max concurrent stream limit buffering event also helped u improve performance client sending notification corresponds new request boil write connection tcp socket mean buffering event would many tcp writes close buffer event client designed send request issued time single blob byte tcp socket buffer event time send one tcp write corresponding request work connection process event send notification asynchronous sends request apple asynchronously wait response reason use genstage internal demand mechanism use manual demand mode send demand producer simplified code connection look like defmodule apnsconnection use genstage def init hostinfo ok client mc hostinfo state client client eventstoask mc maxconcurrentstreams mc consumer state subscribeto apnslake end def handlesubscribe producer option state state maybeaskdemand state subscription manual state set demand manual end def handleevents notification state work async send notification without sending demand upstream state sendnotifications notification state noreply state end def handleinfo streamresponse state processstreamresponse streamresponse eventstoask stateeventstoask state maybeaskdemand state eventstoask eventstoask noreply state end def maybeaskdemand state stateeventstoask genstageask statesubscription stateeventstoask state eventstoask else state end end end number connection today around result experimenting optimal number connection single machine performance robustness happy performance getting system graph show day many big match look like metric dashboard system two server handling apple notification graph show performance two combined peak time able send million notification around second number satisfied time aimed mostly performance rearchitecting system also improved robustness system thanks work distributed many connection bounded queue ensures get overflow isolation elixir erlang vm provide confident problem may happen affect small part system without significantly degrading overall performance conclusion next step post explored took advantage genstage build system around new apple api able reliably deliver million push notification user happy current number still improvement make system case want squeeze even performance one possible thanks distribute workload parallel multiple server albeit two mean system scalable turn mean throw server able increase throughput notification able send
240,Lobsters,elixir,Elixir programming,ACE: Web Server and Client in Elixir for HTTP v1.0 and 2.0,https://github.com/CrowdHailer/Ace,ace web server client elixir http,ace http web server client support raxxkit raxx ace get started hello world start service raxx documentation tlsssl supervising service http testing alternative http server cowboy elli elixir http benchmark ace v cowboy,ace http web server client support see raxxkit project generator help set web project based raxxace get started hello world defmodule myapp use acehttpservice port cleartext true use raxxsimpleserver impl raxxsimpleserver def handlerequest method get path greeting greeting response ok setheader contenttype textplain setbody greeting world end end argument given use acehttpservice default value starting service start service config greeting hello myappstartlink config port default port value overridden startup raxx ace implement raxx http interface allows application built component raxx ecosystem raxx tooling streaming serverpush routing api documentation see documentation detail correct version raxx included ace raxx need added dependency tlsssl service started without cleartext start using tl requires certificate key config greeting hello option port certfile pathtocertificate keyfile pathtokey myappstartlink application option tl required serve content via supervising service normal way run service part project supervision tree starting new project use sup flag add service supervised application file libmyappapplicationex defmodule myappapplication moduledoc false use application def start type args import supervisorspec warn false child myapp greeting hello opts strategy oneforone name myappsupervisor supervisorstartlink child opts end end start project using iex mix visit http testing mix test include ci true run one test specified environment variable path downloaded executed alternative http server server use elixirerlang application cowboy elli three cowboy widely used elli cowboy written erlang ace written elixir elixir http benchmark ace v cowboy
242,Lobsters,elixir,Elixir programming,Overview of Elixir executables,https://monades.roperzh.com/overview-elixir-executables-escripts/,overview elixir executables,escripts archive phoenix well documented mix escript mix escriptbuild mix escriptinstall subscribe,escripts good way distribute selfcontained applicationsscripts executed command line consumer requirement erlang installed described valid erlang escripts erlang feature article focus escripts elixir perspective scenario constructing executable mean bundle entire project file arbitrary extension invoked command line accept argument erlang provides functionality box escripts elixir leverage escripts allows package entire otp application including dependency single executable file every time escript boot trigger independant erlang node therefore everything erlang thus elixir done escripts may find elixir library support option installed globally execute command commandline via archive notable example phoenix worth clarify archive always try stick escripts whenever possible erlang archive zip file extension ez file contain application part application well compiled beam file include application dependency elixir archive installed mix several peculiarity pollute every mix project system module archive accessed application consumer archive elixir installed run mix come bunch builtin task help build manage distribute escripts well documented official documentation summary used command mix escript list escripts installed directory listing mixescripts mix escriptbuild compiles project dependency package escript invoking mix escriptbuild necessary define escript key mainmodule option mixexs file escript mainmodule myappcli mix escriptinstall argument provided try install project current folder otherwise argument local path url prebuilt escript git repository git url github repository github url hex package hex packagename installing escript mean compiling placing binary mixescripts subscribe try post week interesting stuff programming nix web like notified new post go subscribe form
243,Lobsters,elixir,Elixir programming,StreamData: Property-based testing comes to Elixir,https://elixir-lang.org/blog/2017/10/31/stream-data-property-based-testing-and-data-generation-for-elixir/,streamdata propertybased testing come elixir,streamdata sample data generation streamdata propertybased testing shrinking using propertybased testing streamdata streamdata advantage propertybased testing learning resource original quickcheck paper testcheck hypothesis quickcheck propertestingcom proper include propertybased testing elixir rewriting scratch past elixirforum post pragdave pollution roadmap streamdata update,blog post talk propertybased testing sample data generation cover want elixir plan future want use feature discussed want read formal documentation head streamdata library currently provides feature albeit beta form focusing effort sample data generation core streamdata library streamdata module provides functionality related generating sample data many kind includes data generator data type like integer booleans well tool combine generator oneof listofgenerators developer supposed create generator scratch use provided generator provided combinator function compose example generator one returned streamdatainteger function return generator generates integer generator infinite stream term implement enumerable protocol mean operation taking term generator function enum stream enumtake streamdatainteger streamdata contains function modify generator example build generator positive integer top streamdatainteger generator streamdatamap streamdatainteger enumtake generator encouraged generator return value shrink something propertybased testing take advantage see later treated enumerables generator return normal value shrinked decided separate datageneration propertybased testing something developer take advantage situation outside propertybased testing example data stream used seed database randomly generated data available regular test propertybased testing often write test like test calculates length list assert length assert length one assert length end test written using examplebased approach writing input piece software testing well expected output testing tool verifying running software given input result expected output style testing common useful let get running easily also let test known corner case explicit way however hard test many case way even harder uncover unknown corner case may reveal bug code propertybased testing intuitive way fix problem mentioned property always check list listof term assert length list end end propertybased testing specify set valid input list example code verify code hold property value taken random valid input example test take many usually around value random listof term generator verifies property always return nonnegative integer generator streamdata generator discussed previous section shrinking since generating lot random input test input cause failure often complex convoluted take trivial example property property list contain multiple check list listof positiveinteger refute enumany list rem end end running property failure might trigger list like list easy see test failing well know wrote doctored test supposed fail running property though failure reported look like property list contain multiple mypropertytest failed generated value attempt list listof positiveinteger expected false nil got true code refute enumany list rem error show minimal generated value trigger failure process finding minimal generated value trigger failure called shrinking generator come streamdata generate value bundle way shrink propertybased testing use provide shrinking functionality shrinking fundamental part propertybased testing take noise randomgenerated data reduce failing data focused easiertounderstand term using propertybased testing streamdata core propertybased testing streamdata check macro macro list bunch generator filter similarly would comprehension pas body verify property hold generated data make check macro available test alongside importing function streamdata use exunitproperties defmodule mypropertytest use exunitcase async true use exunitproperties test operator work list check list listof term list elem memberof list assert elem list end end end see filter generated data list directly check macro also simple assignment example us check macro inside regular test want property reported property end exunit test run use property macro instead defmodule mypropertytest use exunitcase async true use exunitproperties property sum positive integer greater integer check list listof term list elem memberof list assert elem list end end end property also tagged property tag mean able thing like run property much mechanic streamdata work revolves around finding good property test code writing good generator data want test head streamdata documentation detailed documentation advantage propertybased testing using propertybased testing advantage first let test property code many value otherwise would examplebased testing true random data generation cover possible value piece code deal confidence codebase still increase time propertybased test likely generate different value run examplebased testing mean test data change time propertybased testing however also powerful impact way design software start writing propertybased test start thinking guarantee code provides property satisfies write property writing code easily influence way write code learning resource propertybased testing something specific elixir root haskell check original quickcheck paper interested nowadays many language stable usable implementation clojure testcheck python hypothesis many one famous complete tool propertybased testing exists erlang quickcheck quviq complete commercial solution propertybased testing erlang stateless well stateful system quviq even provides custom erlang scheduler test race condition concurrent program young awesome book propertybased testing written fred hebert also available propertestingcom book proper pun intended guide propertybased testing us erlang library called proper however concept technique perfectly apply elixir streamdata well include propertybased testing elixir rewriting scratch community expressed concern regarding two main thing want include propertybased testing tool elixir standard library write tool scratch instead using one existing erlang elixir solution answer first question believe providing tool standard library encourage developer use propertybased testing ultimately improve software way write time want able use propertybased testing test elixir codebase already turned great past reason writing new propertybased testing library scratch best explained josé elixirforum post since want bundle part elixir code open source appropriate license wanted add data generation property testing elixir library called streamdata instead something named property test goal reduce learning curve behind property testing exposing data generation aspect stream known construct elixir developer approach mind first library saw leveraging practice pragdave pollution finally since core team taking responsibility maintaining property testing part elixir potentially rest life want full understanding every single line code nonnegotiable guarantee continue consistently improve code move forward understand rolling implementation downside especially since lack maturity compared alternative balance actively seeking input knowledgeable folk listening feedback come community thankful roadmap streamdata functionality includes scheduled included one next two elixir release likely possibly used name streamdata exunitproperties avoid conflict module eventually merged elixir merged renamed proper streamdata exunitproperties module right development happening streamdata repository discussing feature giving user chance try functionality early love anyone get involved trying streamdata love feedback update careful consideration elixir team decided include streamdata elixir keep package able provide necessary feature without need direct integration language
244,Lobsters,elixir,Elixir programming,Pleroma: Mastodon API-compatible OStatus implementation in Elixir,https://git.pleroma.social/pleroma/pleroma,pleroma mastodon apicompatible ostatus implementation elixir,find file,find file select archive format download artifact previous artifact
246,Lobsters,elixir,Elixir programming,Data generation and property testing for Elixir,https://github.com/whatyouhide/stream_data,data generation property testing elixir,streamdata data generation propertybased testing announcement elixir website installation usage documentation available online data generation property testing propertestingcom original quickcheck paper testcheck difference propertybased testing framework propcheck proper proper streamdata license,streamdata streamdata elixir library data generation propertybased testing read announcement elixir website installation add streamdata list dependency defp deps streamdata test end run mix depsget streamdata usually added test environment since used test test data generation also import streamdata formatter configuration add dev environment well test streamdata add streamdata formatterexs importdeps streamdata usage documentation available online streamdata made two main component data generation propertybased testing streamdata module provides tool work data generation exunitproperties module take care propertybased testing functionality data generation data generation functionality provided streamdata module streamdata provides generator function combine generator create new one since generator implement enumerable protocol easy use infinite stream data streamdatainteger streammap enumtake streamdata provides necessary tool create arbitrarily complex custom generator require exunitproperties domain gmailcom hotmailcom yahoocom emailgenerator exunitpropertiesgen name streamdatastring alphanumeric name domain streamdatamemberof domain name domain end enumtake streamdataresize emailgenerator hotmailcom yahoocom property testing property testing aim randomizing test data order make test robust instead writing bunch input expected output hand propertybased testing write property code hold set data generated data set verify property generate data use abovementioned streamdata module use exunitproperties property always start check binary binary assert stringstartswith end end know propertybased testing read exunitproperties documentation another great resource propertybased testing erlang idea apply elixir well fred hebert website propertestingcom propertybased testing side library heavily inspired original quickcheck paper targeted haskell well clojure take propertybased testing testcheck difference propertybased testing framework handful propertybased testing framework beam ecosystem erlang elixir elixir main alternative streamdata propcheck propcheck wrapper around proper propertybased testing framework erlang fundamental difference streamdata proper listed help choose two proper via propcheck provides stateful propertybased testing need test system state building model system test go propcheck since streamdata nt support yet store counterexample streamdata nt support storing counterexample file reuse seed caused failure order reproduce streamdata provides functionality generating data base propertybased testing streamdata generator used outside propertybased testing normal elixir stream produce random data native elixir written entirely elixir idiomatic elixir api example generator elixir enumerables license copyright andrea leopardi josé valim licensed apache license version license may use file except compliance license may obtain copy license http unless required applicable law agreed writing software distributed license distributed basis without warranty condition kind either express implied see license specific language governing permission limitation license
247,Lobsters,elixir,Elixir programming,SpawnFest is Back!,http://spawnfest.github.io,spawnfest back,,tweet spawnfest status event
248,Lobsters,elixir,Elixir programming,Mastering Elixir Releases with Distillery — A (Pretty) Complete Guide,https://hackernoon.com/mastering-elixir-releases-with-distillery-a-pretty-complete-guide-497546f298bc,mastering elixir release distillery pretty complete guide,mastering elixir release distillery pretty complete guide create elixir release tip phoenix ecto umbrella application quick refresher bit history release great detail code remot relx bitwalker distillery stepbystep guide installing distillery creating first release note currently bug distillery might crash release starting case run mix clean mix compile try running application release profile environment using environment dev distillery us environment allow multiple configuration release building process combination environment specific release name called release build configuration erlang cookie include hardcoded cookie want commit configuration git repository backwards compatibility lifecycle script aka hook umbrella apps runtime configuration release voiced concern problem mix configuration distillery build release configuration file evaluated buildtime simple solution replaceosvars method great initializing erlang cookie ecto atmo confex phoenix upgrading release creating upgrade release make sure previous release still available build folder building upgrade creating production release terminal terminal creating upgrade release terminal live terminal master elixir release yet article part ongoing series developing deploying elixir application production,mastering elixir release distillery pretty complete guidehow create elixir release tip phoenix ecto umbrella applicationsa quick refresher bit historyreleases long around erlangotp worldi previously written release great detail little refresher release selfcontained bundle compiled elixirerlang code easily deployed remote machinesnaturally tool creating release far come erlang world erlang ship systools reltool usage rather complicated community built relx easiertouse alternative become defacto standard creating release erlang project since tool made work erlang work elixir project leave much desiredin paul aka bitwalker set make elixir release easier published exrm built top relx elixirspecific feature due limitation relx exrm inflexible never able leverage full potential modular elixir application paul decided create new release manager written scratch pure elixir distillery bornstepbystep guidein section article learn add distillery project build first release stepbystep let go created small application print current time every second use build release installing distillery creating first releasebefore create first release need install distillery add distillery list dependency project mixexs run mix depsgetnext initialize distillery calling mix releaseinit command creates configuration file relconfigexs could also manually create file convenient like thiswe look content configuration file bit enough build first release order run mix release distillery create output look something like assembling release building release using environment dev set devmode true skipping archival phase release successfully built run one following way interactive builddevrelclockbinclock console foreground builddevrelclockbinclock foreground daemon builddevrelclockbinclock startcongratulations created first release run builddevrelclockbinclock foreground expected application print current time onesecond interval terminate application hitting ctrlcnote currently bug distillery might crash release starting case run mix clean mix compile try running application againin call start application passed foreground command end boot command also boot command starting application console launch interactive iex session application start creates daemon process backgroundrelease profile environmentslet take step back probably already familiar elixir build tool mix mix support multiple environment dev prod test depending current environment mix example determine dependency configuration file includeyou might noticed created release distillery printed line building release using environment dev distillery also environment different mix environment distillery us environment allow multiple configuration release building processconveniently confusingly distillery environment default mix environment let take look autogenerated configuration file relconfigexs order better understand profile work use mixreleasesconfig defaultrelease default defaultenvironment mixenv see defaultenvironment set mixenv mean distillery match mix environment override default environment env switch example could work mix release mix environment distillery environment devmixenvprod mix release mix environment distillery environment prodmixenvprod mix release envdev mix environment prod distillery environment devthe configuration file also specifies defaultrelease default actually define one release project default setting distillery automatically pick first release defined relconfigexs want override default release specify name flagthe combination environment specific release name called profile pick specific profile profilename env flagin next section going take look use multiple environment configure distilleryrelease build configurationour distillery configuration includes two environment dev prod top one release named like project clock environment dev set devmode true set includeerts false set cookie w cn g ayui ku nubrbu f endenvironment prod set includeerts true set includesrc false set cookie fz dk nf endrelease clock set version currentversion clock set application runtimetools endhere option included configuration file devmode truefalse true bytecode asset file copied release folder instead distillery creates symlinks make creating release faster great testing purposesincludeerts truefalse true distillery includes erlang runtime ert necessary development machine recommended making selfcontained releasesif want deploy release machine different operating system processor architecture specify path crosscompiled version ert instead truefalsecookie string distillery set erlang cookie autogenerated configuration includes random erlang cooky include hardcoded cookie want commit configuration git repository later post look better way configure magic cookieincludesrc truefalse option available backwards compatibility erlang release tool relx true erlang source code project dependency included release elixir code never included time ignore optionversion versionstring set version release use function extract version project mixexsapplications appname list additional application want include default distillery includes runtimetools part erlang standard library enables certain debugging featureslifecycle script aka hooksit possible add shell script release run certain point application lifecycle script also referred hook configured relconfigexs simply add env release section like environment prod set prestarthook relhooksprestartsh endnotice path relative project directory relative rel directory interesting hook certainly prestart also poststart prepostconfigure prepoststop prepostupgrade currently configure one script per hook distillery although erlang would theoretically allow moreumbrella appsdistillery also great working umbrella apps really two thing need pay attention include name child application application list release configurationyou choose take release version number child application using currentversion mychildapp mentioned also possible define one release relconfigexs thus specify multiple release profile useful want release include certain child application umbrella projectruntime configuration releasesconfiguring elixir application especially come thirdparty library tricky affair ecto coredeveloper michał recently voiced concern confusing status quothe problem mix configurationthe first thing need remember configuration mix configuration file evaluated compiletime problem run application source code distillery build release configuration file evaluated buildtimeif anything like foo systemgetenv barvar mixconfig file luck foo take value barvar environment variable build system launch application another machine value updatedfortunately way around easiest one little trick employed distillery simple solution replaceosvarsdistillery special way injecting environment variable mix configuration simply use string like barvar config file good go distillery replace corresponding environment variable value application start need work setting environment variable replaceosvarstrue launching release make easy write configuration like config myapp foo barvar method great initializing erlang cookie use set cookie erlangcookie relconfigexs set cookie environment variablereplaceosvars come without problem importantly method work string try something like stringtointeger bar get error message compiler evaluates expression distillery get chance replace special stringfortunately many library support flexible approach configurationectoecto introduced new way dynamically configuring application dependency solution callback dynamically configure ecto callbackthis callback take type config argument safely ignore type either supervisor dryrun depending context call config configuration keyword list mix configuration convenient allows set default value mix configuration override environment variablesthe callback return ok config ignore simple example type conversion instead writing code parsing environment variable might find thirdparty application atmo confex useful tried yet seem nice convenience featuresphoenixcreating release phoenix application easybefore create production release make sure asset built digested nodemodulesbrunchbinbrunch b pmixenvprod mix phxdigestwith version phoenix also adapted ecto callbackstyle configuration method make easy flexibly configure phoenixendpoint upgrading releasesno pretty complete guide elixir release would pretty complete without mentioning one coolest feature hot updatesyou probably know erlang elixir compiled bytecode executed beam virtual machine thanks beam upgrade application without ever stopping itcreating upgrade releaserelease upgrade internally use appup file determine module upgraded fortunately u distillery creates automatically pas upgrade parameter make sure previous release still available build folder building upgrade otherwise distillery able determine module need updatingcreating production releaseonly release include ert use hot upgrading let start creating production release clock application terminal mix depsgetmixenvprod mix releasenow open second terminal window launch release terminal distilleryclockdemobuildprodrelclockbinclock foregroundagain see current time printed every secondcreating upgrade releaselet create new version clock since print current version number together current time need get different output change version mixexs currently set let change create upgrade release passing upgrade flag mixrelease terminal mix release upgradewe live release upgrade created clock application second terminal changed yet still first terminal run following command terminal upgrade second terminal clock output change start also print current date neat updating application wile running master elixir release yet hope reading guide better understanding elixir release certainly writing think missed aspect elixir release part pretty complete guide please let know try add article part ongoing series developing deploying elixir application production upcoming article cover deployment strategy building docker imagesin series sharing experience creating dblsqd release update server written elixir check nostringsattached free demo subscribe get daily roundup top tech story
249,Lobsters,elixir,Elixir programming,Erlang Behaviors… and how to behave around them,https://medium.com/erlang-battleground/erlang-behaviors-4348e89351ff,erlang behave around,using behavior disclaimer introduction heuristic encapsulation server rest api handler black box testing caveat optional callback dialyzer callback katana test opaque state mixer mixer kevin smith juan facorro inakaesi caveat,using behaviorsthis article focus using already existing behavior leave tip creating behavior next onedisclaimer introductionas usual kind list following one heuristic rule exception situation much convenient bend break guideline better accommodate encapsulationas said general using behavior building thing composed behavior callback implement genserver callback building server implement cowboyrest callback building rest api handler etc fact implement using generic module implementation decision usually best hide user providing api callback module instead relying others using generic one directlynotice outside module nobody need know implemented using genserver module want use relay kv kv kv eventually need start using genstatem instead genserver simply change internals module move forward black box testingfollowing line thought previous paragraph usage behavior seen implementation detail considering test test implementation functionality keeping mind followed previous rule already provided nice api write test apiin word even exported module write test evaluate directly contrary would much convenient write test start server use api let genserver invoke functiona basic common test suiteas see nowhere test directly testing callback test indirectly module interfacethe reason behind guideline one previous one assert anything module implemented focus behave free change implementation test let know affected functionality notcaveat general longer case thanks optional callback used quite difficult follow guideline wanted ensure test coverage code certain callback may still almost never evaluated hard trigger case need end writing white box testing coverage advocate tend put test one ensure coverage coveragesuite test dialyzersince introduction callback attribute dialyzer able verify properly implementing behavior want implement great tool use day project even add directly test suite using katana opaque statebehaviors particularly used process tend sort state context passed function state kept hidden rest world implementation detail strictly tied behavior choose implementrecords great ensure since bound module defines since achieve similar effect using well typed map case convenient define nonexported type state add proper spec exported functionsnotice added type spec function subtypes behavior defines exported used api function ie anybody try use type outside kv dialyzer properly warn u mixerthere one limitation imposed genericcallback module implementation callback written single module mean callback function shared several callback module workaround use mixer opensource library created kevin smith working chef later improved juan facorro working inakaesi let mix function moduleslet say want implement handling unexpected message way server write code baseserver mix function server et voilàcaveat example assuming baseserver ignores second parameter need use type defined kv following tip list might need relax rule bit sometimes share part state type among module map really handy need make sure type module mix function generic one use type subtypes one used one example spec baseserver case see kv subtype baseserver dialyzer certainly able figure even use parameterized type matter another blog post
250,Lobsters,elixir,Elixir programming,Subscribe GenStages Under Umbrella,https://medium.com/@iacobson/subscribe-genstages-under-umbrella-1fceec366633,subscribe genstages umbrella,subscribe genstages umbrella genstage umbrella part working application test passing fitzdares genstage umbrella umbrellastage registry automated subscription mixexs umbrellastage consumer subscribe producer soon start find full code stockr app github http githubcomiacobsonblogstockr turn umbrellastage issue,subscribe genstages umbrellagenstage umbrella part last article genstage umbrella series shortest made quite progress working application test passing genstages sending receiving expected information across umbrella appswe miss one thing automate genstage subscription remember manually subscribed consumer producer test like genstagesyncsubscribe myukappreceiveconsumer converterreceiveproducerconsumer last article saw possible handle subscription genstage init basically control application start order flat umbrella architecture guarantee producer consumer try subscribewhat fitzdares use genstage umbrella architecture one current elixir project working small hex package called umbrellastage function subscribe genstage consumer producersunder hood registry track genstage process across apps registry store also subscription detail soon producerconsumer pair process becomes available subscribes themfor moment package implement subscriptionslet add umbrellastage stockr app add package shared application mixexs umbrellastage run mix depsget install packagenow look test delete try run test fail genstages longer communicating otherit time add umbrellastage configuration genstage contains information genstage type well producer name option add following configuration top genstages right use genstagethe umbrellastage hex package work named producer producerconsumers finally last step genstage init function call umbrellasyncsubscribe rerun test pas consumer subscribe producer soon startsyou find full code stockr app github http githubcomiacobsonblogstockryour turnhere end long series interested hear opinion experience genstage umbrella project personally find pretty cool please leave comment thought possible concern idea etcalso would like see feature umbrellastage hex package use issue request please feel free contribute project rise pr
251,Lobsters,elixir,Elixir programming,A simple approach to building a real-time collaborative text editor,http://digitalfreepen.com/2017/10/06/simple-real-time-collaborative-text-editor.html,simple approach building realtime collaborative text editor,realtime collaborative text editor firepad sharejs crdt conflictfree replicated data type logoot simpler understand convince work recurse center problem synchronization causality commute idempotent synchronize commute converge idempotent make everything kiwi unique different example crdts bag also known multiset assign individual fruit unique id created globally unique id never used text editing order fruit kingdom text document ordered bag character generating unique id character sort order id tell u order character document occurrence hard ok fractional index two character position identifier unique site id tag digit site id inserted lamport timestamp show ze money ze code position identifier position identifier case head digit different case head digit site different case head digit site staying sync abstractionland userland array position identifier character array array position identifier character binary search tree position identifier character order statistic trie position treedoc conclusion,post attempt write easy understand introduction main idea behind building realtime collaborative text editor tricky want client synchronize see sensible result even face concurrent edits way already solved problem operational transform ot opensource implementation like firepad sharejs want pluginplay solution use one move along decided use crdt conflictfree replicated data type newer technique specifically adapted logoot technical pro con versus ots gon na bore major advantage crdt approach simpler understand convince work thus maintain hope demonstrate post splitting problem implementing crdt multiple conceptual layer layer fairly easy understand one time contrast ots work requiring handle every combination operation arriving different order ie weird shit user proving handled edge case code may complicated make mistake screwed fun side project build recurse center also quite relevant application increasingly moving web becoming collaborative good ol google doc showed quite useful multiple people able edit time dropbox paper overleaf coderpad etc support collaborative writing problem synchronization first briefly introduce make collaborative text editor hard let say two student ping pong working together essay working different part document ping make change insert string sadface end line naive way ping editor could transmit change pong editor send message insert sadface would work change could transmitted applied instantaneously possibly breaking causality along way practice ping neighbor torrenting emoji movie ask causing ping message arrive really slowly pong ping message stuck emoji traffic pong added string column wop time insert sadface arrives end line longer column still insert though get inconsistent state matrix fall apart around ping pong commute idempotent synchronize let look first insight allow u make collaborative text editor previous example two operation generated concurrently different client send client end applied different order client end different state commute hand every operation could commute every operation client would converge state regardless message arrived first still need require operation commute way make sense user course lest get lazy programmer make every operation delete whole file hey state end otherwise operation commute synchronization trivially easy basic example addonly set matter order add thing set set end commutativity capture idea practice need another condition synchronization operation need idempotent apply operation twice give result applying useful message get duplicated somehow maybe using udp instead tcp dunno also two client decide operation time receiving client duplicate operation noop nothing using term commute loosely practice need operation commute sense every operation commute every operation great since commutativity sufficient condition convergence necessary condition instance make sense reorder operation generated one client might end putting delete x create x really want sort interleaveability defined causal order operation merging obey partial order goal post provide intuition even expense correct technicality refer crdt paper big word make everything kiwi unique abstract level crdt data structure set operation data structure commute lot different example crdts quite simple read breakfast others well le get text editing one le simple crdts let create simple crdt help u gain intuition going build bag also known multiset like name implies collection put retrieve object like set contain multiple copy element two main operation bag concerned probably also want iterate bag count element etc modify bag therefore need synchronization add remove commutative imagine ping pong pang instance bag contains kiwi ie simultaneously ping put another kiwi pong remove kiwi pang remove kiwi happens fact pong pang decided remove kiwi bag problem although jeez pong pang remember operation idempotent end result kiwi got removed bag problem ping two kiwi bag receiving two delete message pong pang ping deletes kiwi meantime pong pang end either one kiwi kiwi depending whether add delete arrived first kiwipocalypse fix changing semantics operation little kiwi unique fruit different fruit make every kiwi unique calling kiwi manifesto specifically assign individual fruit unique id created programmer modify bag way add remove operation get sent client add unique id remove unique id adding fruit bag globally unique id never used client ever get created assigned fruit removing fruit bag remove operation remove fruit local bag get removed fruit unique id send message client remove item bag unique id exposing unique id user also make sure ask delete kiwi exist yet make intuitive sense delete message deleting kiwi deleting kiwi longer run ordering problem finally generate new globally unique id need consensus client implement paxos kidding assuming client unique identifier make part new object unique id make sure object created different client distinguishable without needing communicate make sure object created client distinguishable create counter client increment bag modified add unique id summary object tagged client id counter text editing order fruit kingdom alright say cool come build fruit basket want make text editor fine fine text document different bag bag alphabit cereal anybody bunch character add delete problem bit harder character position one way look another way helpful u say text document ordered bag character position character simply follow order even newlines n character order going going try section next section design way generating unique id character sort order id tell u order character document let first think would insert character line existing character already assigned unique id suppose id integer sorted character increasing id might something like c c u r e n c e wait occurence occurrence spelled spelling occurrence hard ok anyway let fix adding r r e room guess stuck spelling natural thing would create fractional index insert character r get expected result c c u r r e n c e therefore could use float instead integer store character id practice would want store list integer representing digit fraction ever run precision also need index going fractional index anyway store fractional digit fractional index course globally unique id id need bit clever unique like snowflake two character generate globally unique id call position identifier since identify stuff position stuff two situation need handle two client generating id time eg insert character position concurrently one client generating id already generated eg delete character reinsert high level idea going solve assume client unique site id still going use fractional index every time insert character add change digit fraction tag digit site id inserted look like say whale start document hero water buffalo enters document h e r water buffalo add super document might look like u p e r h e r whale accidentally hit keyboard add bunch u whale fat finger read wikipedia could look like u u u p e r h e r went friendship whale water buffalo formed making sure last digit newly added character position identifier always tagged site id two client never conflict adding new character might think every position identifier could contain single site id instead site id every digit need tag every digit site id see later sort order depends site id site id need preserved make sure inserting right place finally handle case client deleting reinserting character know silly monkey every client get counter always increment anytime action happens simple integer counter suffices central server though logoot paper suggests using lamport timestamp two line arithmetic anyway deleting character simply delete position identifier operation like fruit bag example got globally unique id create operation create delete commute sort order id defines order character represent text got collaborative synchronized text editor well mostly true guess talk implementation detail show ze money ze code point handwaving detail give intuition crdt work detail kind important make sure covered edge case recommend also reading logoot paper completeness pretty readable paper note using similar slightly different terminology place ease presentation let start proper definition position identifier position identifier generated site tuple position clock clock lamport clock value site position list identifier identifier tuple digit site id digit site id integer digit base want personally use convert number string ease debugging reasonable choice include maxint etc note also simplicity position insofar digit concerned think position p pi identifier need store anything left decimal code data structure look like class identifier digit number site number class char position identifier lamport number value string next need define sort order position identifier note clock value clock used sorting since client never insert character position another unless character already deleted really defining sort order position implemented function compareposition identifier identifier number let mathmin const comp identifiercompare comp return comp return else return else return function compareidentifier identifier identifier return else return else return else return else return sort order le expect sorting digit using site tiebreaker may refer paper formal definition make sure make mistake worth making sure really understand sort order affect insert character particular site tiebreaker mean sorted list position look like generating new position identifier insertion complex describe came warned made sure write test tested large production system algorithm described logoot suitable use case addition missing think key detail handle certain edge case original paper written synchronizing individual line whereas realtime collaborative editor need synchronize individual character furthermore writing text document character insertion going happen right side last inserted character occasional cursor jump need take account creating position identifier technically position identifier unbounded size try make grow fast naively say generate position identifier halfway two character size position identifier would grow fast arithmetic position arbitrary precision number two digit site could still different example saw lead position sorted way number would sorted furthermore gap position two character get smaller need create smaller increment position algorithm intricate start code explain think function generatepositionbetween identifiert identifiert site number identifiert get either head position fallback default value const head identifiercreate site const head identifiercreate decimalbase site case head digit different const decimalfromidentifierlist const decimalfromidentifierlist const delta decimalsubtractgreaterthan increment amount le delta const next decimalincrement delta return decimaltoidentifierlist next site else case head digit site different return con generatepositionbetween rest site else case head digit site return con generatepositionbetween rest rest site else throw new error invalid site ordering generatepositionbetween function recursively examines significant digit identifier handling three different case case head digit different beforeposition x afterposition base case significant digit position differ possible generate new position beforeposition newposition afterposition regardless value site x simply incrementing digit beforeposition small amount le afterposition beforeposition therefore case first convert position decimal representation dropping site module decimal export type number function fromidentifierlist identifier identifiert return identifiersmap ident identdigit arithmetic operation add subtractgreaterthan simply implement textbook addition subtraction may refer source code implementation increment operation hand bit tricky function increment delta const firstnonzerodigit deltafindindex x x const inc deltaslice firstnonzerodigit concat const add inc const add inc return increment digit increment le delta another tricky bit increment want make sure result increment last digit would later make sure able generate position two ambiguous representation decimal eg simple trick used increment happens done generating new decimal position convert back position assigning site way maintain sort order using toidentifierlist module decimal function toidentifierlist n identifiert identifiert creationsite number identifiert implement constructposition rule logoot paper return nmap digit index index nlength return identifiercreate digit creationsite else index beforelength digit index digit return identifiercreate digit index site else index afterlength digit index digit return identifiercreate digit index site else return identifiercreate digit creationsite case head digit site different beforeposition afterposition observe newposition anything always satisfy newposition afterposition generally site used tiebreaker notice new position could anything start identifier beforeposition still sorted afterposition recursion return con generatepositionbetween rest site pas empty list second parameter case head digit site beforeposition afterposition two digit need look subsequent digit find inbetween position recurse rest return con generatepositionbetween rest rest site three case covered able generate new position inserted character staying sync synchronize client add remove event sent namespace remotechange type add remove chart function add char chart return add char function remove char chart return remove char chart object containing position identifier character case fruit basket deleting character need delete id simplicity always send remote change single character insertion deletion efficiency would better batch though simple optimization abstractionland userland let recap created far way maintaining ordered list character unique identifier generate new identifier inbetween character using seen previously sufficient represent text document synchronize client serverside actually sufficient store character unordered hashtable since server read relay add delete operation course clientside user want representation text document user want able modify simple interface case using codemirror underlying text editor popular opensource javascript library codemirror obviously idea crdts store text content line character mean store two copy text one text editor client use one crdt synchronization use interact codemirror using programming api receive change event send patch using editorchange object look something like interface editorchange line number column number line number column number added string removed string actual object bit different changed ease presentation mean need keep codemirror editor crdt sync following four event happen remote change insertion get index preceding character crdt insert character crdt create local change inserting character index remote change deletion get index character position identifier crdt delete character crdt create local change deleting character index local change insertion position n find nth th character crdt create position identifier character n n insert character crdt send remote insert change character local change deletion position n find nth character crdt delete character crdt send remote delete change character go detail event handled nontrivial lot line code ultimately rather mechanical think whole lot insight said way could implement easiest least performant hardest performant array position identifier character simplest thing store character linear array need search position identifier use binary search searching newline character may require linear search going scale hundred character since worstcase quadratic complexity making large change however perfectly reasonable start prototype array array position identifier character also split array character whole document one array line allow support text document hundred line assuming text document hundred character per line want build collaborative text editor side project approach probably fine binary search tree position identifier character efficient approach store character binary search tree probably supply custom comparator finding inserting deleting character log n operation long choose implementation balanced however also need augment binary tree order statistic also want able query nth character tree storing size tree node might also want able query nth newline character downside addition requiring custom data structure binary tree require additional storage per character least left right pointer integer node size big given memory hungry approach already trie position reuse individual position digit position identifier storing whole thing trie course bit challenging regular trie since deal site tiebreaker removal character see also treedoc note case use hashtable client since hashtables provide ordering key conclusion going pretend writing realtime collaborative text editor easy project took day write core order magnitude write test make ui nice add feature top eg seeing people cursor would take even make resilient failure implement access control etc however hope article convinced approach fairly intuitive solution understood series layer broken approachable task thanks reading let know feedback thanks ryan kaplan reading reviewing blog post
253,Lobsters,elixir,Elixir programming,Pigeon - iOS and Android push notifications for Elixir,https://elixirforum.com/t/pigeon-ios-and-android-push-notifications-for-elixir/9030,pigeon io android push notification elixir,talklittle http githubcomcodedgellcpigeon new kadabra bumped runtime worker configs note standardized notification response roadmap ahead,two year development latest version pigeon finally consider done regard original vision project brings several needed apibreaking change rolled otherwise overshadowed complexity fcm implementation special thanks talklittle help release pigeon library sending io android amazon android push notification check project http githubcomcodedgellcpigeon new kadabra bumped kadabra client wrote scratch specifically support pigeon brings significant stability improvement might actually run bit faster bump minimum requirement elixir otp runtime worker configs apnsfcmadm worker connection started custom structs old config style still valid recommended use new style configexs config pigeon worker yourapppigeon apnsconfig yourapppigeonex defmodule yourapppigeon def apnsconfig pigeonapnsconfignew name apnsdefault mode prod cert systemgetenv apnscert key systemgetenv apnskey reconnect false port pingperiod end end note apnsdefault fcmdefault admdefault still need specified name config want pigeon push default standardized notification response notification contain push response notification make sending batch notification straightforward apns adm response key indicating success failure fcmnotificationresponse done away favor new style though syntax bit different response keyword list response reg id perregid response second status key notification indicates whether whole batch successful example usage async response handling fcm def handleresponse fcmnotification status success response response enummap response handleregid end def handleresponse else sort error end def handleregid update old new update def handleregid invalidregistration regid remove def handleregid notregistered regid remove def handleregid unavailable regid retry fcmpush notif onresponse roadmap ahead forcus going shift tackling smaller feature backburner among jwt token support apns topic subscription fcm better onboarding contributor mock apns server anyone thanks everyone contributed project past couple year someone previously never involved open source feel like learned lot process
254,Lobsters,elixir,Elixir programming,Keep an Eye on the Sky with Nerves and Phoenix (ElixirConf 2017),https://www.youtube.com/watch?v=UoSQBOP_Siw,keep eye sky nerve phoenix elixirconf,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature elixirconf keep eye sky nerve phoenix jeff smith youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature elixirconf keep eye sky nerve phoenix jeff smith youtube
255,Lobsters,elixir,Elixir programming,What I learned migrating a Rails app to Elixir/Phoenix (2016),https://medium.com/@stueccles/what-i-learned-migrating-a-rails-app-to-elixir-phoenix-f707436749aa,learned migrating rail app elixirphoenix,learned migrating rail app elixirphoenix colleague form thread lose object orientated mindset especially around model integration going write segmentcom library elixir thing done completely differently elixirphoenix sidekiq delayedjob migrating front end build pipeline brunch sassbrunch module bourbon csspatterns import import import activerecord ecto model migration http robotsthoughtbotcomembeddingelixirstructsinectomodels using model scope http blogdrewolsonorgcomposablequeriesecto lazy loading association embrace changeset instead model callback defaultshippingcou controller migration product templatesviews service summary,learned migrating rail app elixirphoenixi keen elixir u made many promise productivity ruby without compromising raw performance scalability rapidly making prime candidate goto serverside language choiceto overcome elixir learning curve done thing including reading working exercise excellent dave thomas book attending elixir conf austin thing migrate colleague rail app phoenixthe app nontrivial ecommerce application run excellent highend sock business form thread documented initial gotchas interesting thing migration migrating rail app mileage may vary may much different issue get detail three highlevel insightsnote going go elixir basic install phoenix etc presumes knowledge language phoenix lose object orientated mindset especially around modelsthis biggest mental transition go used ruby programming especially mindset thin controller fat model baked rail programmer created many obese model even using decoratorpresenter pattern service objectsinstead thinking small function string together make transition found actually easier understand going lot le magic wrap head integration going write yourselfthe elixir ecosystem developed point library integrate every service may use might roll sleeve make integration library grow ecosystem created segmentcom library elixir reasonthere also far fewer utility extension helper library available phoenix far found language feature lot overcome although end expect write little thing done completely differently elixirphoenixthere software design pattern differently creating elixir app instance think asynchronous general rail pattern think message queue worker background process sidekiqdelayedjob etc totally unnecessary elixir designed concurrency typically wrap function taskasync create otp application lot le magic wrap head around migrating front end build pipeline brunchfirst step setting new phoenix application migrate front end build pipeline rail pipeline phoenix frontend build choice brunchthe first problem rail pipeline handle sas default brunch sas easily added sassbrunch module added packagejson along node module needed sassbrunch bourbon csspatterns normalizecss modification required brunchconfig configure sassbrunch include nodemodules directory sas add bourbon normalize made many csspatternsplugins babel use compiler vendor code ignore webstaticvendor sas option includepaths nodemodules imported top applicationscss path relative nodemodules directory import bourbonappassetsstylesheetsbourbon import normalizecssnormalizecss import csspatternsstylesheetspatterns little directory restructure required move j cs asset directory webstatic image font directory go webstaticassetsthe major frontend change sassrails gem magically providing assetpath asseturl need removing specific path addedurl assetpath apercu boldwebfonteot becomes url fontsapercu boldwebfonteot activerecord ecto model migrationnote although phoenix still call model ecto moved schema terminology expect phoenix help lot think model get oo mindset going refer phoenix modelsthis relatively simple task taking schemarb creating necessary migration model file phoenix mix phoenixgenmodel task exception ran mileage may varyno hasandbelongstomany functionality ecto may mean need create join model would unnecessary rail use hasmany create similar structureno working hstore implementation ectothe existing data model used postgres hstore store keyvalue information model moment ecto support hstore making would taken long instead migrated data jsonb internal elixir map representation see http robotsthoughtbotcomembeddingelixirstructsinectomodels one gotcha though using jsonb ensuring json extension config environment config formandthread formandthreadrepo adapter ectoadapterspostgres extension postgrexextensionsjson library nil migrate seed data ecto elixir code privreposeedsexs run invoking mix run privreposeedsexsusing modelsecto activerecord going thing need change two ran scopeecto use scope instead use pattern storing query module composing needed see http blogdrewolsonorgcomposablequeriesectoclass order activerecord base scope receivedorshipped state received shipped becomes defmodule formandthreadorder def receivedorshippedquery query query ostate received ostate shipped endendorder orderreceivedorshippedquery repoallno lazy loading associationsactiverecord lazy load association come access however ecto need use repopreload throw error use pattern storing relation want commonly preloaded method passed repopreload method note deeply nested preloads defmodule formandthreadorder def preloaded shippingaddress lineitems variant product endendorder getcurrentorder conn repopreload orderpreloaded embrace changeset instead model callbacksthe changeset pattern going make change model new immutable world use different type changesets update rather rely model callbacksbeforecreate setdefaultshippingcountry setrandomnumber becomes def createchangeset model params empty changeset model params putchange number randomuniqueordernumber putchange shippingcountry defaultshippingcountry end ecto activerecord controller migrationthe controller structure follows similar pattern rail phoenix fact even go route similar let look thing change upthe rail app migrating used lot beforeaction controller fetch data could converted plug phoenix instead used pattern pipelining different function inside action method becomes clean easy see happens render pipeline beforeaction fetchproduct show def fetchproduct product productincludes variant findby slug params id end becomes def show conn id id conn assigncurrentorder assignproduct id render showhtml enddefp assignproduct conn id assign conn product repoget product id preload variant endand case used plug check requirement action methodbeforeaction checkfororder show update def checkfororder redirectto rootpath unless currentorderpresent endbecomesplug checkfororderdefp checkfororder conn params case getcurrentorder conn nil conn redirect halt order assign conn order order endendtemplatesviewsthere little nomenclature change rail call view actual template phoenix template file actually compiled function within view module phoenix view also would put helper function normally found rail helper simple example calculating total amount line item displaydef lineitemamount lineitem decimalmult lineitemprice decimalnew lineitemquantity endonly explicitly assigned variable accessed view unlike rail allows instance variable accessed default rail app migrating also used decorator using draper gem enhance model instead move function view productimageryeachwithindex image index becomes img index enumwithindex productimages product productimages function formandthreadproductviewservicesthe main component application actually service ran main business logic core action created elixir module contain functionalitythe great thing elixir simple make easy understand flow action pattern every action mutates underlying order record database return new state passed next actiondefmodule formandthreadcheckout def complete changeset changeset repoupdate repopreload orderpreloaded chargecustomer deliverconfirmationemail reconcilestocklevels markasreceivedenddef chargecustomer order gatewaychargecustomer order enddef deliverconfirmationemail order mailersendorderreceivedemail order enddef reconcilestocklevels order repotransaction fn li orderlineitems repoupdate livariant stocklevel livariantstocklevel liquantity end end orderenddef markasreceived order orderchangeset order state received completedat ectodatetimelocal repoupdate endsummaryso sure many transition pattern useful migrating rail app far found process pretty painless also feel vastly superior mention much faster elixir app response time bring joy heart
256,Lobsters,elixir,Elixir programming,Deploying Phoenix to production using Docker,http://teamon.eu/2017/deploying-phoenix-to-production-using-docker/,deploying phoenix production using docker,recruitee would want docker real world putting phoenix app inside docker image mixdocker paul schoenfelder distillery alpineerlang configuring dockerized application runtime configuration distillery running app using remote console upcoming post,short tutorial recruitee running phoenix elixir application docker production would want main reason choosing docker unification deployment using many different technology ranging rubyrails elixirphoenix java python even php simply put want use best tool job would love use single languageplatform elixirbeam everything possible docker container single deployment mechanism matter technology used inside docker real world docker promise single dockerfile able build runnable image put straight production statement true runnable image part enough standard approach end huge image containing compiletime dependency necessary runtime decided use twostep process separate building app compiling making release running next part take elixir example apply principle image example runtime container javascript client app compiled code without unnecessary npm dependency putting phoenix app inside docker image mentioned building docker image twostep process build phase install erlang install elixir run mix depsget run mix release save myapptargz release package release phase install erlang extract myapptargz release package build phase inside container done since use process elixir apps made simple package mix command mixdocker mixdocker provides handful mix command make putting elixir apps inside docker image simple repeatable possible based paul schoenfelder excellent distillery package alpineerlang lightweight docker image six step zero ready docker image add mixdocker mixexs def deps mixdocker end configure image name configconfigexs config mixdocker image teamondemo initialize release configuration run distillery init create relconfigexs file need change default value ready docker box build release create teamondemo build image demotargz release package inside build minimal release image extract demotargz put minimal docker image ready run production image typically time smaller build one finally publish release image docker hub tag release image current version based app version mixexs current git commit count git sha eg full image name also shortcut command mix dockershipit run build release publish configuring dockerized application since production release contain mix easiest way provide runtime configuration use env variable default docker image provided mixdocker contain replaceosvarstrue need prepare configprodexs following way config demo demoendpoint server true use system var library support http port system port use var syntax replace config startup url host appdomain config demo demomailer adapter bamboomailgunadapter apikey mailgunapikey read runtime configuration distillery doc remember rebuild image changing config running app ready run app like docker container docker run e foreground using remote console since docker container selfcontained order connect running node using remoteconsole need exec running container docker exec cid optappbindemo remoteconsole one implicit benefit using env variable configure application runtime able use exact image staging production changing domain api key etc give u much confidence deploying production upcoming post go deploying docker container rancher connecting multiple instance single erlang cluster
257,Lobsters,elixir,Elixir programming,Using CircleCI 2.0 with Elixir and Phoenix,http://joeellis.la/using-circle-2-0-with-elixir/,using circleci elixir phoenix,boast many new feature docker image prebuilt elixir image official docker image doc read understand caching doc tweet elixirlang slack channel,recently took advantage circleci new feature phoenix application thought worth sharing circleci boast many new feature interesting one native support docker image advanced caching feature turn great move feature helped cut build time least using docker image meant circleci longer needed compile elixir erlang node job advanced caching feature went step giving u control build deps directory cached saving u compilation time job take research doc forum figure create complete working circleci yaml file wanted write case example help save time people start example config assumes following elixir erlang node yarn compiled single docker image phoenix app postgresql stack may differ ok strategy outlined still work majority phoenix elixir project know may thing change make config work project start full circleci yaml config file look like circleciconfigyml version job build docker image environment mixenvtest image environment postgresusermydatabaseuser postgrespasswordmydatabasepassword postgreshostlocalhost workingdirectory app step checkout restorecache key branch checksum mixlock branch restorecache key branch run mix depsget compile savecache key branch checksum mixlock path deps savecache key branch path deps savecache key path deps savecache key branch path build savecache key path build restorecache key branch checksum assetsyarnlock branch run workingdirectory asset command yarn install yarn test savecache key branch checksum assetsyarnlock path assetsnodemodules savecache key branch path assetsnodemodules savecache key path assetsnodemodules run mix ectocreate mix ectomigrate run mix phoenixdigest run mix test bunch config let break piece piece see going circleciconfigyml version job build docker image environment mixenvtest image environment postgresusermydatabaseuser postgrespasswordmydatabasepassword postgreshostlocalhost workingdirectory app first tell circleci like build execute docker image simple docker image built elixir erlang node yarn already installed docker image though circleci even offer prebuilt elixir image rather create config also downloads second docker image create database container app database credential see official docker image doc supported option lastly set working directory folder called app circleci user home directory next build check git repo restores cache may already exist checkout restorecache key branch checksum mixlock branch restorecache key branch run mix depsget compile restorecache cache key make look funny come short part circleci new caching mechanism read rest article highly recommend read understand caching doc need understand create best caching strategy app reading read savecache step first cirle back restorecache stuff work minute step savecache key branch checksum mixlock path deps savecache key branch path deps savecache key path deps deps directory create three type circleci cache cache keyed branch name mixlock checksum cache used commits branch also us mixlock checksum part key new dependency added mixlock file change make sure cause cache miss force recompilation new dependency cache keyed branch name circleci us cache fallback first cache found usually mixlock file changed cache generic key cache used circleci find cache like case first commit new branch also creating small commits often find cache useful saving compilation time branch build directory see similar deps caching strategy savecache key branch path build savecache key path build one small difference use two type cache lockfile build directory cache make sense though want project always recompile new change made commit understand savecache work restorecache key step make sense checkout restorecache key branch checksum mixlock branch restorecache key branch run mix depsget compile declaring saved cache check order check next use exact caching strategy install frontend nodemodules using yarn restorecache key branch checksum assetsyarnlock branch run workingdirectory asset command yarn install yarn test savecache key branch checksum assetsyarnlock path assetsnodemodules savecache key branch path assetsnodemodules savecache key path assetsnodemodules using npm setup roughly instead keying yarnlock checksum would key packagelockjson prefer yarn fast deterministic also latest npm time writing issue compiling correctly production run mix ectocreate mix ectomigrate run mix phoenixdigest run mix test last step look familiar anyone run phoenix application create database create digest asset needed finally run mix test hopefully rundown circleci feature help someone config file look long see bulk repeated use caching pattern give try run trouble free tweet ping elixirlang slack channel
258,Lobsters,elixir,Elixir programming,Morphological parsing and lemmatization in Elixir,https://github.com/xiamx/lemma,morphological parsing lemmatization elixir,finite state transducer morphological parsing lemmatization stanford nlp group production use library neither cpu memory efficient example usage http hexdocspmlemma installation available hex benchmarking lemmatize paragraph word sample output compiletime v runtime parser sample output,morphological parser analyser lemmatizer written elixir implemented using textbook classic method relying abstraction called finite state transducer morphological parsing lemmatization grammatical reason document going use different form word organize organizes organizing additionally family derivationally related word similar meaning democracy democratic democratization many situation seems would useful search one word return document contain another word set goal stemming lemmatization reduce inflectional form sometimes derivationally related form word common base form instance car car car car car result mapping text something like boy car different color boy car differ color stanford nlp group production use library neither cpu memory efficient example usage initialize new morphological parser english parser lemmanew en assert ok play parser lemmaparse play documentation found http hexdocspmlemma installation available hex package installed adding lemma list dependency mixexs def deps lemma end benchmarking lemmatize paragraph word simple benchmarking script provided test performance performing lemmatization paragraph word script invoked mix run benchmarkslemmatizingexs sample output benchmark using fixture word operating system window cpu information intel r core tm cpu number available core available memory gb elixir erlang benchmark suite executing following configuration warmup time parallel input none specified estimated total run time benchmarking lemmatize input sequential name ip average deviation median lemmatize input sequential m m compiletime v runtime parser evaluate difference building parser compile time v building parser runtime another benchmarking script script invoked mix run benchmarksruntimevscompiletimeexs sample output operating system window cpu information intel r core tm cpu number available core available memory gb elixir erlang benchmark suite executing following configuration warmup time parallel input none specified estimated total run time benchmarking compiled parser benchmarking dynamic parser name ip average deviation median compiled parser k u u dynamic parser k u u comparison compiled parser k dynamic parser k slower
259,Lobsters,elixir,Elixir programming,Understanding Elixir's recompilation,http://milhouseonsoftware.com/2016/08/11/understanding-elixir-recompilation/,understanding elixir recompilation,understanding elixir recompilation edit tl dr xerpa github understanding recompilation need happen already great explaining finding recompiled finding thing recompiled xref xerpa documentation compiletime dependency created module seen macro expansion actually inside runtime impact library code issue jaserializer using structs syntax import require ing module even macroexpanding implementing protocol using behaviour defining bug file defined module attribute change book trick used untangle realworld code base general advice safe kosaraju erlc,understanding elixir recompilation aug understandingelixirrecompilation edit presented much uptodate version blogpost elixirconf check tl dr recently xerpa became victim annoying problem whenever change file elixir project would faced recompilation file lot struggle able solve mess post explains problem describes hack technique used solve excerptseparator massive recompilations started consume lot time morale team started crusade solve make everyone life happier next section describe recompilation happens process tool used untangle codebase avoid massive recompilations seeing example post available github understanding recompilation need happen although elixir runtime semantics identical erlang compilation behavior quite different since erlang offer limited metaprogramming codegeneration capability occasion recompilation necessary one design goal elixir bring metaprogramming erlangland elixir via feature called macro get detail macro people much smarter already done great work explaining still basic understanding elixir macro work difficult time groking rest post order understand relationship macro compilation dependency consider following module definition aex defmodule require b def bmacro end bex defmodule b def remotecall cc defmacro macro x remotecall quote unquote x else quote unquote x end end end cex defmodule c def c end b code change need reevaluate macro expanding part compilation relationship b called compiletime dependency important somewhat tricky fact need understand arbitrary code executed macroexpansion time whenever macrodefining module one dependency change macrodependant module need recompiled macro expansion module code equivalent defmodule def end end imagine change c code following defmodule c def c end end would imply expansion defmodule def end end mean whenever c change need recompile notice b need recompiled previous example indicates runtime dependency module depend compiletime become compiletime dependency compile b z implies compile z since elixir metaprogramming feature based macro fact big deal finding recompiled one tool help verify understand behavior described previously inotify debugging recompilation problem app used following command inotifywait rm e modify builddev grep myappnameebin beam inotifywait output line stdout describing change file given path following described example previous section see something like inotifywait rm e modify builddev grep comptestebin beam setting watch beware since r given may take watch established builddevlibcomptestebin modify elixircbeam builddevlibcomptestebin modify elixirabeam great give insight actually happening rug finding thing recompiled elixir approach similar described previous section available debug understand recompilation behavior elixir compiler fortunately elixir equipped mix nice tool called xref among thing xref give task generates dependency graph elixir application reason updated elixir xerpa get dependency graph system following command mix xref graph format dot generated output file previous example would digraph xref graph libaex libaex libbex label compile libbex libcex see compiletime dependency aex cex readily visible output even though exists able verify previous section narrow shown graph via sink source option check xref documentation description actual output graph project xerpa edge imagine hurt trying make sense xref inotifywait basically used validate progress effort next session describe occasion compiletime dependency created compiletime dependency created module seen macro expansion whenever module seen evaluating macro expansion phase compilation compiletime dependency created regardless whether actually call anything seen module seen mean module participates body macro prior expansion take note module happens inside quoted block macrodefining module depend example consider following code compiledepex defmodule compiledep def x end runtimedepex defmodule runtimedep def x end usesmacroex defmodule usesmacro require macroz def macrozmacro end def c macrozmacronodepend end end macrozex defmodule macroz defmacro macro x compiledepx quote unquote x end else quote unquote x end end end defmacro macronodepend quote runtimedepa end end end running xref yield digraph xref graph libcompiledepex libruntimedepex libmacrozex libmacrozex libcompiledepex libusesmacroex libusesmacroex libmacrozex label compile libusesmacroex libruntimedepex see usesmacro compiletime dependency macroz runtime dependency runtimedep macroz depend runtimedep mean runtimedepex change usesmacroex macrozex would recompiled impact library code reason define association ecto module defining association compiletime dependency associated one schemaaex defmodule schemaa use ectoschema schema tablea belongsto b schemab end end schemabex defmodule schemab use ectoschema schema tableb field lol string end end running xref yield digraph xref graph libschemaaex libschemaaex libschemabex label compile libschemabex ended issue ecto github repository similar issue library like jaserializer beware providing module reference macro using structs syntax whenever use mystruct add compiletime dependency happens key passed building struct way checked compiletime struct definition struct definition change check would need reexecuted following code structaex defmodule structa defstruct field end bex defmodule b def b structa field end end running xref yield digraph xref graph libstructaex libbex libstructaex label compile libbex import require ing module whenever require import module establish compiletime dependency necessary reason outlined previous bullet point imported module use function even macroexpanding following code aex defmodule def yolo end importsaex defmodule importsa import end running xref yield digraph xref graph libaex libimportsaex libimportsaex libaex label compile implementing protocol implementing protocol file defines compiletime dependency protocol module following code structaex defmodule structa defstruct lol haha end protocolzex defprotocol protocolz def x end implzex defimpl protocolz structa def x end dependsonprotocolzex defmodule dependsonprotocolz def encode x protocolzx x end end running xref yield digraph xref graph libimplzex libimplzex libprotocolzex label compile libimplzex libstructaex label compile libprotocolzex libstructaex libdependsonprotocolzex libdependsonprotocolzex libprotocolzex notice using protocol imply compiletime dependency behaviour behaviour behave like protocol module implement behaviour compiletime dependency behaviorzex defmodule behavs use behaviour defcallback stuff stringt end usebehavsex defmodule usebehavs behaviour behavs def stuff x x end running xref graph yield digraph xref graph libbehaviorzex libusebehavsex libusebehavsex libbehaviorzex label compile surprise defining typespecs using type defined another module typespec also configures compiletime dependency typeaex defmodule typea type end typebex defmodule typeb spec b typeat def b end running xref yield digraph xref graph libtypeaex libtypebex libtypebex libtypeaex label compile unexpected think limit lot benefit typespecs large edit ended bug elixir compiler notice using special struct syntax typespec still configure compiletime dependency file defined externalresource module attribute change externalresource module attribute convenience allows tell elixir compiler recompile given module whenever file change externalex defmodule external externalresource pathjoin dir externaltxt defmacro read fileread externalresource end end externaltxt chapter chris mccord book metaprogramming elixir contains example showing attribute used implement elixir unicode support dependency relationship shown xref output verify work using inotifywait command shown previously trick used untangle realworld code base general advice dirty trick break compile time dependency use hide module compiler example changing association schema described following scenario schemaaex defmodule schemaa use ectoschema schema tablea belongsto b moduleconcat schemab end end schemabex defmodule schemab use ectoschema schema tableb field lol string end end dependency graph would digraph xref graph libschemaaex libschemabex although possible need make sure safe break dependency call anything concat module risk stale beam file might present hard reproduce bug use last resort cycle dependency graph huge red flag cycle single compile labeled edge whenever module member cycle changed file cycle file depend recompiled notice cycle dependency graph graph algorithm might help used kosaraju algorithm find strongly connected component dependency graph helped eliminate cycle reducing number recompiled file avoid cycle cost require import module needlessly also would like thank jose valim time helping sort issue codebase help invaluable fundamental success task footnote come erlang way inject code module via header file hrl mechanism akin c include statement erlang compiler erlc provides option generate makefile tracking header dependency far know changing header hrl file situation erlang code need recompilation
260,Lobsters,elixir,Elixir programming,Erlang in Anger Ebook,https://www.erlang-in-anger.com/,erlang anger ebook,author fred hebert learn erlang great good,stuff go bad erlang anger book intends little guide erlang medic time war first foremost collection tip trick help understand failure come dictionary different code snippet practice helped developer debug production system built erlang download pdf author fred hebert author learn erlang great good free online also paid paper book designed teach erlang worked principal member technical staff heroku routing component helping design program maintain operate large scale distributed system cloud often written erlang
261,Lobsters,elixir,Elixir programming,A Phoenix+React initial setup that actually works,https://resir014.github.io/blog/2017/08/09/a-phoenix-react-initial-setup-that-actually-works/,phoenixreact initial setup actually work,click redirected,click redirected
263,Lobsters,elixir,Elixir programming,The guts of a property testing library,http://andrealeopardi.com/posts/the-guts-of-a-property-testing-library/,gut property testing library,quickcheck lightweight tool random testing haskell program haskell erlang clojure python scala streamdata elixir streamdata look like data generation inner working original quickcheck paper resulting library generator random splitting random byte stream approach clojure testcheck hypothesis haskell approach shrinking typed approach shrinking lazy tree random byte stream approach shrinking time conclusion credit great article,propertybased testing common tool improve testing testing property piece software many value drawn random large space valid value methodology first introduced paper quickcheck lightweight tool random testing haskell program describes basic idea show possible implementation haskell since many tool aid property based testing appeared many programming language time writing library haskell erlang clojure python scala many others day ago released first version streamdata property testing data generation library elixir candidate inclusion elixir future post introduction propertybased testing tutorial use streamdata want dig mechanic streamdata work design compare propertybased testing library mentioned streamdata look like let say want test basic property function want test first element list last element reverse list property written using streamdata would look like property first elem list last elem reverse check list listof int assert hd list listlast listsreverse list end end syntax mean take list randomly generated listof int generator generates list integer test body assertion using generated list test pass new list generated go failure found failure found streamdata try shrink list order find smallest example still fails property case fail empty list streamdata report correct test would use value generated nonempty listof int check capable also combine generator use previously generated value influence generator filter value good test example take trivial test property return true element taken list check list listof int list elem memberof list assert elem list end end see generator case us list value previously generated listof int generator list line filter filter fails generated value test run thrown away new value generated data generation focused property testing streamdata also provides data generation functionality generator implement enumerable protocol infinite stream data easily used generating test data similar purpose streamdataint streammap enumtake inner working first thing starting research possible property testing implementation reading original quickcheck paper look resulting library generator reading paper research haskell implementation requirement mind generator able generate random value indefinitely without running value reproducible explicitly take randomness order able deterministically replay generated value able use size control space generated value able start test run smaller value grow generated value time requirement already got going implemented first version generator back generator struct able distinguish term one field generator function took random seed size defmodule streamdata defstruct generator end first version generator function return term randstate tuples first value generated value second value updated random seed important generator use mutable seed share seed making seed explicit input output ensured passing initial seed around generated value would give idea generator generator integer implemented like def int streamdata generator fn seed size randomint newseed randuniforms size seed randomint size newseed end end see seed used generated random value size used control space value drawn case return integer size size range generating value generator straightforward data int randseeds firstvalue datagenerator size secondvalue datagenerator size random splitting worked fairly well reading quickcheck paper noticed something missed first time seed never returned alongside value quickcheck instead split seed splitting seed way take one random seed deterministically return two random seed used need use random seed twice instead using something like split seed use generated integer throw away since still need seed something else split effectively making u able use many seed want generate value mind changed generator function take seed size return value needed call generator twice would split seed use two resulting seed call twice looked like def int streamdata generator fn seed size randomint seed randuniforms size seed randomint size end end data int randseeds splitseed firstvalue datagenerator size secondvalue datagenerator size worked really well ended used streamdata thing changed return value simple value anymore shrinking discus random byte stream approach approach used haskell quickcheck also example clojure testcheck interesting bit different approach taken hypothesis python library property testing instead using random seed drive generation hypothesis us infinite random stream byte generator take many byte needed stream generate value deterministically related byte approach also deterministic reproducible since feeding generator byte stream whole generation unchanged enables hypothesis database known failure set byte stream saved previous run stream replayed new run ensure known failure always tested streamdata case would enough store initial seed known failure order reproduce also take look hypothesis take advantage byte stream approach model shrinking haskell approach haskell take similar approach streamdata rather way around big difference haskell able use type system infer value generate based type haskell generation integer done similarly need define first place define generate integer int type make noticeable difference since give haskell quickcheck function able test right randomly generated value looking type signature however typed approach drawback see shrinking section shrinking got generation knew toughest problem tackle shrinking shrinking important component property testing since property testing based idea generating random data order find bug software often data find bug full noise shrinking take noise data cause failure find minimal failure case common example used illustrate alwaysfailing property look like property list integer nt contain check list listof int assert list end end property fail anytime generated int often list generated contain element example list hard tell failure caused number list shrinking list however streamdata reduce minimal value listof int generate fails property typed approach shrinking approach haskell take straightforward completely separate generation shrinking haskell fairly easily thanks type system need generate data shrink data type quickcheck haskell defines arbitrary class defines two function arbitrary shrink class arbitrary arbitrary gen shrink arbitrary function responsible generating random value type implement class gen wrapper type around function take random seed size return value type streamdata described example arbitrary int type implemented similarly implemented function shrink function completely independent arbitrary function take value type let call x return list value type value possible shrink x go slightly detail return value shrink first level shrink tree x imagine since shrink x type also passed shrink function shrunk done recursively effectively forming tree shrink x note thanks haskell laziness tree completely lazy list returned shrink evaluated one element time needed want go tree instead going left call shrink value rest original list evaluated shrink easy implement well example shrink type could simply take list return list obtained removing element original list would make tree smaller list go tree ending smallest list leaf approach elegant easy implement one major drawback since generation shrinking completely separated generation logic encoded type must repeated shrinking understand mean let say want generate even integer assuming function map function value generated generator evenint generator would look like generator correctly generates even integer typed approach integer would still shrunk integer would repeat even logic using generator test require integer check evenint integeriseven end solution problem couple generation shrinking lazy tree approach went taken straight testcheck keep mind idea shrink tree mentioned basically generator return streamdatalazytree struct instead simple value lazy tree tree realized eager root lazy stream child child lazy tree defmodule streamdatalazytree defstruct root child end root generated value child shrunk value first level root child first level shrink tree corresponds return value shrink haskell implementation let see generator take generator generates list value generated generator could implemented returning lazy tree def listof data streamdata generator fn seed size splitseed seed length randuniforms size let pretend function generates value generator n time root generatenvalues data length size listlazytree root end end defp listlazytree lazytree root child end defp listlazytree list child length list streammap listdeleteat list streammap lazytree root list child child end core idea root lazy tree return generated list firstlevel child stream tree root value obtained removing element one time generated list child recursively calculated using process generator combinators transform whole tree instead returned value example map given function value tree generated given generator lazy tree place shrinking becomes straightforward fancy depthfirst search lazy tree basically walk tree find value pass test move right start node pass right sibling parent smallest failing value fails right sibling child smallest failing value algorithm explore whole tree unfeasible since start composing generator tree become large practice usually find good shrink random byte stream approach shrinking time briefly mentioned hypothesis python library propertybased testing us infinite stream random byte generator use generate value stream foundation shrinking well need shrink value remove byte original stream also shrink byte original stream towards generator expected written somehow proportional byte stream shrinking byte stream also shrink generated value using deterministic way generate value byte stream shrinking also deterministic hypothesis approach really interesting research see compare practically approach platform evaluate potential switch architecture conclusion ton fun writing library learned lot thing post little insight learned thing hopefully interesting read everyone especially potential contributor streamdata credit idea streamdata original taken partially quickcheck mostly testcheck big thank go everyone helped project blog post also influenced great article author hypothesis thank david well
264,Lobsters,elixir,Elixir programming,khusnetdinov/phoenix_gon,https://github.com/khusnetdinov/phoenix_gon,khusnetdinovphoenixgon,phoenixgon phoenix variable javascript installation usage three step configuration phoenix controller controller method javascript browser javascript asset javascript method contributor license mit license,phoenixgon phoenix variable javascript installation package installed adding phoenixgon list dependency mixexs def deps phoenixgon end usage three step configuration need add plug libprojectrouterex plug fetchsession defmodule projectrouter pipeline browser plug fetchsession plug phoenixgonpipeline end end plug accepts option env option hard overloading mixenv namespace namespace javascript object global window space asset map keeping permanent variable javascript camelcase set true asset name converted camel case format render add possibility use view helper adding use phoenixgonview template webviewslayoutviewex file defmodule projectlayoutview import phoenixgonview end add helper rendergonscript layout webtemplateslayoutapphtmleex main javascript file rendergonscript conn script src staticpath conn jsappjs script body read phoenix variable browser console javascript code phoenix controller using gon controller add defmodule projectcontroller import phoenixgoncontroller end controller method controller variable kept asset map putgon put variable asset updategon update variable asset dropgon drop variable asset getgon get variable asset example def index conn params conn putgon conn controller variable render conn indexhtml end def index conn params conn putgon conn controller variable redirect conn somewherehtml end javascript gon object kept window browser access variable console browser console gonassets object controller variable javascript asset somewhere javascript module windowgonassets javascript method phoenix env method getenv return current phoenix env isdev return boolean development env isprod return boolean production env iscustomenv env return bollean custom env asset variable method asset return variable setting config controller getasset key return variable key contributor special thanks andrey soshchenko getux license library available open source term mit license
268,Lobsters,elixir,Elixir programming,Joy of Elixir,https://joyofelixir.com/toc.html,joy elixir,,
269,Lobsters,elixir,Elixir programming,The book - Joy of Elixir,https://joyofelixir.com/,book joy elixir,power programming joy read online,hello joy elixir gentle introduction programming aimed people already know thing computer littletono programming experience think nt know enough computer well got already enough book teach core concept elixir programming language fun enjoyable way completely new programming want learn make computer thing using power programming want experience joy read book buy book read online
270,Lobsters,elixir,Elixir programming,Phoenix 1.3.0 released,http://phoenixframework.org/blog/phoenix-1-3-0-released,phoenix released,phoenix released particularly nice json api controller http wwwyoutubecomwatch upgrade guide phoenix design intent context plataformatec dockyard upgrade instruction,phoenix released posted july chris mccord phoenix release focus code generator improved project structure first class umbrella project support scaffolding reenforces phoenix webinterface greater elixir application also included new actionfallback feature phoenixcontroller allows translate common datastructures domain valid response practice clean controller code give single place handle otherwise duplicated codepaths particularly nice json api controller also making release channel wire protocol resolve race condition certain messaging pattern well improved serialization format interested detailed overview change design decision check lonestarelixir keynote http wwwyoutubecomwatch note directory structure talk slightly outdated idea still apply use new phxnew project generator install archive following command mix archiveinstall http githubcomphoenixframeworkarchivesrawmasterphxnewez us phx prefix generator old generator still around though give community learning resource time catch removed always upgrade guide detailed instruction migrating project backwards compatible release upgrading easy bumping phoenix dep mixexs wanting adopt new convention upgrade guide take stepbystep upgrade worth watching keynote exploring design decision outlined phoenix design intent new project code generator take lesson learned last two year push folk towards better design decision learning new project libmyapp directory business logic libmyappweb directory hold phoenix related web module web interface greater elixir application along new project structure come new phxgenhtml phxgenjson generator adopt goal isolating web interface domain context generate html json resource phxgenhtmljson phoenix generate code inside context context dedicated module expose group related functionality example anytime call elixir standard library accessing different context internally elixir logger made multiple module loggerconfig loggerbackends never interact module directly call logger module context exactly expose group logging functionality example generate user resource run mix phxgenhtml account user user email string unique notice account new required first parameter context module code live carry business logic user account application could include feature like authentication user registration peek part code generated libmyappwebcontrollersusercontrollerex defmodule myappwebusercontroller alias myappaccounts def index conn params user accountslistusers render conn indexhtml user user end def create conn user userparams case accountscreateuser userparams ok user conn putflash info user created successfully redirect userpath conn show user error ectochangeset changeset render conn newhtml changeset changeset end end end libmyappaccountsaccountsex defmodule myappaccounts alias myappaccountsuser def listusers repoall user end def createuser attrs user userchangeset attrs repoinsert end end also ecto schema generated inside libmyappaccountsuserex notice controller call api boundary create fetch user system easily reuse logic controller phoenix channel administrative task etc testing also becomes straightforward test in out domain without going web stack designing context give solid foundation grow application using discrete welldefined apis expose intent system allows write maintainable application reusable code additionally get glimpse application featureset exploring application directory structure lib myapp account accountsex userex sale managerex salesex ticketex repoex myappex myappweb channel controller template view myappwebex glance directory structure see application user account system well sale system also infer natural api system thru salesex accountsex module gain insight without seeing single line code contrast previous webmodels reveal relationship file mostly reflected database structure providing insight actually related domain actionfallback new actionfallback feature allows specify plug called controller action fails return valid plugconn struct action fallback plug job take connection controller action well result convert valid plug response particularly nice json apis remove duplication across controller example previous controller probably looked something like def myappwebpagecontroller alias myappcms def show conn id id case cmsgetpage id connassignscurrentuser ok page render conn showhtml page page error notfound conn putstatus render myappweberrorview error unauthorized conn putstatus render myappweberrorview end end end code fine issue common datastructures domain error notfound error unauthorized must handled repeatedly across many different controller better way action fallback write def myappwebpagecontroller alias myappcms actionfallback myappwebfallbackcontroller def show conn id id ok page cmsgetpage id connassignscurrentuser render conn showhtml page page end end end defmodule myappwebfallbackcontroller def call conn error notfound conn putstatus notfound render myappweberrorview end def call conn error unauthorized conn putstatus unauthorized render myappweberrorview end end notice controller match happy path using expression specify fallback controller handle response conversion single place huge win code clarity removing duplication excited change longterm payoff maintainability also feel lead sharable isolated library whole community take advantage inside outside phoenix related project issue upgrading please find u elixirlang irc slack get thing sorted last least would like take moment thank company make project possible much love plataformatec continued support elixir development dockyard sponsorship phoenix happy coding chris full changelog enhancement channeltest subscribe connect usersocketid support testing forceful disconnect socket support static assigns defining channel route channel add wire channel wire protocol resolved race condition compacted payload phxnew use new libmyapp libmyappweb directory structure phxnew use new myappweb alias convention web module phxgencontext longer prefix ecto table name context name javascript client enhancement use channel wire protocol support javascript client bug fix resolve race condition join timeouts occur client server channel successfully join see upgrade instruction bring existing apps speed enhancement generator add new phxnew phxnewweb phxnewecto project generator improved application structure support umbrella application generator add new phxgenhtml phxgenjson resource generator improved isolation api boundary controller add currentpath currenturl generate connection path url controller introduce actionfallback register plug call fallback controller action controller wrap exception controller maintain connection state channel add ability configure channel event logging logjoin loghandlein option channel warn unhandled message channel channel distinguish graceful exit application restarts allowing client enter error mode reconnected cold deploys router document match support matching http method special argument router populate connpathparams path parameter route conntest add return named params matched router redirected url digester add mix phxdigestclean remove old version compiled asset phxnew add erlang support phxnew installer archive bug fix controller harden local redirect arbitrary url redirection favor new phx task constructor custom encoding decoding outgoing incoming message detect heartbeat timeouts client handle ungraceful connection loss faster socket error detection add support amdrequirejs
272,Lobsters,elixir,Elixir programming,"Choosing Elixir for the Code, not the Performance",https://pragtob.wordpress.com/2017/07/26/choosing-elixir-for-the-code-not-the-performance/,choosing elixir code performance,ruby slow web scale help write software faster quality happiness honestly cared performance still writing assembly pinterest api response microsecond bleacher report went server make elixir language worth learning make day day coding productive spite performance let get performance stuff way extra engineering spent making faster flow let look code make life easier pattern matching could pick single feature adopted programming language would pattern matching changed way think separate data different header file couple line elixir immutable data structure pure function everything function depends parameter pipeline operator benchee transformation input railway oriented programming already good blog post explicit code python folk right along phoenix ecto love query ecto changesets ecto changesets explicitly know exactly step happens optional typechecking dialyxir dialyzer parallelism taskasync taskawait otp supervisor genserver little elixir otp guidebook doctests pr elixir nice doctests help future generation good language learn elixir phoenix fast concurrent explicit like,people like argue programming language one better one discussion often performance card pulled language much faster benchmark company need many server performance matter much opinion nate berkopec make good point blog post ruby slow web scale tldr add server developer time often cost server better conversation meaningful impactful one framework help write software faster quality happiness agree lot point nate make like post still rubbed wrong way bit also state make seem like people switch language performance gain brought topic bugging switching main language purely performance high chance wrong honestly cared performance still writing assembly cc least also true performance often hyped lot around new language specifically elixir also guilty sure performance great read amazing story two prominent adoption story recall usually cited referred great performance number pinterest api response microsecond bleacher report went server reread article though benefit elixir mentioned well ore even discussed performance even pinterest article focus first elixir good language performance arguably secondary post ever talk microsecond lot talk language make heavy use pattern matching technique prevents value error much common type error also innovative pipelining operator allows data flow one function next clear easy read fashion famous microsecond drop one paragraph immediately turn around talk code clarity also seen improvement code clarity converting notification system java elixir java version used actor system weighed around line code new elixir system shrunk around line bleacher report article performance headline heart also mention different benefit elixir new language led cleaner code base much le technical debt according marx also increased speed development people rave performance much performance number objective rationale impressive people like easy argument make bleacher report us server instead old ruby stack fact easy remember easy put headline discussing advantage immutable data structure pattern matching let crash philosophy much subjective personal nuanced jump blog post general specific point might resonate best ruby crowd main programming languagewhere coming language point make like meh already got might miss obvious cool thing ruby elixir hence lengthy introduction let focus something different make elixir language worth learning make day day coding productive spite performance let get performance stuff way irony starting first section blog post decisively performance discussing performance lost first wan na touch topic performance really quickly really matter seamlessly scale horizontally performance impact productivity well certainly remarked devon general sense runtime already fast enough need bother complex algorithm extra concept leave extra engineering spent making faster next good thing especially caching wonderful debug performance big task like data processing case company working solving vehicle routing scale throwing server might able parallelize easy ruby general often bigger engineering effort language make easier well like elixir flow vertical scaling limit work fine serving web request working background job get complicated big problem solve easily parallelizable especially need done wihin given time frame also might one cool docker kubernetes kid tell overhead managing server versus server tend believe simply chance anyone server failing time much bigger cause got well finally enough performance chatter post performance let look code make life easier swear try keep section short sweet although admittedly exactly strength would guessed pattern matching defmodule pattern def greet name name age age ioputs hi name age end def greet name josé valim ioputs hi josé thanks elixir end def greet name name ioputs hi name end def greet ioputs hi end end patternsgreet name tobi age hi tobi patternsgreet name josé valim hi josé thanks elixir patternsgreet name dear reader hi dear reader patternsgreet mop hi pattern matching single favorite feature could pick single feature adopted programming language would pattern matching find writing pattern matching code ruby ugh right changed way think enough soo great pattern matching basically make assertion structure get value directly deeply nested map put value variable run deeper though also method overloading elixir try match function top bottom mean different function definition based structure input data use map though use list well separate function clause empty one element list really great recursion catching edge case one fascinating us seen parsing file also use string separate data different header file couple line elixir bytesize binary binary binary tag title artist album year comment rest binary immutable data structure pure function unfamiliar immutable data structure might wonder hell one ever get anything done well reassign value return value function wan na sort change get pure function mean side effect thing happens return value function help anyone well mean dependency effect right state hold execution could depend everything function depends parameter make superior understandability debugging experience testing already month elixir journey noticed seemingly much better debugging library code ruby reason believe debug something ruby method often depends one instance variable yo wan na understand method misbehaves got ta figure code set instance variable might depend instance variable set similarly method might side effect changing instance variable effect end might never know pure function see dependency function glance see return new return value used function call read like straight book le like interconnected net might know start stop looking pipeline operator config bencheeinit bencheesystem bencheebenchmark job fn magic end bencheemeasure bencheestatistics bencheeformattersconsoleoutput bencheeformattershtmloutput simple operator make list well code lead pipeline operator pass value previous expression next function first argument give couple guideline first determining order argument thinking one main data structure putting one first give new guideline secondly lead design main data structure per function turn really nice actual interface benchmarking library benchee one design goal pipable elixir lead design main suite data structure important information stored result implementing formatters super easy function take suite pick information take account moreover every one step interchangeable well suited plugins long provide needed data later processing step nothing stopping replacing function pipe lastly pipeline operator represents well learned think functional programming transformation input pipeline operator perfectly mirror start data structure series transformation get data structure start configuration end complete benchmarking suite start url parameter transform html send user railway oriented programming ok record validatedata params ok record validateinothersystem record ok record repoinsert record ok record else error changeset error changeset end love ramble railway oriented programming already good blog post basically instead always checking error already occurred earlier branch error track point seem magical use first time remember suggesting using colleague pull request without ever using colleague came back like amazing pattern application ever since go bit like check basic validity data field presentsensible data validate data another system business logic rule external service insert record database anyone step could fail fails executing step make sense soon function return ok something error error track otherwise stay happy track explicit code python folk right along implicit code feel like magic work without writing code controller instance variable present view name view automatically inferred write anything magic many wow phoenix popular elixir web framework take another approach specify template like rail view name explicitly pas parameter def new conn params changeset usernewchangeset user render conn newhtml changeset changeset end magic happens right see accidentally making something accessible view partial anymore know else connection parameter make use pattern match another place elixir eco system explicit loading relation record iex user repogetby user name homer iex uservideos ectoassociationnotloaded association video loaded iex user repopreload user video iex uservideos video ecto database access layer elixir world see explicitly preload association want use seems awful bothersome love query rail load thing magically also get control know db query application fire database day fixed severe performance degradation app loading countless record database instantiated simple count query long story short presenter object association loaded object put presenter let size executed would never explicitly preloaded data hence found much earlier something wrong speaking explicitness ecto changesets def newchangeset model params model cast params w name username validaterequired w name username uniqueconstraint username validatelength username min max end def registrationchangeset model params model newchangeset params cast params w password validaterequired w password validatelength password min max putpasshash end callback validation nemesis problem topic another topic entirely short validation callback executed time save validation create whatever lot added one feature maybe used place think user password validating hashingsalting ever relevant user register change password code sits executed exactly trivial determine order sometimes get way new feature test start throw bunch ifs ecto changesets one strangest thing get used coming elixir basically encapsulate change operation saying parameter take part validated code execute also easily combine changesets code registrationchangeset us newchangeset add password functionality top deal password stuff explicitly want know parameter allowed go inchange need validate know exactly step happens easy debug understand beautiful optional typechecking type jobname stringt atom spec benchmark suitet jobname fun module suitet def benchmark suite suite scenario scenario jobname function printer printer end want try typing time elixir got something cool enough space explain dialyxir make dialyzer tool quite usable also go beyond type checking includes static analysis feature well still case like type optional parallelism wait swore performance outrageous relax parallelism used better performance thing great parallelism elixirthe erlang vm general low cost seamless spawning new process like operating system process like actor super easy low overhead unlike starting new thread million one machine problem moreover thanks immutability guarantee every process isolated worry process messing first want geocode pick drop address parallel bit taskasync taskawait never trust whatever ruby gem use geocoding threadsafe due global et al help well something easily parallelizable benchee generates statistic different scenario parallel easily nice lot sample might actually take couple second per scenario another point le need background worker let take web socket example best knowledge recommended load bigger task communication background worker evented architecture block threadoperating system process handling event phoenix every connection already run elixir process mean already executed parallel work one block others ultimately make application easier deal background worker loading work etc otp defining otp really hard somewhat set tool concurrent programming includes everything memory database dialyzer tool mentioned earlier probably notorious behaviour like supervisor help build concurrent distributed system famous let crash restart known good state maybe philosophy big book written gon na try explain much year experience highly available system much learn change see programming might daunting worry people built nice abstraction better use often job library framework set phoenix ecto web requestsdatabase connection respectively right never written supervisor genserver production purpose used abstraction relied framework brought gotten interested warmly recommend little elixir otp guidebook walk building complete worker pool application simple complex fully featured version doctests doc example iex ok pid agentstartlink fn end iex agentgetandupdate pid fn state state state end iex agentget pid fn state state end imo underrated feature elixir doc test allow write iex example session documentation method executed test run check still return valuesstill pas also part awesome generated documentation dateslightly wrong code sample documentation entire module rely doctests pretty awesome ask also contributing doc test library pretty great way provide documentation test eg upon time wanted learn agent module click right away made pr elixir nice doctests help future generation good language learn end elixir good language learn contains many great concept make coding life easier enjoyable life nice accessible syntax even use work straight away learning concept influence improve code experienced learned read couple book clojure never wrote professionally improved ruby code might ask go write elixir many great language silver bullet eco system still growing instance also fan rewriting application start small see like work lastly peaked interest whole talk focus great explicit feature elixir explains detail elixir phoenix fast concurrent explicit clarified bleacher report blog post mostly performance little else fixed got ta specify template name view sort like traveling salesman put together knapsack also need decide go short hard problem solve like like loading related
273,Lobsters,elixir,Elixir programming,Elixir 1.5.0 released,https://github.com/elixir-lang/elixir/releases/tag/v1.5.0,elixir released,http enhancement elixir exunit iex logger mix bug fix elixir exunit iex mix soft deprecation warning emitted elixir deprecation elixir eex reload reload,official announcement http enhancement elixir access optimize base optimize base encodedecode calendar implement inspect datetime calendariso calendar add iso day format conversion calendar well bang variant calendar add calendar field time struct calendar add calendar add calendar add allow specifing calendar enum add enum add explicit api exception add add metadata exception file add filereadlink file introduce trimbom option filestream inspect add printablelimit control limit printable structure integer add kernel add left right check left side enumerable right kernel use new debuginfo chunk otp provides mechanism tool retrieve elixir ast beam file kernel accepts module name argument mark callback overridable kernel allow nonquoted unicode atom variable according unicode annex see unicode syntax document kernel warn struct key used buildingupdating structs kernel cache ast definition speed compilation time measured across different project kernel improve compiler error message invalid pattern guard keyword add replace replacing existing key list liststartswith macro introduce map optimize choosing merging direction map add replace replacing existing key map raise badmaperror mapequal either two argument map mapset reduce mapset size serialized approximately half process add protocol show available implementation protocolundefinederror protocol consolidated registry support ets guard condition registry support parallel true registry introduce stream add explicit api string optimise binary pattern matching stringtrim supervisor add supervisor allow module module arg given invoke modulechildspec arg argument task support ontimeout taskasyncstream control task terminated task add ordered false support taskasyncstream exunit exunit show code snippet test source file case test error exunit use formatting test error exunit make fail underlying exception broken implementation exunit add exunit process started function automatically shut test exit iex iexautocomplete support autocompletion variable name iexautocomplete support autocompletion function imported using import mod iexevaluator use showing error terminal iexhelpers add iex helper list export module iexhelpers add break break code debugging iexhelpers longer emit warning iex command without parenthesis iexhelpers add printing runtime system information iexhelpers add open source given modulefunction editor iexinfo implement iexinfo protocol calendar type logger logger add metadata configuration log metadata mix mix compileelixir add allwarnings option elixir compiler show warning previous compilation instead file compiled mix escriptbuild strip debug information escripts default add option stripbeam default true mix loadpaths ensure nodepscheck trigger scm callback git mix localhex add ifmissing flag localhex mix task mix profilecprof add mixtasksprofilecprof countbased profiling mix new new styling generated application bug fix elixir calendar ensure calendariso raise readable error reaching year restriction calendar return error invalidtime wrong precision instead crashing parsing iso date enumerable raise protocolundefinederror bad function enumerable implementation file ensure recursive file operation raise path null byte security issue reported griffin byatt file support ram raw file inspect use color inspecting error message kernel support guard anonymous function zero arity kernel fix compilation map used map key inside match kernel ensure clause tail call optimizable module callback receives body wrapped keyword list body solves bug impossible distinguish bodyless clause function return nil path ensure recursive path operation raise path null byte security issue reported griffin byatt protocol lose source compile info protocol consolidation record properly escape quoted expression passed defrecord regex fix regexes terminator registry ensure work key stream fix stream cycle empty enumerable string consider unicode noncharacters valid according specification stringvalid stringio fix encoding performance issue stringiogetuntil system raise path null byte security issue reported griffin byatt system raise illformed environment variable security issue reported griffin byatt exunit exunit properly account failed test setupall fails iex iex skip autocompletion module name invalid without quoted iex skip autocompletion function default argument doc false iex start oldshell alongside iex mix mix compileelixir store multiple source case module conflict solves issue build would get corrupted compiling elixir project module conflict mix compileerlang silently discard erlang compile error mix compileerlang properly track compile module attribute specified list mix compileprotocols ensure protocol implementation disappear switching application umbrella project separate consolidation path per project mix compileprotocols raise consolidating protocol converted module soft deprecation warning emitted elixir kernel left right softdeprecated favor left right deprecation elixir deprecated favor tocharlist version aligns naming convention erlang elixir enum deprecate favor forcomprehensions genevent deprecate genevent provide alternative doc kernel using mean nil deprecated kernel ascharlists value type favor ascharlists kernel charlists key type favor charlists module using erlang parse transforms via compile parsetransform deprecated stream deprecate favor string deprecated favor binary padding string deprecated favor string deprecated favor string deprecated favor binary second argument typespec type deprecated favor eex eex deprecate middle end expression eg else end perform action time signed another tab window reload refresh session signed another tab window reload refresh session
274,Lobsters,elixir,Elixir programming,Videos from EFLBA2017,http://www.youtube.com/playlist?list=PLWbHc_FXPo2gZTX5oTYvIqTtKvS6WNNq8,video,,
275,Lobsters,elixir,Elixir programming,"Prototyping Vivaldi, a simple distributed algorithm in Elixir",https://pramod.io/blog/prototyping-vivaldi-a-simple-distributed-algorithm-in-elixir/,prototyping vivaldi simple distributed algorithm elixir,programming elixir paper love hashicorp vivaldi algorithm vivaldi needed serf consul work b b b c intuition force action b c b c centralized algorithm distributed algorithm implementing vivaldi elixir github process discovery sarat running simulation pattern matching state machine tooling praveen,learning elixir using programming elixir book came across excellent paper love talk armon dadgar hashicorp vivaldi algorithm thought elixir would great fit implement algorithm vivaldi vivaldi developed frank dabek rus cox mit decentralized algorithm predicts round trip time node cluster assigning coordinate node needed paper largescale internet application benefit ability predict roundtrip time host without contact first explicit measurement often unattractive cost measurement outweigh benefit exploiting proximity information vivaldi simple lightweight algorithm assigns synthetic coordinate host distance coordinate two host accurately predicts communication latency host modified version vivaldi used hashicorp serf inturn used consul system used service discovery configuration vivaldi also used vuze bittorrent client work paper talk accessible ca nt better job nt time quick simplified explanation vivaldi goal assign euclidean coordinate node cluster coordinate accurately within error predict roundtriptime rtt node node start origin node make request another node b b responds payload also latest version coordinate us difference real rtt rtt predicted b coordinate calculate next version coordinate another node c communicates responds updated coordinate process repeat throughout cluster node converge coordinate predict rtts node communicated also rtts remaining node simulation found cluster without triangleinequality violation node converged communicating peer author found euclidean coordinate alone nt good enough model internet added height factor accommodate node high latency reach internet backbone intuition build intuition coordinate updated step force action consider cluster four node leftmost node new whereas others node b c stable ie coordinate already assigned distance also equal latency assume latency node equal desired position centre triangle formed among node b c exerts force towards magnitude force proportional difference real latency latency predicted coordinate calculates resultant force vectorsum force take small step direction resultant force process repeat move towards centre triangle centralized algorithm previous case worry one new node case node new start origin first iteration node take step random direction continues follow principle explained previous case node converge iteration distributed algorithm previous two case node communicated node taking step right direction think batched gradient descent case node take step communicating single node stochastic gradient descent algorithm continues work realworld scenario often find node nt join cluster point time hence visualization node added cluster stage see node move aggresively new error rate high node stable enough nt affected much presence newer node height factor visualized since small compared euclidean coordinate implementing vivaldi elixir find code github highlight certain feature elixir erlangotp helped prototype algorithm quickly process discovery impedancemismatch local mode distributed mode local mode peer ran development machine distributed node peer ran different machine nt write low level networking code serializationdeserialization code got algorithm working machine spun bunch node aws digital ocean google cloud platform test algorithm spent little time debugging networking issue peer run following process ping client node id pingclient ping server node id pingserver coordinate node id coordinate coordinate stash node id coordinatestash connection node id connection coordinator node id coordinator supervisor node id supervisor pingclient periodically ping random peer receives response forward peer coordinate latency information coordinate process coordinate update peer coordinate using vivaldi store value coordinatestash process pingserver responds ping coordinate stored coordinatestash coordinatestash store latest version peer coordinate connection help connect another peer pingserver later coordinator help configure peer simulation supervisor supervises process example pingclient process go another peer pingserver respond within timeout supervisor restarts pingclient nt handle error manually pingclient assigned unique name process process name prefixed nodeid process communicate using name instead explicitly using pid development mode peer run single node whereas distributed mode peer run different node pingserver need visible across network made pingserver pid globally visible using globalregistername defmodule pingserver use genserver def init nodeid sessionid nodeid getname globalregistername self ok nodeid sessionid end def getserverpid nodeid nodeid getname globalwhereisname end defp getname nodeid nodeid pingserver end end connection module help discover pingserver pid distributed mode first connects peer us globalwhereisname relies underlying erlangotp system return pingserver pid defmodule connection use genserver def handlecall getpeerpingserverpid peerid config case config localmode true getlocalpingserverpid peerid config false getremotepingserverpid peerid config end end def getlocalpingserverpid peerid config pingservergetserverpid peerid end def getremotepingserverpid peerid config peername config peernames peerid peername nodelist pingservergetserverpid peerid else case nodeconnect peername true timersleep pingservergetserverpid peerid loggererror connect peername end end end end careful reader might noticed slipped timersleep nodeconnect added quick hack since globalwhereisname returned undefined without timeout sarat sarat explained issue occurs otp take small amount time propagate global name across cluster running simulation default value recommend vivaldi serf excellent tune value based cluster used additional controller node sends command configure peer elixir pipe came really handy modelling setup operation defmodule controller def run peer baseconfig peer connect checkstatus expectedstatus notstarted generatepeerconfigs baseconfig sendcommand configure checkstatus expectedstatus juststarted sendcommand getready checkstatus expectedstatus ready sendcommand beginpings end end controller first connects peer check peer generates configuration information contains nodeids ip address check configuration successful controller code github yet simple since last part project wanted get system working point pattern matching state machine peer run coordinator process receives command controller modelled coordinator simple state machine ever done ui programming written code prevent user clicking button continuously performing action elixir erlang pattern matching provides feature free defmodule coordinator def handlecall configure config notstarted nodeid application logic reply ok juststarted x error end def handlecall beginpings juststarted nodeid application logic reply ok pinging x error end def handlecall getstatus status nodeid reply ok status status nodeid end end coordinator accepts configure command notstarted state move juststarted state similarly accepts beginpings command juststarted state move pinging state tooling elixir excellent tooling considering young language ecosystem build tool mix come support unit testing outofthebox encouraged write unit test beginning similarly logger package also available default hex package manager integrated mix easy use well also loved interactive development using iex recompile command wish python importlibreload function intelligent faced issue setting name cooky node dynamically asked stackoverflow question quickly received answer still resort couple hack get system working expected considering first elixir project mainly familiar erlang ecosystem overall understood appeal erlangotp building distributed soft realtime system also first time used functional programming language elixir eased learning curve praveen praveen explained nt use complex concept order productive elixir resonated well looking forward using elixir upcoming project
276,Lobsters,elixir,Elixir programming,Creating slugs for Ecto schemas,https://medium.com/wemake-services/creating-slugs-for-ecto-schemas-7349513410f0,creating slug ecto schema,creating slug ecto schema slug ectoautoslugfield ectoautoslugfield work installation simple example conditional example modify slug conclusion available online gratis slugger,creating slug ecto schemaswhat slug term slug come world newspaper production ever created simple blog application already reinvented itwhen need access post url need identify somehow simplest idea identify id seem pretty would better identify post based title content blog post title creating slug ecto model would accessible via nicelooking url myappcompostscreatingslugsforectomodels creatingslugsforectomodels slug pretty cool slug goodlooking websafe unique string used identify datacreating slug common actually created utility library generate slug based field called ectoautoslugfieldhow ectoautoslugfield work imagine simple article schema inside blog context look like freshly generator libectoslugsblogarticleexit three meaningfull field title unique content article breaking news set false defaultnow want generate slug titleinstallationfirstly add ectoautoslugfield mixexs fetch dependency mix depsgetthen need add new field schema let call sluglibectoslugsblogarticleextake close note titleslug used everywhere would slug field module right exist implement lateryou also need add new migration would something like privrepomigrationalterarticlewithslugexssimple exampleremember implement titleslug yet let decide look like first use case simplest one article created generate slug title nothing morelibectoslugsblogarticleexthat take value field put change field maybe want let step upconditional exampleimagine business rule put breaking front every breaking news article slug could achieve note right use option anymore instead using function creating article provide conditional source slug since access changeset struct possibility endless logic also pretty simple changeset breaking key set true prepend breaking source list business rule satisfied let move onmodify slugor maybe different use case business want slug joined differently need modify resulting slug possible define custom function accepts two argument list source initial changeset function designed build return slug saved database super call transforms list source slugstringbut slug returned multiple thing check either slug unique increment somehowmodify slugor even build slug without magic super calland course use function alongside short introduction ectoautoslugfieldbut even feature covered option possibility like recreating slug every save alwayschange option others tried cover everything inside documentation available onlinecheck ectoautoslugfield gratisspecial thanks creating slugger rely
277,Lobsters,elixir,Elixir programming,"How Discord Scaled Elixir to 5,000,000 Concurrent Users",https://blog.discordapp.com/scaling-elixir-f9b8e1e7c29b,discord scaled elixir concurrent user,five million concurrent user million event per second erlang anger message fanout people started using discord large scale group roverwatch benchmarking blog post manifold http githubcomdiscordappmanifold fast access shared data consistent hashing library chris moo ets converted code pure elixir mochiglobal http githubcomdiscordappfastglobal limited concurrency cascading service outage circuit breaker semaphore http githubcomdiscordappsemaphore conclusion,beginning discord early adopter elixir erlang vm perfect candidate highly concurrent realtime system aiming build developed original prototype discord elixir became foundation infrastructure today elixir promise simple access power erlang vm much modern userfriendly language toolsetfast forward two year nearly five million concurrent user million event per second flowing system regret choice infrastructure lot research experimentation get elixir new ecosystem erlang ecosystem lack information using production although erlang anger awesome follows set lesson learned library created throughout journey making elixir work discordmessage fanoutwhile discord rich feature boil pubsub user connect websocket spin session process genserver communicates remote erlang node contain guild internal discord server process also genservers anything published guild fanned every session connected itwhen user come online connect guild guild publishes presence connected session guild lot logic behind scene simplified example fine approach originally built discord group le however fortunate enough good problem arise people started using discord large scale group eventually ended many discord server like roverwatch concurrent user peak hour began see process fail keep message queue certain point manually intervene turn feature generated message help cope load figure became fulltime jobwe began benchmarking hot path within guild process quickly stumbled onto obvious culprit sending message erlang process cheap expected reduction cost erlang unit work used process scheduling also quite high found wall clock time single call could range due erlang descheduling calling process meant peak hour publishing event large guild could take anywhere erlang process effectively single threaded way parallelize work shard would quite undertaking knew better waywe knew somehow distribute work sending message since spawning process erlang cheap first guess spawn another process handle publish however publish could scheduled different time discord client depend linearizability event solution also scale well guild service also responsible evergrowing amount workinspired blog post boosting performance message passing node manifold born manifold distributes work sending message remote node pid erlang process identifier guarantee sending process call equal number involved remote node manifold first grouping pid remote node sending manifoldpartitioner node partitioner consistently hash pid using group number core sends child worker finally worker send message actual process ensures partitioner get overloaded still provides linearizability guaranteed solution effectively dropin replacement awesome sideeffect manifold able distribute cpu cost fanning message also reduce network traffic node network reduction guild nodemanifold available github give spin http githubcomdiscordappmanifoldfast access shared datadiscord distributed system achieved consistent hashing using method requires u create ring data structure used lookup node particular entity want fast chose wonderful library chris moo via erlang c port process responsible interfacing c code worked great u discord scaled started notice issue burst user reconnecting erlang process responsible controlling ring would start get busy would fail keep request ring whole system would become overloaded solution first seemed obvious run multiple process ring data better utilize machine core answer request however noticed hot path could better let break cost hot patha user number guild average user erlang vm responsible session live session itwhen session connects lookup remote node guild interested inthe cost communicating another erlang process using requestreply session server crash restart would take second cost lookup ring even account erlang descheduling single process involved ring process work could remove cost completely first thing people elixir want speed data access introduce ets ets fast mutable dictionary implemented c tradeoff data copied move ring ets using c port control ring converted code pure elixir implemented process whose job ring constantly copy ets process could read directly ets noticeably improved performance ets read still spending second looking value ring ring data structure actually fairly large copying ets majority cost disappointed language could easily shared value safe read way erlang research found mochiglobal module exploit feature vm erlang see function always return constant data put data readonly shared heap process access without copying data mochiglobal take advantage creating erlang module one function runtime compiling since data never copied lookup cost decrease bringing total time thing free lunch though cost building module data structure large ring runtime take second good news rarely change ring penalty willing takewe decided port mochiglobal elixir add functionality avoid creating atom version called fastglobal available http githubcomdiscordappfastgloballimited concurrencyafter solving performance node lookup hot path noticed process responsible handling guildpid lookup guild node getting backed inherent back pressure slow node lookup previously protected process new problem nearly session process trying stampede ten process one guild node making path faster solve problem underlying issue call session process guild registry would timeout leave request queue guild registry would retry request backoff perpetually pile request get unrecoverable state session would block request timed receiving message service causing balloon message queue eventually oom whole erlang vm resulting cascading service outageswe needed make session process smarter ideally even try make call guild registry failure inevitable want use circuit breaker want burst timeouts result temporary state attempt made knew would solve language would solve elixir language could use atomic counter track outstanding request bail early number high effectively implementing semaphore erlang vm built around coordinating communication process knew want overload process responsible coordination research stumbled upon performs atomic conditional increment operation number inside ets key since needed high concurrency could also run ets writeconcurrency mode still read value since return result gave u fundamental piece create semaphore library extremely easy use performs really well high throughput library proved instrumental protecting elixir infrastructure similar situation aforementioned cascading outage occurred recently last week outage time presence service crashed due unrelated issue session service even budge presence service able rebuild within minute restarting live presence within presence servicecpu usage session service around time periodyou find semaphore library github http githubcomdiscordappsemaphoreconclusionchoosing use getting familiar erlang elixir proven great experience go back start would definitely choose path hope sharing experience tool prof useful elixir erlang developer hope continue sharing progress journey solving problem learning lesson along waywe hiring come join u type stuff tickle fancy
278,Lobsters,elixir,Elixir programming,Debugging Mix Dependencies Locally,http://joeellis.la/debugging-mix-dependencies-locally/,debugging mix dependency locally,absolute relative path reset dependency,ever needed debug dependency perhaps track bug maybe see work scripted language like ruby j usually add debug statement like put test consolelog test dependency code see output next time run app quite work elixir mix project dependency compiled usually compiled fetched fortunately u mix elixir build tool give u option called path automatically recompile dependency whenever change simply declare path option dependency project mixexs like defp deps mydep path depsmydep end tell mix look depsmydep folder dependency compiling recompile related project file anytime change detected open code depsmydep add debug statement explore away absolute relative path note path option limited looking deps folder also accepts relative absolute system path like defp deps mydep path pathtomylocalmydep end particularly useful developing new hex package along side project want clone package locally track change submit patch original author later reset dependency finished debugging want restore dependency normal state simply clean refetch running mix depsclean mydep depsget compile everything reset back beginning
279,Lobsters,elixir,Elixir programming,Course From Dave Thomas - Elixir for Programmers,https://codestool.coding-gnome.com/courses/elixir-for-programmers,course dave thomas elixir programmer,team discount available,programmer nt need spoon feeding conventional drivel integer need know different want know quickly dave man discovered ruby launched united state applying new approach teaching elixir approach give enough structure get started make special time dedicated working realworld problem carefully designed build specific tactical organizational skill course masterpiece bruce tate entrepreneur author bookscan attest course everything done far well thought extremely jack relearning elixir great opinionated way put theory jaime iniesta spaini love much comfortable feel elixir taking course use build new allenwyma want true mastery elixir come understanding underlying idiom functional programming transformation concurrency application structure need know tool iex mix need understand framework otp phoenix course get started road experience take rest way course video show stuff text give fact quiz help remember exercise let practice developer switching elixir take course join team discount available
280,Lobsters,elixir,Elixir programming,Working with the new Phoenix 1.3 directory structure – A Love Story,https://blog.jakewilkins.com/2017/06/23/working-with-phoenix-1-3-directory-structure-a-love-story/,working new phoenix directory structure love story,project keynote check,recently opportunity build project notyetreleased phoenix minor version bump includes optional new feature greatly improved ergonomics developing project insider info project motivation behind change say someone worked phoenix fit start since day whole really enjoyed top head fresh thought exhaustive list change lazy vacation going pull notable feature memory think sort value memorable someone focused primarily developing elixir side app phoenix web folder moved inside lib project web line typical mix application anyone used phoenix project would immediately noticeable change along change controller view also namespaced inside web example standard projectpagecontroller come generator becomes projectwebpagecontroller projectpageview becomes projectwebpageview first impression change phoenix trying become line traditional elixirerlang otp app structure including supervision tree structure support keynote change announced talked visualizing phoenix code one way interact underlying application could many way already true even within phoenix application api ui likely multiple avenue achieving result bringing explicitly huge win developer one way phoenix make explicit also next big change app generate new resource whether genhtml genshema genmodel replacement also specify context doc context elixir module serf api boundary given resource context often hold many related resource therefore context already exists augmented function given resource note resource may also split distinct context accountsuser paymentsuser really shine first wrapping head around tended use domain lot head instead context helpful generate new resource context also generated along outline function probably belong defmodule projectaccounts moduledoc boundary account system import ecto query changeset warn false alias projectrepo alias projectaccountsuser doc return list user example iex listusers user def listusers repoall user end doc get single user raise ectonoresultserror user exist example iex getuser user iex getuser ectonoresultserror def getuser id repoget user id end lends perfectly building application around multiple access point data also something seen framework worked sort organization typically left exercise user context ended influencing app design building app multiple account needed track accountsuser githubuser slackuser responsible storing data inside context function needed work resource contained example needed able log register accountsuser guardian function got added context def authenticate params findfromauth params validatepassword params password end def register password pas passwordconfirmation conf params pas conf doregistration params end def register params error password match end slackuser needed way associate accountsuser helper function well function githubuser maintaining link user account api also built setting context user setting context knew load setting applicable whatever model provied wanted slackusers setting aware slack channel team well user context provided good place house separate semantics context welcome abstraction previous phoenix project always bit confusing whether something belonged web lib project grew pretty hefty ended libdatastore folder vaguely similar context provide reaching place hold code oo framework like rail would shoved model love repo pattern phoenix us love includeing ectoquery everywhere needed lookup record context provide clear place holding code elixir way taken together think context move web libproject clear win lead well organized project end think save many headache think project structure provides clear avenue growth structure default rather solving simpler use case really set phoenix apart excited keep building stuff elixir phoenix outsider perspective team really taken hard challenge head really moved forward new project build bridge work github issue inside slack check
281,Lobsters,elixir,Elixir programming,Connecting to Running Elixir Applications with IEx Remote Shell,http://joeellis.la/iex-remsh-shells/,connecting running elixir application iex remote shell,note security section security cookie security issue access make rpc call local workstation alex weber writeup,note remsh security issue aware using local machine please sure read security section bottom article recently learned fun option built iex called remsh remote shell creates iex shell context elixir node allowing debug reproduce issue inside running application also note despite name remsh connect iex either local remote node application example work running elixir app server called examplecom iex name joe iextest cookie secretcookie remsh node examplecom iex node examplecom nodelist joe iextest remsh work combination two option name cookie first required creates named iex shell identify node cluster second required usually needed security cookie needed access node often found home directory erlangcookie could also wrap simple bash script make even easier use function reiex staging iex name whoami reiex cookie secretcookie remsh node stagingexamplecom elif prod iex name whoami reiex cookie secretcookie remsh node prodexamplecom else echo environment found fi run reiex environment name connect staging production server security issue remsh security implication aware using remember elixir erlang node complete access node given cluster connect laptop via remsh node cluster access make rpc call local workstation connect remote node compromised local machine private file even private ssh key would grab plan serious work remsh recommend reading alex weber writeup go detail issue alex also offer u secure alternative create ssh connection remote machine first remsh locally node least prevent node rpc call made workstation well establish secure connection machine node happy remshing everyone
282,Lobsters,elixir,Elixir programming,expostal - parsing and normalizing street addresses with Elixir,https://github.com/SweetIQ/expostal,expostal parsing normalizing street address elixir,expostal libpostal http installation dependency systemwide installation libpostal usage documentation http hexdocspmexpostal,expostal elixir binding libpostal library parsingnormalizing street address around world powered statistical nlp open geo data tutorial write elixirerlang nif http installation package installed adding expostal list dependency mixexs def deps expostal end dependency depends systemwide installation libpostal usage parsing address iex expostalparseaddress rene levesque ouest montreal qc canada city montreal country canada housenumber road rene levesque ouest state qc expanding address iex expostalexpandaddress franklin ave crown hts brooklyn ny franklin avenue crown height brooklyn new york franklin avenue crown height brooklyn ny documentation view doc http hexdocspmexpostal generate doc locally mix doc
284,Lobsters,elixir,Elixir programming,Streaming Data with Ecto,http://joeellis.la/streaming-with-ecto/,streaming data ecto,note read documentation fantastic tool csv library,note familiar elixir stream read documentation stream first post may hard follow given programming career need fetch dataset run set operation small datasets often get away fetching record need trying fetch large dataset run common problem slow creates blocking database connection database library load dataset memory slow kill server fortunately ecto fantastic tool handling situation avoids fetching everything instead fetch data iterative cycle performing operation record along way example work typical app feature exporting database record csv file useful feature good example show versatile elixir stream first let look code defmodule userexporter column w id email insertedat updatedat def export query path tmpuserscsv repotransaction fn query repostream streammap csvencode enuminto filestream path write end end defp parseline user order data match column order enummap column mapget user end end module one public function accepts ecto query return back file stream top declare column module attribute define user data show file need refer column list later reorder data csv file next meat exporter first thing open database transaction good idea iterating large dataset also requirement using either mysql postgres work using need take place inside transaction opened transaction pas query creates initial stream remember creates stream stream lazily evaluated starting making call database yet pas stream streammap function fetch transform data user struct list user data matching order column using wonderful csv library pas stream function hard work accepts return stream fit right pipeline setup finally call enuminto run whole stream actual database call start default pull record time parsed written file tmpuserscsv lastly function return file stream point newly created file use new stream filebased operation start streambased work like uploading file etc test see result csv iex console iex ok file userexporterexport u user ok filestream lineorbytes line mode write encoding binary path tmpuserscsv raw false iex fileread filepath joe jane jill pretty neat eh using stream created simple ordered pipeline efficiently fetch data transform write file record time handy tool dealing large datasets highly recommend give try heard
285,Lobsters,elixir,Elixir programming,Speed up data access in Elixir,https://medium.com/learn-elixir/speed-up-data-access-in-elixir-842617030514,speed data access elixir,speed data access elixir accessing map two time slower accessing keyword list time slower time slower time slower tuples benchmark repository github warning,speed data access elixirworking data structure straightforward predictable day erlang time getting exactly expectelixir different beast allows way work map list keyword list turn performancewise radically different othersfirst nice graph access time depending structure size come explanation raw data benchmarking code end articleaccess time structure size elementsaccess time structure size elementsaccessing mapsthere way access map elixir using pattern matching fastest key value mapmap foo bar foo foovalue mapusing pattern matching case function clause head fast using mapfetch slower mapfetch slower match value also creates extra tuplemap foo bar ok foovalue mapfetch map foo using access module much slower map foo bar foovalue map foo obscure nonintuitive behavior elixir coming programming language immediately recognize notion keyindex access probably use itin elixir allow much example addressing updating element map show next article come huge cost two time slower pattern matchingaccessing keyword listserlang elixir turn use list name tuples pas around option introduction map erlang feasible way data structure dynamic propertieskeywordlist foo bar compact formkeywordlist foo bar list accessing element requires scan find necessary element access speed n expected really use keyword list couple element using custom function speedup lookup fastest know keyword list using limited value may want faster lookup function get value keyword listdef kwlistaccess kwlist key defaultnil case kwlist h v v h v v h v v h v v keywordget kwlist key default endend using keywordget slow time slower using custom functionkeywordlist foo bar foovalue keywordget keywordlist fooyou also supply default value keywordget list foo default case key found list using access module slowest story map access module great provide extra functionality time slower compared custom function time slower compared keywordgetkeywordlist foo bar foovalue keywordlist foo tuplesi cover tuple access v map list article tuples blazingly fast little bit le flexiblehow benchmarkclone repository github runmix bench benchaccessvsmapfetchvsmatchexswarning using modern computer o constantly change processor speed order save energy keep cool quiet great every day work terrible benchmark running benchmark manually set processor fixed speed example debian instruction show current settingsgrep sysdevicessystemcpucpu cpufreqscalinggovernornumber test name mean much element tested structure uncomment line element mapkwlistetcbaseline function call without processing done see much function call cost benchfellamatch test key value lookup mapmapfetch call mapfetch map kwgetunroll manually unrolled function lookup keyword list element big switch keywordgetkwget call keywordget keyword listaccesskw kwlist index callaccessmap map index callso see least time slower manual know flaw microbenchmarks also optimization real code based input significant speed ups access module nice slow case map matching function head fastest
286,Lobsters,elixir,Elixir programming,Elixir's Secret Weapon,http://blog.drewolson.org/elixirs-secret-weapon/,elixir secret weapon,elixir secret weapon tagged tuples using better error handling doc,may elixir secret weapon recently began using new ish feature elixir completely transformed way build program talking special form feel unfamiliar first extremely powerful flexible article explain work used make code robust error first though look problem trying solve tagged tuples elixir community borrowed idiom erlang community called tagged tuples using approach function return tuple first value atom describing result common pattern returning ok value successful response error someerror error response defmodule math def divide b b error divide zero def divide b ok b end case mathdivide ok result success result error error error error end success nice reason first allows u treat error value know function always return even provided semantically invalid data second use pattern matching act explicitly success failure case pattern start break want perform multiple dependent action fail suppose example like divide two number successful divide result third number case mathdivide ok result case mathdivide result ok result success result error error error error end error error error error end success work sure becoming challenging read easily imagine mess becomes arbitrarily long list dependent operation want continue using pattern safe explicit feel ugly unreadable realworld example answer course use using special form allows define set operation perform associated pattern match result operation use binding pattern match previous operation match fail entire form stop nonmatching result returned explore rewriting example using ok mathdivide ok b mathdivide success b end success walk execution first call mathdivide result ok form check see match pattern lefthand side variable bound execution continues second line run mathdivide bound return ok check match pattern lefthand side b bound operation perform body block executed block use binding operation us b return string success try walking error case ok mathdivide ok b mathdivide success b end error divide zero first call mathdivide result error divide zero check see match patter left soon mismatch occurs form immediately stop executing operation return result match therefore return value form error divide zero better error handling already better spot using go even form allows u describe else clause handle nonmatching value rather simply returning add one ok mathdivide ok b mathdivide success b else error error error error end error divide zero first operation return error divide zero match pattern value passed else block next check clause else block order example one clause first clause match error divide zero string divide zero bound error finally body clause executed binding match return string error divide zero form allows even flexibility including guard clause operation example see doc
287,Lobsters,elixir,Elixir programming,What's a Monad? Digging into Haskell,https://blog.scottnonnenberg.com/what-s-a-monad-digging-into-haskell/,monad digging haskell,javascript technique briefly explored functional language got comfortable elixir algebraic data type pure go beyond elixir elixir erlangotp absinthe graphql library elixir ecto always trying improve excellent video ocaml ocaml compiler assist changing reference given type java invalid state possible express exploring dialyzer dialyzer flow disjoint union credo linter elixir mix understands file without jumping hoop least statement still useful documentation haskell io haskell curry currying word one committee member quite compiler available haskellorg pretty clear start learning great good learn haskell great good day module question day type typeclasses io function color question http enwikibooksorgwikihaskellindentation day io functors monoids day monad question well monad douglas crockford lodash javascript promise monad going forward idris,warning long post might consider skipping entire learning great good section jumping directly well monad section functional journey started javascript technique grew briefly explored functional language bloomed got comfortable elixir going finally defined longnebulous term shown power algebraic data type compiler assurance given function truly pure go beyond elixir think anything else let first say still think elixir great concurrency primitive inherits erlangotp topnotch innovation like easy macro use via quoteunquote truly powerful example absinthe graphql library elixir us macro compiletime validation schema sound written good bit elixir code including custom ecto absinthe data type always trying improve internet wandering encountered excellent video ocaml couple key point stuck ocaml ensures exhaustive patternmatching algebraic data type compiler assist changing reference given type similar changing interface java algebraic data type arranged invalid state possible express need manuallyimplemented guard point spoke directly realworld experience wanted feature exploring dialyzer excited try dialyzer great experience gradual typing javascript via flow flow disjoint union give something close expressive power language like ocaml expected dialyzer give similar level power slowly added type annotation entire project pushed forward credo linter elixir first surprise dialyzer work ex file mix understands ex file test directory run mix test gradual typing test least without jumping hoop second error expected materialize elixir code problem spec test item one two three four five def test item case item zero four one five two six end end three error would like dialyzer catch potential value path three different atom one two three case statement patternmatching refers zero potential value case statement also missing potential value three case return value specified four five value six returned third case disappoint least spec statement still useful documentation guess looking static typing language also universal immutability functional design like elixir haskell pretty obscure like really used anyone production people use problem injecting term like monad everyday conversation hear always immutable like elixir draw nice line around io let dig first noted named haskell curry currying pretty important concept functional programming really reached star naming thing level gravity fit language designed working group evolved conference called functional programming language computer architecture word one committee member committee primary goal design language satisfied constraint suitable teaching research application including building large system completely described via publication formal syntax semantics freely available anyone permitted implement language distribute whomever please based idea enjoy wide consensus reduce unnecessary diversity functional programming language interesting outcome considered academic quite compiler available good news point haskellorg pretty clear start okay learning great good come across learn haskell great good tutorial couple time never motivation power time mission note thing thought surprising particularly important went section day introduction way module module somethingname x x question standard api documentation haskell expected rely console integer expands biginteger automatically fractional rational seems better way deal decimal since preserve intended meaning floatdouble approximation haskell use instead float pi float dataratio get requires import dataratio fractional get get information typeclasses eq ord give error answer info eq give information typeclass make compiler tell nonexhaustive pattern matching datachar deal unicode toupper tolower unicodeaware prelude datatext noel pack prelude datatext datatextreverse noel day type typeclasses bit io data keyword allows create new type contains type name creates function arity construct type handwaving deriving show required type printed console export type module like point includes constructor interesting could also opt export value constructor shape writing shape export statement way someone importing module could make shape using auxiliary function mapmap exported create one fromlist record syntax give kind custom type except field named far seen data type followed concrete type class like float int parameterize type lowercase value usually data maybe nothing applied type maybe make sense maybe int strong convention haskell never add typeclass constraint data declaration example map k v almost always ord k lookup tree ordered end happening function operate map k v specify k must ord k couple function care whether k ordered term nullary function take parameter cool stuff thing like minbound maxbound day defining data day monday tuesday wednesday thursday friday saturday sunday deriving eq ord show read bounded enum use type synonym like type name string make function signature easier deal also parameterized like type assoclist k v k v use partial application type intmap map int key difference produce new function name specified type used type declaration cast disappointing would appreciated selfexplanatory type capturing errorresult duality interested function failed usually use result type either b sort type tell u something possible failure b type successful computation hence error use left value constructor result use right whoa control precedence associative direction leftright infixr infixl pattern matching actually matching constructor even new operator define element data type recursive type easy binary tree list defined anyway class keyword essentially give interface like eq provides instance provides implementation class given type time class constraint class declaration used making typeclass subclass another typeclass class constraint instance declaration used express requirement content type id standard library function take parameter return thing functor represents thing mapped class functor f wheren fmap b f f b f could list example rule functor behavior like order maintained checking kind using k ghci mean concrete type mean concrete type generated concrete type provided maybe type maybe int final concrete type empty represented empty tuple type operator like name getline read piece code like perform io action getline bind result value name function color think io action box little foot go real world something like write graffiti wall maybe bring back data fetched data way open box get data inside use construct taking data io action take inside another io action keyword allows sequence operation let used freely return make io action pure value return sort opposite controlmonad essentially something io action else return mapm form mapping io action getcontents streaming representation stdio interact similar pull line time handing respond dealing file systemio readfile writefile appendfile low level streaming method openfile withfile systemio set file buffered streaming hsetbuffering working file work file handle method operate stdio available file handle well hgetcontents hgetline hputstr etc commandline tool systemenvironment getargs progname look like need tool combine thing like cow one object get random number surprising stuff generator pure function return something different given input keep track generator repeatedly pas subsequent call r gen random mkstdgen int stdgen systemrandom randoms useful infinite list random number based initial generator randomr randomrs bound systemrandomgetstdgen io stdgen initial seed newstdgen update global generator call getstdgen get something different overhead list onerous dealing file use databytestring lazy databytestringlazy lazy list lot behavior list con probably want use strict version con byte get packed larger chunk lot filesystem manipulation goody systemdirectory question find example io management example web server built top haskell perhaps game loop good haskell argument processing library indentation important haskell exactly http enwikibooksorgwikihaskellindentation golden rule indentation code part expression indented beginning expression important grouping statement let two choice let let day bit io functors monoids interesting pure code throw exception caught io part code systemioerrorcatchioerror io ioerror io io number useful method patternmatching exception handler systemioerrorisxxxerror extract data ioerror systemioerrorioexxx rely exception handling io method return something like io either b compiler help deal fact something went wrong instance keyword key applying typeclass like functor new type ever find binding result io action name apply function call something else consider using fmap look prettier functor fmap kind like unboxing applying function reboxing consider functor fmap function fmap act like function function composition chaining sadly analogy start break think fmap either function take function functor map function functor think function take function lift function operates functors law functor map id function functor functor get back original functor noop composing two function mapping resulting function functor first mapping one function functor mapping one associativity applicative functor even greater ability composed result functor applicative like going meta level x hello show x fmapjust x hello show x give law applicative pure f x equivalent fmap f x pure id v v pure u v w u v w pure f pure x pure f x u pure pure u pretty much thing fmap johntra volta equivalent johntra volta except maybe wrapper applicative operation list permutation explosion avoid zip first pair combined second pair combined etc via ziplist getziplist ziplist ziplist return newtype keyword used simple wrapping another type likely new implementation instance keyword different typeclass method like ziplist little bit faster type created data wrappingunwrapping monoid type class monoid associative binary function value act identity respect function something act identity respect function mean called function value result always equal value identity respect identity respect worth noting decision name mappend named kind unfortunate implies appending two thing way take two list append one really appending multiplies two number together law monoid mappend mempty x x mappend x mempty x mappend mappend x z mappend x mappend z notice monoids require mappend b equal mappend b datafoldable export generic foldxx method work foldable type day finally talkin monad today also complete tutorial monad beefed applicative functors much like applicative functors beefed functors monad applicative functors support b b applicative boo second couple place tutorial date say monad declared applicative type constraint interesting pure return exactly based prior point seems like return came pure funny polewalking analogy help explain return landleft banana landright okay pretty cool reveal made smile nested use lambda preserve context becomes foo maybe string foo x show x rewritten could even take last line turn return make foo maybe string foo x show x important remember expression different syntax chaining monadic value pattern matching fails expression fail function called interesting keep talking list monad representing nondeterminism number possible result given computation guess way make sense permutation explosion rewrite monad list comprehension rewritten notation long write guard function replicate filter clause law monad return x f equivalent f x return equivalent f g equivalent x f x g thing applicative associativity unboxing boxing make syntax little harder define monadic function composition operator f g x g x f becomes easier grok f return equivalent f return f equivalent f f g h equivalent f g h useful command seeing installed ghcpkg list controlmonadwriter keeping track monoid along primary target calculation could used logging string string used monoid key remember using writer monoid slow append end list fast prepend sure make thing rightassociative use tailcall recursion essentially attach log calculating next level recursion difflist higherperformance type plain list function monad also called reader monad lot function missing one parameter eventually applied thing use reader monad sort extract future result implementation make sure work modeling state pure world state monad controlmonadstate newtype state state runstate ouch run state example exactly provided number function available work monad instead applicative fmap liftm ap filter filterm mapm mapm foldl foldm join flatten call monad join result work two layer f equivalent join fmap f dataratiorational loss precision math nonintegers written fraction percentage sign resolve something else need interesting tutorial present probability monad track probability given outcome along value outcome tutorial frequently defines operator make chaining easier x f f x zipper pattern whereby navigate data structure keeping enough state reassemble datastructure wherever break take list predicate first item pair set item predicate returned false predicate return true rest item second item pair question difflist example compile difference state statet year tutorial come april make sense stuff date wanted writer string maybe int would work would nice syntax still apply would need develop yet another level meta introspectionexecution surprise method fully deal maybe writer guess big question seen good example truly pure function used stuff inside monad suppose inside method could calling pure function instead simply return x dropfourorless maybe int writer string maybe int dropfourorless nothing return nothing dropfourorless x x tell keeping show x return x otherwise tell show x small dropping return nothing droptenormore maybe int writer string maybe int droptenormore nothing return nothing droptenormore x x tell keeping show x return x otherwise tell show x large throwing away return nothing main io main putstrln show return dropfourorless droptenormore output writert identity nothing keeping large throwing away well monad monad strange mysterious weird powerful expressive pattern use programming come curse monadic curse someone learns monad use lose ability explain people douglas crockford understand difficulty understand previous article monad read pretty much incomprehensible truth want understand monad really metaphor need start couple basic building block functional concept mapping operation content something quite widely known thanks library like lodash lodash ability map javascript object array functor anything mapped fmap simplest form replacing value inside functor single value prelude fmap prelude applicative functor composable create new applicative value pure function example apply function know anything applicative value inside prelude pure prelude pure maybe int prelude prelude drumroll please monad applicative implement two new function return exactly like pure assembling monad raw value new operator take monad extract value give provided function responsible returning new monad take look chained call using lambda function prelude return return j return j prelude return return j return j maybe int notice return eliminates need specify exact monad want allows u change meaning expression type hint expression work monad whose content compatible initialized probably wondering big deal sure collection trait maybe thing monad whatever whole lot others io list either controlmonadstate see available set typing monad ghci added list import new module explore get feel idea encapsulate neatly described maybe container another value nothing whole lot abstract example encapsulating future state state side effect io wide applicability one reason people hard time explaining monad concept least claim javascript promise monad make bit sense see everywhere explore haskell worth covering seems scary term monad pretty scary two behavior specified ability create empty monoid ability combine two different monoids one final monoid prelude mempty int prelude mappend going forward haskell incredibly powerful incredibly complex see reputation huge barrier entry really vastly different set language primarily taught used today might pull someone world get job know yet really comfortable plan practice drawn value provided type system restriction around io also heard unpredictability regarding performance especially looking forward exploring concurrency capability see feel like good stopping point functional programming journey least know maybe idris future resource
288,Lobsters,elixir,Elixir programming,On the security posture of Elixir HTTPS clients,https://blog.voltone.net/post/7,security posture elixir http client,great http client shootout elixirconf eu talk came httpoison hexpm httpotion simplehttp httpc setting important note test endpoint update longer available http blogvoltonenet let encrypt httpoison hackey option httpotion ibrowse rfc simplehttp httpc inets good case twitter elixir forum thread back,great http client shootout posted let start apologising clickbait title better title would security posture elixir http client topic covered elixirconf eu talk recently came goal post compare feature performance usability even choose secure client instead try establish take use client connect securely server given http url many elixir application http client used connect party api server aws facebook google request often contain sensitive data api key personal information must protected eavesdropping maninthemiddle attack developer might expect http client accepts http url take care thing thing always simple shall please meet contender httpoison popular http client hexpm powered hackney httpotion powered ibrowse simplehttp powered httpc httpc erlangotp builtin http client setting want follow along create new project using mix new edit mixexs file list package application dependency shown run mix depsget defmodule httpclientsmixfile snip def application application logger httpoison httpotion simplehttp inets ssl end snip defp deps httpoison httpotion simplehttp end end may also want set trusted ca certificate available get one mkdir priv wget q http curlhaxxsecacacertpem privcacertpem run iex mix ready start interactively exploring http client apis important note http client include connection pool erlang ssl module support session resumption lead unexpected behaviour experimenting different tl option change seem effect one request next restart application iex session make sure fresh tl handshake take place test endpoint using blog test server various scenario update please note test endpoint longer available http blogvoltonenet regular site valid time writing certificate issued let encrypt http selfsignedvoltonenet url serve site using selfsigned certificate client complete tl handshake unless explicitly allowed user http mismatchvoltonenet url serve site using regular site certificate client detect hostname mismatch abort tl handshake followup post explain build tl test server using phoenix line code use openssl cli debug handshake issue let get started first httpoison hackey version used hackney iex httpoisonget http blogvoltonenet ok httpoisonresponse iex httpoisonget http selfsignedvoltonenet error httpoisonerror id nil reason tlsalert bad certificate iex httpoisonget http mismatchvoltonenet error httpoisonerror id nil reason tlsalert handshake failure perfect thanks hackney certifi sslverifyfun dependency along sensible default httpoison correctly detects certificate issue depending erlangotp release logging configuration may see log message containing slightly specific reason failure wanted use httpoison connect private server selfsigned certificate problem override ssl option setting verify verifynone disable server certificate verification meaning loose mitm protection tl still provides protection casual eavesdropper iex httpoisonget http selfsignedvoltonenet ssl verify verifynone ok httpoisonresponse remember check update certifi package regular basis ca certificate added removed trust store likely want application pick change mix hexoutdated dependency current latest requirement certifi mix depsupdate certifi running dependency resolution dependency resolution completed certifi updating certifi hex package checking package http using locally cached package httpotion ibrowse version used ibrowse iex httpotionget http blogvoltonenet httpotionresponse statuscode iex httpotionget http selfsignedvoltonenet httpotionresponse statuscode iex httpotionget http mismatchvoltonenet httpotionresponse statuscode clear httpotion ibrowse perform server certificate verification default neither ca trust store hostname verification function included library fair enough might better set verify verifypeer default iex httpotionget http blogvoltonenet ibrowse ssloptions verify verifypeer httpotionerrorresponse message option cacertfile http connection fail tl handshake even initiated force developer choose explicitly overriding verify option adding necessary option make http work securely make httpotion default behaviour project adding following line configconfigexs file config httpotion defaultibrowse ssloptions verify verifypeer restarting iex find httpotion connect http url unless explicitly pas verifynone value iex httpotionget http blogvoltonenet httpotionerrorresponse message option cacertfile iex httpotionget http blogvoltonenet ibrowse ssloptions verify verifynone httpotionresponse statuscode okay prevents nasty surprise enable proper server certificate verification first need tell ssl module ca certificate trust one way pas cacertfile option choose whichever method prefer getting full path file remember erlang expects get path character list string binary iex cacertfile codeprivdir httpclients cacertpem iex cacertfile httpclients applicationappdir priv cacertpem tocharlist iex httpotionget http blogvoltonenet ibrowse ssloptions verify verifypeer cacertfile cacertfile httpotionresponse statuscode iex httpotionget http selfsignedvoltonenet ibrowse ssloptions verify verifypeer cacertfile cacertfile httpotionerrorresponse message tlsalert bad certificate note httpotion deepmerge ssloptions application configconfigexs file parameter passed remember include desired ssloptions including verifypeer stop httpotion silently accepting selfsigned certificate enable hostname verification attacker still pull maninthemiddle attack simply presenting trusted server certificate hostname attacker control httpotion detect mismatch iex httpotionget http mismatchvoltonenet ibrowse ssloptions cacertfile cacertfile verify verifypeer httpotionresponse statuscode need callback implementation pas verifyfun option could write based rfc might well reuse implementation used httpoisonhackney sslverifyfun package already available sample application transitive dependency application simply add direct dependency would use iex httpotionget http blogvoltonenet ibrowse ssloptions cacertfile cacertfile verify verifypeer verifyfun checkhostname blogvoltonenet httpotionresponse statuscode iex httpotionget http mismatchvoltonenet ibrowse ssloptions cacertfile cacertfile verify verifypeer verifyfun checkhostname mismatchvoltonenet httpotionerrorresponse message tlsalert handshake failure note necessary pas expected hostname explicitly charlist extracted url passed httpotionibrowse since aware verifyfun callback erlang ssl module since never see url requirement possible configure verifyfun option globally httpotion application configuration ssloptions shown must included call httpotion api finally could replace ca trust store application priv directory certifi package assuming package available dependency test project replace cacertfile option cacerts option passing certificate list iex httpotionget http blogvoltonenet ibrowse ssloptions cacerts certificacerts verify verifypeer verifyfun checkhostname blogvoltonenet httpotionresponse statuscode simplehttp version used iex simplehttpget http blogvoltonenet ok simplehttpresponse iex simplehttpget http selfsignedvoltonenet ok simplehttpresponse iex simplehttpget http mismatchvoltonenet ok simplehttpresponse like httpotionibrowse simplehttp perform tl server certificate verification unfortunately seems simplehttp currently allow ssl option specified possible make http work securely reason recommend use client time instead consider using httpc client directly described httpc version used inets included erlangotp httpc http client included erlangotp part inets application might attractive option wish keep application dependency minimum good case made policy however httpc peculiarity mileage may vary iex httpcrequest http blogvoltonenet ok ok iex httpcrequest http selfsignedvoltonenet ok ok iex httpcrequest http mismatchvoltonenet ok ok familiar pattern server certificate verification outofthebox let first override verify option iex httpcsetoptions socketopts verify verifypeer ok iex httpcrequest http blogvoltonenet error failedconnect toaddress blogvoltonenet inet inet verify verifypeer option cacertfile prevents insecure use http url instead silently ignoring server certificate may want add setoptions call application initialisation using httpc next step actually verify server certificate chain trust store iex cacertfile codeprivdir httpclients cacertpem iex httpcsetoptions socketopts verify verifypeer cacertfile cacertfile ok iex httpcrequest http blogvoltonenet ok ok iex httpcrequest http selfsignedvoltonenet error failedconnect toaddress selfsignedvoltonenet inet inet verify verifypeer cacertfile httpclientsbuilddevlibhttpclientsprivcacertpem tlsalert bad certificate adding hostname verification sslverifyfun package similar httpotion order pas expected hostname value part verifyfun option need pas ssl option part request httpc mean using elaborate api iex httpcrequest get http mismatchvoltonenet ssl verify verifypeer cacertfile cacertfile verifyfun checkhostname mismatchvoltonenet error failedconnect toaddress mismatchvoltonenet inet inet tlsalert handshake failure still chance add comment blog engine sorry instead feel free get touch via twitter share thought post elixir forum thread back
289,Lobsters,elixir,Elixir programming,Gaming with Elixir: discovering new lands in the BEAM realm,https://medium.com/@unbalancedparen/gaming-with-elixir-discovering-new-lands-in-the-beam-realm-c7c04c51acce,gaming elixir discovering new land beam realm,gaming elixir discovering new land beam realm chris jimison building releasing massively multiplayer online game unbalancedparen monad tutorial lasp stay tuned could describe experience software industry merigo sde languagesplatforms consider try settling beamelixir made choose erlang vm beam instead jvm lua language pretty common game development community erlang vm lua based language called luerl choose implement playground elixir instead luerl biggest difference implementing backend video game http rest json api state latency main difference implementing actual game game development tool experience using riak core like liked dislike anything miss implementing actual videogames,gaming elixir discovering new land beam realmin opportunity interviewed somebody normally interview client chris jimison cto merigo one client working almost year merigo appreciate understand difference using beam language develop typical rest json system using develop videogame backend aware many company using elixir develop backends watch talk jamie winsor called building releasing massively multiplayer online game hope able interview jamie following weeksto sum interview wanted share experience using elixir developing different kind beast also writting post like dislike elixir developing erlang quite yearsreach via twitter unbalancedparen comment interview request monad tutorial post another group interview lasp postgresql rust stay tuned discus vote lobster reddit hncould describe experience software industry started software industry year ago career focused game development industry specializing networking problem includes game peertopeer deterministic game play model way big mmorpg title last year working mobile title game networking requirement hybrid rest mmorpgstyle technology company worked past include ea sony r ngmoco denawhat merigo half year ago cofounder decided wanted start company help game developer successful market one big issue come around last year single player game make much money market place outside occasional indie hit mobile game developer move online gaming space cost creating application increasing exponentially iphone first launched first model app store many game team consisted one two engineer large game engineer seeing team size anywhere even heard title consisting engineer mean cost title skyrocketing need fail fast critical fail fast get heart game development game designer come idea think fun however truly know hand play idea work high development cost many game team must choose implement feature hope work budget try second third time merigo want team spending time focusing fun le time worrying make workwhat sde merigo sde server development environment system allows developer build server logic quickly without worry pain scale manage stack provide many common game service authentication purchase verification leaderboards player persistence etc however sde bunch black box rest apis sde enables developer write custom script elixir loadedupdated runtime allowing create custom apis behavior needed application since provided basic framework script managed called scale logic across distributed server cluster main philosophy sde server cheap people expensive sde wanted provide system allows fast development rapid iteration knowledge always spin new server balance load even business logic optimized high performance team decide want invest time game go live decide best invest time building new feature optimizing code reduce server cost basically turning development simple return investment roi equationwhat languagesplatforms consider try settling beamelixir java scala go one crazy day even debated writing whole stack cwhat made choose erlang vm beam instead jvm hate writing real reason go jvm environment tuning kind black art something done year since java also following goal high level fault tolerancea game team write script want able bring node wrote bad codeb game server go bad game developer user get mad quickly download different game slim chance may come backc user acquisition ua expensive buy user done via ad promotion etc spend per person game server crashed money easy scale easy upgrade server hot patch without taking system downwith three goal beam one best tool joblua language pretty common game development community erlang vm lua based language called luerl choose implement playground elixir instead luerl actually started luerl early scripting language problem luerl time reviewed year basic architecture fit need luerl designed pas bunch data process data lua get result back however know lua code need pas possible data one big map preerlang map custom struct luerl lib created meant spend lot time modifying actual luerl package extend basic apis game logic could ask erlang code needed data etc around midlate elixir matured felt language easy enough folk could pick basic syntax without lot work end really happy moved luerl system scripting environment near zero overhead serializedeserialize struct etc fact liked elixir much ended porting erlang system pretty much elixir shopalso elixir made easy walk code ast check operation allow example team writes elixir business logic allow use otp even spawn process etcwhat biggest difference implementing backend video game http rest json api boil two thing latency statestategames statefull send data needed finish restbased transaction json would huge upstream downstream game also tend react event user generate bidirectional communication strong requirement example player attack player player need notified event different action may triggered player online also state may need presented player last example player may see player combat heshe may jump help player typically ecommerce site latency may completely unnoticeable however game m could difference winning losing constantly concerned latency includes thing like time spent serializingdeserializing communication much data sending wire long spent accessing db etc etcwhat main difference implementing actual game game development tool developing toolslib v product go directly consumer tool need think tool also think others use flexibility work n different use case etc game know exactly product behave quickly tell thing work tool may work great designed use case creative engineer decided repurpose completely different way toolslib developer challenge flexibility support bothwhat experience using riak core like riak core cool library really look two anglesdo buy whole consistency hashing thing want implement solution two year ago said yes first question however getting riak core work elixir environment painful rolled solution worked well actually bit faster riak core however nearly robust handle node failure handoff well recently phoenix basho got hex package actually work elixir jumped chance try evaluation decided little bit performance gain got system outweighed expanded functionality riak core providedlikedvery robust software handle lot error case usbuilt gossip protocolhandles data handoff new node brought onlinedislikedependencies work basho base libstools erlang heavy weightdifficult track error deep system codeis anything miss implementing actual videogames working videogames truly unique experience working smart engineer also get work closely artist game designer musician sometimes even actor fun exciting environment
290,Lobsters,elixir,Elixir programming,The BEAM Book (Exhaustive book on Erlang/Elixir VM),https://github.com/happi/theBeamBook,beam book exhaustive book erlangelixir vm,beam book latest stable release online webpage bookasciidoc github io page contributing style guide comment asciidoc linking otperlang source code directory structure build tag chapter section figure process issue tracker building pdf locally source docker dcokerasciidoctor linux mac osx asciidoc asciidoctorpdf asciidoctordiagram ditaa graphviz rouge wget mac osx using brew etc license http githubcomhappithebeambook short personal history book,beam book attempt document internals erlang runtime system erlang virtual machine known beam read download book pdf latest stable release online webpage book written asciidoc read directly source github browser read book online open file bookasciidoc also read github io page contributing plan make book project collaboration effort get complete documentation erlang runtime system soon possible please feel free contribute since work far done contribute raising issue comment open issue create branch fix addition note book released creative common license see anything contribute also included license chapter book one four state placeholder basically title perhaps outline chapter done interested writing chapter part chapter grab corresponding issue start writing first draft text place editing needed feel free comment focusing missing content hard read passage order section within chapter diagram picture needed plain error final draft spelling error probably still need fixing done otp version x thing change later version erlang otp chapter need update chapter yet marked way style guide several way use asciidoc construct work better environment target priority asciidoc code project render nicely following target following order pdf target html target view directly github try come specific guide asciidoc construct use add discover work nt work comment asciidoc chapter begin comment status chapter one placeholder first draft final draft done erlang xx also link issue describing needed bring chapter next level comment code start linking otperlang source code refering source code erlangotp please add link tagged version master code github link http erltimeh directory structure build try keep root directory clean put chapter separate asciidoc file chapter directory use underscore separate word chapter name try use oneword file name chapter put code used chapter codechapternamechaptersrc add include code apcodelistingsasciidoc put image image directory tag chapter section figure following yet done consistently please feel free contribute fixing tag current version chapter tag start ch word tag separated underscore part tag start p section tag start sec figure tag start fig appendix tag start ap code listing tag appendix start listing process find something understand incorrect please raise issue issue tracker find spelling formatting error feel free fix make pull request larger rewrite check status chapter check issue see someone likely working chapter right someone else working chapter try contact person major rewrite otherwise either go ahead rewrite pull request start opening issue declaring intend building pdf locally source project contains makefile let build pdf source provided needed tool installed docker docker image asciidoctor available dcokerasciidoctor linux wip updated mac osx install asciidoc install asciidoctorpdf install asciidoctordiagram install ditaa install graphviz install rouge install wget make mac osx using brew etc brew install asciidoctor gem install asciidoctorpdf gem install asciidoctordiagram brew install ditaa brew install graphviz gem install rouge brew install wget make license erlang runtime system erik stenman licensed creative common attribution international license based work http githubcomhappithebeambook complete copy license found short personal history book erik stenman happi started writing book back first thinking self publishing book blog since english nt native language felt needed help good editor managed get deal oreilly started converting outline build process original plan long thorough book editor felt would get reader started cutting content tried write tutorial manual unfortunately progress slow presales even slower publisher cancelled book managed get new deal pragmatic started converting content build system rewriting book according pragmatic style new publisher cutting content even series editor also wanted fit book elixir series tried add elixir example really manage make elixir book also progress still slow led another cancellation book early three repository three different book building system three different outline book end le went back original longer book outline original asciidoc build system started new repository private github account started pulling content three different version april opened repository public share student nt think anyone else would notice planning release book real yet since repo currently contains bit piece different version book interest expected though fortunately also several willing contribute book collaborative effort document erlang runtime system ert released creative common license see watch space news see whole book take shape erik stenman aka happi
291,Lobsters,elixir,Elixir programming,Testing Mix Tasks in Elixir,https://jc00ke.com/2017/04/05/testing-elixir-mix-tasks/,testing mix task elixir,mix task jwt phoenix route task test assertreceived top file twitter option update kelvin stinghen clarified umbrella,best way test mix task needed write custom mix task yesterday wanted start right writing test wanted reuse code generates verifies jwt spit terminal code always relatively simple defmodule mixtasksjwtgen use mixtask shortdoc generates jwt moduledoc generates jwt far far future mix jwtgen def run argv exp jokencurrenttime jti randuniform i jesse jwt jwtgeneratejwt exp exp jti jti i i mixshellinfo jwt end end test started looking like defmodule mixtasksjwtgentest use exunitcase async true import exunitcaptureio describe test print valid jwt jwt captureio fn mixtasksjwtgenrun end stringtrim token jwtverify jwt refute tokenerrors end end end ok fine annoying side effect jwt printed stdio ran test thought captureio supposed actually capture suppress wrong missing something ended case figured best guidance could get would see phoenix found example route task test test format route specific router mixtasksphxroutesrun phoenixtestwebrouter assertreceived mixshell info route ooh assert route pagepath get pagecontroller index end yes assertreceived seems like cleaner way go change test defmodule mixtasksjwtgentest use exunitcase async true describe test print valid jwt mixtasksjwtgenrun assertreceived mixshell info jwt pattern matching ftw token jwtverify jwt refute tokenerrors end end end much nicer still though jwt printed stdio even know begin searching handle went back phoenix test noticed helper required coderequirefile installertestmixhelperexs dir key top file get mix output sent current process avoid polluting test mixshell mixshellprocess changed test include unwanted output went away happy shape test get mix output sent current process avoid polluting test mixshell mixshellprocess defmodule mixtasksjwtgentest use exunitcase async true describe test print valid jwt mixtasksjwtgenrun assertreceived mixshell info jwt pattern matching ftw token jwtverify jwt refute tokenerrors end end end hope save trouble love hear test task mention twitter link gist add option ended using optionparser could pas exp i jti final test looked like coderequirefile mixtesthelperexs dir defmodule cerebrojwtgentest use exunitcase async true alias mixtasksjwtgen describe setup context genrun context argv assertreceived mixshell info jwt token cerebrojwtverifyjwt jwt ok claim tokenclaims token token end tag argv test print valid jwt args token token refute tokenerror end tag argv exp test print valid jwt passed expiration claim claim assertindelta claim exp jokencurrenttime end tag argv jti fdsa test print valid jwt passed jti claim claim assert claim jti fdsa end tag argv i logan test print valid jwt passed i claim claim assert claim i logan end tag argv token asdf test print valid jwt passed token claim claim assert claim token asdf end end end really happy way turned update kelvin stinghen clarified one might use mixshell mixshellprocess umbrella application setup mixshell mixshellprocess onexit fn mixshell mixshellio end ok end jesse
292,Lobsters,elixir,Elixir programming,Getting started with Elixir,https://blog.scottnonnenberg.com/getting-started-with-elixir/,getting started elixir,javascript dangerous cliff nodejs functional design elixir ruby erlangotp erlang open telecom platform joe armstrong thesis creation erlang josé valim plataformatec quite pedigree according joe armstrong prolog smalltalk csp functional programming ruby dcgs haskell road elixir objectoriented programming expensive disaster must end objectoriented programming inheritance encapsulation polymorphism clojure word code variable started uppercase character atom otherwise erlang string data type university washington cse programming language class ml ocaml jsofocaml project clojurescript om especially object came custom constructor thoughtworks technologytool radar proper unicode support mainstream language first take phoenix phoenix rail installed fromscratch getting started tutorial day one elixir basic elixir guide impressive http fun commit http hexdocspmelixirkernelspecialformshtml noteworthy warning added noparameter function call without parenthesis http elixirlangorggettingstartedcasecondandifhtml expressionsinguardclauses http question day two going deeper enumerables stream impressive http hexdocspmelixirwritingdocumentationhtml flow http erlangorgdocappsstdlibindexhtml noteworthy http elixirlangorggettingstartedprotocolshtml http elixirlangorggettingstartedcomprehensionshtml question http wwwdjmorgukpostselixirbehavioursvsprotocolswhatisthedifference http elixirlangorgcrashcoursehtml notabledifferences day three mix impressive http hexdocspmelixir noteworthy question impressive http hexdocspmelixirsupervisorhtml modulestrategies http elixirlangorggettingstartedmetaquoteandunquotehtml noteworthy http hexdocspmelixirkernelspecialformshtml http elixirlangorggettingstartedmetamacroshtml writemacrosresponsibly question excited certain domain interest elixir doc,time spend javascript brush dangerous cliff nodejs gravitate toward functional design principle thus periodically find looking functional language deepest gone far elixir excited elixir rubylike language built erlangotp known high availability faulttolerance initially created ericsson hence er erlang open telecom platform primarily used telephone switch opensourced joe armstrong creator erlang talk reliability thesis creation erlang time writing largest project major ericsson product million line erlang code product thought one reliable product ever made ericsson switching system run acceptable level service even presence error telephone exchange expected extremely reliable typically le two hour downtime year elixir developed josé valim plataformatec first released modern language quite pedigree according joe armstrong erlang syntax derived prolog heavily influenced smalltalk csp functional programming elixir heavily influenced erlang ruby erlang brings pattern matching higher order function entire process error handling let crash philosophy ruby brings sigils shortcut syntax also add goody pipe operator reminiscent prolog dcgs haskell monad though le complicated like good old unix pipe operator macro quote unquote operator come lisp quasiquote comma operator new language built top good idea road elixir first encountered eyeopening article objectoriented programming expensive disaster must end originally taught objectoriented programming principle first college programming class via c largely stayed tradition thereafter java c net ruby surprised discover need mix method data together classical object get claimed benefit objectoriented design like inheritance encapsulation polymorphism got excited conclusion article functional language haskell erlang clojure offer powerful approach problem software developer always faced socalled strength oop found language fan strict datatyping use haskell fan actor model use erlang like work flexible dynamic language immutable default use clojure especially paired previous discussion erlang like erlang work genius feel frustration get attention took look erlang language wanted work like word code variable started uppercase character atom otherwise erlang string data type top site looked like updated year couple month later worked way university washington cse programming language class learning ml pretty inspiring type inference functional purity part push looked ocaml jsofocaml project little bit still see writing much code another couple month later took look clojurescript om impressed ultimately like required conversion back forth javascript native object clojurescript data type especially object came custom constructor finally past fall heard elixir couple different place including trial zone thoughtworks technologytool radar took look surprised see built top erlangotp runtime impressed year previous paged userfriendly tutorial little bit pleasantly surprised proper unicode support uncommon mainstream language officially list learn first take phoenix generally pursue fastest road productivity long later went directly fullfeatured framework phoenix fit bill attempt bring railslike productivity world elixir installed went fromscratch getting started tutorial impressed fast userfriendly really nice error message page felt comfortable typing thing fully understand really cool stuff wanted understand fully really savor day one elixir basic couple week later time devote went right elixir guide got started kept track impressive thing thing thought worth keeping mind either due unintuitive perhaps even bit disappointing also kept track question answered immediately ever case tutorial went back research later impressive help iex console h h string h stringmatch specifies stringmatch overload take two parameter tabcompletion console string tab tab data immutable local variable rebound thing like macro make like function take condition true block false block doend block syntactic convenience top false else end keyword list like false else excellent string support specifically standard problem listed fixed http fun commit powerful patternmatching operator third third head tail head tail rest hello rest llo x binary x need cast treat x remainder instead next single element guard used ensure precondition always met function pattern matching etc capture operator required capture function variable pas parameter http hexdocspmelixirkernelspecialformshtml enum module functional list manipulation method would expect map reduce mapjoin mapreduce flatmapreduce noteworthy div rem integer division method v return float value atom string call method without parenthesis like ruby warning added noparameter function call without parenthesis singlequote string integer list list doublequote string real string bitstring list linkedlists linear lookup tuples stored contiguously memory faster subitem lookup counting element data structure elixir also abides simple rule function named size operation constant time ie value precalculated length operation linear anonymous function use singlearrow dash doublearrow equal sign andornot accept booleans accept type type coercion like triple equal happily accepts type precedence number atom reference function port pid tuple map list bitstring variable rebound elixir used patternmatching two way use pin operator want pattern match existing variable value rather rebinding variable used placeholder match variable special never read trying read give unbound variable error make function call left side match limit guard expression http elixirlangorggettingstartedcasecondandifhtml expressionsinguardclauses cond like elseif language look first result evaluates true cond considers value besides nil false true binary bitstring number bit divisible create bitstrings number bit per entry char list singlequote string practice char list used mostly interfacing erlang particular old library accept binary argument keyword list useful optional parameter duplicate key linear lookup syntax b equivalent b created implicitly last parameter provided function call call b accessing certain key us syntax list key nonexistent key lookup recursive nonexistent lookup return nil instead crash map constanttime lookup unique key key type syntax b useful pattern matching map match long key pattern exist given map also key map atom use keyword syntax convenience b two technique get map value mapkey crash missing key map key return nil missing mapkey recommended fail fast http interesting method deep accessmodification kernel module defmodule define function private function use default parameter value expression function multiple clause default value separate bodyless clause like def dowork x ioputs hello range like enumerable enum function operate sadly rangerange way test match rest type function question day two going deeper next day continued language tutorial enumerables stream impressive elixir treat documentation firstclass provides many function access documentation right inline moduledoc doc http hexdocspmelixirwritingdocumentationhtml pipe operator turn enumsum enumfilter enummap odd enummap enumfilter odd enumsum result previous expression inserted first parameter next function call stream give lazy evaluation pipe syntax even streamcycle infinitely repeating stream streamunfold like opposite reduce need return tuple result next remaining state like stringnextcodepoint erlang process core building block concurrency lightweight create thousand given o process little impact spawn spawnlink create new erlang process direct use unlikely taskstart taskstartlink better monitoring management supervisor agent genserver take even messagepassing via send receive adding retrieving thing processspecific mailbox file full complement method cpr mkdirp rmrf standard set path manipulation method well path plain string import customized excluding including part target module related keywords alias require use inside module even function protocol like interface enumerable regular expression rfooi implemented sigils mechanism extension language eight different delimiters used depending character inside make thing easier note actually compiled created runtime interesting sigils sigil string double quote string escape character interpolation useful doc moduledoc make custom sigils sigiln function would provide n sigil type specification type type reused spec describe signature function typep private type dialyzer builtin erlang static analysis tool us analyze code reminds flow erlang standard library code available http erlangorgdocappsstdlibindexhtml noteworthy terse maybe bit much another use operator anonymous function odd rem equivalent odd fn x rem x end character give codepoint character receive block receives something though provide timeout clause send blocking method end like file method throw fail instead returning tuple like error enoent use want handle error case fail fast pathexpand go tilde directory full directory turn file io stringio method actually create separate process get back pid process id use macro expands pulling external code applying functionality current module keyword syntax compiletime construct specific elixir used sort stuff adding documentation tagging test case exunit building set middleware handle incoming http request plug structs provide compiletime guarantee original field exist map secret field storing type struct called bare standard protocol like enumerable available structs use map module method though enforcekeys required field behavior seems almost like protocol method shape defined via callback weirdness protocol handle type know use derive module fall back protocol global solution fallbacktoany protocol generally though error specific implementation better http elixirlangorggettingstartedprotocolshtml really common protocol stringchars tostring interpolation enumerable inspect iex console comprehension extremely powerful enumeration construct kind look like forin statement http elixirlangorggettingstartedcomprehensionshtml clause allows control exactly resultant value handled via collectable protocol tryrescueafter exists elixir developer rarely use tryrescue construct seems useful finallystyle cleanup use without initial try doafterend throw uncommon uncommon practice except interfacing library provide proper api finishing computation make sense erlang builtins available erlangtrunc etc creating typespecs use elixir string use stringt callback behavior work together create something like interface generate compiletime error fully implemented question get list thing inside directory see readdir difference protocol behavior callback kind subtle difference seems one able supporting different type data given algorithmintent contract modularization protocol handle polymorphism datatype level whereas behaviour provide module level http wwwdjmorgukpostselixirbehavioursvsprotocolswhatisthedifference callback component behavior defining part api surface area know elixir difference erlang useful article http elixirlangorgcrashcoursehtml notabledifferences erlang endofstatement character period erlang allow redefinition variable variable need start uppercase atom imanatom v imavar elixir normalizes erlang subject function always first argument allows pipe operator data structure function employ zerobased access elixir better string string erlang refers char list string module aware work mostly char list erlang runtime compilation regular expression v compiletime elixir r sigil day three mix point tutorial moved language feature tool library come along language first mix project automation tool used generating project running test installing dependency impressive really compiling adding doc attribute showing iex console h beautiful doctest test file verifies code example documentation exdoc take inline doc build web page like official elixir doc http hexdocspmelixir noteworthy mixenvprod option dev test use exunitcase async true give parallel test run might expect async must set test case rely change global value important never convert user input atom atom garbage collected hex package manager mix hexoutdated mix depsget useful pull dependency directly git repository even specify tag annoying pattern matching map requires item item instead item want tuple syntax first second linked process end process sent message like ref process pid reason ref thing come back processmonitor pid genserver allows write client api server functionality one module callbacksbehaviors elixir facilitate functional split callback run process created server test context exunit available callback like setup test includes default key like case test file line say project think mix mix tool manages project talk application talk otp application entity started stopped whole runtime question get doc module compiled memory c define attribute add onto test getting error tag external specify new attribute give new value mix test watch exactly code coverage work report work getting warning usage earmarktohtml deprecated error trying build html doc exdoc exdoc issue looking typescallbacks genserver see term type sure coming get list running otp application vm applicationstartedapplications four day finally ready dig core concept faulttolerant application world erlangotp supervisor application impressive observerstart show builtin erlang monitor gui application tab top show visual representation process tree toplevel otp application supervisor restart process number configurable strategy http hexdocspmelixirsupervisorhtml modulestrategies mix generates mixlock file guarantee repeatable build lock file must checked version control system guarantee everyone us project use dependency version construct patternmatching corollary operator wow quote return abstract syntax tree ast code provided unquote execute ast http elixirlangorggettingstartedmetaquoteandunquotehtml produce original source code provided ast quote true else equivalent quote true else end unquotesplicing take block code behaves code copied current context code block inserting array element macro take code construct transform code construct injected back original code macroexpandonce help debug showing intermediate code run turned bytecode macro interfere variable already target scope unless var surround target value noteworthy mean recent mix support umbrella project umbrella project allow create one project host many application keeping single source code repository use mix new appspath instead app inside def project mixexs mix new build supervision tree ouch proper datetime implementation requires timezone database currently provided part elixir much elixir overridden macro part overridden called special form http hexdocspmelixirkernelspecialformshtml great power come great responsibility key tip macro http elixirlangorggettingstartedmetamacroshtml writemacrosresponsibly wow finally dsl section understand phoenix plug exunit provide much functionality example special macro name using run use keyword beforecompile run right code generation see module documenation attribute macro go well together compiletime attribute provide temporary storage macro might need behaviour attribute defined module british spelling question good time zone databaselibrary elixir excited started project use new knowledge graphql postgres certain domain interest far extremely productive unlike nodejsjavascript world feel like fighting system anymore async operation pure functional style like basic like testing documentation spend lot time elixir doc lot le searching new module check suspect enjoy resource
293,Lobsters,elixir,Elixir programming,Phoenix 1.3 is pure love for API development,http://swanros.com/phoenix-1-3-is-pure-love-for-api-development/,phoenix pure love api development,chris mccord talk new folder structure thinking ahead powerful written also mean centralized list error code api expose client module final thought link edit actionfallback context phoenix made controller tiny,phoenix released still final release already feel solid h ck personal project side web api component wrote phoenix first time using phoenix serious project intend ship release phoenix watched chris mccord talk change brings table decided rewrite api scratch new version oh boy great firstimpressions new folder structure said lot time phoenix rail elixir core team sure want notion dead web folder model concept going explain everything chris talked keynote lonestar elixir seriously go watch think worth saying change folder structure phoenix project bigger implication file moving one place another concrete boundary actual elixir application interface phoenix provides communicate web responsibility separation design love thinking ahead long gone mix phoenix command say hi mix phx le thing type love also generator make think advance want actually instance phoenix could something like mix phoenixgenjson user user email string would generate right migration model defmodule myappuser use myappweb model schema user field email string end end along web controller would handle crud task logic validation within action time using structure easy end controller action hundred line long phoenix need specify context resource create call model anymore mix phxgenjson account user user email string command account context module going also generated context interact user module accountsgetuser user email oscar swanroscom accountscreateuser params ok newuser powerful define clear boundary application domain say concept contact application user user contact also user instance get messy written using new notion context contactrelationship context handle everything clean way user contactrelationshipsrelationshipwith anotheruser contactrelationshipsaccept user contactrelationshipsgetcontacts user contactrelationshipsrequestcontact anotheruser scenario would make folder structure look something like lib myapp account contactrelationships web defining concrete boundary responsibility within app make come better code time actionfallback far addition framework really nice welcomed however think favorite one new actionfallback plug phoenix earlier every controller needed return valid conn every request otherwise exception would rise still true new actionfallback plug delegate task another controller whose sole purpose handle case controller provide successful response request let wrote code similar every controller action def create conn user userparams user repogetby user phonenumber userparams phonenumber cond user checkpw userparams password userpasswordhash case createsession user ok session conn putstatus created render showjson session session user user conn putstatus unauthorized render errorjson end true dummycheckpw conn putstatus unauthorized render errorjson end end bad truly still better phoenix actionfallback myappwebfallbackcontroller def create conn user userparams user accountsgetuserbyphone userparams phonenumber cond user checkpw userparams password userhashedpassword ok session session sessionscreatesession user conn putstatus created render authsuccessjson user user session session end true error wrongcredentials end end phoenix controller action simplified care happy path leave rest fallback controller define using actionfallback plug case cond evaluates true return action error wrongcredentials since valid connection fallback controller come forward defmodule myappwebfallbackcontroller use myappweb controller def call conn error ectochangeset changeset conn putstatus unprocessableentity render myappwebchangesetview errorjson changeset changeset end def call conn error unauthorized conn putstatus unauthorized render myappweberrorview authrequiredjson end def call conn error wrongcredentials conn putstatus unprocessableentity render myappweberrorview wrongcredentialsjson end end pattern matching fallback controller know exactly send back response request also mean centralized list error code api expose client errorview module error definition scattered around codebase however stop error api default response action rely fallback controller display def delete conn params ok session authenticationgetsession conn ok deleted sessionsdeletesession session success else error unauthorized end end success passed appropriate action fallback controller go default response final thought phoenix great update please keep mind default offer could done fact default really speaks much attention detail phoenix team putting want u using phoenix rather provide sensible default enable u create solution best possible way point new fallbackcontroller plug awesome fact need think term boundary app think eventually lead better maintainable codebases smarter code generation apis centralized list available error really welcomed love productive phoenix building apis really looking forward alreadygreat framework evolve past link edit also wrote actionfallback context phoenix made controller tiny
294,Lobsters,elixir,Elixir programming,Phoenix v1.3.0-rc.0 released,https://elixirforum.com/t/phoenix-v1-3-0-rc-0-released/3947,phoenix released,http wwwyoutubecomwatch http phoenix design intent context wojtekmach,promised first release candidate phoenix release focus code generator improved project structure first class umbrella project support scaffolding reenforces phoenix webinterface greater elixir application also included new actionfallback feature phoenixcontroller allows translate common datastructures domain valid response practice clean controller code give single plug handle otherwise duplicated code path particularly nice json api controller interested detailed overview change design decision check lonestarelixir keynote went live http wwwyoutubecomwatch use new phxnew project generator install archive following command mix archiveinstall http githubcomphoenixframeworkarchivesrawmasterphxnewez always upgrade guide detailed instruction migrating project http backwards compatible release upgrading easy bumping phoenix dep mixexs wanting adopt new convention upgrade guide take stepbystep upgrade worth watching keynote exploring design decision outlined phoenix design intent new project code generator take lesson learned last two year push folk towards better design decision learning change new project include moving web inside lib avoid special directory well introduction new web namespace convention signal phoenix related web module web interface greater elixir application along new project structure come new phxgenhtml phxhtmljson generator adopt goal isolating web interface domain context generate html json resource phxgenhtmljson phoenix generate code inside context simply wellnamed module wellnamed function representing api boundary part application domain example generate user resource run mix phxgenhtml account user user email string unique notice account new required first parameter context module code live carry business logic user account application peek part code generated libmyappwebcontrollersusercontrollerex defmodule myappwebusercontroller alias myappaccounts def index conn params user accountslistusers render conn indexhtml user user end def create conn user userparams case accountscreateuser userparams ok user conn putflash info user created successfully redirect userpath conn show user error ectochangeset changeset render conn newhtml changeset changeset end end end libmyappaccountsaccountsex defmodule myappaccounts moduledoc boundary account system alias myappaccountsuser def listusers repoall user end def createuser attrs user userchangeset attrs repoinsert end end also ecto schema generated inside libmyappaccountsuserex notice controller call api boundary create fetch user system still using ecto database application logic separated webinterface need know detail storage db representatin user account module could internally store user agent ets elsewhere controller code remains untouched asking user think boundary apis end maintainable well structured code additionally get glimpse application featureset exploring application directory structure libmyapp account userex accountsex sale ticketex managerex salesex repoex web channel controller template view glance directory structure see application user account system well sale system also infer natural boundary system thru salesex accountsex module gain insight without seeing single line code contrast previous webmodels reveal relationship file mostly reflected database structure providing insight actually related domain excited change longterm payoff maintainability also feel lead sharable isolated library whole community take advantage inside outside phoenix related project issue upgrading please find u elixirlang irc slack get thing sorted would also like give special thank wojtekmach help getting new generator ready primetime happy coding chris full changelog
295,Lobsters,elixir,Elixir programming,Lonestar Elixir 2017,http://www.youtube.com/playlist?list=PLE7tQUdRKcyaMEekS1T32hUw19UxzqBEo,lonestar elixir,,
296,Lobsters,elixir,Elixir programming,Nerves and Elixir Updates - (Lonestar ElixirConf 2017- Keynote by Justin Schneck),https://www.youtube.com/watch?v=pVHhmqYozOM,nerve elixir update lonestar elixirconf keynote justin schneck,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature lonestar elixirconf opening keynote justin schneck youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature lonestar elixirconf opening keynote justin schneck youtube
297,Lobsters,elixir,Elixir programming,Phoenix with Ecto and MongoDb,http://tomjoro.github.io/2017-02-09-ecto3-mongodb-phoenix/,phoenix ecto mongodb,get started background strategy quick start configure database start mongodb ecto changesets schema example creating new user example finding single one user example updating document example updating document changeset example embedded document example find one update bson date format mix integration migration reset seed caveat note conclusion proposal,use mongodb phoenix ecto might sound confusing use newest version phoenix use newest version ecto use mongodbecto instead use newest version mongodb driver mongodb post explains technique leverage feature ecto eg changesets directly mongodb driver work well together also post show use mongodb driver much documentation available mongodb driver site post show thing like index find update set etc get started start project create new phoenix project without database specified ecto included default adjust mix etc adding directly mongodb driver follow instruction post startup etc background ecto supported mongodb ecto created lot confusion developer want use mongodb phoenix web application downgrade earlier version ecto want use mongodb phoenix use newest version ecto mongodb driver small amount code post strategy let use many ecto cool feature like changesets also directly using mongodb driver might sound hacky mongodb driver thanks ericmj really excellent quality used mongodb ruby javascript find make lot sense blog learn use mongodb driver elixir phoenix ecto use ecto mongodb driver example code snippits help get started strategy want build phoenix application us mongodb use latest greatest version phoenix ecto use mongodb driver directly ecto version ecto ecto lot great stuff like changesets great work really well mongodb explain going use repo part ecto one great thing elixir phoenixecto really many deep dependency difficult mixexs look like may differ point get mongodb ecto database specific ecto driver defp deps phoenix phoenixpubsub phoenixhtml phoenixlivereload dev gettext cowboy mongodb poolboy phoenixecto httpoison uuid loggerfilebackend exrm end application section application phoenix phoenixpubsub phoenixhtml phoenixecto cowboy logger gettext mongodb poolboy loggerfilebackend uuid httpoison quick start configure database added prodexs devexs testexs prodexs config myapp db name mymongoprod devexs config myapp db name mymongodev testexs config myapp db name mymongotest start mongodb libmyappex defmodule myapp use application def start type args import supervisorspec define worker child supervisor supervised child supervisor myappendpoint start mongo worker mongo database applicationgetenv myapp db name name mongo opts strategy oneforone name myappsupervisor result supervisorstartlink child opts index myappstartupensureindexes result end def configchange changed new removed myappendpointconfigchange changed removed ok end end mongodb started database pool also take opportunity ensure index need ensureindexes function look like find lot documentation command like back door mongodb let anything defmodule myappstartup def ensureindexes ioputs using database applicationgetenv myapp db name mongocommand mongo createindexes user index key email name emailidx unique true end end ecto changesets ecto us schema validate changeset use ecto schema field know always really handy field dynamic schema really help case fine like bit trick using changeset realize change function give exactly syntax need insert mongodb could sweeter schema include whole thing enough get idea defmodule myappuser use myappweb model require logger primarykey id binaryid autogenerate true id map uuid schema user field email string field phonenumber string field firstname string field lastname string field status string end def changesetnewuser user params params scrubparams params change nil user cast params email phonenumber firstname lastname validaterequired email validatephonenumber putchange status end example creating new user example create new user controller defmodule myappusercontroller changesetnewuser myappuserchangesetnewuser myappuser params ok user mongofindoneandreplace mongo user changesetnewuserchanges returndocument upsert true loggerinfo created new user inspect user example finding single one user cursor mongofind mongo user email someone somewherecom limit list enumtolist cursor length list ok hd list else error nil end got pull request findone version may become near future user mongofindone mongo user email someone somewherecom example updating document use set make change ok userafter mapsize userupdatechangesetchanges mongofindoneandupdate mongo user email someone somewherecom set userupdatechangesetchanges returndocument example updating document changeset application like field known ahead time use changesets whole point mongodb flexible schema mean know field key name ahead time think good strategy separate logic dynamic update code use snippit controller take id user bunch update warning parameter validated service working internally already validated probably want validate thing stuff mongodb def putclient conn params userid params id need merge x attribute attribute params mapdelete id reduced enuminto attribute fn key value key value end ok user mongofindoneandupdate mongo user email someone somewherecom set reduced returndocument example embedded document quite often want array model embedded document created another model object use changeset directly manage inserting array like ok result mongofindoneandupdate mongo user email someone somewherecom push address oneaddress returndocument removing pull mongofindoneandupdate mongo user email someone somewherecom pull address oneaddress example find one update case actual field schema use changeset change userupdatechangeset myappuserchangesetupdateuser myappuser params ok userafter mongofindoneandupdate mongo user email someone somewherecom set userupdatechangesetchanges returndocument note change ecto struct change give map change bson date format routine get timenow bson format mongodb always good idea use date format bson format mongodb understands help query etc defmodule myappbsontime epoch epoch calendardatetimetogregorianseconds epoch def fromerltimestamptoecto erlts timestamp fromostimestamptousec erlts t trunc timestamp t t epoch tstuple calendargregoriansecondstodatetime t need remainder u rem h mn tstuple h mn u end def fromostimestamptousec megasecs sec microsecs megasecs sec microsecs end def bsontimenow ostimestamp nowecto fromerltimestamptoecto bsondatetimefromdatetime nowecto end end bson date returned mongo probably want render view serialize json updatedat user updatedat schema bsondatetime specified string field createdat string use like user createdat myappbsontimebsontimenow since using ecto persistence get automatic timestamp feature ecto case easiest thing follow pattern using business logic layer make mongoid like driver could automatic management insertedat updatedat example mongodb document id timestamp already embedded mix integration migration kidding mongodb collection come existence instant try insert one field present document write one thing startup ensureindex see reset needed database reset seed ecto mix task going work made defmodule mixtasksmyappreset use mixtask shortdoc reset data database moduledoc might better way list collection listed def run args mixtaskrun appstart mixshellinfo reset data mongodeletemany mongo user mongodeletemany mongo pony end end drop index need drop index mongodb console dbusersdropindexes seed seeding create little mix task devops guy hate special case seeding service use mongodb instead postgresql one line code mix myappreset mix myappseed defmodule mixtasksmyappseed use mixtask shortdoc seed moduledoc def run args mixshellinfo seeding user starting application mixtaskrun appstart user email someone somewherecom mongoinsertone mongo user user end end caveat mix atom stringkeys map driver like another reason use ecto changesets everything end atom even string key otherwise resort walking map getting fixed example phoenix enum map convert atom string viceversa note thanks friend posting comment actually bunch thing forgot mention remove mongodbecto mixexs add elixir mongodb driver shown delete repoex since need make sure add startup code myappex note start remove myapprepo also remove ectoadapterssqlsandbox stuff testsupportconncaseex etc test use deletemany setup test since transaction feature mongodb anyways database set test started automatically follow instruction conclusion mongodb driver elixir proven reliable also support replica set also work well phoenix need little bit configuration good go liked article correction addition send email pullrequest sure developer done similar solution proposal would great something akin rail mongoid driver elixirphoenix would grab best part ecto branch provide handy feature dealing various time date timestamps id etc embedded document tag elixir phoenix mongodb
298,Lobsters,elixir,Elixir programming,Drab - Manipulate UI directly from an Elixir backend,https://github.com/grych/drab,drab manipulate ui directly elixir backend,see demo page live demo description teaser prerequisite installation guide installation guide browser requirement installation manual installation phoenix web application umbrella go usage example available demo page documentation getting help elixirforumcom test sandbox sandbox test chromedriver manual installation want use drabquery jquery based module contact grych tgpl http wwwvecteezycom,see demo page live demo description drab access browser user interface server side javascript programming needed anymore drab extends phoenix framework remote control ui browser live idea move user interface logic serverside eliminate javascript ajax call teaser div class progress div class progressbar progressbarclass role progressbar stylewidth barwidth barwidth div div button class btn btnprimary drabclick performlongprocess longprocessbuttontext button defhandler performlongprocess socket sender poke socket progressbarclass progressbardanger longprocessbuttontext processing step randuniform step processsleep randuniform simulate real work poke socket barwidth floatround step end poke socket progressbarclass progressbarsuccess longprocessbuttontext click restart end prerequisite elixir see installation guide phoenix see installation guide browser requirement requirement phoenixsockets depends javascript call potential tool use top drab installation first need phoenix application top install drab standard app generated mix phxnew may use drab installer make running one simple step otherwise see manual installation section edit mixexs main folder web application multiple application umbrella one ending web locate function deps search def deps string add entry drab list nt forget comma def deps drab end download install package go application directory phoenix web application umbrella go run mix drabinstall bash mix drabinstall checking prerequisite myapp libmyappwebtemplateslayoutapphtmleex libmyappwebchannelsusersocketex configconfigexs configdevexs installer going modify file ok proceed yn drab successfully installed phoenix application time create first commander example pagecontroller mix drabgencommander page congratulation installed drab proceed commander please notice drab run page corresponding commander usage drab function callback event handler placed module called commander think controller live page commander placed webcommanders directory enable drab page generated corresponding controller need create twin commander example myapppagecontroller commander named myapppagecommander remember difference controller render page commander work live page generate page commander commander name correspond controller pagecontroller pagecommander mix drabgencommander page creating webcommanderspagecommanderex add welcometext assign index action controller used future defmodule myapppagecontroller use exampleweb controller def index conn params render conn indexhtml welcometext welcome phoenix end end rename template webtemplatespageindexhtmleex indexhtmldrab edit template webtemplatespageindexhtmldrab change fixed welcome text assign div class jumbotron welcometext edit commander file webcommanderspagecommanderex add real action onload callback fire browser connects drab server defmodule drabexamplepagecommander use drabcommander onload pageloaded drab callback def pageloaded socket poke socket welcometext page drabbed setprop socket divjumbotron plead innerhtml please visit hrefhttps tgpldrab drab page end end function update assign update property dom object done live without reloading page run iex mix phoenixserver go http see changed web page may play page live directly iex observe instruction given browser connects page debug started drab samepath handling event drabexamplepagecommander may debug drab function iex copypaste following import drab core element live socket drabgetsocket pid example socket execjs alert hello iex socket poke count instructed copy paste two line check could remotely control displayed page iex alert socket alert title like modal button ok juści cancel poniechaj ok iex poke socket welcometext wow nice phoenixsocket iex query socket divjumbotron innertext ok innertext wow nice iex setstyle socket divjumbotron backgroundcolor red ok example available visit demo page live demo description visit documentation page getting help drab thread elixirforumcom please address question test sandbox since drab equipped phoenix server running integration test automatically sandboxing playing sandbox git clone git githubcom grychdrabgit cd drab get deps node module mix depsget npm install nodemodulesbrunchbinbrunch build iex mix phoenixserver import drab core live element query waiter socket drabgetsocket pid iex query socket innertext ok header innertext drab test pageloadedindicator innertext page loaded iex setprop socket innertext updated iex ok iex execjs socket alert like alert ok nil test drab test integration endtoend test thus require automated browser drab us chromedriver must running run test git clone git githubcom grychdrabgit cd drab get deps node module mix depsget npm install nodemodulesbrunchbinbrunch build run chromedriver run test mix test compiling file ex finished second test failure randomized seed manual installation add drab dependency mixexs initialize drab client library adding layout page apphtmleex layout use drabclientrun conn following line script src staticpath conn jsappjs script initialize drab socket adding following usersocketex add drab template engine application name endpoint configexs config phoenix templateengines drab drabliveengine config drab myappwebendpoint otpapp myappweb add drab application started default mixexs def application mod myapp application phoenix phoenixpubsub phoenixhtml cowboy logger gettext drab end needed running phoenix enable live reload drab page add drab extension live reload pattern devexs config myapp myappendpoint livereload pattern r privstatic jscsspngjpegjpggifsvg r privgettext po r webviews ex r webtemplates eexdrab using webpack get require defined error need provide socket appjs add global variable passed drab later windowsocket require phoenix socket tell drab use instead default require phoenix socket add configexs config drab myappwebendpoint jssocketconstructor windowsocket want use drabquery jquery based module add jquery boostrap packagejson dependency jquery bootstrap add jquery global end brunchconfigjs npm globals jquery jquery jquery bootstrap bootstrap install npm install nodemodulesbrunchbinbrunch build contact c tomek grych gryszkiewicz grych tgpl illustration http wwwvecteezycom
300,Lobsters,elixir,Elixir programming,A tour of Elixir performance & monitoring tools,https://hackernoon.com/a-tour-of-elixir-performance-monitoring-tools-aac2df726e8c#.b2v3ch2m1,tour elixir performance monitoring tool,tour elixir performance monitoring tool nasa mission control room metric collection exometer exometer recording metric storing metric reporting metric michael schäfermeyer elixometer elixometer beam resource usage observer observer wombat wombat recon recon application monitoring appsignal app monitoring agent scout learn new relic communitydeveloped agent new relixir newrelic roman smirnov take tracing profiling recon trace recon trace tap tap erlyberly elyberly getting started guide elyberly redbug redbug redbug tutorial dbg dbg dbg exception monitoring honeybadger experience elixir,tour elixir performance monitoring toolsworking bookletai cofounded scout server monitoring acq scoutapm acq nasa mission control roomupdated appsignal exited beta scout released beta agentyou diving elixir getting close releasing first production elixir app profile monitor production tour available elixir ecosystem today note many tool erlangbased access via elixirmetric collectiongeneric metric collection sensor array app counter user signups collecting average call time critical http call etc service assist collecting aggregating metric send metric another service ex graphite influxdb datadog etc visualization alertingexometerulf wiger magnus feuer exometer defacto erlang instrumentation package several part exometer recording metric tell exometer update value exometer run function interval choosing record valuesstoring metric raw metric stored via etf beam vmreporting metric metric aggregated forwarded onto external system like graphite amnq statsdthe following story michael schäfermeyer provides great overview exometer elixometerpinterest elixometer light elixir wrapper around exometer make definingupdating metric easier plus nice timed annotation easily time function execution time timing function metric name timed function key prefixdevtimerstimedfunction timed key timedfunction def functionthatistimed othermoduleslowmethodendbeam resource usagethere several tool monitoring resource usage beam vm run elixr erlang apps beam feel like operating system versus typical vm monitoring tool sophistication matchobserverthe default goto observer likely already installed computer try launching observer via iex observer also connect remote systemwombata fullfeatured operation maintenance framework wombat commercial software available via erlang solutionsreconrecon one module erlang recon application module provides access highlevel resource usage information beam vmfor example iex reconinfo self meta registeredname memoryused memory messagequeuelen heapsize totalheapsize garbagecollection maxheapsize errorlogger true kill true size minbinvheapsize minheapsize application monitoringapplication performance monitoring apm service instrument elixir function call provide breakdown performance via transaction trace apm tool orientated around monitoring web request v general performance monitoringappsignalappsignal officiallysupported app monitoring agent elixirscoutat day job released app monitoring agent elixir learn morenew relicnew relic officially supported agent couple communitydeveloped agent available new relixirnewrelic author newrelic module roman smirnov mentioned response newrelixir trigger performance memory cpu issue triggered newrelicerlang module address issuesmy take app monitoring magical form monitoring get lot little work however making magic happen involve hook application cause crash reason lean towards service official support team dedicated keeping monitoring agent updatedtracing profilingsometimes need walk application execution framebyframe debug issue several tool provide erlang elixir appsrecon tracepart previously mentioned recon application recon trace erlang module allows safe tracing function production environmenttaptap thin elixir wrapper around recon trace providing easy elixir interface recon trace iex require tapniliex tapcall stringstrip max stringstrip test e pid stringstrip test pid e erlyberlyelyberly provides gui interface debugging profiling erlang elixir apps addition tracing elyberly collection information process memory usage elyberly meant trace production system overload protectionthe folk plataformatec great getting started guide elyberlyredbugredbug productionsafe debuggingtracing utility erlang roberto aloi great redbug tutorial blogdbgdbg erlang module tracing also thin elixir wrapper around dbg monitoringmany existing exception monitoring service already support elixir elixir erlang unique take exception important see service exception logic match needssome option take prefer service use language monitor production firsthand experience monitoring pain honeybadger experience elixir production appssubscribe get daily roundup top tech story
301,Lobsters,elixir,Elixir programming,Creating a supervision tree for Elixir GenEvent behavior,http://pedroassumpcao.ghost.io/creating-a-supervision-tree-for-elixir-genevent-behavior/,creating supervision tree elixir genevent behavior,event sourcing cqrs genevent context event manager handler elixir genevent documentation reacting event manager failure let crash supervisor dealing handler failure watcher genserver,one project working right based event sourcing cqrs concept core content post think nice add context better understanding one component application event bus event manager using genevent behavior context summary application work following step interface sends command event manager command handler pick command sends message model model validates persists event event published event manager event handler pick event update projection basically one event manager two handler one command another one event go detail genevent work post elixir genevent documentation excellent place go question assuming know genevent general work following situation need considered term fault tolerance event manager fail restart event manager fails restarts handler need added back handler fails need added back event manager reacting event manager failure important part let crash philosophy deterministic way define happens something fails due fact nothing happen magically let use supervisor application supervise event manager later handler well application start call myappeventsupervisor defmodule myapp use application def start type args import supervisorspec warn false child supervisor myappeventsupervisor opts strategy oneforone name myappsupervisor supervisorstartlink child opts end end eventsupervisor module call myappeventmanager defmodule myappeventsupervisor use supervisor server module def startlink supervisorstartlink server ok name server end def init ok child worker myappeventmanager supervise child strategy oneforone end end event manager simply start defmodule myappeventmanager server module def startlink geneventstartlink name server end code omitted end case myappeventmanager crash reason myappeventsupervisor notified know restart manager dealing handler failure handler crash also dependent event manager health supervision complex let third component call watcher watcher responsible add handler back manager case handler failure crash event manager crash handler watcher simple genserver monitor event manager process know add handler manager application two handler one watcher handler example one defmodule myappcommandhandlerwatcher use genserver server module def startlink eventmanager genserverstartlink server eventmanager name server end def init eventmanager processmonitor eventmanager starthandler eventmanager end doc stop watcher case event manager go def handleinfo myappeventmanager node reason stop eventmanager end doc handle exit message genevent handler restarts def handleinfo geneventexit handler reason eventmanager ok eventmanager starthandler eventmanager noreply eventmanager end defp starthandler eventmanager case geneventaddmonhandler eventmanager myappcommandhandler ok ok eventmanager error reason stop reason end end end last missing piece supervise watcher restarting crash event manager crash defined way let add current eventsupervisor two worker defmodule myappeventsupervisor alias myapp eventmanager commandhandlerwatcher eventhandlerwatcher code omitted def init ok child worker eventmanager worker commandhandlerwatcher eventmanager worker eventhandlerwatcher eventmanager supervise child strategy oneforone end end important notice watcher add handler using monitor event manager function make watcher receive exit message handler manager handled function using pattern matching
302,Lobsters,elixir,Elixir programming,"Phoenix and Elm, a real use case (pt. 1)",http://codeloveandboards.com/blog/2017/02/02/phoenix-and-elm-a-real-use-case-pt-1/,phoenix elm real use case pt,introduction book everyone team elixir phoenix elm phoenix battleship react redux elm tboe elm spa elm phoenix elm elm phoenix application rail react installing elm hello world http hello world comment powered disqus comment powered,introduction long time since last post last september joined book everyone cool startup awesome product passionate talented team well busy since apart working team another main reason joining current stack elixir phoenix excellent opportunity solving real problem using favorite technology time also started play around elm functional programming language web rewriting pet project like phoenix battleship reactredux fan recently converted functional programmer felt right path take comfortable enough syntax architecture proposed building proof concept elm new frontend internal tool use tboe creating landing page week later poc ready pushed production working without single runtime error since much fun coding elm ca nt resist writing small series creating small spa covering basic topic integrating elm phoenix project routing elm program making http request socket support let get started elm people either know well worked know extremely passionate new technology start learning like however case elm different first heard elm almost year ago learning elixir first pet project think reading kind article redux fact thanks article discovered elm architecture inspired redux caught attention immediately initial try decided learning elixir enough task left elm later kept reading article tutorial version came decided give another try coding elm almost every day since joy time joy word truly represents experience coding elm functional immutable therefore need switching paradigm coding backend frontend type system combination gentle compiler force write good errorfree code talking compiler best error message ever seen look like tutorial nothing error message used also make refactoring really easy straightforward generates good javascript free runtime error compiles work browser true story decent package manager repository strict term publishing package even detects breaking change new version language framework tried redux find elm architecture easy understand familiar decent linting formatting package almost editor assist writing clean pretty code performant fast virtual dom get experiment real productivity boost could probably keep adding reason list let leave start fun part phoenix application continuing let take closer look going build following blog sure find familiar concept using since started writing rail react starting new phoenix application let create model need mix phoenixgenmodel contact contact firstname lastname gender integer birthdate date location phonenumber email headline text picture creates following migration file defmodule phoenixandelmrepomigrationscreatecontact use ectomigration def change create table contact add firstname string null false add lastname string null false add gender integer default add birthdate date null false add location string null false add phonenumber string add email string null false add headline text add picture string timestamps end end end previous command also creates basic modelschema bunch field webmodelscontactex defmodule phoenixandelmcontact use phoenixandelmweb model schema contact field firstname string field lastname string field gender integer field birthdate ectodate field location string field phonenumber string field email string field headline string field picture string timestamps end doc build changeset based struct params def changeset struct params struct cast params firstname lastname gender birthdate location phonenumber email headline picture validaterequired firstname lastname gender birthdate location phonenumber email headline picture end end need moment eventually adding fulltext search support see later nt forget run migration task moving next step mix ectomigrate installing elm order add elm project first need install necessary npm package npm install elm elmbrunch save going placing elm stuff webelm folder update brunchconfigjs file adding following change brunchconfigjs exportsconfig path watched webelm plugins elmbrunch elmfolder webelm mainmodules mainelm outputfolder staticjs telling brunch watch webelm folder configuring elmbrunch plugin set correctly let create webelm folder install first one elm package using mkdir webelm cd webelm elmpackage install elmlanghtml installs elm core html library creates basic elmpackagejson file similar npm packagejson file core configuration elm application version summary helpful summary project le character repository http githubcomuserprojectgit license sourcedirectories exposedmodules dependency elmlangcore v elmlanghtml v elmversion v add basic mainelm file main module simply return hello world message webelmmainelm module main exposing import html exposing html text main html main text hello world next need update main appjs file import javascript generated elm render result webstaticjsappjs import elm main const elmdiv documentqueryselector elmtarget elmdiv elmmainembed elmdiv want embed div elmtarget id let go ahead add div corresponding phoenix template webtemplatespageindexhtmleex div id elmtarget div ready start phoenix server check everything working fine output something similar iex mix phoenixserver erlangotp source hipe kernelpoll false info running phoenixandelmendpoint cowboy using http interactive elixir press ctrlc exit type h enter help iex elm compile mainelm webelm staticjsmainjs babel note code generator deoptimised styling webstaticjsmainjs exceeds max info compiling info compiled file file copied sec visiting http render hello world message browser enough next part dig bit elm architecture define application state start coding first elm module meantime take look repository final result see action live demo happy coding please enable javascript view comment powered disqus comment powered
304,Lobsters,elixir,Elixir programming,Building A Slack Bot in Elixir Part 2,http://bendyworks.com/blog/building-a-slackbot-in-elixir-part-2,building slack bot elixir part,building slack bot elixir part first part receiving slack message incoming outgoing bot user setting hook custom integration ngrok localtunnel receiving webhook predicting weather darksky api dependency httpoison poison keeping secret making request responding slack putting together spawn next step exvcr area forecast discussion floki,building slack bot elixir part first part tutorial covered basic defining running testing web server elixir using plug cowboy part tutorial build groundwork create slack bot fetch sends weather forecast receiving slack message tutorial using slack incoming outgoing webhook apis handle message traffic note slack also provides feature rich bot user api using simpler solution focus implementing elixir side le particular slack api setting hook begin need register new incoming outgoing webhook slack custom integration page notice outgoing webhook requires target url address slack send request unsurprisingly must publicly accessible could set application server control paas provider heroku much easier iterate make change app use localhost tunnel ngrok localtunnel development use ngrok set tunnel port app run running ngrok http ngrok provide url set outgoing webhook target also recommend defining trigger word forecast weatherbot wb otherwise easy accidentally get bot stuck loop triggering response receiving webhook verify slack integration set properly let define webhook route return ok simple response message add post route routerex following definition post webhook sendresp conn text ok end everything set correctly get response ok enter trigger word slack predicting weather fetch weather prediction using darksky api free tier allowing request per day following along go ahead sign account make note secret key given dependency need new dependency interact dark sky api httpoison making http request poison parsing json response see elixir follows ruby footstep regarding odd thematically appropriate library name refer readmes project previous post series instruction adding library elixir app keeping secret planning saving project via github another publicly accessible vcs solution want make sure nt commit dark sky api key incoming slack webhook set easy way accomplish without complicating application configuration create configsecretexs file config directory add gitignore instruct application load adding importconfig configsecretexs main configexs file example configsecretexs look like use mixconfig config weatherbot incomingslackwebhook webhook url config weatherbot darkskykey darksky key making request organize function interacting dark sky api let create new module libweatherbotweatherfetcherex following definition defmodule weatherbotweatherfetcher darkskyurl http apiforecastioforecast applicationgetenv weatherbot darkskykey def getforecast httpoisonget darkskyurl body poisonparserparse end def hourlyforecast getforecast mapget hourly mapget summary end def dailyforecast getforecast mapget daily mapget summary end def dailyandhourlyforecasts hourly hourlyforecast daily dailyforecast end end test new module opening iex prompt iex mix calling weatherbotweatherfetcherdailyandhourlyforecasts let break component part new function first fetching dark sky key via call applicationgetenv weatherbot darkskykey second line also unless really interested receiving weather forecast bendyworks hq want change latlong number end url fetch forecast data making call via httpoisonget api endpoint passing response body poisonparserparse case unfamiliar convention elixir generally mean function unsafe throw exception circumstance take parsed response represented map extract daily hourly summary combined via heredoc sigil build response responding slack create another new module libweatherbotslacksenderex sending forecast slack defmodule weatherbotslacksender def posttoslack encodedmsg httpoisonpost applicationgetenv weatherbot incomingslackwebhook encodedmsg end def sendmsg msg poisonencode username forecastbot iconemoji cloud text msg posttoslack end end module nearly reverse one wrote receive outgoing webhooks encodes json payload poisonencode post incomingslackwebhook url defined configsecretexs weatherbotweatherfetcher module test new functionality opening new iex prompt calling recompile existing one running weatherbotweatherfetcherdailyandhourlyforecasts weatherbotslacksendersendmsg putting together route router receive outgoing webhooks module fetch weather forecast dark sky api another module send forecast back slack wire together need make slight modification behavior webhook route although slack longer requires timely response outgoing webhook request still leverage elixir excellent concurrency facility friendlier responsive api consumer post webhook spawn fn weatherbotweatherfetcherdailyandhourlyforecasts weatherbotslacksendersendmsg end sendresp conn text ok end spawn new elixir process manage fetching forecast sending slack allow current process immediately respond original webhook request weather forecasting slack bot ready go run application mix run nohalt case forgotten able get forecast entering outgoing webhook trigger word slack next step fully functional weather forecasting slack bot lot could build simple app interested extending built far idea using exvcr write robust network independent unit test taking zip code address argument geocoding latlong using different iconemoji param depending weather condition delivering area forecast discussion requires web page scraping parsing coming ruby familiar nokogiri floki good elixir equivalent implementing complex behavior able ask rain today need jacket
305,Lobsters,elixir,Elixir programming,Make Phoenix even faster with a GenServer-backed key value store,https://robots.thoughtbot.com/make-phoenix-even-faster-with-a-genserver-backed-key-value-store,make phoenix even faster genserverbacked key value store,elixir gen server struct ecto ets erlang term storage supervisor elixir discussion otp topic heroku siege,developer many u build breakable toy various programming language learning something new goal learn language intricacy new product u reach todo apps others messaging clone like though url shortener built recent url shortener elixir decided see much raw speed could get application using genserver generic server build keyvalue store bypass database possible genserver one mechanism leveraging state elixir perfect use transient inmemory cache example caching struct straight ecto using slug url determine cache key understand underlying mechanism using cache behavior next step liblinkcachecacheex defmodule linkcachecache def fetch slug defaultvaluefunction case get slug notfound set slug defaultvaluefunction found result result end end end use provide slug lookup function execute populate cache value found exist yet infer behavior either return tuple notfound point call assign value return found result point return result directly leverage let change redirecttoredirectcontroller awebcontrollersredirectcontrollerex bwebcontrollersredirectcontrollerex defmodule redirecttoredirectcontroller alias redirecttoqueries def show conn slug slug link querieslinkbyslug slug repoone link linkcachecachefetch slug fn querieslinkbyslug slug repoone end redirect conn external linklongurl end usage way let build rest linkcachecache liblinkcachecacheex defmodule linkcachecache use genserver def startlink opts genserverstartlink module etstablename linkcachetable loglimit opts end def fetch slug defaultvaluefunction case get slug notfound set slug defaultvaluefunction found result result end end defp get slug case genservercall module get slug notfound slug result found result end end defp set slug value genservercall module set slug value end genserver callback def handlecall get slug state etstablename etstablename state result etslookup etstablename slug reply result state end def handlecall set slug value state etstablename etstablename state true etsinsert etstablename slug value reply value state end def init args etstablename etstablename loglimit loglimit args etsnew etstablename namedtable set private ok loglimit loglimit etstablename etstablename end end already seen let move defp get slug case genservercall module get slug notfound slug result found result end end synchronous function use send request server module equivalent linkcachecache get slug patternmatch tell server retrieve value key slug return zero one result due underlying storage mechanism using defp set slug value genservercall module set slug value end performing another synchronous action cache value specific slug returning slug value sending request module discussed need hook behavior patternmatching request sending trigger underlying behavior seen used appropriate tuples passed let look hook written handle request def handlecall get slug state etstablename etstablename state result etslookup etstablename slug reply result state end def handlecall set slug value state etstablename etstablename state true etsinsert etstablename slug value reply value state end manages request either get slug set slug value request sender pid descriptor ignoring server internal state state reply request reply linkstruct state link struct available retrieve url send user way reference ets erlang module referencing underlying ets erlang term storage architecture incredibly performant inmemory store lookup set storage using definition patternmatch state retrieve table name link cache perform insert lookup operation configure ets def startlink opts genserverstartlink module etstablename linkcachetable loglimit opts end def init args etstablename etstablename loglimit loglimit args etsnew etstablename namedtable set private ok loglimit loglimit etstablename etstablename end function prepare linkcachecache supervised configuration table named linkcachetable room million well create table configured named table set storage underlying cache built want ensure phoenix keep cache running elixir promotes strategy letting thing crash ensuring recovery quick straightforward supervisor helm let build supervisor ensure linkcachecache monitored run correctly liblinkcachesupervisorex defmodule linkcachesupervisor use supervisor def startlink supervisorstartlink module ok name module end def init ok child worker linkcachecache name linkcachecache supervise child strategy oneforone end end linkcachesupervisor supervises linkcachecache oneforone strategy also need update application include supervisor libredirecttoex defmodule redirectto use application def start type args import supervisorspec warn false child supervisor redirecttoendpoint supervisor redirecttorepo supervisor linkcachesupervisor opts strategy oneforone name redirecttosupervisor supervisorstartlink child opts end end addition redirecttoendpoint redirecttorepo linkcachesupervisor also managed redirectto ensures anything happens cache application restart find thorough walkthrough supervisor supervision tree tie various component together elixir discussion otp topic test cache wrote small test ensuring cache set value based return value function reused value subsequent lookup testliblinkcachecachetestexs defmodule linkcachetest use exunitcase test cache find correct data assert linkcachecachefetch fn id longurl http wwwexamplecom end id longurl http wwwexamplecom assert linkcachecachefetch fn end id longurl http wwwexamplecom end end cache store structs map sort data structure case cache invalidation might tricky architecture application link updated concerned invalid data mileage may vary admittedly chosen loglimit million pair without knowing memory implication particular cache size lookup constant time regardless number pair cache want verify running memory verify first fire iex running phoenix application iex mix phoenixserver next run observerstart within iex see gui outlining various metric running application assuming ets make sort optimization around similar value link redirecttoquerieslinkbyslug redirecttorepoone enumeach fn linkcachecachefetch tostring fn link end end insert one million pair cache key string version integer etc value struct directly ecto course million pair stored inmemory insertion result size around per pair storing subset data result significantly le memory usage link redirecttoquerieslinkbyslug redirecttorepoone maptake slug longurl cache place deployed cache databaseread version application heroku running free server database test used siege http version application configured follow redirects slug concurrent user case heroku dyno running spinup time transaction hit availability elapsed time sec data transferred mb response time sec transaction rate transsec throughput mbsec concurrency successful transaction failed transaction longest transaction shortest transaction impressed number almost request per minute free hardware average response time roughly hitting database request connection dropped transaction hit availability elapsed time sec data transferred mb response time sec transaction rate transsec throughput mbsec concurrency successful transaction failed transaction longest transaction shortest transaction throughput reading cache significantly better serving request additionally average response time half run hitting database even elixir incredible speed concurrency support box rpm free heroku hardware subsecond response time pretty great always way leverage certain technology great leveraging erlang ets genserver supervisor able build faulttolerant scalable inmemory cache improve performance throughput
306,Lobsters,elixir,Elixir programming,Cron-like job scheduler for Elixir,https://github.com/c-rack/quantum-elixir,cronlike job scheduler elixir,join github today sign,dismiss join github today github home million developer working together host review code manage project build software together sign
308,Lobsters,elixir,Elixir programming,Rustler - Safe Elixir and Erlang NIFs in Rust,http://hansihe.com/2017/02/05/rustler-safe-erlang-elixir-nifs-in-rust.html,rustler safe elixir erlang nifs rust,http hansihecompostsrustlersafeerlangelixirnifsinrust,http hansihecompostsrustlersafeerlangelixirnifsinrust
309,Lobsters,elixir,Elixir programming,Elixir deployments on AWS,https://medium.com/mint-digital/elixir-deployments-on-aws-ee787aa02a9d,elixir deployment aws,elixir deployment aws elixir http newsycombinatorcomitem edeliver exrm distillery existing deployment process might work deploy elixir apps heroku using tool docker hot code swap ha hot code reload option using docker option heroku distributed clustering kubernetes option heroku firewalled processbased persistence option heroku hexpm elixir user survey mint aws deployment aws using distillery get feedback launching web stack aws cloudformation currently template requires launch stack region preparing secret console nameofbucket configuring app build distillery addconfigure distillery distillery documentation update production config retrieve secret environment add script start stop compile verify app shell script nameofbucket configure codedeploy codedeploy deployment codedeploy clean nameofbucket next step filling,elixir deployment awsif spend time around elixir community long come across mention state deployment thing stand start little rough side biggest issue elixir hard set proper cideployment pipeline done done nothing work like node try dockerizing phoenix app setting heroku instance see mean thing work obscure language one need advanced understand address problem areahttps newsycombinatorcomitem great work around community project edeliver exrm exrm recent replacement distillery developer used running simple git push heroku master still many area painful overcometl dr recipe deploying elixir even recipe relevant please fill quick survey want better understand people struggle elixir deployment best extend recipe future updated april survey closed read found post findingsyour existing deployment process might workwhile possible deploy elixir apps heroku using tool docker brings limitation rule use vm feature may key reason choosing elixir first place feature hot code swap zerodowntime deployment networking node separate machine ha deployment may ruled start hot code reloaderlang elixir allow u swap old code new runtime persisting state might add unnecessary complexity many system might want keen deploy new code keeping application running maintaining state allowing zerodowntime deploymentsnot option using docker deployment typically swap currently running container one running updated code user might experience downtime codebase swapped entirety state carried new containernot option heroku heroku restart dynos part deployment losing statedistributed clusteringif running app across multiple server may need make node aware eg using phoenix channel guarantee w http request hit server tool kubernetes may help using dockernot option heroku dynos firewalled one another ruling one outprocessbased persistenceerlang offer u tool mnesia ets inmemory data store perhaps need hit db introduce dependency redis resist temptationwith docker possible persistence deploymentsnot option heroku even without restarts deployment heroku dynos restart dailythe issue every application instance time writing hexpm run heroku latest elixir user survey indicates plenty using tool looking take advantage everything ecosystem offer tool might make gradehere mint looking various strategy resolving issue settling towards solution using distillery build various service aws umbrella hosting execution deploymentdeployments aws using distilleryaws give much greater control setup v heroku main tradeoff manage setup allows u setup hot code swap clustering autoscaling anything else ecosystem offerwe working towards generalised solution deploying elixir apps fashion run tackled advanced feature referenced outline keen get feedback important member communitylaunching web stack awswe used cloudformation automate setup fairly typical web stack aws get json headline feature instance size configurable prelaunch application load balancerpostgres rds instancecodedeploy deployment bucket setup storage encrypted secretsvarious networking bit piece http port load balancer ssh configurable ip instance using publicprivate key currently template requires launch stack regionan easy understand diagramyou launch stack handy link going flow create resource account may want shut end want keep paying included step end post need sign user permission create manage stack sample iam policy granting suitable permission version statement effect allow action cloudformation describestacks cloudformation describestackevents cloudformation describestackresource cloudformation describestackresources cloudformation gettemplate cloudformation gettemplatesummary cloudformation createstack cloudformation updatestack cloudformation deletestack cloudformation list resource require set value used stack prelaunch include database name username password ssh key ip address whitelisting ssh access instance email address sn notification stackonce set params click rest flow wait foraws create resource set stack output show value need continue step output seen detail pane created stackpreparing secretsonce stack ready need upload secret created bucket many way could handle confidential value making use seemed simple way get goingin template set bucket policy reject uploads unless encrypted rest flight coming another resource stack vpcas whitelisted ssh access instance get secret bucket later retrieve making call taking hostname one instance output using user console able access instance using key set initialising stack create file tmpcredstxt ssh console ipaddress vim tmpcredstxtthe content file look something like following database detail coming new rds instance user password database name come params set earlier whereas host seen stack output secretkeybasesecretdatabaseurlpostgres rdsuser rdspassword able upload file new bucket name stack output using aws cli console ipaddress cd tmpconsole ipaddress aws cp credstxt nameofbucket region sseconfiguring app build distillerynext need prepare app deployment setup example phoenix application try try step application example standard phoenix install change get deployment working view line diff addconfigure distilleryfirst add distillery app dependency defp deps cowboy cowboy distillery endfetch updated dependency initialise distillery mix depsget releaseinit update production config runninga release config myapp myappendpoint http port system port url host examplecom port cachestaticmanifest privstaticmanifestjson cachestaticmanifest privstaticmanifestjson server true root version mixprojectconfig version read configuration option online distillery update production config retrieve secret environmentour secret safely stored text file pull set environment compilation need update production config retrieve value instead using prodsecretexs file finally import configprodsecretexs versioned separatelyimportconfig prodsecretexs config myapp myappendpoint secretkeybase systemgetenv secretkeybase configure databaseconfig myapp myapprepo adapter ectoadapterspostgres url systemgetenv databaseurl poolsize stringtointeger systemgetenv poolsize ssl add script start stop compile verify appthese shell script mostly wrapper around distillery cli compilation script need edits updating name shown stack output region bucket app secret stored update value bucket nt update line configure codedeployfinally need add appspecyml project root configures codedeploy use call script right point deployment version linux hook applicationstop location scriptsstopsh runas owner afterinstall location scriptscompilesh runas root applicationstart location scriptsstartsh runas owner validateservice location scriptsverifysh runas ownerdeploymentfinally ready deploy application heading aws console codedeploy see application deployment group created stack deploy instance creating new deployment app github repo source click codedeploy applicationselect deployment group select deploy new revisionenter source detail deploy assuming successful view running application hitting url load balancer shown stack output browserclean upif want get rid resource rather keep paying need perform step delete file created bucket need resource vpc instance aws rm nameofbucketcredstxt region itdisable termination protection instancesdisable termination protection load balanceronce done able delete stack cloudformation index pagenext stepswhile clearly think straightforward repeatable method deploying elixir application solid stack yet tackled advanced issue referenced earlier post clean state look buildnext plan look clustering autoscaling hot code swap simplified deploy trigger keen hear community feature important planning deploymentwe put together short question survey around deploying elixir love hear please help u filling
312,Lobsters,elixir,Elixir programming,"Writing An Interpreter In Elixir - Rewriting a complete Interpreter in Elixir, using only the stdlib",https://github.com/fabrik42/writing_an_interpreter_in_elixir,writing interpreter elixir rewriting complete interpreter elixir using stdlib,writing interpreter elixir introduction monkey writing interpreter go please let know monkey language feature usage starting repl running test notable change original golang implementation token lexer parser evaluator todos,writing interpreter elixir introduction project interpreter monkey programming language featuring lexer ast producing parser evaluator monkey programming language well structure interpreter based book writing interpreter go really enjoyed reading book following implementation interpreter go built using simple straightforward pattern learn build interpreter completely generator external dependency code even though first sight interpreter seems big hairy complex machine author manages implement fully working version using easy understand code pattern like early return simple forloops small amount well encapsulated state well known programmer easy reason however none thing exist elixir looking get hand dirty language decided implement interpreter monkey elixir instead go see pattern applied solve problem functional approach know way sophisticated pattern functional language like monad wanted solve problem using standard lib elixir first reference implementation golang second wanted dive deeper standard lib important keep mind whole basic structure interpreter derived original golang book maybe even better way lay interpreter elixir case let know code repository current state interpreter fully functional tested tried best implement using elixir best practice still rough edge think still lot learn elixir functional programming general welcome walk code spot something could done better please let know monkey language feature list language feature found able try repl see usage project us stdlib elixir mix depsget necessary starting repl handy mix task start monkey repl play around language mix repl running test mix test notable change original golang implementation token use constant atom specify token type lexer maintain state implemented using recursive function call parser prefix parse function defined using pattern matching function call instead lookup table function value extra nil handling evaluator structs immutable evaluator output evaluated result also environment used evaluate code defined variable consequence evaluator also called environment work resume working environment see repl todos check code quality elixir way thing add typespecs dialyzer static analysis try remove todos aka nested condition maybe builtin function
313,Lobsters,elixir,Elixir programming,Erlang & Elixir Factory Lite at Buenos Aires,https://medium.com/@elbrujohalcon/erlang-factory-lite-at-buenos-aires-bfa28b62b527,erlang elixir factory lite buenos aire,bleacher report eventfabric sponsor prospectus register register,simon coauthor one popular book erlang erlang programming written book erlang haskell dependent type talking power functional programming increase programming productivity using idea paradigmben elixir programmer lead developer bleacher report leading transition ruby rail elixir phoenix giving talk using bleacher report story show fulfillment promise elixir phoenixmariano born córdoba still keep accent p working company eventfabric talking distributed system necessarythe founder erlang solution coauthor book mentioned couple others francesco giving workshop reactive system micro service architecturesi also take chance give talk course p talking adts heuristic would help better erlangerbut room several speaker one idea talk submit love hear say talk spanish english mine spanish course sponsorswe sponsor already linked erlang solution inaka event fabric bleacher report looking company interested sponsoring awesome event check prospectus feel free reach u timeregister come join u amazing conference register get super early bird price
314,Lobsters,elixir,Elixir programming,Meet Phoenix: A Rails-like Framework for Modern Web Apps,https://www.toptal.com/phoenix/phoenix-rails-like-framework-web-apps,meet phoenix railslike framework modern web apps,fastest framework blog post official guide ruby rail developer naming convention simpler routing easier manage view template two different thing ruby rail appcontrollershellocontrollerrb appviewshelloindexhtmlerb phoenix webcontrollershellocontrollerex webviewshelloviewex webtemplateshelloindexhtmleex model data model email protected changesets allow clear validation transformation rule importing functionality straightforward yet flexible quote use concurrency core channel phoenix make building modern web apps painless,phoenix framework growing popularity quick pace offering productivity framework like ruby rail also one fastest framework available break myth sacrifice performance order increase productivity exactly phoenix phoenix web framework built elixir programming language elixir built erlang vm used building lowlatency faulttolerant distributed system increasingly necessary quality modern web application learn elixir blog post official guide ruby rail developer definitely take interest phoenix performance gain promise developer framework also follow along see phoenix approach web development article learn thing phoenix keep mind coming world ruby rail unlike ruby elixir functional programming language probably biggest difference may deal however key difference two platform anyone learning phoenix aware order maximize productivity naming convention simpler small one easy mess coming ruby rail phoenix convention write everything singular form would usercontroller instead userscontroller like would ruby rail applies everywhere except naming database table convention name table plural form might seem like big deal learning use plural form ruby rail bit confusing first learning use ruby rail sure confused many others well phoenix give one le thing worry routing easier manage phoenix ruby rail similar come routing key difference control way request processed ruby rail rack application done middleware whereas phoenix done referred plug plug use process connection example middleware rail rack logger log request rail phoenix would done pluglogger plug basically anything rack middleware done using plug example router phoenix defmodule helloworldrouter use helloworldweb router pipeline browser plug accepts html plug fetchsession plug fetchflash plug protectfromforgery plug putsecurebrowserheaders end pipeline api plug accepts json end scope helloworld pipethrough browser get hellocontroller index end scope api helloworld pipethrough api end end first let look pipeline group plug request travel think middleware stack used example verify request expects html fetch session make sure request secure happens reaching controller specify multiple pipeline pick choose plug necessary specific route router example different pipeline page html api json request always make sense use exact pipeline different type request phoenix give u flexibility view template two different thing view phoenix view ruby rail view phoenix charge rendering template providing function make raw data easier template use view phoenix closely resembles helper ruby rail addition rendering template let write example display hello world browser ruby rail appcontrollershellocontrollerrb class hellocontroller applicationcontroller def index end end appviewshelloindexhtmlerb hello world phoenix webcontrollershellocontrollerex defmodule helloworldhellocontroller use helloworldweb controller def index conn params render conn indexhtml end end webviewshelloviewex defmodule helloworldhelloview use helloworldweb view end webtemplateshelloindexhtmleex hello world example display hello world browser key difference first explicitly state template wish render phoenix unlike ruby rail next include view phoenix stand controller template may wondering need view empty key hood phoenix compiles template function roughly equal code defmodule helloworldhelloview use helloworldweb view def render indexhtml assigns raw hello world end end delete template use new render function get result useful want return text even json model data model phoenix model primarily handle data validation schema relationship model presented specifying schema model may sound weird first allows easily create virtual field field persisted database let take look example defmodule hellophoenixuser use hellophoenixweb model schema user field name string field email string field password string virtual true field passwordhash string end end define four field user table name email password passwordhash much interesting except password field set virtual allows u set get field without saving change database useful would logic convert password hash would save passwordhash field save database still need create migration schema model needed field automatically loaded model like ruby rail difference phoenix ruby rail model handle persistence database handled module called repo configured database information shown example config myapp repo adapter ectoadapterspostgres database ectosimple username postgres password postgres hostname localhost code included environment specific configuration file configdevexs configtestexs allows u use repo perform database operation create update repoinsert user name john smith example email protected ok user insertion successful error changeset insertion failed end common example controller phoenix provide user name email repo attempt create new record database optionally handle successful failed attempt shown example understand code better need understand pattern matching elixir value returned function tuple function return tuple two value status either model changeset changeset way track change validate model changesets discussed next section first tuple top bottom match pattern tuple returned function attempted insert user database run defined function could set variable status instead atom basically symbol ruby would match successful failed attempt would use function situation specifying atom want match define function specifically status ruby rail persistence functionality built model activerecord add responsibility model sometimes make testing model complex result phoenix separated way make sense prevents bloating every model persistence logic changesets allow clear validation transformation rule ruby rail validating transforming data source hard find bug immediately obvious data transformed callback beforecreate validation phoenix explicitly validation transformation using changesets one favorite feature phoenix let take look changeset adding one previous model defmodule hellophoenixuser use hellophoenixweb model schema user field name string field email string field password string virtual true field passwordhash string end def changeset struct params struct cast params name email password validaterequired email password end end changeset two thing first call cast function whitelist permitted field similar strongparameters ruby rail validates email password field included making name field optional way field allow modified user nice thing approach limited one changeset create multiple changesets changeset registration one updating user common maybe want require password field registering updating user compare approach commonly done ruby rail would specify validation run create sometimes make hard rail figure code complex model importing functionality straightforward yet flexible much functionality library called ecto imported model model usually line near top use hellophoenixweb model hellophoenixweb module located webwebex module function called model follows def model quote use ectoschema import ecto import ectochangeset import ectoquery end end see module importing ecto remove add module want imported model also similar function view controller serve purpose view controller respectively quote use keywords might seem confusing example think quote directly running code context module calling function equivalent written code inside quote module use keyword also allows run code context called essentially requires specified module call using macro module running context called read quote use official guide really help understand certain function located framework help reduce feeling framework lot magic concurrency core concurrency come free phoenix main feature elixir get application spawn multiple process run multiple core without worry thread safety reliability spawn new process elixir simply spawn fn end everything spawn end run new process fact every request phoenix handled process elixir us power erlang vm bring reliable efficient concurrency free also make phoenix great choice running service use websockets since websockets need maintain open connection client server mean need build application handle possibly thousand concurrent connection requirement would add lot complexity project built ruby rail phoenix meet requirement free elixir want use websockets phoenix application going need use channel equivalent actioncable ruby rail le complex set need run separate server phoenix make building modern web apps painless largely focusing difference phoenix thing common ruby rail phoenix roughly follows mvc pattern ruby rail figuring code go difficult know main difference phoenix also similar generator ruby rail creating model controller migration learning elixir slowly approach ruby rail level productivity comfortable phoenix time feel productive encounter problem solved gem ruby find similar library elixir luckily gap slowly filled growing elixir community difference phoenix help solve lot pain came managing complex ruby rail project solve issue help push right direction choosing slow framework want productivity longer valid excuse phoenix let
316,Lobsters,elixir,Elixir programming,llaisdy/beam_languages,https://github.com/llaisdy/beam_languages,llaisdybeamlanguages,language language beam content overview language lispinfluenced staticallytyped others erlang lisp clojerl joxa kapok lfe concurrent schemer staticallytyped language alpaca cuneiform elchemy eml fez gleam hamler haskerl et al http wwwdcsglaacukpartainhaskerlhtml http wikihaskellorgyhcerlangproofofconcept idriserlang purerl http etc efene elixir ephp bragful http http http erlog erlyjs http ajaxiancomarchiveserlyjsjavascriptonerlang http ffe forthflavoured erlang interfix luerl otpcl reia xerl http language implementing language beam implementing language beam efene beam community beam made eric merritt erlang distributed system expert give view beam language type system new technology create language implement language top erlang virtual machine beam implementing language beam implementing language beam erlang lfe joxa elixir established emerging language erlang ecosystem beam beam book http githubcomhappithebeambook beam toolbox http efeneorgtoolboxhtml erlang type http homepagesinfedacukwadlertopicserlanghtml practical subtyping system erlang great type hope om erlang system fomega erlang type proposal gradualizer gradual type system erlang,language language beam content overview document intended list language implemented run beam erlang virtual machine b document article presentation hows why writing language run beam moment want better name call language beam language although heard erlang vms would like document comprehensive least representative missed beam language noteworthy discussion beam language documentation implementing language targetting beam please let know usual channel issue fork pr tweet email etc thank language first erlang lispinfluenced language staticallytyped language others including erlang language erlang lisp clojerl clojerl clojure erlang vm joxa difference joxa lfe joxa full featured lisp erlang vm kapok lfe concurrent schemer staticallytyped language alpaca cuneiform elchemy elm syntax frontend elixir ie convert elmstyle input language elixir source code eml eml erlang flavored ml fez fez fsharp core erlang compiler experiment gleam gleam statically typed language erlang vm hamler haskellstyle functional programming language running erlang vm haskerl et al haskerl index http wwwdcsglaacukpartainhaskerlhtml yhcerlangproof concept http wikihaskellorgyhcerlangproofofconcept idriserlang idris package therefore requiring haskell idris compiles idris source code erlang source code purerl erlang backend purescript introducing purescript erlang http etc efene elixir ephp erlang interpreter php presumably used bragful resilient scalable php announcement ensuing discussion erlangquestions http improvement erlang euc http blog post presentation chinese http erlog backtracking erlang part control erlyjs original repo google code longer exists several fork eg couple blog post second original developer erlyjs erlyjs javascript erlang http ajaxiancomarchiveserlyjsjavascriptonerlang erlyjs translating javascript erlang http ffe forthflavoured erlang interfix luerl otpcl open telecom platform command language scripting language designed integrate extend application written beambased language reia xerl five web article starting xerl empty module http language implementing language beam video implementing language beam video efene beam community slide video beam made slide link github repo eric merritt erlang distributed system expert give view beam language type system new technology articleinterview link podcast video create language implement language top erlang virtual machine beam slide implementing language beam slide video implementing language beam video erlang lfe joxa elixir established emerging language erlang ecosystem slide beam beam book description erlang runtime system ert virtual machine beam http githubcomhappithebeambook beam toolbox list tool library useful beam language like efene erlang lfe elixir project http efeneorgtoolboxhtml erlang type first two paper linked philip wadler erlang page http homepagesinfedacukwadlertopicserlanghtml practical subtyping system erlang paper great type hope slide om erlang system fomega erlang type proposal gradualizer gradual type system erlang gradual typing system static code analysis tool erlang type system based gradual typing functional language siek taha see docgtlchs
317,Lobsters,elixir,Elixir programming,Building a CQRS/ES web application in Elixir using Phoenix,https://10consulting.com/2017/01/04/building-a-cqrs-web-application-in-elixir-using-phoenix/,building cqrses web application elixir using phoenix,background greg young rcqrs eventstore commanded process segment challenge article content segment challenge strava segment challenge command query responsibility segregation cqrs cqrs command domain event event sourcing benefit cost using cqrs building cqrses application elixir write model event store eventstore aggregate host command dispatch commanded read model store ecto web frontend phoenix framework elm using umbrella application architecture lost year domain model domaindriven design event sourced domain model using elixir domain model example challenge aggregate root command event structs example start challenge command quantum vex command validation example challenge started event poison process manager saga example include stage challenge commanded supervision commanded command write model commanded genserver command routing dispatch example router module middleware command handler aggregate root example challenge command handler example command dispatch command dispatching web controller example phoenix command controller exconstructor canada poison command validation vex phoenix command controller command authorisation strava canada example authorisation module example challenge policy module querying read model ecto example ecto repo projection example club projection example projection supervision query example challenge created athlete query rebuild read model testing unit testing aggregate root exmachina example challenge aggregate root unit test integration testing application example host challenge integration test example create challenge test use case example challenge projection integration test deployment distillery edeliver subscribe mailing list conclusion eventstore commanded get touch want discover cqrses elixir,background interested command query responsibility segregation event sourcing since hearing greg young talk subject early past seven year built opensource ruby cqrs library rcqrs worked professionally net application following pattern recently built event store eventstore cqrs library commanded elixir building application following domaindriven design using cqrs feel really natural elixir erlang actor model aggregate root fit well within elixir process driven immutable message message mailbox allowing run concurrently isolation web application built implement idea elixir segment challenge helped develop resilient robust cqrses application article content segment challenge compete friend teammate fellow club rider ride different segment month keen cyclist runner know strava social network athlete record ride run upload site strava user create segment section route example segment cover climb hill starting bottom finishing top segment get leaderboard display ranked attempt athlete cycled run fastest man king mountain kom fastest woman queen mountain qom athlete compare strava user cycle run along route segment challenge allows athlete create competition cycling club member different strava segment used month point accumulated based position end stage site us api fetch segment attempt member rank attempt tally point end stage replacing tedium manually tracking information spreadsheet site entirely selfservice registered strava user create host challenge cycling club member deployed end hosting active challenge five local club promoting club host challenge year fantastic way encourage member go ride throughout year helping bring competitive spirit command query responsibility segregation cqrs simplest cqrs separation command query command used mutate state write model query used retrieve value read model command used instruct application something named imperative register account transfer fund mark fraudulent activity domain event indicate something importance occurred within domain model named past tense account registered fund transferred fraudulent activity detected read write model different logical model may also separated physically using different database storage mechanism read model optimised querying using whatever technology appropriate relational database inmemory store nosql database fulltext search index domain event write model used update read model specialised time series data storage used event sourcing write model event sourcing application state change modelled domain event persisted order logical stream aggregate current state built replaying domain event typical event sourcing example ecommerce shopping cart crud system current state would recorded cart contains two item using event sourcing event took cart empty state current recorded item added cart item removed cart item added cart event stream canonical source truth perfect audit log state system may rebuilt event rebuild read model replaying every event beginning time benefit cost using cqrs domain event describe system activity time using rich domainspecific language immutable source truth system support temporal query separate logical read model allows optimised highly specialised query model built scale read write model independently processing command query asymmetrical dedicate appropriate number server side needed event schema provide ideal integration point system allow migration readonly data persistence technology replaying projecting event unfortunately event also provide history poor design decision event immutable alternative le common approach building application basic crud demand richer understanding domain modelled cqrs add risky complexity eventual consistency building cqrses application elixir build application website require domain model containing aggregate command domain event hosting aggregate root way send command event store persist domain event read model store querying event handler build update read model web frontend ui display read model data dispatch command write model segment challenge us following library help fulfil requirement write model event store eventstore elixir library using postgresql underlying storage engine provides api append event read event logical event stream subscribe event subscription individual stream event stream allows handler notified persisted event subscription guarantee least delivery every persisted event subscription may independently paused later resumed stopped aggregate host command dispatch commanded provides building block creating cqrs application elixir support command registration dispatch hosting delegation aggregate root event handling long running process manager read model store ecto postgresql database used build read model querying web frontend phoenix framework used web frontend also implemented form using elm functional language building webapps compiles javascript using umbrella application segment challenge created elixir umbrella application mix new segmentchallenge module segmentchallenge umbrella contains following apps authorisation policy authorise command dispatch challenge core domain model command router process manager read model projection query periodic task command module structs command eg segmentchallengecommandsapprovechallenge event module structs domain event eg segmentchallengeeventschallengeapproved infrastructure serialization command middleware projection ecto repository database migration build read model database schema web phoenix web frontend containing router controller plug template view static asset cd segmentchallenge cd apps mix new authorisation module segmentchallengeauthorisation mix new challenge module segmentchallengechallenges sup mix new command module segmentchallengecommands mix new event module segmentchallengeevents mix new infrastructure module segmentchallengeinfrastructure mix new projection module segmentchallengeprojections sup mix phoenixnew web app web module segmentchallengeweb nobrunch noecto challenge app ideal candidate split logical area athlete challenge club leaderboards stage toplevel structure inform intent eg challenge leaderboards delivery mechanism technology us eg projection query task uncle bob describes ideal architecture lost talk domain model domaindriven design domain model conceptual model core business domain application containing behaviour data includes aggregate command domain event process manager comprise business logic event sourced domain model aggregate root must conform following behaviour implement event sourcing pattern public function must accept command return resultant domain event error internal state may modified applying domain event current state internal state rebuilt initial empty state replaying domain event order created using elixir domain model building event sourced aggregate elixir requires defining module containing state command function state mutator function use struct aggregate state aggregate defined without external dependency using event sourcing persistence concern relationship aggregate root identity orchestration aggregate root handled process manager respond event one aggregate root dispatch command another example challenge aggregate root challenge aggregate root used segment challenge track hosted challenge snippet challenge module implement aggregate root see public command function eg accept challenge state challenge struct command eg createchallenge struct return zero one many domain event response aggregate root must protect command would cause invariant broken example attempting start challenge approved return error tagged tuple error challengenotapproved pattern matching used validate state aggregate finite state machine used formalise allowed state change within aggregate root defmodule segmentchallengechallengeschallenge moduledoc challenge multistage competition hosted club athlete compete every month challenge set fastest time current stage defstruct challengeuuid nil name nil description nil startdate nil startdatelocal nil challengestate nil alias segmentchallengecommands createchallenge includecompetitorsinchallenge hostchallenge startchallenge endchallenge alias segmentchallengeevents challengecreated competitorsjoinedchallenge challengehosted challengestarted challengeended alias segmentchallengechallengeschallenge doc create new challenge def createchallenge challenge createchallenge def createchallenge challenge challengestate nil createchallenge createchallenge challengecreated challengeuuid createchallengechallengeuuid name createchallengename description createchallengedescription end def createchallenge challenge createchallenge error challengealreadycreated doc start challenge making active def startchallenge challenge startchallenge def startchallenge challenge challengeuuid challengeuuid challengestate approved challenge startchallenge challengestarted challengeuuid challengeuuid startdate challengestartdate startdatelocal challengestartdatelocal end def startchallenge challenge startchallenge error challengenotapproved def apply challenge challenge challengecreated challengeuuid challengeuuid name name description description challenge challenge challengeuuid challengeuuid name name description description challengestate created end def apply challenge challenge challengestarted challenge challenge challengestate active end end every domain event returned aggregate must corresponding function argument aggregate root state domain event used mutate state function also used aggregate rebuilt empty state replaying event apply function must never fail reject event occurred command event segment challenge implemented command domain event module module located relevant command event app could combine two single app eg message use elixir structs define field providing compiletime check default value example start challenge command starting challenge used transition hosted challenge active state command dispatched periodic task scheduled using quantum challenge begin midnight scheduled task run day locate challenge ready start dispatch command challenge defmodule segmentchallengecommandsstartchallenge defstruct challengeuuid use vexstruct validates challengeuuid uuid true end vex used provide basic command validation simple presence formatting data type validation rule business rule validation belongs within aggregate command validated passed aggregate root using command validation middleware example challenge started event challenge aggregate root return challengestarted event response start command valid state begin defmodule segmentchallengeeventschallengestarted defstruct challengeuuid startdate startdatelocal end event returned aggregate root serialised json using poison library persisted event store persisted event published interested subscriber process manager read model projection event handler process manager process manager responsible coordinating one aggregate root handle event may dispatch command response process manager state used track aggregate root orchestrated vital interaggregate communication coordination longrunning business process saga implemented using process manager alternative using distributed transaction managing longrunning business process step business process defined compensating action business process encounter error condition unable continue execute compensating action step already completed undoes work completed far maintain consistency system typically would use process manager route message aggregate within bounded context would use saga manage longrunning business process span multiple bounded context example include stage challenge segment challenge challenge stage separate aggregate root use process manager allow challenge track stage included commanded provides building block defining process manager us interested routing function indicate event process manager receives response used route event existing process manager instance create new one example process manager started challengecreated event us challengeuuid identify instance process stagecreated event received includestageinchallenge command sent corresponding challenge aggregate root event ignored process manager defmodule segmentchallengechallengeschallengestageprocessmanager moduledoc track stage comprise challenge defstruct challengeuuid nil stage defmodule stage defstruct stageuuid stagenumber name end alias segmentchallengeevents challengecreated stagecreated alias segmentchallengecommands includestageinchallenge alias segmentchallengechallengeschallengestageprocessmanager alias challengestageprocessmanagerstage def interested challengecreated challengeuuid challengeuuid start challengeuuid def interested stagecreated challengeuuid challengeuuid continue challengeuuid def interested event false def handle challengestageprocessmanager challengecreated def handle challengestageprocessmanager challengeuuid challengeuuid stagecreated stageuuid stageuuid stagenumber stagenumber name name startdate startdate startdatelocal startdatelocal enddate enddate enddatelocal enddatelocal includestageinchallenge challengeuuid challengeuuid stageuuid stageuuid stagenumber stagenumber name name startdate startdate startdatelocal startdatelocal enddate enddate enddatelocal enddatelocal end def apply challengestageprocessmanager processmanager challengecreated challengeuuid challengeuuid challengestageprocessmanager processmanager challengeuuid challengeuuid end def apply challengestageprocessmanager stage stage processmanager stagecreated stageuuid stageuuid stagenumber stagenumber name name stage stage stageuuid stageuuid stagenumber stagenumber name name challengestageprocessmanager processmanager stage stage stage end end state process manager instance modified following aggregate root approach function must exist handled domain event process state mutated returned simple process manager example segment challenge contains complex process manager following principle example include tracking club member include challenge active stage hosted club applying score based stage rank end stage update overall challenge leaderboards supervision process manager must supervised ensure start application restarts failure commanded provides commandedprocessmanagersprocessrouter module host process manager defmodule segmentchallengechallengessupervisor use supervisor alias segmentchallengechallenges alias challenge challengestageprocessmanager def startlink supervisorstartlink module nil end def init child projection supervisor segmentchallengechallengesprojectionssupervisor process manager worker commandedprocessmanagersprocessrouter challengestageprocessmanager challengestageprocessmanager challengesrouter id challengestageprocessmanager supervise child strategy oneforone end end commanded take care creating subscription event store process manager serialises snapshot state event store every handled event ensure state rehydrated restart command write model core domain model built time provide external interface allow command sent commanded library provides aggregate root hosting command registration dispatch every command exactly one registered handler sent command handler module directly target aggregate root attempting dispatch unregistered command result exception command router used configure aggregate root command handler responds command analogous routing phoenix web framework however sends command handler rather http request controller command dispatch elixir genserver process started host aggregate root instance fetch event stream event store rebuild state returned domain event appended event stream aggregate root host process remains alive subsequent command routed instance require rebuilding state event store command routing dispatch segment challenge defines segmentchallengechallengesrouter module us commandedcommandsrouter macro register every command available within application example router snippet show command relating challenge aggregate root defmodule segmentchallengechallengesrouter use commandedcommandsrouter alias segmentchallengechallenges challenge challengecommandhandler middleware commandedmiddlewareauditing middleware commandedmiddlewarelogger middleware segmentchallengeinfrastructurevalidationmiddleware dispatch segmentchallengecommandscreatechallenge segmentchallengecommandsincludecompetitorsinchallenge segmentchallengecommandsremovecompetitorfromchallenge segmentchallengecommandsexcludecompetitorfromchallenge segmentchallengecommandshostchallenge segmentchallengecommandsstartchallenge segmentchallengecommandsendchallenge challengecommandhandler aggregate challenge identity challengeuuid end command sent aggregate via challengecommandhandler module middleware router allows configuration middleware dispatched command pas middleware chain order defined middleware choose halt execution provides integration point crosscutting concern including command auditing logging validation concern applicable command command handler aggregate root registered command handler module receives target aggregate root state dispatched command allows additional processing done delegating aggregate root example challenge command handler example show unique url slug created using challenge name included command defmodule segmentchallengechallengeschallengecommandhandler behaviour commandedcommandshandler alias segmentchallengecommands createchallenge startchallenge alias segmentchallengechallengeschallenge alias segmentchallengechallengesservicesurlslugsuniqueslugger def handle challenge challenge createchallenge challengeuuid challengeuuid name name createchallenge assign unique url slug challenge name ok urlslug uniquesluggerslugify challengeslugsource challengeuuid name challenge challengecreatechallenge createchallenge createchallenge urlslug urlslug end def handle challenge challenge startchallenge startchallenge challenge challengestartchallenge startchallenge end end example command dispatch command dispatched using configured router module alias segmentchallengechallengesrouter alias segmentchallengecommandsstartchallenge ok routerdispatch startchallenge challengeuuid challengeuuid command dispatching web controller segment challenge command sent single phoenix controller phoenix web router configured accept json request posted apicommands sent controller apicommandcontroller defmodule segmentchallengewebrouter use segmentchallengewebweb router pipeline api plug accepts json plug fetchsession plug assigncurrentuser end scope api segmentchallengeweb api pipethrough api post command apicommandcontroller dispatch end end example phoenix command controller router contains single public dispatch function build populates command struct defined command parameter using exconstructor library authorises current user dispatch command using canada library dispatch command return appropriate http response code depending upon outcome command dispatch defmodule segmentchallengewebapicommandcontroller use segmentchallengewebweb controller import canadacan alias segmentchallengeauthorisationuser alias segmentchallengechallengesrouter alias segmentchallengewebcommandbuilder emptyjsonresponse doc dispatch command defined params def dispatch conn command command params command commandbuilderbuild command conn mapdelete params command user currentuser conn user dispatch command case routerdispatch command ok conn sendresp emptyjsonresponse error validationfailure error conn putstatus unprocessableentity render dispatch error error error reason conn sendresp emptyjsonresponse end else conn sendresp emptyjsonresponse end end doc attempted dispatch missing command def dispatch conn params conn sendresp emptyjsonresponse end defp currentuser conn case currentathleteuuid conn nil nil athleteuuid user athleteuuid athleteuuid end end end command validation error returned client json view commandview deal formatting data default phoenix us poison serialize json defmodule segmentchallengewebapicommandview use segmentchallengewebweb view def render dispatchjson error error enummap error end defp tojson error field type message name field message message end end command validation dispatched command validated passed onto target aggregate root use following middleware verifies simple validation rule defined command using vex defmodule segmentchallengeinfrastructurevalidationmiddleware behaviour commandedmiddleware require logger alias commandedmiddlewarepipeline import pipeline def beforedispatch pipeline command command pipeline case vexvalid command true pipeline false failedvalidation pipeline end end def afterdispatch pipeline pipeline def afterfailure pipeline pipeline defp failedvalidation pipeline command command pipeline error vexerrors command loggerwarn fn command inspect commandstruct failed validation error inspect error command inspect command end pipeline respond error validationfailure error halt end end middleware registered command routing module using commandedcommandsrouter macro defmodule segmentchallengechallengesrouter use commandedcommandsrouter middleware segmentchallengeinfrastructurevalidationmiddleware end validation failure returned command dispatcher may shown end user example phoenix command controller demonstrates error handled command authorisation segment challenge authentication provided strava using authentication protocol strava library provides strategy generate relevant strava login url handle authentication response canada used implement authorisation define permission rule authenticated user used authorise command dispatch example authorisation module use canada implemented canadacan protocol command dispatched web frontend unconfigured command disallowed defimpl canadacan segmentchallengeauthorisationuser alias segmentchallengeauthorisationuser alias segmentchallengeauthorisationpolicies challengepolicy stagepolicy alias segmentchallengecommands createchallenge createstage def user user dispatch createchallenge command challengepolicycan user dispatch command def user user dispatch createstage command stagepolicycan user dispatch command def user action command false end canadacan protocol implementation simply delegate appropriate policy module eg challengepolicy containing permission rule elixir pattern matching provides convenient way defining rule function without match provides default disallow response example challenge policy module snippet host challenge command us read model projection enforce rule user must original creator challenge must pending state defmodule segmentchallengeauthorisationpolicieschallengepolicy alias segmentchallengeauthorisationuser alias segmentchallengecommands hostchallenge alias segmentchallengechallengesprojectionschallengeprojection alias segmentchallengeprojectionsrepo def user athleteuuid athleteuuid user dispatch hostchallenge challengeuuid challengeuuid hostedbyathleteuuid athleteuuid command challenge repoget challengeprojection challengeuuid user dispatch command challenge end def user action command false def user athleteuuid athleteuuid dispatch hostchallenge challengeuuid challengeuuid hostedbyathleteuuid athleteuuid challengeprojection challengeuuid challengeuuid createdbyathleteuuid athleteuuid status pending true def user action command challenge false end querying read model reporting querying state application handled building read model use ecto library dedicated read store postgresql database segment challenge ecto provides domain specific language writing query interacting database elixir includes mix command line tool create database schema migration execute used migrate development production database read model optimised querying data duplicated denormalised required query table join infrequent example ecto repo read store us single ecto repository execute query database defmodule segmentchallengeprojectionsrepo use ectorepo otpapp projection end create migrate database mix ectocreate r segmentchallengeprojectionsrepo mix ectomigrate r segmentchallengeprojectionsrepo projection read model populated using projection projection event handler receives every persisted event event store executes query database add update delete data event handler run concurrently eventually consistent example club projection projection includes least one ecto schema definition projector event handler module projector handle event relevant read model build example includes event related club defmodule segmentchallengechallengesprojectionsclubs defmodule clubprojection use segmentchallengeprojectionsprojection primarykey clubuuid string schema club field name string field profile string timestamps end end alias segmentchallengechallengesprojectionsclubsclubprojection defmodule projector import ectoquery alias segmentchallengeevents clubimported behaviour commandedeventhandler projectionname club def handle clubimported clubuuid clubuuid name name profile profile eventid eventid clubprojectionupdateprojection projectionname eventid fn multi ectomultiinsert multi club clubprojection clubuuid clubuuid name name profile profile end end ignore event def handle event metadata ok end end use ectomulti execute query insert update delete data segmentchallengeprojectionsprojection macro ensures event processed event handler may receive event projection record last seen event within database transaction data manipulation already seen event ignored transaction containing duplicate change get rolled back defmodule segmentchallengeprojectionsprojection moduledoc false defmacro using quote use ectoschema import ectochangeset import ectoquery alias segmentchallengeprojections repo projection projectionversion def updateprojection projectionname eventid multifn multi ectomultinew ectomultirun verifyprojectionversion fn version case repoget projectionversion projectionname nil repoinsert projectionversion projectionname projectionname lastseeneventid version version end versionlastseeneventid eventid ok version version else error alreadyseenevent end end ectomultiupdate projectionversion projectionversionchangeset projectionversion projectionname projectionname lastseeneventid eventid multi apply multifn multi case repotransaction multi ok change ok error verifyprojectionversion alreadyseenevent changessofar ok error stage reason changessofar error reason end end end end end example projection supervision read model projector supervised ensure start application restart failure defmodule segmentchallengechallengesprojectionssupervisor use supervisor alias projectionsclubs def startlink supervisorstartlink module nil end def init child projection worker commandedeventhandler clubprojection clubsprojector id clubprojection supervise child strategy oneforone end end query read model optimised query required application read model projection contain denormalised data every query fulfilled using predicate indexed column without complex join provides performant read querying example challenge created athlete query ectoquery domain specific query language used build query retrieve challenge created given athlete us index createdbyathleteuuid column defmodule segmentchallengechallengesquerieschallengeschallengescreatedbyathletequery import ectoquery alias segmentchallengechallengesprojectionschallengeprojection def new athleteuuid c challengeprojection ccreatedbyathleteuuid athleteuuid orderby desc cstartdatelocal end end query constructed executed ecto repo module challenge challengescreatedbyathletequerynew currentathleteuuid conn repoall rebuild read model event sourced system event stream canonical source truth allows read model entirely rebuilt replaced significantly altered assuming domain event contain relevant information repurpose read model future need dictate rebuild define new schema modify affected projection replay event beginning time projector approach allows migrate data one storage mechanism eg relational database another eg document database rebuild data migration done application online configure new projection replay first event caught switch use new read model read application testing application built using cqrses great unit integration testing unit testing aggregate root within domain model command input domain event output unit test verify expected event produced use exmachina define fixture data test segment challenge defmodule segmentchallengefactory use exmachina def challengefactory name segment month startdate n startdatelocal n enddate n enddatelocal n hostedbyclubuuid hostedbyclubname example club createdbyathleteuuid createdbyathletename ben smith urlslug segmentofthemonth end end used calling build function included importing factory module test createchallenge struct createchallenge build challenge challengeuuid example challenge aggregate root unit test two unit test example shown aggregate root test second test excluding competitor show aggregate state must mutated applying returned event defmodule segmentchallengechallengeschallengetest use exunitcase import segmentchallengefactory import segmentchallengeaggregate evolve alias segmentchallengecommands createchallenge includecompetitorsinchallenge excludecompetitorfromchallenge alias segmentchallengeevents challengecreated competitorsjoinedchallenge competitorexcludedfromchallenge alias segmentchallengechallengeschallenge defp createchallenge challengeuuid challengecreatechallenge challenge struct createchallenge build challenge challengeuuid challengeuuid end tag unit test create challenge challengeuuid assert createchallenge challengeuuid struct challengecreated build challenge challengeuuid challengeuuid end describe exclude competitor tag unit test remove competitor challengeuuid athleteuuid reason paid club member competitorexcluded challenge evolve challenge createchallenge challengeuuid challenge evolve challenge challengeincludecompetitors challenge includecompetitorsinchallenge challengeuuid challengeuuid competitor includecompetitorsinchallengecompetitor athleteuuid athleteuuid challengeexcludecompetitor challenge excludecompetitorfromchallenge challengeuuid challengeuuid athleteuuid athleteuuid reason reason assert competitorexcluded competitorexcludedfromchallenge challengeuuid challengeuuid athleteuuid athleteuuid reason reason end end end use keyword chain command function function unit test helper mutates aggregate root state calling function given event starting empty state eg challenge defmodule segmentchallengeaggregate def evolve aggregate event enumreduce listwrap event aggregate aggregatestructapply end end apply unit tag unit test allows execute fast unit test suite integration testing application integration test follow approach use command input verify expected domain event published segment challenge execute full application integration test including event store aggregate root process manager hosting read store projection external http request event read store reset test example host challenge integration test example integration test create challenge command dispatch hidden createchallenge function call setup leaving test assert expected domain event received defmodule segmentchallengechallengeshostchallengetest use segmentchallengestoragecase import commandedassertionseventassertions import segmentchallengeusecasescreatechallengeusecase createchallenge alias segmentchallengeevents challengecreated competitorsjoinedchallenge setup httpoisonstart ok end describe creating challenge setup createchallenge tag integration test create challenge context assertreceiveevent challengecreated fn event assert eventchallengeuuid context challengeuuid assert eventhostedbyclubuuid context clubuuid assert eventurlslug segmentofthemonth end end tag integration test include competitor context assertreceiveevent competitorsjoinedchallenge fn event assert eventchallengeuuid context challengeuuid assert enumany eventcompetitors fn competitor competitorathleteuuid end end end end end assertreceiveevent function provided commandedassertionseventassertion module creates new subscription event store received event matching given module eg challengecreated attempt verify using provided assertion function wait expected event received within limited timeout period fail example create challenge test use case created test use case module reusable function cover enduser scenario test creates challenge createchallengeusecase module exunit support chaining function call using setup inside describe block function receives context map may append new value return allowing function build upon work done previous example test use case make external http call strava api use exvcr record initial response disk replay cached response subsequent test run guarantee test work endtoend yet allows short test feedback loop external request made cached request present defmodule segmentchallengeusecasescreatechallengeusecase use exvcrmock adapter exvcradapterhackney import commandedassertionseventassertions import segmentchallengefactory alias segmentchallengeevents athleteimported alias segmentchallengecommands importclub importclubmembers createchallenge alias segmentchallengeevents athleteimported clubimported competitorsjoinedchallenge alias segmentchallengechallengesrouter def createchallenge context stravaclubid clubuuid challengeuuid athleteuuid usecassette challengecreatechallenge stravaclubid matchrequestson query ok routerdispatch importclub clubuuid clubuuid stravaid stravaclubid stravaaccesstoken stravaaccesstoken ok routerdispatch importclubmembers clubuuid clubuuid stravaid stravaclubid stravaaccesstoken stravaaccesstoken wait athlete create club host challenge imported waitforevent clubimported fn event eventclubuuid clubuuid end waitforevent athleteimported fn event eventathleteuuid athleteuuid end ok routerdispatch struct createchallenge build challenge challengeuuid challengeuuid hostedbyclubuuid clubuuid waitforevent competitorsjoinedchallenge fn event eventchallengeuuid challengeuuid end end stravaclubid stravaclubid clubuuid clubuuid challengeuuid challengeuuid athleteuuid athleteuuid end end keyword list returned function merged context map made available subsequent setup function test allowing keybased access eg context challengeuuid example challenge projection integration test integration test read model projection follow similar pattern reuse use case succinct test containing assertion defmodule segmentchallengeprojectionschallengeschallengeprojectiontest use segmentchallengestoragecase import segmentchallengefactory import commandedassertionseventassertions import segmentchallengeusecasescreatechallengeusecase createchallenge alias segmentchallengewait alias segmentchallengeprojectionsrepo alias segmentchallengechallengesprojectionschallengeprojection setup httpoisonstart ok end describe creating challenge setup createchallenge tag integration tag projection test create challenge projection context waituntil fn challenge repoget challengeprojection context challengeuuid assert challenge nil assert challengename segment month assert challengestartdate n end end end end read model eventually consistent use following wait helper module allow projection built within timeout period test fails defmodule segmentchallengewait def fun fun def fun fun def timeout fun try fun rescue exunitassertionerror timersleep max timeout fun end end end integration projection test tagged integration projection allows execute slower test suite mix test integration mix test projection deployment segment challenge us distillery create elixir release build deployment production host handled edeliver deployment administration production cqrses application deserves full article subscribe mailing list notified new relevant content published conclusion applying command query responsibility segregation event sourcing pattern elixir phoenix web application unorthodox approach hope case study demonstrated briefly might eventstore commanded elixir library provide building block help event store relies upon postgresql persistence commanded us otp behaviour supervision provide concurrency reliability resiliency please get touch feedback idea request article criticism subscribe mailing list like stay informed want discover cqrses elixir subscribe build cqrses application using mailing list receive guidance delivered inbox
318,Lobsters,elixir,Elixir programming,Elixir v1.4,https://github.com/elixir-lang/elixir/releases/tag/v1.4.0,elixir,http enhancement elixir exunit iex mix bug fix elixir exunit iex mix soft deprecation warning emitted elixir exunit deprecation elixir iex mix reload reload,official announcement http enhancement elixir calendar add calendar support adding second microsecond well difference two naivedatetimes second microsecond calendar add dateleapyear calendar ensure date time naivedatetime apis work struct provides set field respective struct example naivedatetime given date since contains superset field date struct enum add invokes given function every nth item enum add allow function specifying default value enumerable empty enum introduce zip multiple entry float introduce return tuple numerator denominator integer retrieve given float genserver log warn default implementation inspect support syntax coloring via syntaxcolor option integer accepts negative integer integer add io add label option help distinguish multiple call kernel recognize merge conflict marker source provide readable error message kernel warn unused module attribute kernel improve compiler message unexpected end line kernel raise badbooleanerror nonboolean given lefthand side andor list add list add optionparser expand multiletter alias optionparser process add process improve error message error registry add local decentralized scalable keyvalue process storage stream add invokes given function every nth item stream introduce lazily zip multiple entry string update unicode task add well supervised version uri allow uri scheme default port exunit exunitdiff use red green background whitespaceonly diffs exunitdoctest allow inspected structure multiple line unicode character doctest result exunitformatter replace lhsrhs leftright formatter clarity iex iexautocomplete stop appending trailing dot autocompleting module iex iexautocomplete support autocompletion structs iexautocomplete improve iex autocomplete support navigating map atom key iexhelpers compiles memory default avoid common issue beam file remain project root directory iexhelpers add info protocol iexserver support interrupting iex evaluation ctrlg prompt mix mix archive compress archive file built mix archive unzipped installation mix archive install scm mix compile automatically infer list application mix project mix cmd add ability specify one apps mix cmd mix deps warn nonapplications apps directory umbrella project mix deps add warning invalid path mix depsclean mix deps add mixprojectappspaths return path child application umbrella project mix deps add mixrebar environment variable overriding local rebar mix escript install scm mix new check directory existence mix new ask proceed one exists mix new application built sup flag individual module work application callback mix test add formatter option mix test mix xref provide mean suggestion mix xref bug fix elixir access accept nil favor explicit default value accesskey expect key always available float avoid multiple rounding kernel nt crash macroexported dealing erlang module kernel ensure local call rewritten calling local function macro inside module kernel annotate context variable zeroarity fun quote kernelspecialforms ensure comprehension guard filter keep proper ordering kernelspecialforms produce meaningful warning else clause effect macro wrap fn call parens macro print alias key inside keyword list optionparser support option ensure count switch correctly encoded stream ensure consume next element suspend string fix infinite recursion given empty string task fix infinite block task monitor task ensure task link parent unlinks exunit exunit fix race condition assertreceive would assert message received show list message message delivered right timeout value iex iexhelpers purge consolidated protocol mix mixdep use gmake freebsd instead make compiling make dependency mixproject copy file source newer destination window machine mixtask ensure nonrecursive task inside umbrella reenabled soft deprecation warning emitted elixir enum deprecated favor system deprecate plural time unit favor singular one align future erlang release exunit exunit using genevent implement exunit formatters deprecated please use new genserver based formatters instead deprecation elixir access deprecated due erratic behaviour missing key please use instead proper default value behaviour behaviour module deprecated callback may defined directly via callback attribute enum deprecate favor float deprecated use erlang function conversion desired kernel deprecate support making private function overridable overridable function must always public must contract kernel warn variable used function call optionparser deprecate alias multiple letter abc set deprecate set module stream deprecate favor iex iexhelpers deprecated favor mix mixutils deprecated perform action time signed another tab window reload refresh session signed another tab window reload refresh session
319,Lobsters,elixir,Elixir programming,Elixir v1.4 released,http://elixir-lang.org/blog/2017/01/05/elixir-v1-4-0-released/,elixir released,release note registry bram verburg extensive benchmark syntax coloring taskasyncstream genstage project application inference mix install scm summing release note install section getting started guide,elixir brings new feature enhancement bug fix notable change addition registry module function aid developer writing concurrent software new application inference command added mix post cover main addition complete release note also available registry registry new module elixir standard library allows elixir developer implement pattern name lookup code dispatching even pubsub system simple scalable way broadly speaking registry local decentralized scalable keyvalue process storage let break part local key value accessible current node opposite distributed decentralized single entity responsible managing registry scalable performance scale linearly addition core upon partitioning registry may unique duplicate key every keyvalue pair associated process registering key key automatically removed owner process terminates starting registering looking key quite straightforward iex registrystartlink unique myregistry iex ok registryregister myregistry hello iex registrylookup myregistry hello self finally huge thanks bram verburg performed extensive benchmark registry show scale linearly number core increasing number partition syntax coloring elixir introduces ability syntax color inspected data structure iex automatically relies feature provide syntax coloring evaluated shell result behaviour configured via syntaxcolors coloring option iexconfigure color syntaxcolors atom cyan string green disable coloring altogether simply pas empty list syntaxcolors taskasyncstream need traverse collection item concurrently elixir developer often resort task collection enummap taskasync somemod function enummap snippet spawn new task invoking somemodfunction element every element collection await task result however snippet spawn run concurrently many task item collection may fine many occasion including small collection sometimes necessary restrict amount task running concurrently specially shared resource involved elixir add brings lesson learned genstage project directly elixir collection taskasyncstream somemod function maxconcurrency enumtolist code also start somemodfunction element task every element collection except also guarantee task processed time use systemschedulersonline retrieve number core balance processing based amount core available taskasyncstream function also lazy allowing developer partially consume stream condition reached furthermore used ensure concurrent task spawned given supervisor application inference previous mix version dependency added dependency list application list mixexs would look like def application application logger plug postgrex end def deps plug postgrex end common source confusion quite error prone many developer would list dependency application list mix automatically infers application list long leave application key empty mixexs rewritten def application extraapplications logger end def deps plug postgrex end mix automatically build application list based dependency developer need specify application shipped part erlang elixir require logger finally dependency want include application runtime list specifying runtime false option distillery runtime false hope feature provides streamlined workflow developer building release elixir project mix install scm mix install escripts archive git hex providing even option distributing elixir code make possible distribute cli application written elixir publishing package build escript hex exdoc updated serve example use new functionality simply running mix escriptinstall hex exdoc fetch exdoc dependency build install exdoc mixescripts default adding mixescripts path running exdoc simple also install archive hex way since fetched built user machine limitation prebuilt archive however keep mind archive loaded every mix command may conflict module dependency project reason escripts preferred format sharing executables also possible install escripts archive providing gitgithub repo see mix help escriptinstall mix help archiveinstall detail summing full list change available release note forget check install section get elixir installed getting started guide learn happy coding
320,Lobsters,elixir,Elixir programming,"Background processing using Elixir, GenServer and the Erlang queue module",https://hackernoon.com/background-processing-using-elixir-genserver-and-the-erlang-queue-class-8d476d4942c2,background processing using elixir genserver erlang queue module,background processing using elixir genserver erlang queue module story replaced redisexq pure elixir erlang queue class omgneering magnetissimo working kinda working working magnetissimo step one towards ultimate goal distillery magnetissimo,background processing using elixir genserver erlang queue modulei writing ruby code year like may reach familiar tool like redis sidekiq process background job data like show sometimes pure elixir enough get job donethis story replaced redisexq pure elixir erlang queue classa huge thank omgneering video genserver trouble understanding genserver tremendous helpi built magnetissimo learning exercise really understand elixir see take ship production ready code version github right work lacking important area set initial goalsgoals crawl multiple index site torrent magnet link working run without ceremony pointless configuration needed kinda high performance leveraging elixir genserver erlang beam vm working unit tested correctness working easy people run project even developer question wanted zerofrictionthe le step running magnetissimo higher adoption rate would bei found solution erlang queue class elixir genserverthis step one towards ultimate goalthe first thing make crawler create worker ofthose crawler supervised supervisorchildren start ecto repository supervisor magnetissimorepo start endpoint application start supervisor magnetissimoendpoint worker magnetissimocrawlerthepiratebay worker magnetissimocrawlereztv worker magnetissimocrawlerlimetorrents worker magnetissimocrawlerleetx worker magnetissimocrawlerdemonoid crawler actually genserver implementation example thepiratebay version crawlerdefmodule magnetissimocrawlerthepiratebay use genserver alias magnetissimotorrent alias magnetissimocrawlerhelper def startlink queue initialqueue genserverstartlink module queue end def init queue schedulework ok queue end defp schedulework processsendafter self work second end callback def handleinfo work queue case queueout queue value item queue queue process item queue ioputs queue empty restarting queue queue initialqueue end schedulework noreply queue end def process pagelink url queue ioputs downloading page url htmlbody helperdownload url htmlbody nil torrent torrentlinks htmlbody queue enumreduce torrent queue fn torrent queue queuein torrentlink torrent queue end end queue end def process torrentlink url queue ioputs downloading torrent url htmlbody helperdownload url htmlbody nil torrentstruct torrentinformation htmlbody torrentsavetorrent torrentstruct end queue end parser function def initialqueue url j pagelink http thepiratebayorgbrowse j end queuefromlist url end def torrentlinks htmlbody htmlbody flokifind detname flokiattribute href enummap fn url http thepiratebayorg url end end def torrentinformation htmlbody name htmlbody flokifind title flokitext stringtrim htmlentitiesdecode magnet htmlbody flokifind download flokiattribute href enumfilter fn url stringstartswith url magnet end enumat size htmlbody flokifind detailsframe detail dd enumat flokitext stringsplit enumat stringreplace seeder htmlbody flokifind detailsframe detail dd enumat flokitext integerparse leechers htmlbody flokifind detailsframe detail dd enumat flokitext integerparse name name magnet magnet size size websitesource thepiratebay seeder seeder leechers leechers endendinitialqueue function creates erlang queue object initial url sprawl link pagination page individual torrent linkseach element queue tuple two part torrentlink someurl pagelink someurl using function pattern matching process method easily either parse pagination link parse individual torrent pagethe schedulework function schedule next item processedthe end result cohesive code le indirection much easier add new crawler project also easier know exactly running le chance bug predictable growth behavior one downside approach volatility app shuts lose queue process comfortable particular projectone potential upgrade change handleinfo async handlecallmy next step going using distillery build single deployable executable end user run magnetissimo start service localhostsubscribe get daily roundup top tech story
322,Lobsters,elixir,Elixir programming,Reducing the maximum latency [on BEAM],http://theerlangelist.com/article/reducing_maximum_latency,reducing maximum latency beam,low latency large working set ghc garbage collector pick two three golang realtime gc theory practice challenge accepted measuring asdf functional implementation queue article one refc binary ets based implementation final thought processspawn inprocess c nifs outprocess anything port,recently came across two great article pusher blog low latency large working set ghc garbage collector pick two three golang realtime gc theory practice article tell story pusher engineer reimplemented message bus first take done haskell performance test noticed high latency percentile range bared code able prove spike caused ghc stoptheworld garbage collector coupled large working set number inmemory object team experimented go got much better result owing go concurrent garbage collector highly recommend article pusher test great benching example focused solving real challenge evaluating technology based whether suitable job kind evaluation prefer instead comparing technology shallow synthetic benchmark passing token ring benching web server return ok find much useful make simple implementation critical functionality see behaves desired load provide answer question solve x efficiently using approach took first evaluated erlang hour test simulation real system time expected load convinced technology capable needed challenge accepted reading pusher article made wonder well would elixir implementation perform underlying erlang vm beam built low predictable latency mind coupled property faulttolerance massive concurrency scalability support distributed system seems like compelling choice job let define challenge based original article implement fifo buffer handle two operation push pull buffer bound maximum size buffer full push operation overwrite oldest item queue goal reduce maximum latency push pull operation large buffer max item important keep final goal mind care smoothing latency spike buffer operation care le language give better worstcase gc pause root issue pusher challenge caused long gc pause mean solve moving another language demonstrate relying trick elixirerlang bypass gc completely bring max latency microsecond area measuring measure performance decided run buffer separate genserver powered process see implementation measurement taken using erlang tracing capability separate process started set trace buffer process receives startfinish time push pull operation well buffer garbage collection collect time asked produce final stats find implementation tracing cause slowdown whole bench seems take longer tracing used say much affect reported time care much able get good result tracing turned implementation suffice tracing turned familiar erlang word process refers erlang process lightweight concurrent program run o process share nothing erlang process o level still one o process inside multiple erlang process running separately process nothing common share memory communicate sending message particular process separate heap garbage collected separately process therefore whatever data allocated tracer process code put gc pressure buffer data actually pushing buffer considered buffer gc thus affect latency buffer operation approach demonstrates great benefit erlang running different thing separate process prevent gc pressure one process affect others system aware lightweight concurrency platform provides guarantee test first start brief stretch warmup create buffer maximum capacity item number used pusher bench push item pull push item end warmup buffer maximum capacity bench start issuing request cycle push followed pull buffer therefore mostly operates overflow mode total push performed full buffer push nearly full buffer item pushed byte erlang binares item different others meaning test create different item bench code resides full project available benched using erlang elixir installed asdf version manager test performed imac ghz intel core functional implementation first try consider idiomatic approach elixir erlang purely functional implementation based queue module according doc module implement doubleended fifo queue efficient manner operation amortized running time api module provides thing needed use pushpull item direct support setting maximum size fairly simple implement top queue module find implementation originally read pusher article pretty certain implementation lead larger latency spike stoptheworld gc erlang still stoptheprocess gc erlang process start fairly small heap kb need allocate process gced heap possibly expanded detail gc recommend article one test mean buffer process pretty soon expand large heap need accommodate item pushing item create garbage gc lot work consequently expect significant gc pause lead latency spike let verify mix bufferbench bufferqueue pushpull time average μs μs μs μs μs μs longest μs gc time average μs μs μs μs μs μs longest μs buffer process memory kb total memory used mb lot data highlight number find interesting start average latency buffer operation average get bad reputation day still find useful metric observed average latency microsecond tell implementation cope roughly operationssec without lagging even buffer completely full tolerate latency variation expect request higher rate queue implementation suit need looking latency distribution see max latency millisecond might unacceptable may fine depending particular use case would wrong broadly extrapolate queue powered buffer always suck proclaim work well case interpret number know specification requirement particular problem hand look closer latency distribution pushpull operation see latency grows rapidly four five nine transition two digit microsecond two digit millisecond area operation mean experience latency spike le whether acceptable depends constraint particular problem printed gc stats related buffer process see gc took place buffer process high percentile latency twodigit millisecond range unsurprisingly seems strong correlation gc time latency spike start nine percentile range finally notice buffer process heap size mb might expect around mb since buffer hold item byte however bench item called refc binary mean stored separate heap buffer process heap hold reference binary data course buffer process still live reference heap together garbage removed message cause latency spike looking worstcase gc time comparing language erlang fare well might wrongly conclude suitable job ets based implementation however work around gc limitation ets table ets table come couple shape article keep simple saying serve inprocess inmemory keyvalue store come semantics ets table bring anything new table pun intended could implement functionality using plain erlang process data structure however ets table couple interesting property make perform well case first ets table data stored separate memory space outside process heap hence use ets table store item buffer process need hold lot live reference anymore reduce gc time moreover data ets table released immediately removal mean completely remove gc large set implementation ets based buffer based pusher go implementation basically using ets table simulate mutable array storing kv pair index value table maintaining two index one determines going push next item another pull operation originally start value zero push store pushindex value pair table increase push index one push index reach maximum buffer size set zero likewise pulling data read value associated pullindex key increment pull index buffer full push operation overwrite oldest value increment index thus making sure next pull operation read proper location full implementation available let see performs mix bufferbench bufferets pushpull time average μs μs μs μs μs μs longest μs gc time average μs μs μs μs μs μs longest μs buffer process memory kb total memory used mb average time microsecond radically better queue powered implementation however latency spike much smaller longest observed latency microsecond five nine range already twodigits microsecond area fact push took longer microsecond shabby full disclosure result best one got couple run machine max latency sometimes go slightly number change significantly particular always μs looking gc stats see large increase number gc buffer process queue implementation buffer process triggered gc implementation observe gc reason keep mind buffer process still manages data heap includes index next pushpull operation well temporary reference item pushedpulled since lot request arrive buffer process going generate lot garbage however given buffer item stored separate heap ets table buffer never maintain large live set corresponds pusher conclusion gc spike problem related amount generated garbage rather amount live working set implementation reduced set keeping buffer process heap pretty small consequently although trigger lot gc pretty short longest observed gc buffer process took microsecond final thought given erlang stoptheprocess gc property might sometimes experience large pause process however option disposal help u trim large spike main trick control pause keep process heap small large active heap coupled frequent incoming request going put pressure gc latency going increase particular example using ets helped reduce heap size buffer process although number gc increased dramatically gc pause pretty short keeping overall latency stable erlang certainly fastest platform around allows keep latency predictable build system finetune reach desired performance expect le surprise production worth mentioning two technique might help reduce gc spike one approach split process manages big heap multiple process smaller working set lead fragmented gc possibly remove spike case capitalize fact process memory immediately released process terminates need perform oneoff job allocates lot temporary memory consider using processspawn allows explicitly preallocate larger heap starting process might completely prevent gc happening process calculation spit result finally terminate process memory get immediately reclaimed without ever gced finally make critical part system efficient erlang always resort inprocess c nifs outprocess anything port keeping elixirerlang main platform controller plane system many option table give lot confidence able handle challenge encounter matter tricky might
323,Lobsters,elixir,Elixir programming,Tuning Elixir GenStage/Flow pipeline processing,http://teamon.eu/2016/tuning-elixir-genstage-flow-pipeline-processing/,tuning elixir genstageflow pipeline processing,understanding problem repostream genstage flow implementation tuning last word followup measuring visualizing genstageflow gnuplot,many use case genstageflow one case recently faced get record postgresql database download file associated record amazon extract text file index text elasticsearch task represented pipeline four step select record database download pdf file extract text file index extracted text since dealing hundred thousand record find efficient way pipeline processing example could implement efficient parallel processing line code understanding problem basic question asked problem jumping conclusion crucial understand problem dealing processing pipeline every step different characteristic select need execute sql query return record best done using postgresql cursor recently added repostream easily step single serial source emit continouous stream record download step mostly network io easily parallelized extract one mostly cpu work also parallelized multiple core index elasticsearch indexing performing best done batch much better one document time simple analysis give u highlevel overview need deal turned perfect example make use genstage especially flow implementation genstage separate pipeline stage three different type producer take input emits event case select step producerconsumer receives event emits event case download extract step consumer receives event emit case index step think stage simple function spec select stream def select spec download record file def download record spec extract file text def extract file spec index text nothing def index text full pipeline look like one select stage download stage extract stage accumulate stage required prepare batch next stage index stage need run stage line code def perform start calling function get stream select convert flow flowfromenumerable maxdemand distribute flow record process flowpartition maxdemand stage calling function every record received flowmap result flow file distribute process flowpartition maxdemand stage calling function every file received flowmap since want indexing batch need accumulate flow text chunk using flowpartition window flowwindowcount stage function take two argument accumulator init function called start every batch reduce function called every item batch simply putting incoming item list flowreduce fn end fn item list item list end right flow event still single text need tell flow interested reducer state flowemit state finally use flowpartition function start process flowpartition maxdemand stage calling every list text flowmap end simply run flow block whole pipeline finished flowrun end end unfortunately quite yet tuning example used somehow arbitrary value maxdemand stage parameter code work produce correct result performance characteristic far perfect take look graph produced sample data around record line represents number item processed stage time see select stage immediately fetched record database putting memory extract stage started processing around second already almost file downloaded also index stage started late already text item ready indexed processing pipeline performance single stage le important performance whole pipeline processing large datasets want whole system stable term resource usage playing around different value plotting quite chart ended following value def perform select flowfromenumerable maxdemand flowpartition maxdemand stage instead flowmap flowpartition maxdemand stage instead flowmap flowpartition window flowwindowcount stage flowreduce fn end fn item list item list end flowemit state flowpartition maxdemand stage instead flowmap flowrun end resulted much better flow data tuned parameter stage processing data pipeline minimizing buffering memory consumption also seems little bit faster since hitting real external service taken proper speed benchmark last word genstage higherlevel wrapper flow provide building block efficient parallel pipeline processing obviously magic forget performance measurement yet confident correct performance characteristic achieved whole system scale pretty well larger datasets keeping resource usage low followup measuring visualizing genstageflow gnuplot
325,Lobsters,elixir,Elixir programming,"Released: benchee 0.6.0, benchee_csv 0.5.0, benchee_json and benchee_html – HTML reports and nice graphs!",https://pragtob.wordpress.com/2016/12/01/released-benchee-0-6-0-benchee_csv-0-5-0-benchee_json-and-benchee_html-html-reports-and-nice-graphs/,released benchee bencheecsv bencheejson bencheehtml html report nice graph,benchee changelog bencheecsv changelog bencheehtml bencheejson example online report big new feature benchee new run api option last keyword list elixirforum multiple input inspired discussion elixir issue josé valim bencheehtml wiki page bencheehtml discern different graph sample report closing thought like,last day hard work polish finish release benchee changelog bencheecsv changelog well initial release bencheehtml bencheejson proudest happiest finally getting bencheehtml door along great html report including plenty graph ability export check example online report glance screenshot bencheecsv mere update compatibility bencheejson transforms general suite json used html formatter particularly excited big new feature benchee course bencheehtml benchee probably biggest release core benchee library needed api change great feature new run api option last keyword list old way optionally pas option first argument run map define job benchmark another map mind configuration come first map much easier work pattern matching opposed keyword list however optional first argument already felt kind thing elixir way rather conventional pas option last argument keyword list voicing concern elixirforum solution allow passing option keyword list convert map internally still advantage good pattern matching among advantage list enumtolist mapfun fn end bencheerun flatmap fn enumflatmap list mapfun end mapflatten fn list enummap mapfun listflatten end formatters html file samplesoutputflatmaphtml old style still work thanks pattern matching might get deprecated future process though run interface first version run used list tuples work anymore multiple input great new feature benchee support multiple input one suite run function multiple different input important function behave differently input different size different structure therefore good check function multiple input feature inspired discussion elixir issue josé valim look like go mapfun fn end bencheerun flatmap fn input enumflatmap input mapfun end mapflatten fn input input enummap mapfun listflatten end input small enumtolist bigger enumtolist erlangotp hipe kernelpoll false elixir benchmark suite executing following configuration warmup time parallel input bigger small estimated total run time benchmarking input bigger benchmarking benchmarking benchmarking input small benchmarking benchmarking input bigger name ip average deviation median mapflatten m m flatmap m m comparison mapflatten flatmap slower input small name ip average deviation median mapflatten k μs μs flatmap k μs μs comparison mapflatten k flatmap k slower hard thing changed benchmarking result represented internally another level represent different input needed lead quite work benchee plugins end worth bencheehtml making way long released month ago provides nice html table four different graph comparing different benchmarking job graph individual job take closer look distribution run time particular job wiki page bencheehtml discern different graph highlighting might useful also export png image graph click simple icon wonder use well already shown earlier post showing new api specify formatters file written without ado check sample report take look image closing thought hope enjoy benchmarking different input see great report let know like benchee like could better like like loading related
326,Lobsters,elixir,Elixir programming,Tips for Getting Started with Elixir & IEx,https://www.promptworks.com/blog/getting-started-with-elixir-and-iex,tip getting started elixir iex,get shellbreak menu pretty old behavior defined beam get information module repl defining function iex compiling code file add new function module bonus learn available command,new elixir hopefully post help knock basic problem encounter first hour trying elixir order get interesting stuff faster get shellbreak menu bort c ontinue p roc info nfo l oadedi ca nt tell number time thought minute kill play erlangelixir gotten stuck prompt realized pressing thing moved another task fifteen time maybe higherso start typing code realize made mistake hit ctrlc cancel entered given strange prompt erlang call shellbreak iex x fn b c b break bort c ontinue p roc info nfo l oaded v ersion k ill btables istributionthe option need care c c ontinue option take back normal entry mode want really hit enter twice exit replthis pretty old behavior defined beam virtual machine interprets elixir erlang code option spews ton information certain come handy someday debugging beam overkill get information module replone favorite thing ruby call method object get back list method object support found invaluable starting ruby still use timeso elixir modulemoduleinfo example defined foobarawesomeex defmodule awesome def verycool arg end def beastisthebestofthexmen true endiex awesomemoduleinfo export argument moduleinfo return keyword list key module attribute compile native passed argument scope return valuethere also thing ca nt elixir repl might expect especially coming defining function iexin ruby repl define toplevel function true almost every language try something like iex iex def square x x x endyou get argumenterror invoke outside module elixir elixir elixir expanding macro file option option define anonymous function need call sorta weird syntax technically valid ruby pretty obscure iex square fn x x x end iex square define extra module probably better way even starting put definition fileiex defmodule necessary def square x x x end end iex necessarysquare compiling code filesay defined code module compile c followed path file iex c foobarawesomeex awesome module defined awesomeex available add new function moduleelixir module nt open try defmodule alreadyexistingmodule redefine module function specified new definition also mean ca nt really monkeypatch core moduleif want add new function redefine one code stored file edit recompile enterering r modulename rebuild code subsequent call updated method new bonus h learn available commandsthe syntax tooling really similar ruby language also totally different property exciting much growing interest elixir go play around repl
327,Lobsters,elixir,Elixir programming,Elixir v1.4.0-rc.0 released,https://elixirforum.com/t/elixir-v1-4-0-rc-0-released/2627,elixir released,http http http elixirlangorginstallhtml precompiledpackage faq http,hello folk elixir released release candidate upcoming elixir notable change addition registry module aid developer writing concurrent software overall smallest release since elixir also feature find information release changelog http release also officially moving doc elixir friend hexdocs http provides unified doc experience throughout ecosystem ability version version far kept latest branch please give elixir try since prerelease may available package manager easily use precompiled package explained http elixirlangorginstallhtml precompiledpackage finally previous release release includes new warning please update library dependency emitting warning please update appropriate send pull request possible faq frequent elixir release elixir release happening interval month true since elixir reason officially planning new minor release every month hard rule necessary release earlier later nothing worthwhile added master timeline work genstage elixir core discussed agreed include genstage part elixir actually good news genstage became obvious last month genstage grown beyond expectation keeping genstage flow separate project flexibility evolving case continue plan remove genevent elixir core long term genstage elixir registry used replacement known tool supervisor genservers may job well recently written plataformatec blog http elixir final released announce full plan genstage flow relate future elixir version
328,Lobsters,elixir,Elixir programming,How Supervisors Work,https://jbodah.github.io/blog/2016/11/18/supervisors-work/,supervisor work,elixir source erlang source genserver work childspec trap exit record source conventionally call startlink worker module errorlogger reading handleinfo genserverstop supervisor terminate callback,erlang elixir supervisor process manage child process restart crash post going take look detail supervisor implemented rough idea worked understand specific felt like learning stuff figured share dive would helpful understand use genserver supervisor module used elixir equivalent fine delegate erlang module really change behaviorally let start example elixir straight doc defmodule myappsupervisor use supervisor def startlink supervisorstartlink module end def init child worker stack hello imported supervisorspec supervise child strategy oneforone end end example startlink spawning supervisor init callback used supervisor behaviour let dig supervisor quick recap behaviour use supervisor call expand compile time whatever behaviour using macro let look using supervisor module elixir source tangent elixir source laid conventionally recommend take little time get comfortable navigating using macro time writing defmacro using quote location keep behaviour supervisor import supervisorspec end end behaviour check make sure implement necessary callback supervisor import statement pulling extra method myappsupervisor supervisorspec worker supervise method defined gist use supervisor statement mixing function making sure implement right callback way start supervisor calling myappsupervisorstartlink let dig obviously delegate supervisorstartlink passing reference via module checking source supervisorstartlink def startlink module arg option islist option case keywordget option name nil supervisorstartlink module arg atom isatom atom supervisorstartlink local atom module arg global term tuple supervisorstartlink tuple module arg via viamodule term tuple isatom viamodule supervisorstartlink tuple module arg raise argumenterror expected name option one nil atom global term via module term got inspect end end main thing see elixir module delegating erlang supervisor module wait run screaming follow erlang source trust grepping startlink find export statement exposing outside module spec telling type function expects actual implementation startlink mod args genserver startlink supervisor self mod args see already something familiar starting genserver dig genserver work main takeaway supervisor built ontop genserver genserver expects u implement bunch callback one concerned right init note even though myappsupervisor implement init callback called next look back startlink erlang supervisor module see pass self reference meaning supervisorinit function looking next source init supname mod args processflag trapexit true case mod init args ok supflags startspec case initstate supname supflags mod args ok state issimple state initdynamic state startspec ok state initchildren state startspec error stop supervisordata error end ignore ignore error stop badreturn mod init error end thing first calling mod init args calling myappsupervisorinit let look real quickly def init child worker stack hello imported supervisorspec supervise child strategy oneforone end remember worker supervise helper coming supervisorspec without digging plumbing cut chase focus erlang side thing worker output childspec supervise output tuple looking like ok strategy maxretries maxseconds childspecs back supervisorinit next importantly call processflag trap exit important central supervisor know restart process tl dr process terminates sends exit signal linked process calling processflag trap signal instead send exit frompid reason message process instead see later supervisor process use frompid value know process died restart okay left supervisorinit started trapping exit signal next initialize state child go initstate let go initchildren since dealing simpleoneforone supervisor initchildren state startspec supname state statename case checkstartspec startspec ok child case startchildren child supname ok nchildren ok state state child nchildren error nchildren reason terminatechildren nchildren supname stop shutdown reason end error stop startspec error end oh boy symbol another quick tangent state statename accessing variable state state record plucking name field record moreorless structs stored ordered tuples like state josh kind like enum type language record way decouple position field meaning source state record defined top file record state name strategy strategy undefined child childrec dynamic dict dict pid list set set pid undefined intensity nonneginteger undefined period posinteger undefined restarts dynamicrestarts nonneginteger module args see state record name field supname state statename treating state tuple state record plucking whatever field corresponds name saving supname glancing checkstartspec validation well casting spec received myappsupervisorinit record source real meat supervisorinitchildren startchildren though startchildren child supname startchildren child supname startchildren childchs nchildren supname case dostartchild supname child ok undefined child childrestarttype temporary startchildren chs nchildren supname ok pid startchildren chs child child pid pid nchildren supname ok pid extra startchildren chs child child pid pid nchildren supname error reason reporterror starterror reason child supname error list reverse chs child nchildren failedtostartchild child childname reason end startchildren nchildren supname ok nchildren little recursion plucking child calling dostartchild dostartchild supname child child mfargs f args child case catch apply f args ok pid ispid pid nchild child child pid pid reportprogress nchild supname ok pid ok pid extra ispid pid nchild child child pid pid reportprogress nchild supname ok pid extra ignore ok undefined error error error end apply erlang dynamic function invocation method similar send ruby applycall javascript wind dynamically calling callback defined supervisorspecworker conventionally call startlink worker module finally call reportprogress us erlang unfortunately named errorlogger publish info event new process started supervisor first breathe okay let continue zooming way supervisor start trap exit start child still gotten real beef supervisor restart child really close remember processflag trap exit signal turn exit frompid reason tuples also remember supervisor built top genserver well genserver handle noncallcast message using handleinfo reading handleinfo supervisor handle exit child handleinfo exit pid reason state case restartchild pid reason state ok noreply shutdown stop shutdown end see handle exit message contains pid child process exited reason feed restartchild victory already seen dostartchild work restartchild fairly similar leave curious look interested supervisor implement shutdown strategy take peek genserverstop delegate supervisor terminate callback let sum elixir implement conventional framework writing supervisor framework interface erlang supervisor module built top genserver elixir pass configs supervisor module us start child process manages child process trapping exit signal child convert signal message implement handleinfo callback handle exit message restart correct worker finally worth reiterating publishes report errorlogger erlang event manager anyways learned ton dig hope found post useful way think could clearer please let know thanks reading
329,Lobsters,elixir,Elixir programming,Binary data over Phoenix sockets,https://nerds.stoiximan.gr/2016/11/23/binary-data-over-phoenix-sockets/,binary data phoenix socket,tl dr phoenix framework messagepack messagepack say well wrong json stoiximan mentioned gzipping everybody mom know gzipped json data smaller msgpackedgzipped counterpart make sense anything else know expansion ok got somewhat interested scared extra work msgpackelixir websocketserializerex implementation modern http client imaya zlibjs messagepack spec default implementation network tool websocket debugging github,tl dr send raw binary data channel phoenix framework read data client using messagepack format deliver payload gzipping make sense messagepack say well wrong json nothing really except could leaner see stoiximan delivering lot lot data customer even minor gain payload translate lot byte saved end customer mobile data plan server load plus cool kid use raw byte mentioned gzipping everybody mom know gzipped json data smaller msgpackedgzipped counterpart true payload usually small enough gzipping make sense time data send msgpacked msgpack size smaller generally speaking json size data fit description though app chunky rather chatty mean use json right mean le work anything else know technique described work fairly modern browser ie supporting websockets allow raw byte sending receiving typedarrays ie targeting need support older browser connect longpolling transport send json data possibly ie text data taking expansion account gzipping detective work capability detection work find supported none shown keep post focused ok got somewhat interested scared extra work go ahead create new folder named binarydataoverphoenixsockets cd inside create sample project mix phoenixnew noecto command line press asked fetch dependency open mixexs add msgpackelixir dependency file mixexs defp deps deps go messagepack end run mix depsget download first thing need create msgpack serializer use phoenix transport looking course default websocketserializerex implementation inspiration create folder webtransports add new file messagepackserializerex file webtransportsmessagepackserializerex defmodule binarydataoverphoenixsocketstransportsmessagepackserializer moduledoc false behaviour phoenixtransportsserializer alias phoenixsocketreply alias phoenixsocketmessage alias phoenixsocketbroadcast gzip data gzipthreshold def fastlane broadcast msg socketpush binary packdata topic msgtopic event msgevent payload msgpayload end def encode reply reply packed packdata topic replytopic event phxreply ref replyref payload status replystatus response replypayload socketpush binary packed end def encode message msg need convert message struct plain map messagepack work properly alternatively could implemented enumerable behaviour pick poison socketpush binary packdata mapfromstruct msg end message received client still json format use case client mostly passive listener made sense optimize incoming traffic def decode message opts message poisondecode phoenixsocketmessagefrommap end defp packdata data msgpacked messagepackpack data enablestring true gzipdata msgpacked bytesize msgpacked end defp gzipdata data size size gzipthreshold data defp gzipdata data size zlibgzip data end anyone bothered click default implementation link immediately see code essentially except using messagepack serialize payload duh telling phoenix payload binary text data relates websocket frame handling open webchannelsusersocketex file override default serializer file webchannelsusersocketex transport websocket phoenixtransportswebsocket serializer binarydataoverphoenixsocketstransportsmessagepackserializer also need channel actual talking go ahead run command line mix phoenixgenchannel test create file webchannelstestchannelex follow suggestion add channel usersocketex file webchannelsusersocketex add line transport channel test lobby binarydataoverphoenixsocketstestchannel note depending phoenix version may need run mix phoenixgenchannel test lobby instead add two callback return sample response showcase plain gzipped payload delivery open testchannelex add following line inside testchannel module file webchannelstestchannelex def handlein small payload socket push socket smallreply small response msgpacked true noreply socket end def handlein large payload socket push socket largereply large response msgpackedgzipped enummap fn end enuminto noreply socket end wrap server portion thing run mix phoenixserver fire app open modern browser navigate http client time get crackin client first thing first need gunzip data sent server gzipped need unpack msgpacked message unfortunately native browser support thing need get little creative unzipping using stripped version imaya zlibjs since need unzipping part go ahead create file gunzipjs webstaticjsvendor adding content file webstaticjsvendorgunzipjs paste content http githubcomstoiximanservicesblogblobmasterbinarydataoverphoenixsocketswebstaticjsvendorgunzipjs unpacking need unpack message client need packing searching around produce anything fit need get roll messagepack decoder yay nt worry messagepack spec pretty straight forward need lookaheadlookbehind modeling decoder state machine pose much problem mention fast well create file webstaticjsmsgpackjs put following inside file webstaticmsgpackjs let format positivefixintstart positivefixintend fixmapstart fixmapend fixarrstart fixarrend fixstrstart fixstrend nil none bfalse btrue negativefixintstart negativefixintend decode return two element po data array index hold new position parser index contains parsed data carry around original binary data array avoid copying new slice updating parser position recursively calling decode consumed buffer missing implementation extension support add need let decode function binarydata start start start let format binarydata start format formatspositivefixintend return start format formatspositivefixintstart format formatsfixmapend let keycount format formatsfixmapstart return parsemap binarydata keycount start format formatsfixarrend let len format formatsfixarrstart return parsearray binarydata len start format formatsfixstrend let len format formatsfixstrstart return binarydata len start let po len switch format case formatsnil return start null case formatsbfalse return start false case formatsbtrue return start true case po len parseuint binarydata start return parsebinaryarray binarydata len po case po len parseuint binarydata start return parsebinaryarray binarydata len po case po len parseuint binarydata start return parsebinaryarray binarydata len po case return parsefloat binarydata start case return parsefloat binarydata start case return parseuint binarydata start case return parseuint binarydata start case return parseuint binarydata start case return parseuint binarydata start case return parseint binarydata start case return parseint binarydata start case return parseint binarydata start case return parseint binarydata start case po len parseuint binarydata start return binarydata len po case po len parseuint binarydata start return binarydata len po case po len parseuint binarydata start return binarydata len po case po len parseuint binarydata start return parsearray binarydata len po case po len parseuint binarydata start return parsearray binarydata len po case po len parseuint binarydata start return parsemap binarydata len po case po len parseuint binarydata start return parsemap binarydata len po format formatsnegativefixintstart format formatsnegativefixintend return start formatsnegativefixintend format throw new error nt know decode format format function parsemap binarydata keycount start let ret let po start let keycount let keypos key decode binarydata po po keypos let valpos value decode binarydata po po valpos ret key value return po ret function parsearray binarydata length start let ret let po start let length let newpos data decode binarydata po po newpos retpush data return po ret function parseuint binarydata length start let num let po start let count length count count num binarydata po count po return po num function parseint binarydata length start let po unum parseuint binarydata length start let length http githubcominexorabletashpolyfillblobmastertypedarrayjs return po unum function parsebinaryarray binarydata length start let binarydatasubarray binarydataslice let po start length return po mcall binarydata start po function parsefloat binarydata length start let bytecount length let view new dataview new arraybuffer length let start bytecount istart binarydata let fnname getfloat length let result view fnname false return start bytecount result function data length start http var result var start var c var var bom skip length data data data let mark length start mark c data c resultpush stringfromcharcode c else c c datalength throw decode failed two byte character truncated data resultpush stringfromcharcode c else datalength throw decode failed multi byte character truncated data data resultpush stringfromcharcode c return mark resultjoin let msgpack decode function binaryarray return decode binaryarray export default msgpack phew mouthful ready intercept socket incoming message use decoder parsing data going look default implementation inspiration start abstracting msgpack parsing module reusability use inside socketjs start creating new file webstaticjsbinarysocketjs add following file webstaticjsbinarysocketjs import msgpack msgpack lot consolelog statement educational purpose file nt forget remove production function converttobinary socket let parentonconnopen socketonconnopen socketonconnopen function setting arraybuffer help u deal blob thisconnbinarytype arraybuffer parentonconnopenapply argument also need override onconnmessage function checking binary data delegate default implementation expected let parentonconnmessage socketonconnmessage socketonconnmessage function rawmessage rawmessagedata instanceof windowarraybuffer return parentonconnmessageapply argument let msg decodemessage rawmessagedata let topic msgtopic let event msgevent let payload msgpayload let ref msgref thislog receive payloadstatus topic event ref ref payload thischannelsfilter function channel return channelismember topic foreach function channel return channeltrigger event payload ref thisstatechangecallbacksmessageforeach function callback return callback msg return socket function decodemessage rawdata rawdata return let binary new rawdata let data check gzip magic byte binarylength binary binary let inflate new windowzlibgunzip binary data inflatedecompress consolelog received binarylength byte gzipped data datalength byte inflating else consolelog received binarylength byte plain msgpacked data data binary let msg msgpackdecode data return msg export default converttobinary let head webstaticjssocketjs replace content following file webstaticjssocketjs import socket phoenix import binarysocket binarysocket typemsgpack param added distinguish connection phoenix live reload connection browser network tab let socket new socket socket params type msgpack socket binarysocketconverttobinary socket socketconnect let join lobby let channel socketchannel test lobby channelon smallreply function data consolelog small reply server responded data channelon largereply function data consolelog large reply server responded data channeljoin receive ok resp consolelog joined successfully resp channelpush small channelpush large receive error resp consolelog unable join resp export default socket lastly need import socketjs content appjs file open webstaticjsappjs uncomment following line file webstaticjsappjs import socket socket browser refreshed quite lot time let open dev tool head network tab switch websocket frame debugging keeping console window open refresh page make sure debugging typemsgpack websocket connection one phoenix live reload feature seeing everything worked binary frame sent server text json frame sent client remember work server able send msgpacked data message console happily notifying u everytime response received heartbeat part network tool websocket debugging folk hope enjoyed post wish lot happy elixir coding p code test course github
331,Lobsters,elixir,Elixir programming,"Beyond 10,000 Lines",https://shift.infinite.red/beyond-10-000-lines-ba1adc17cc7b,beyond line,beyond line lesson learned large phoenix project phoenix infinite red repo ecto schema view module plug service replacing callback ectomulti use otp advantage blog post gist write fewer valuable test avoid dsl integration apis elasticsearch httpoison test data fixture ecto admin panel activeadmin avoid nonrestful route conclusion,beyond lineslessons learned large phoenix projectwe recently finished large phoenix project infinite red learned tip trick along way want share overall impressed well organized maintainable phoenix project beyond line codesome tip post specific phoenix others could equally applied rail web framework none meant applied woodenly though keep brain repo ecto schemasdon use repo ecto schema alias use easy way prevent schema becoming large bloated like activerecord model tend rail without access repo schema center business logic anymore execute query actually feel natural phoenix much better way share business logic following view business logic viewrelated put helper function view module easily share function view import callsimport myappphoneview formatphone module plug often somewhat complicated logic fetching data database find best place put logic like module plug add assigns conn use plug controller even whole router scope added webplugs folder project promote controllersplug myappcurrentuser router scopespipeline authorization plug myappcurrentuserendscope myapp pipethrough authorization endservices wrote replacing callback ectomulti side effect best done service layer built ectomulti see post added webservices folder use otp advantagebecause heroku deployment target limited could use otp heroku isolates dynos really set otp cluster without paying lot extra private heroku space however still came number clever way use supervised process advantageautomatically starting elasticsearch kibana development mode see blog postrunning mix task regularly custom schedule like cron job supported heroku scheduler simple scheduler genserver see write fewer valuable testswe focused automated test controller action plug rather going test coverage since main way phoenix application interface outside world critical point failurecontroller test also exercise lot code path application making le necessary unit test every single module result end fewer test make easier refactoring provided change preserve behavior controller avoid dslswe avoided adding new dsl beyond come ecto phoenix far big win u least three area could used dsl tintegration apistest dataadmin panellet talk detail one integration apiswe used elasticsearch power search feature instead using library dsl talk rest api directly tiny httpoison modulethis mean code look close official elasticsearch documentation figure make given json request dsl make request documentation show query like get search query bool must match title search match content elasticsearch filter term status published range publishdate gte execute query elixir like convert notation json elixirelasticsearchget search query bool must match title search match content elasticsearch filter term status published range publishdate gte simplicity like valuable allowed u iterate much quicker make site much easier maintain since new developer follow official elasticsearch documentation closely learn work implement new test datawe followed advice fixture ecto test data worked great even project size model many association really need dsl simple function work fine fact one file fixture yet quite admin panelthe project extensive admin panel continue expand future rail world common generate kind panel using activeadmin library rely dslrather use approach built admin using generator create standard phoenix code get benefit activeadmin quick setup search filtering even new thing like customizable style without downside dslif want add anything admin regular phoenix code controller view template rest need learn anything new wrangle dsl maintain opensourcing admin panel generator soon follow publication want first know avoid nonrestful routesthis tip hold true restbased web framework including rail whenever find adding function controller index new create show edit update delete treat code smell investigate adding might good reason usually tthroughout project observed whenever added nonrestful route result muddled thinking requirement often work allit combined multiple responsibility one controller logically belong two separate controller made controller harder work maintain muchbecause instance refactored later causing extra effortfar better keep route action restful first place creating new controller cheap reason resist currently controller still feel like muchconclusionwe learned lot project validated u phoenix stable platform large small project alike despite fact well line elixir code codebase feel bloated disorganized refactoring remains easythese practice helped ton also found elixir pretty forgiving mistake since nearly code made stateless module function hard move thing around refactor even make mistake le likely end code maintainso waiting phoenix mature jumping wait mature enough let build thing
333,Lobsters,elixir,Elixir programming,Changelog.com is Open Source,https://changelog.com/posts/changelog-is-open-source,changelogcom open source,relaunch announcement source code github elixir phoenix postgresql host great open source website good war ridiculously fast semantic ui webpack cmark httpoison concache arc scrivener bamboo changelog join community next gerhard lazu ansible docker concourse ci keep changelog changelog weekly,promised relaunch announcement morning open sourced code power new changelogcom want full rundown go star source code github changelogcom elixir application built phoenix web framework postgresql host great open source effort built deliver good oldfashioned serverrendered html javascript sprinkle expect future post decision others made along way open source website changelogcom platform build library open source reason love open source career livelihood possible without open source keeping closed felt wrong phoenix really great still young many inproduction open source site people reference example inspiration want throw hat ring hopefully others follow changelog community hacker open sourcing website lead bug report feature request pull request mean better overall product enjoy good absolutely nothing oh sorry war perfect mean work something also told ridiculously fast incomplete list feature implemented might find useful distinct admin public pipeline admin crud semantic ui integration itunes compatible well vanilla r feed passwordless logins comprehensive meta tag strategy persistent audio player rudimentary search api coming public site soon two asset build pipeline thanks webpack markdown processing thanks cmark party api access thanks httpoison caching party api response thanks concache file uploads processing thanks arc pagination thanks scrivener transactional email delivery thanks bamboo question code holler changelog better yet join community indepth discussion software development industry trend everything else sun next source code tell full story working bunch post share experience building site including take working phoenix made site stinkin fast chose use turbolinks tool service relied upon along way addition venerable gerhard lazu helped u set slick production deployment scheme using ansible docker concourse ci gerhard series post work break process came know maybe open source come keep follow changelog twitter subscribe changelog weekly miss thing
334,Lobsters,elixir,Elixir programming,Reactive Tweets with Elixir GenStage,https://almightycouch.org/blog/reactive-tweets-elixir-genstage/,reactive tweet elixir genstage,genstage backpressure elixir announced keynote elixir conf reactivestreams project queue fix overload erlang anger genstage documentation twittex implementing genstage behaviour documentation handling http response message applying backpressure putting part together going step,genstage backpressure last july josé valim creator elixir programming language announced genstage new behaviour exchanging event backpressure process going explain genstage work already plenty article video subject latest josé keynote elixir conf instead focus one fundamental maybe important aspect genstage provides backpressure prevent downstream stage receiving message could handle handling stream live data whose volume special care asynchronous system prominent issue resource consumption need controlled fast data source overwhelm stream destination reactivestreams project erlang world beam implicitly support backpressure process receives message process require memory crashing virtual machine long term problem left developer understand problematic different perspective let take great metaphoric example borrowed fred hébert article queue fix overload definitely check original article fred author erlang anger writing always real pleasure read normal load system handle data come carry fine however time time see temporary overload system inevitably encounter prolonged overload system crash course oversimplification problem might encounter message passing end reflects pretty much going happen design system backpressure mind prevent happen first must identify bottleneck find way prevent process messagequeue grow indefinitely otp provides lot construct work around problem using example provides way apply backpressure instead sending message caller wait response server server overloaded respond given period time call fails timeout error even better solution would adjust producer throughput consumer demand way could ensure stage never overloaded actually genstage take similar approach instead producer asking consumer pushing event follows demand driven approach start flow event subscribe consumer producer communication channel established consumer ask producer event typically say consumer sending demand upstream demand arrives producer emit item never emitting item consumer asked provides backpressure mechanism genstage documentation concept mind let implement twitter streaming genstage producer using twitter streaming api straightforward return infinite stream json tweet prefixed delimiter representing length tweet ok contenttype applicationjson transferencoding chunked retweetcount text man like twitterapi entity url hashtags usermentions index name twitter api id screenname twitterapi idstr retweeted false inreplytostatusidstr null place null inreplytouseridstr null coordinate null source web inreplytoscreenname null inreplytouserid null inreplytostatusid null favorited false contributor null geo null truncated false createdat wed feb user istranslator false followrequestsent null statusescount profilebackgroundcolor defaultprofile false lang en notification null profilebackgroundtile true location profilesidebarfillcolor ffffff followerscount profileimageurl http contributorsenabled false profilebackgroundimageurlhttps http description testing account following probably wo nt gain much following null profilesidebarbordercolor profileimageurlhttps http defaultprofileimage false showallinlinemedia false verified false profileusebackgroundimage true favouritescount friendscount profiletextcolor protected false profilebackgroundimageurl http timezone pacific time u canada createdat fri sep name fakekurrik geoenabled true profilelinkcolor url http blogroomannacom id idstr listedcount utcoffset screenname fakekurrik id idstr indicates many byte get rest tweet including rn use twittex twitter client application wrote ago learning purpose support provides wrapper twitter api twittex depends hackney http library erlang latter capability stream response given process simplify task lot implementing genstage behaviour implementing genstage behaviour simple act dispatching data providing backpressure completely abstracted away developer defmodule twitterstream use genstage def startlink option genstagestartlink module option defdelegate stop stage reason normal timeout infinity genstage impl true def init producer ref nil demand buffer buffersize define state callback provides following field ref reference hackney http response demand actual demand buffer used store partial tweet get data buffersize number byte next tweet see need buffer buffersize later first let handle demand producer check documentation detail def handledemand demand state statedemand hackneystreamnext stateref noreply state demand statedemand demand end callback increment demand state current demand also fetch next chunk data using handling http response message next handle hackneyresponse message def handleinfo hackneyresponse ref status statuscode reason state statuscode statedemand hackneystreamnext ref noreply state ref ref else stop reason state end end def handleinfo hackneyresponse ref header header state hackneystreamnext stateref noreply state end def handleinfo hackneyresponse ref chunk state isbinary chunk chunksize bytesize chunk cond statebuffersize hackneystreamnext stateref case stringsplit chunk rn part size chunk noreply state buffer chunk buffersize stringtointeger size bytesize chunk noreply state end statebuffersize chunksize hackneystreamnext stateref noreply state buffer statebuffer chunk buffersize statebuffersize chunksize statebuffersize chunksize statedemand hackneystreamnext stateref event poisondecode statebuffer chunk noreply event state buffer buffersize demand max statedemand end end def handleinfo hackneyresponse ref done state stop connection closed state end def handleinfo hackneyresponse ref error reason state stop reason state end five type hackneyresponse message first receive status use store message ref state second header important case receive chunk data response done error occurs process chunk data order extract tweet send downstream consumer reason need store current buffer buffersize use delimiter value know many byte read stream next tweet basically call tweet completely buffered look third function implementation bit tricky actually hard understand last thing implement module way tell hackney stop streaming data course best place callback def terminate reason state hackneystopasync stateref end call close connection shutting stage process hackney provides function exactly applying backpressure started post long introduction backpressure important told take special care bad thing would happen implementation stage talk single time issue indeed backpressure already applied might asked call almost every function right implementation stage consumer hackney stream us control throughput data process check current demand fetching data twitter stream tidily coupled stage demand word applying backpressure tcp level yes right pushing boundary outside beam even outside local machine consumer slow process stream incoming data stage stop calling automatically prevent underlying operating system acknowledging tcp package end twitter streaming server stop sending u data able process putting part together genstage twitter streaming producer ready may noticed never made http request api endpoint tell hackney send u response let see def twittersamples ok stage twitterstreamstartlink streamto stage tell hackney send stream stage async tell hackney control flow connopts hackney streamto stage async recvtimeout infinity url http delimitedlength case twittexapirequest post url connopts ok httpoisonasyncresponse ok stage error error streamstop stage error error end end finally connect consumer actually something stream following example print text tweet ok stage twittersamples genstagestream stage streammap mapget text streameach streamrun going step even go step write complex example using flow example show top hashtags multiple twitter stream regular time interval w trump hillary enummap twittexclientstream stage true flowfromstages flowflatmap entity hashtags flowmap text flowpartition window flowwindowperiodic minute flowreduce fn word acc mapupdate acc word end flowdepartition mapmerge fn end enumeach fn map iexhelpersclear map enumsortby elem enumtake enumeach fn hashtag count ioputs ioansibright stringpadleading integertostring count ioansireset hashtag end end flow make fairly simple pipe incoming data multiple stage similar way would use enum stream benefit levering concurrency
335,Lobsters,elixir,Elixir programming,Learning Elixir's GenStage,http://learningelixir.joekain.com/gen-stage/,learning elixir genstage,genstage genstage announcement background genstage doc connecting stage genstage use case genstage dataingestion domain scraper genstage event dispatching using genevent notify channel update elixir look flow next step elixirconf keynote,hello learning elixir reader long time since last post focused technology taken new job want thank friend doug goldie keeping invovled elixir time want thank wife encouraging get back track blog lot changed elixir since last serious work elixir released elixir world one thing caught eye genstage last year plan build genrouter look like evolved genstage lot learn genstage approach subject let start question genstage flow matter find information would good project try question started google search turned official genstage announcement wow posted back july gone long time anyway give following description genstage new elixir behaviour exchanging event backpressure elixir process mean let go definition piece peice first genstage elixir simple enough genstage behaviour otp term interface specifically genstage defines set function callback must implemented process adopting behaviour genstage may also provide default implementation function genstage exchanging event elixir procsses event change remember genrouter intended remember correctly genrouter streaming data multiprocess pipeline think shift event may generalization genrouter genstage backpressure backpressure mechanism controlling rate producerconsumer setup producer consumer run assynchronously likely one get ahead consumer fall behind backpressure used prevent producer overproducing background announcement give example filestream pathtosomefile streamflatmap fn line stringsplit line end enumreduce fn word acc mapupdate acc word end enumtolist describe motivation genstage example lazy data transformation pipeline common elixir solution leverage concurrency afforded beam modern cpu goal genstage enable concurrent processing large datasets still retaining elixir easy understand style data transformation pipeline genstage announcement go show example genstage stage first counter called alias experimentalgenstage defmodule use genstage def init counter producer counter end def handledemand demand counter demand counter ask item emit item set state event enumtolist counter event emit second element tuple third state noreply event counter demand end end producer one thing left wondering reading announcement meaning producer function producer special value recognized genstage name looking doc found case successful start callback must return tuple first element stage type either producer consumer producerconsumer taking role fact producer special value recognized genstage rest function callback genstage use request item producer type stage demand argument requested demanded number event counter argument current state process since stage counter maintains current count state call enough value satisfy demand returned counter incremented demand way return subsequent set value next call announcment go build consumer type stage callback function process store passed event update genstage state announcment also build producerconsumer type stage type must define callback connecting stage next step start stage connect using step seems bit manual sound like flow privde easier way assembly stage simple case part found interesting multiple consumer connected order create concurrency initially started reading announcment worried genstage would allow creating pipelined concurrency effective form concurrency stage pipeline allows concurrent activity genstage seems much flexible genstage use case announcment describes use case genstage genstage dataingestion one use case genstage consume data thirdparty system sound similar domain scraper domain scraper experiment would interesting exercise go back rewrite domain scraper using genstage genstage event dispatching another use case another scenario genstage useful today replace case developer would used genevent past announcment go describe advantage genstage genevent genevent however one big flaw event manager event handler run process interesting realized limitation genevent genstage seems like big improvement case using genevent notification system observer pattern many observer handler run process handler would run serially sacrificing concurrency beam provides u later announcment call action genevent user first moment community step try genstage used genevent past replaced genstage similarly planning implement event handling system give genstage try well project us genevent back february wrote using genevent notify channel update elixir might good place start experimenting genstage look flow end announcemnt give glimpse flow allows example beginning announcment rewritten like alias experimentalgenstageflow let compile common pattern performance emptyspace binarycompilepattern new filestream pathtosomefile readahead new flowfromenumerable flowflatmap fn line word stringsplit emptyspace word end flowpartitionwith storage ets new flowreducebykey enumtolist allows asynchonrous processing data transformation pipeline looking doc seems flow available like try future post next step post looked genstage announcment dug certain part deeply started list question genstage flow matter find information would good project try answered genstage touched flow found information reading announcement doc also plan watch elixirconf keynote hear cover genstage flow identified two project genevent notify phoenix channel domain scrapper answering question left task follow list watch elixirconf keynote use genstage notify phoenix channel new event experiment flow rewrite domain scrapper use genstage hope work item future post encourage watch keynote done already meantime
336,Lobsters,elixir,Elixir programming,BeamBA just Happened – Erlang Elixir Efene LFE Meetup @ Buenos Aires,https://medium.com/erlang-battleground/beamba-just-happened-807771987a2a,beamba happened erlang elixir efene lfe meetup buenos aire,watch meetup erlangba,watch event streamed live thanks youtube missed video spanish course want thing please join u meetup erlangba
338,Lobsters,elixir,Elixir programming,Erlang Dirty Scheduler Overhead,https://medium.com/@jlouis666/erlang-dirty-scheduler-overhead-6e1219dcc7,erlang dirty scheduler overhead,low level detail overhead measurement strategy schedtime returntime measurement dualize dirty nif handling,low level detailsso really happens detail first compile erlang vm support pas option enabledirtyschedulersto configure script next code change bit standard nif like one obtaining random data enacl library x function signature erlnifterm enifrandombytes erlnifenv int erlnifterm build table nif write following tie knot erlang world static erlniffunc niffuncs randombytesb enifrandombytes randombytes enifrandombytes erlnifdirtyjobcpubound erlnifinit enaclnif niffuncs enifcryptoload null null null tell erlang system function randombytesb regular nif function randombytes bound dirty scheduler cpu bound jobsthe way erlang work nif module replace function module nif function calling erlang read niffuncs array patch function calling function module invoke beam operation callnif first instruction opcode contains function pointer real cfunctionwhen opcode invoked environment set passed c code inspect environment incomnig parameter carry work done simply return erlang term back interpreter turn regard return value function questionwhen loading dirty nif however nif directly patched rather wrapper function scheduledirtyionif scheduledirtycpunif patched nif wrapped yet another helper executedirtynif calling nif really calling say scheduledirtycpunifthe scheduling function alters process flag currently executing function becomes dirty cpubound function bump reduction process reduction force reevaluation process queueing scheduler see dirtyflag evacuates process run queue dirty schedulersonce dirty scheduler executedirtynif wrapper get called wrapper executes real nif clear flag arranges dirtyniffinalizer run function simply return nif result via standard trap scheduler requeues move nif back onto one main scheduler continue execution return valuethe execution wrapper also handle exception nif executes another finalizer raise exception back main scheduler thread also function may decide yield scheduler running order give others chance run like exception case execution wrapper handle thisoverhead measurement strategynow whole dirty nif evacuation back forth free operation longrunning nif could take something like millisecond probably negligible overhead nif return instruction overhead moving thing around would dominate also nif return quickly reason even consider dirty schedulerthe question however large overhead luckily new illumos machine sitting around answer question dtracethe description suggests way grab overhead going back forth use dtrace dynamically add trace probe running erlang system measure actual overhead going back forth scheduler writing dtrace script pid target beamsmp scheduledirtycpunif return timestamp pid target beamsmp executedirtynif entry schedtime lquantize timestamp whenever return scheduledirtycpunif record timestamp whenever start execute dirty nif executedirtynif linearly quantize time took likewise return path measured recording time take dirty nif execution return dirty nif finalizer run happen back normal scheduler core pid target beamsmp executedirtynif return r timestamp pid target beamsmp dirtyniffinalizer entryr returntime lquantize timestamp r r running dtrace script dynamically reach inside erlang vm patch prologueepilogue targeted function hit execute body snippet order measure runtime overheadmeasurementmeasurements done intel r core tm cpu gigabyte ram running sunos dev ie omnios first naive run run many scheduler operation backtoback one time standard configured erlang special provisioning option result following output scheduling overhead nanos value distribution count suggests overhead moving scheduler ballpark nanosecond around return graph look like return overhead nanos value distribution count take around get back main schedulerthe hypothesis reason cost nearly move around highly likely move one cpu core another happening result lot contention cache tlbs locking turn thing get expensive wake core intercommunicate lot worse since need single core moved around cpu core time blow cache destroys tlb make u generally sadto test hypothesis exploit running raw steel machine set erlang flag option runtime erlflagsk true sbt db sbwt verylong swt verylow mulmbcs mumbcgs musmbcs shellthe important flag sbt bind scheduler core sbwtswt setting wakeup threshold option make system allocate megabyte block really help system support superpageshugepages vm layer also tends pack data localitythis huge effect run whereas overhead setting option overhead ballpark scheduling overhead nanos value distribution count overhead nanos value distribution count important caveat far loading system run concurrency level let measurement interfere others easily use threadlocalvariables since measuring work get moved thread use somewhat simplified scheduling operation high several atomics couple mutex lock dram hit cost synchronization rarely entirely free yet another example highly optimized loop eternity given good ilp modern cpu core easily insns number much higher use simd style vector operation suggests pipeline feed system synchronization routine quite differentdualize dirty nif handlingthe erlang documentation suggests using dirty scheduler whenever nif lengthy work measurement suggests another solution overhead executing dirty nif low enough execution hidden noisefor instance running enacl cryptobox operation requires first compute curve shared key take much time compute overhead running dirty scheduler impossible measure hence easier always execute dirty operationfor operation say secret key computation nacllibsodium encrypting byte entry fast movement onto dirty scheduler dominates enacl detects simply run operation directly nondirty scheduler order make many small operation fasteri currently revising overhead threshold enacl subsystem based measurement targeting far smaller threshold suggests stop worring d overhead le say handling byte data take stop worrying run dirty scheduler example run one operation secretboxes size byte abovementioned ivy bridge based enaclnif value distribution count obtain used scott l fritchie etal work erlang dtrace provider directly hook onto nifentry nifreturn erlang measure long took execute suggests current overhead roughly fine think provided know configure erlang system
339,Lobsters,elixir,Elixir programming,Entity Component Systems (in Elixir),http://yos.io/2016/09/17/entity-component-systems/,entity component system elixir,entity component system github get update straight inbox drawback classbased inheritance rigid functionality diamond problem blob antipattern closing entity component system component quality aspect entity entity aggregation container component system system brings entity component life data flow entitycomponentsystem spreadsheet analogy advantage ec good decoupling single responsibility principle composability runtime object definition testable parallelizable separation data behaviour challenge ec ec relatively unknown pattern handling interprocess communication intercomponent communication intersystem communication concretely define design pattern mvc ec real world spatialos ec implementation elixir actor model usage example github implementation entity component system registry closing,entitycomponentsystem ec distributed compositional architectural design pattern mostly used game development enables flexible decoupling domainspecific behaviour overcomes many drawback traditional objectoriented inheritance elixir dynamic functional language built top erlang vm designed building scalable maintainable application article discover use ec elixir novel approach structure program beyond class based inheritance paradigm followup article entity component system talk source code ec implementation elixir open source github get update straight inbox subscribe newsletter nt miss new content drawback classbased inheritance traditional way build game world objectoriented hierarchy game object model world however even simple object end large set unused functionality consider example building game engine find class hierarchy base gameobject subclassed animal animal subclassed bunny whale special behaviour hop swim respectively also killer whale subclass whale kill let try introduce new animal world want killer bunny able hop kill class killer bunny inherit language platform single inheritance luck move hop kill superclass animal killer bunny inherit however subclass animal inherit thing need whale inherits hop bunny inherits swim kill time animal become god object massive set behaviour multiple inheritance either suppose killer bunny inherits bunny killer whale killer bunny inherit swim unneeded functionality face number issue rigid functionality killer whale kill change mind later make animal kill easily behaviour available class specifically coded support behaviour number game entity grow face greater difficulty finding spot hierarchy place new entity diamond problem diamond problem sometimes referred deadly diamond death ambiguity arises two class b c inherit class inherits b c method b c overridden override version method inherit b c blob antipattern inheritance game end huge single root class leaf node large amount functionality subclass become overburdened unneeded functionality closing difficulty mentioned plagued game developer long time entity component system attempt remedy annoyance learn ec next section entity component system three key abstraction ec examine detail starting component component quality aspect entity component minimal reusable data object plugged entity support behaviour component tag entity single quality component behaviour typically implemented struct dictionary imagine bunny entity world define bunny nothing aggregation collection independent component example bunny composed component physical seeing component support behaviour illustrate seeing attribute sightradius support sight behaviour note however component behaviour component simply minimal data object entity aggregation container component entity solely sum component entity implemented globally unique id associated collection component note entity actual data behaviour component give entity data support behaviour let look bunny see dashed box around component bunny entity nothing container component define entity aggregation subset component like carrot ghost entity little collection component ec implementation allow modify entity component collection runtime allows mutate entity fly example could poisoned component make entity tagged component lose health time add remove component dynamically inflict cure poison might also blind status effect remove seeing component entity hit point touched logic behaviour entity aggregation component component data object behaviour ec come come system system system brings entity component life system enumerate component group component updating state according internal rule external event way think behaviour change one state another let see example behaviour bunny tree fall due gravity implement behaviour make placeable component z value decrease time behaviour living being age implement behaviour make living component age value increase time create dedicated system behaviour wish support gravitysystem enumerates placeable component timesystem enumarates living component bear mind system operate component entity data flow entitycomponentsystem cement understanding pattern let see typical data flow architecture system listens event stream time player input update state component response event internal rule continuously changing state available access entity part thus result behaviour another example suppose player press move left key playerinputsystem executes detects keypress updating motion component motionsystem executes see motion entity left applying physic force left rendersystem executes read current position entity draw according spatial definition may include texture region animation information introduction entity system spreadsheet analogy another way think ec relational table like spreadsheet entity component system visualized table column component row entity operate single component select column look cell operate entity selects row look cell advantage ec better understanding entitycomponentsystem architecture let think approach compare classbased inheritance good decoupling single responsibility principle behaviour domain decoupled independent component andor system unlike monolithic god object class based inheritance extract subset functionality assemble combination ec also encourages small interface composability runtime object definition type game object created adding correct component entity also allow developer easily add feature one type object another without dependency issue example entitybuild flyingcomponent seeingcomponent runtime testable component system unit definition also substitute component mocked demo component testing parallelizable many realworld ec implementation mmos system implemented distributed system worker pool distribute work amongst let u horizontally scale size simulation increasing number system worker pool separation data behaviour component hold data system hold behaviour intermingling two property let plugandplay different behaviour apply data challenge ec despite flexibility give u ec introduces number nontrivial challenge ec relatively unknown pattern since design pattern mostly limited game development discussing use ec domain outside building web apps challenging resource available applying pattern domain handling interprocess communication handle communication system component need kind message bus publishsubscribe system enable part ec talk depending language platform ec implemented could introduce spike complexity cost iterating component entity may also result drop performance intercomponent communication happens system need access modify data multiple component component might need share state component communicate prior communicating system example say position sound component entity could positionalsoundsystem need communicate component may need separate channel intercomponent communication support use case intersystem communication happens two system need access modify component say two system one multiplies attribute x add x depending order application two system end result different unless operation associative may need introduce way ensure order system correct concretely define design pattern mvc multitude way implement ec language platform different abstraction available result different flavour ec ec real world aside popular architecture video game current application ec largescale distributed simulation includes realtime city traffic internet telecommunication network physic simulation also used building massively multiplayer backends video game staggering number entity one startup particular building ecsasaservice called spatialos ec implementation elixir section take look one possible implementation entitycomponentsystem elixir start briefly mentioning elixir also erlang concurrency primitive good fit ec pattern since elixir compiles erlang bytecode say elixir also mean erlang actor model one key abstraction elixir process akin actor actor model actor computation entity send message receive message spawn new actor diagram actor sends message actor c receives response message actor c send new message spawn new actor wait receive message actor try running elixir interpreter iex first spawn new actor listens message returning process id pid jeff spawn fn receive sender message ioputs received message process inspect sender end end send message jeff pid adding pid message send jeff self hello world send receive spawn builtin elixir primitive elixir also higherlevel abstraction building actor called genservers defmodule stack use genserver callback def handlecall pop h reply h end def handlecast push item state noreply item state end end start server ok pid genserverstartlink stack hello client genservercall pid pop hello genservercast pid push world ok genservercall pid pop world consider might implement ec help actor usage example implementation would look like use instantiates new entity set parameterized component timecomponent component count bunny ecsentitybuild timecomponentnew age trigger timesystem enumerate timecomponents real world could response event stream player input timesystemprocess pull latest state component bunny ecsentityreload bunny repeat process timesystemprocess bunny ecsentityreload bunny modifies existing entity runtime adding new component bunny ecsentityadd bunny timecomponentnew age repeat process timecomponents receive state update timesystemprocess bunny ecsentityreload bunny ec implementation elixir open source github clone run via iex mix root folder must elixir installed machine implementation entity entity struct randoms string id list component create entity extend adding component done runtime defmodule ecsentity moduledoc base creating new entity defstruct id component type id stringt type component list ecscomponent type ecsentity id stringt component component doc creates new entity spec build component def build component ecsentity id ecscryptorandomstring component component end doc add component runtime def add ecsentity id id component component component ecsentity id id component component component end doc pull latest component state spec reload def reload ecsentity id id component component entity updatedcomponents component enummap fn id pid ecscomponentget pid end entity component updatedcomponents end end actual entity bunny bunny prefab defmodule bunny def new ecsentitybuild timecomponentnew age end end code introduces idea prefab convenient factory entity common set component using prefab save typing much act facade component component componentagent module provide facility get set state component backed actor agent kind genserver component timecomponent implement component behaviour interface ddefmodule ecscomponent moduledoc base creating new component defstruct id state type id pid type componenttype stringt type state map type params map type ecscomponent id id component agent id state state callback new state component interface defmacro using option quote behaviour ecscomponent require component implement interface end end doc create new agent keep state spec new componenttype state def new componenttype initialstate ok pid ecscomponentagentstartlink initialstate ecsregistryinsert componenttype pid register component system reference id pid state initialstate end doc retrieves state spec get id def get pid state ecscomponentagentget pid id pid state state end doc update state spec update id state def update pid newstate ecscomponentagentset pid newstate id pid state newstate end end defmodule ecscomponentagent moduledoc create simple agent get set component instantiates one keep state doc start new bucket return status pid def startlink initialstate opts agentstartlink fn initialstate end opts end doc get entire state pid def get pid agentget pid end doc get value pid key def get pid key agentget pid mapget key end doc overwrites state newstate def set pid newstate agentupdate pid mapmerge newstate end doc update value given key pid def set pid key value agentupdate pid mapput key value end end actual component timecomponent implement component behaviour defmodule timecomponent moduledoc component keeping age something id pid state state timecomponentnew age use ecscomponent componenttype module doc initializes validates state def new age age initialstate ecscomponentnew componenttype initialstate end end system registry system enumerates component type defmodule timesystem moduledoc increment age timecomponents def process component enumeach fn pid dispatch pid increment end end dispatch pure reducer take state action return new state defp dispatch pid action id pid state state ecscomponentget pid newstate case action increment mapput state age stateage decrement mapput state age stateage state end ioputs updated inspect pid inspect newstate ecscomponentupdate pid newstate end defp component ecsregistryget elixirtimecomponent end end thing notice dispatch take external action evaluates based internal rule return new state part inspired largely experience redux reducer elm update component method return set component system enumerate whenever component instantiated register agent registry keep track active component registry actor shown defmodule ecsregistry moduledoc component registry iex ok r ecsregistrystart iex ecsregistryinsert test r ok iex ecsregistryget test pid def start agentstartlink fn end name module end def insert componenttype componentpid agentupdate module fn registry component mapget registry componenttype componentpid mapput registry componenttype component end end def get componenttype agentget module fn registry mapget registry componenttype end end end particular ec implementation may bit rough around edge many flavour ec certainly way make ec work feedback welcome closing ec overlooked architectural pattern overcomes drawback oopstyle inheritance great fit distributed system branching unfamiliar domain game development fruitful source new idea pattern write better software
340,Lobsters,elixir,Elixir programming,What's Ahead for Elixir?,https://www.youtube.com/watch?v=A60nxws_iVs,ahead elixir,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature josé valim ahead elixir elixirconfeu youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature josé valim ahead elixir elixirconfeu youtube
341,Lobsters,elixir,Elixir programming,ElixirConf 2016 Keynote by José Valim,https://www.youtube.com/watch?v=apEWcpfsD2A,elixirconf keynote josé valim,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature elixirconf keynote josé valim youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature elixirconf keynote josé valim youtube
342,Lobsters,elixir,Elixir programming,Using Ruby code in an Elixir project,https://medium.com/@Stephanbv/ruby-code-in-elixir-project-97614a9543d,using ruby code elixir project,ruby code elixir project erlang rubyelixir rubyelixir http rubygemsorg rubyelixir http rubygemsorg http rubygemsorg rubyelixir,ruby code elixir projectdid know fire ruby code inside elixir project done benchmark feeling would slow production however coding trying crazy stuff fun right let jump creating new project mix new rubyelixir creating readmemd creating gitignore cd project folderwe going use export wrapper erlport library erlang help connect erlang python ruby rubyist blog post written ruby elixirto install export package need add dependency list mixexsdefp deps export erlport github hdimaerlport manager make endwe run mix depsget rubyelixir mix depsget getting erlport http githubcomhdimaerlportgit using locally cached packageso lib folder create two new folder one named ruby one named rubyelixir within rubyelixir folder create file called rubycallex write following librubyelixirrubycallexdefmodule rubyelixirrubycall use exportruby def rubycall ok ruby rubystart rubylib pathexpand libruby endendcool first using use macro import export ruby library tell function ruby folder locatedin ruby folder create another file called rubyrb write following librubyrubyrbdef helloworld put hello ruby endnow back rubycallex file librubyelixirrubycallex def rubycall ok ruby rubystart rubylib pathexpand libruby ruby rubycall ruby helloworld endrubycall take parameter ruby folder got tuple filename ruby method parameter since ruby method parameter good go let fire iex try rubyelixir iex mixiex rubyelixirrubycallrubycallhello ruby undefinedsweet worked let try parameter librubyrubyrb def hello name put hello name end librubyelixirrubycallex def rubycall name ok ruby rubystart rubylib pathexpand libruby ruby rubycall ruby hello name endso gave ruby method elixir function new parameter name let see happens run iex rubyelixirrubycallrubycall stephan hello stephan undefinedpretty awesome say killer ruby gem want include elixir project possible sophisticated thing let give shot really like prawn nice pdf gem ruby use ruby gem need gemfile root folder create one write following gemfilesource http rubygemsorggem prawn terminal run bundle install gem rubyelixir bundlefetching gem metadata http rubygemsorgfetching version metadata http rubygemsorgresolving pdfcore sweet look like gem installed let see able generate pdf file write new method ruby file librubyrubyrbrequire prawn def generatepdf prawn documentgenerate prawnelixirpdfpdf text pdf generated ruby elixir prawn endendand change elixir function accordingly librubyelixirrubycallex def rubycall ok ruby rubystart rubylib pathexpand libruby ruby rubycall ruby generatepdf endlet try run rubyelixir iex mixiex rubyelixirrubycallrubycall undefinedthat tell u much however blow always great thing take look root folder got new file prawnelixirpdfpdf open see content freshly generated pdf pdf generated ruby elixir prawnuntil next timestephan bakkelund valois
343,Lobsters,elixir,Elixir programming,BeamBA is Coming!,https://medium.com/@elbrujohalcon/beamba-is-coming-2ee05f9fc83,beamba coming,talk,meetup logo thanks andrés geracethe talksthis time speaker person remotely mariano guerrathis talk describe way programming language created top erlang vm vm work thing simplifies thing complicates shown going step step creating language compiles beam bytecode provides basic functionality needed build calculator variable
344,Lobsters,elixir,Elixir programming,How to Set up a Distributed Elixir Cluster on Amazon EC2,http://engineering.pivotal.io/post/how-to-set-up-an-elixir-cluster-on-amazon-ec2/?,set distributed elixir cluster amazon,outline heroku phoenix web framework prerequisite introduction distribution elixir distribution single computer distributed example chuck norris setting distributed cluster preparing phoenix application step add dependency capistrano exrm versus distillery distillery step configure configure edeliver give name app declare name server assign public dns specify user specify host build release even need build release remote server optionally specify staging host specify host app going deployed point vmargs file prepare phoenix application configuring node sg u uk sg u uk look weird prodsecretexs configuring amazon lock source ip ha proxy copy file wholesale deploy deploy learn conclusion acknowledgment,ask elixir aficionado elixir one answer often come distribution possible definition distribution multiple computer working together perform computation elixir term mean multiple node connected cluster node basically different erlang runtimes communicate setting elixir cluster machine local area network lan usually pretty straightforward show set cluster machine soon slightly challenging read fun node talk internet case node geographically separated node communicating find lot resource set geodistributed cluster deploy elixirphoenix apps want resort something like docker wanted see far could push elixir tooling outline post outline step took order set elixir cluster amazon however likely replicate step another provider digital ocean linode heroku even bother trying distributed elixir heroku way ip routing work within heroku way get around easy wallet running single node heroku could option reading create simple web application using phoenix web framework show create release way packaging elixir application followed deploying release across multiple server prerequisite going need following installed elixir later phoenix later one amazon instance available instance need following ubuntu box could use another distribution would adapt command go along haproxy installed server domain name pointing git elixir article assumes little elixir andor phoenix knowledge fact read article discover much effort would need set distributed cluster elixir introduction distribution elixir background distributed elixir order run iex interactive elixir running repl read eval print loop single erlang runtime opening iex session mean running session separate runtime default runtimes see talk run start runtime distributedmode connect node node join another node cluster formed node successfully connects another node node becomes member cluster word node e successfully connects node automatically connected node thru distribution single computer even mess multiple node across multiple server helpful see run multiple node single computer example going create node node first connected let create first node iex sname barry interactive elixir press ctrlc exit type h enter help iex barry frankel iex interactive elixir shell sname flag stand short name short omitting hostname followed name given node frankel shown prompt host name let spin next node iex sname maurice interactive elixir press ctrlc exit type h enter help iex maurice frankel final one iex sname robin interactive elixir press ctrlc exit type h enter help iex robin frankel node see yet try go node list known node nodelist iex maurice frankel nodelist note nodelist show neighboring node current node list current node use node expected get empty list time build cluster let go barry try connecting robin iex barry frankel nodeconnect robin frankel true true mean connection attempt succeeded let try nodelist iex barry frankel nodelist robin frankel woot robin let connect maurice iex robin frankel nodeconnect maurice frankel true far good nodelist show iex robin frankel nodelist barry frankel maurice frankel sweet robin connected barry maurice notice explicitly connect barry maurice together recall elixir node join cluster everyone see everyone something called hidden node pretending exist take word maurice iex maurice frankel nodelist robin frankel barry frankel barry iex barry frankel nodelist robin frankel maurice frankel distributed example chuck norris let fun example perform http request node use builtin http client come erlang yes use erlang standard library elixir need start inets application node instead manually typing inetsstart node rpcmulticall run function node iex barry frankel rpcmulticall inets start ok ok ok something might immediately apparent even though computation performed individual node result collected presented calling node word make http request barry barry get result look maurice robin see output let see real iex barry frankel rpcmulticall httpc request http apiicndbcomjokesrandom example output ok ok type success value id joke noah man notified chuck norris relieved atlantic ocean category ok ok type success value id joke time wait man unless man chuck norris category ok ok type success value id joke scientist estimated energy given big bang roughly equal chuck norris roundhouse kick category nerdy sweet know manually set cluster single host setting distributed cluster brief overview accomplish going configure vanilla phoenix application deployready install configure tool needed perform deployment configure individual node part cluster configure ha proxy loadbalance ndoes deploy want achieve ha proxy sits front elixir cluster node life server geographically separated whenever http request come ha proxy round robin fashion pick one node handle request preparing phoenix application time configure phoenix application step similar across phoenix application step add dependency mixexs order prepare phoenix application deployment need include exrm edeliver exrm elixir release manager help automatically create release edeliver tool help deployment somewhat like capistrano come ruby world exrm versus distillery visit exrm github page might notice author pointing distillery time writing get work therefore stuck exrm even step change much defmodule yourappmixfile use mixproject def project app yourapp version elixir elixircpaths elixircpaths mixenv compiler phoenix gettext mixcompilers buildembedded mixenv prod startpermanent mixenv prod deps deps end def application mod yourapp application phoenix phoenixhtml cowboy logger gettext exrm edeliver end defp elixircpaths test lib web testsupport defp elixircpaths lib web defp deps phoenix phoenixhtml phoenixlivereload dev gettext cowboy edeliver exrm end end get dependency included remember install dependency mix depsget step configure configprodexs next need configure production environment open configprodexs use mixconfig config yourapp yourappendpoint http port url host yourdomaincom port cachestaticmanifest privstaticmanifestjson config logger level info config phoenix serveendpoints true importconfig prodsecretexs thing note configure http option point port configure host whatever domain name using make sure line uncommented line commented default extremely easy miss config phoenix serveendpoints true option needed otp release turning option tell phoenix start server endpoint otherwise web application basically inaccessible outside world configure edeliver create new deliver folder root directory deliver folder create config file deliverconfig entirety give name app app yourapp declare name server assign public dns sg u uk specify user user ubuntu host want build release buildhost sg builduser user buildat tmpedeliver appbuilds optionally specify staging host staginghosts sg staginguser user deliverto homeubuntu specify host app going deployed productionhosts sg u uk productionuser user deliverto homeubuntu point vmargs file linkvmargs homeubuntuvmargs phoenix project phoenix project symlink prodsecretexs tmp source preerlanggetandupdatedeps local prodsecretpath home userprodsecretexs targetmixenv prod syncremote ln sfn prodsecretpath buildatconfigprodsecretexs cd buildat mkdir p privstatic mix depsget npm install brunch build production app app mixenv targetmixenv mixcmd phoenixdigest silence fi let go file according numbered comment give name app specify name app name directory server containing application declare name server assign public dns named server based geographical location pick naming scheme note using public dns resolve public ip address elastic ip address instance mean even virtual machine somehow reboots get assigned new private ip public ip remain unchanged specify user user ssh folder access previously declared server note server user name specify host build release usually point server closest even need build release remote server o specific library required mean build release say mac transfer release linux system nothing work definitely get strange utterly confusing error optionally specify staging host also specify staging host wish staging host basically host want test release bother step therefore part commented specify host app going deployed productionhosts specifies production host host separated space point vmargs file linkvmargs specifies path vmargs file name suggests file specifies flag used start erlang virtual machine configure file soon prepare phoenix application function run command prepare phoenix application command perform task installing necessary dependency perform asset compilation configuring node need create file sit homeubuntu home user folder host need create three copy vmargs example one copy server sg name sg setcookie kernel inetdistlistenmin inetdistlistenmax config homeubuntuyourappconfig u name u setcookie kernel inetdistlistenmin inetdistlistenmax config homeubuntuyourappconfig uk name uk setcookie kernel inetdistlistenmin inetdistlistenmax config homeubuntuyourappconfig flag mean name name node long name version includes domain setcookie erlang vm relies cookie determine node join cluster kernel specifies range port erlang distribution protocol us need specify manually open port later config specifies path file contains configuration neighboring node cover yourappconfig file next vmargs need create three copy yourappconfig syncnodesoptional specifies list node required current node start mean node connect list node wait syncnodestimeout millisecond case timeout simply continue starting sg kernel syncnodesoptional u uk syncnodestimeout u kernel syncnodesoptional sg uk syncnodestimeout uk kernel syncnodesoptional sg u syncnodestimeout yourappconfig look weird might think yourappconfig look like strange version json however content yourappconfig fact valid erlang code congratulation erlang programmer syncnodesmandatory yes might guess node wait syncnodestimeout millisecond connection made one connection fails node start entirely possible mix syncnodesoptional syncnodesmandatory prodsecretexs last file create prodsecretexs minimum add production specific credential file commit source control since moment file one liner configuring amazon thing need configure amazon port open security group used instance port phoenix erlang port mapper daemon epmd distributed communication might recall port configured previous configprodexs port range specified vmargs example lock source ip screenshot source listed specify source ip node cluster ha proxy configure ha proxy assuming installed opencreate following file root user sudo vim etchaproxyhaproxycfg file look something like global log notice maxconn user haproxy group haproxy default log global mode http option httplog option dontlognull option redispatch timeout connect timeout client timeout server listen yourappname mode http stats enable stats uri haproxy stats stats realm strictly private stats auth admin sekret option forwardfor option httpserverclose balance roundrobin option httpclose server sg check server u check server uk check last three line important always tweak setting later copy file wholesale thing need configure example stats auth option allows access ha proxy admin panel also experiment various balance value example setup ha proxy pick server based location incoming ip address deploy deploy hard work left deploying git push mix edeliver update production branchmaster startdeploy pushing updated change git next command build release deploys production host finally start app host one go everything go well see edeliver yourapp update command updating revision branch master building release update authorizing host ensuring host ready accept git push pushing new commits git ubuntu resetting remote host cleaning generated file last build fetching updating dependency compiling source detecting exrm version generating release copying release local release store copying yourapptargz release store deploying version production host authorizing host uploading archive release local release store extracting archive starting deployed release update done learn conclusion getting node communicate elixir hard however creating release deploying multiple host tricky like thing deployment related get working setup everything becomes pretty smooth sailing acknowledgment thanks pivotal letting work mike mazur gabe hollombe alan yeo proofreading giving lot constructive feedback thank taking time read
345,Lobsters,elixir,Elixir programming,LDAP authentication with Phoenix,http://rny.io/elixir/phoenix/ldap/2016/09/20/ldap-authenication-with-phoenix.html,ldap authentication phoenix,ldap phoenix guardian documentation http exldap eldap forumsystems http http guardian exldap eldap ectoldap,introduction ldap mostly used mediumtolarge one centralized place store user group allow others internal system authenticate user want build phoenix application work within enterprise likely integrate existing ldap server article going show authenticate synchronize user phoenix application setup phoenix let setup new phoenix project user model use demonstrate ldap authentication synchronization phoenix mix phoenixnew ldapexample fetch install dependency yn cd ldapexample mix ectocreate configure db configdevexs needed mix phoenixgenmodel user user username string name string email string mix ectomigrate setup guardian manage authentication process going use guardian one popular authentication framework use elixir article guardian going explain detail code new guardian want know read documentation guardian mixexs defp deps guardian end mixdepsget configconfigexs config guardian guardian allowedalgos optional verifymodule guardianjwt optional issuer ldapexample ttl day verifyissuer true optional secretkey notsosecretbutworksforademo serializer ldapexampleguardianserializer libldapexampleguardianserializerex defmodule ldapexampleguardianserializer behaviour guardianserializer alias ldapexampleuser alias ldapexamplerepo def fortoken user user ok user userid def fortoken error unknown resource type def fromtoken user id ok repoget user id def fromtoken error unknown resource type end webrouterex defmodule ldapexamplerouter use ldapexampleweb router pipeline browsersession plug guardianplugverifysession plug guardianplugloadresource end pipeline browser plug accepts html plug fetchsession plug fetchflash plug protectfromforgery plug putsecurebrowserheaders end scope ldapexample pipethrough browser browsersession get pagecontroller index end end webcontrollerspagecontrollerex defmodule ldapexamplepagecontroller use ldapexampleweb controller plug guardianplugensureauthenticated def index conn params render conn indexhtml end end basic setup guardian need get started verify everything work run mix phoenixserver point browser http see message unauthenticated pagecontroller protected logged yet setup exldap connect ldap server authenticate user going use exldap library exldap basically thin wrapper eldap module erlang make everything little bit easier also going use public ldap server demo user forumsystems spend time setting ldap server testing mixexs def deps exldap end mixexs def application application exldap end configconfigexs use configsecretexs real application config exldap setting server ldapforumsyscom base dcexample dccom port ssl false userdn cnreadonlyadmin dcexample dccom password password searchtimeout code give u access forumsys public ldap server user setup einstein newton galieleo tesla riemann gauss euler euclid user password password develop ldap module finally come part implement module communicate ldap server libldapexampleldapex defmodule ldapexampleldap def authenticate uid password ok ldapconn exldapopen bind uid uid dcexample dccom case exldapverifycredentials ldapconn bind password ok ok error invalid username password end end def getbyuid uid ok ldapconn exldapconnect ok searchresults exldapsearchfield ldapconn uid uid case searchresults error could find user uid uid searchresults enumfetch end end def tomap entry username exldapsearchattributes entry uid name exldapsearchattributes entry cn email exldapsearchattributes entry mail username username name name email email end end authenticate function take uid password argument authenticate user uid stand user id ldap used computer system login name function open connection ldap server verifies credential getbyuid function used search object specified uid ldap use function later synchronize username name email local postgresql database even though information ldap probably want local table user real database relationship table application tomap function helper function transforms ldapentry map sane key name use local database setup sessioncontroller template authenticate user phoenix need create basic gui session controller handle sign sign scenario webcontrollerssessioncontrollerex defmodule ldapexamplesessioncontroller use ldapexampleweb controller alias ldapexample user repo ldap def new conn params render conn newhtml changeset userloginchangeset end def create conn user params username params username password params password case ldapauthenticate username password ok handlesignin conn username handleerror conn end end defp handlesignin conn username ok user insertorupdateuser username conn putflash info logged guardianplugsignin user redirect pagepath conn index end defp insertorupdateuser username ok ldapentry ldapgetbyuid username userattributes ldaptomap ldapentry user repogetby user username username changeset case user nil userchangeset user userattributes userchangeset user userattributes end repoinsertorupdate changeset end defp handleerror conn conn putflash error wrong username password redirect sessionpath conn new end def delete conn params guardianplugsignout conn putflash info logged successfully redirect end end interesting part sessioncontroller happens create handlesignin insertorupdate function create function authenticate user username password using ldap module user authenticated ldap continue handlesignin function call insertorupdateuser function function get user attribute ldap creates map use create ecto changeset changeset deal detail determines need insert user first time sign update user updated attribute ldap differs attribute local user table user model need updated virtual field password special loginchangeset use sign form webmodeluserex defmodule ldapexampleuser use ldapexampleweb model schema user field username string field name string field email string field password string virtual true timestamps end def changeset struct params struct cast params username name email validaterequired username name email end def loginchangeset module cast w username password w end end webtemplatessessionnewhtmleex sign formfor changeset sessionpath conn create method post fn f div class formgroup label username label textinput f username class formcontrol div div class formgroup label password label passwordinput f password class formcontrol div div class formgroup submit sign class btn btnprimary div end webviewssessionviewex defmodule ldapexamplesessionview use ldapexampleweb view end webrouterex get signin sessioncontroller new post signin sessioncontroller create get signout sessioncontroller delete finally need add sessioncontroller router try start phoenix application point browser http try login einstein password see default phoenix page message saying logged sign point browser http see unauthenticated message conclusion implementing ldap authentication synchronization elixir phoenix much straight forward thought library support already place thanks guardian exldap want dig deeper implement advanced thing always fall back eldap module erlang seems virtually everything need work ldap also worth mentioning another ldap library elixir integrates nicely ecto called ectoldap happy ldaping
346,Lobsters,elixir,Elixir programming,ExUnit Cheat Sheet,http://blog.lucidsimple.com/2016/01/31/exunit-cheat-sheet.html,exunit cheat sheet,exunit cheat sheet table content skip pending test run certain test silence stdout ensure service running load support module workhorse assertion setup callback start stop application vcr mocking use test seed fight intermittent error check process alive skip pending test back top back top silence stdout among us technique may still work back top ensure service running example andrea leopardi redix back top load support module mike pack poolboy queue back top workhorse assertion doc elixirlangorg time assertreceived back top setup callback elixirlangorg back top start stop application back top vcr mocking vcr exvcr meck elixir way back top use test seed fight intermittent error back top check process alive cool thing back top closing comment powered disqus,exunit cheat sheet jan lot good documentation exunit least exunit section elixirlangorg little cheat sheet meant comprehensive instead list exunit technique use almost every project table content skip pending test run certain test silence stdout ensure service running load support module workhorse assertion setup callback start stop application vcr mocking use test seed fight intermittent error check process alive skip pending test want mark certain test pending automatically exclude test run use exunitconfigure test helper testhelperexs exunitconfigure exclude pending true exunitstart use tag mark pending cause skipped run mix test defmodule somemoduletest use exunitcase tag pending test pending test assert end end output see pending test skipped actually want run pending test later mix test include pending back top wip test example could select run flag defmodule somemoduletest use exunitcase test test assert end tag pending test pending test assert end tag wip test work progress test assert end end read output see three test ran case test marked wip run similarly could exclude wip test way back top silence stdout like test output littered print log message elixir version use exunitcaptureio keep thing clean among us defmodule somemoduletest use exunitcase import exunitcaptureio test noisy test captureio fn ioputs rawr end assert end end wrap noise producing part function pas captureio output suppressed example rawr end test result fret version elixir captureio technique may still work back top ensure service running exunit specific per se test suite depends particular service running eg redis test test helper get loaded way service available opportunity abort test run print friendly error message testhelperexs exunitstart case gentcpconnect localhost ok socket gentcpclose socket error reason mixraise connect redis http inetformaterror reason end example come andrea leopardi great redix project us gettcp check connect port connection successful close socket test run continues connection successful us mixraise helpful error message shut thing pretty cool back top load support module problem create support module directly test file get big may want move directory technique come mike pack poolboy queue library testhelperexs exunitstart ok file filels testsupport enumeach file fn file coderequirefile support file dir end us filels fetch name file living testsupport applies coderequirefile one exunit specific simple technique pop fairly frequently project back top workhorse assertion best source exunit assertion still doc elixirlangorg however use following assertion roughly time mercifully selfexplanatory assert test simple assertion assert end refute test simple refutation refute end assertreceive test service call back someservicework self assertreceive result someresult end final example might warrant explanation asserting test process eventually receive term result someresult within millisecond expected message arrive time assertion fail assertreceive cousin assertreceived pretty crucial given message passing heart elixir erlang back top setup callback really better great explanation elixirlangorg site case obvious setup run test setupall run onexit life setup block take function argument use onexit way might use teardown different language test framework back top start stop application default application started test run want behavior could stop test helper exunitstart applicationstop yourappname sometimes beneficial find running application competing unit test thankfully much properly using application config file still nice option case remember name app listed mixfile mixexs def project app yourappname end get thing started need call start applicationstart yourappname back top vcr mocking coming ruby world would like something similar vcr fake http response check exvcr similarly use meck want nice mocking library used work well need take care straying far elixir way use back top use test seed fight intermittent error intermittent error probably unavoidable writing concurrent program help fight exunit test run random order via seed integer particular run result error normally see run subsequent test exact order using seed flag mix test seed theseedthattriggerederrors seed printed bottom test output form randomized seed theseedvalue look output see passing integer mix matter many time run mix test seed always get test run exact order getting consistent result go long way squashing pesky error occur time back top check process alive reference process id use processalive pid name instead pid use whereis lookup pid passing alive processname processwhereis processalive would probably worth time check cool thing process get chance back top closing wrote post easily lookup technique use frequently still manage forget hope find least use article might interested please enable javascript view comment powered disqus
347,Lobsters,elixir,Elixir programming,Elixir boilerplate,https://mattvonrocketstein.github.io/heredoc/elixir-boilerplate.html,elixir boilerplate,intro cookiecutter github commit hook yelp precommit framework go extra dependency static analysis dogma proejct dialyxir persistent lookup table test coverage coverex custom mix task,intro writeup talk aspect project skeleton eventually end elixir project interested discussion around feeling cutandpaste read want automation tool actually generates boilerplate consider using cookiecutter used make kind filesdirectory structure template elixir project template cookiecutter includes everything discussed page github commit hook regardless programming language come believe linting done strictly constantly consistently across contributing project member thus advocate moving linters text editor whatever precommit hook another benefit hook approach work better codebases large construction hook force developer fix lint file modifying anyway whereas running lint elsewhere say tox via buildbot might force developer delint entire code base like use yelp precommit framework managing hook setup simple make precommitconfigyaml file source root elixir code hook normally look something like see see python hook go repo local hook id mixtest name elixir mixing test entry mix test language system file ex id mixtest name elixir mixing compile entry mix compile language system file ex repo git githubcomprecommitprecommithooks sha master hook id trailingwhitespace id checkmergeconflict id checkyaml afterwards want actually use file run command pip install precommit precommit install git add precommitconfigyaml git commit add precommit config git push extra dependency several dependency find way almost elixir project related testing staticanalysis inside mixexs modify deps function follows defp deps project dependency linter elixir code dogma dev nb available github hex currently mock git http static analysis tool dialyxir dev coverage tool test http githubcomalfertcoverex coverex test project dependency static analysis added dependency run mix depsget invoke linter command line see dogma proejct detail use dialyxir first time build persistent lookup table take thereafter run test coverage coverage coverex requires modification project function mixexs well coverex dependency mentioned def project projectconfig testcoverage tool coverextask consolelog true projectconfig end run test coverage use commandline custom mix task one end making custom mix task project escript commandline also common mix task need invoke mix task demonstrated mix task requires app started programmatic equivalent mix appstart defmodule mixtasksmymixtask use mixtask def run anything mixtasksappstartrun main anything end def main ioputs argument given end def main fname ioputs given filename fname end end
349,Lobsters,elixir,Elixir programming,Elixir Native Interoperability – Ports vs. NIFs,https://spin.atomicobject.com/2015/03/16/elixir-native-interoperability-ports-vs-nifs/,elixir native interoperability port v nifs,elixir erlang nif port basic erlang interoperability tutorial nifs foot nifs native implemented function ffi ruby nif benefit nif drawback port foot port port benefit port drawback piece puzzle arduino sketch github repository makefiles mix mix elixir serial device access port elixir implementation port example c implementation elixir serial device access nifs makefile elixir implementation nifs example c implementation,lately working personal project creating wireless sensor network across home elixir perfect fit project quickly hit road block serial device access erlang serial library could use ultimately comfortable due many fork adding yet another layer complexity erlang vm elixir run top number different mechanism interoperability external program two discussing port nifs two simplest unique set pro con example interfacing operating system read write data serial device nif port basic first let take highlevel look two basic erlang interoperability mechanism elixir support others interoperability mechanism erlinterface port driver interoperability java cover information check erlang interoperability tutorial particularly useful need greater integration elixir access message passing nifs foot nifs native implemented function technique tend think looking interoperability language implemented erlang similarly ffi ruby nifs allow u load dynamic library bind library native function elixir function nifs appear normal function elixir code invoking invoke underlying dynamic library implementation logic nif benefit fast simple implementation context switch required simple debugging nif drawback safe nifspecific c library native imperative implementation leak functional elixir code important thing note crash c library cause crash entire erlang vm go inherit philosophy erlang error failing fast using supervisor recover port foot port technique communicate external native process stdin stdout port created connected process created used communicate via message passing external native process port benefit safety error trapping flexible communication external erlangelixir specific library required port drawback awkward stdinstdout communication piece puzzle arduino sketch easy testing library used arduino sketch one sends random block text serial connection another loopback detail sketch working example code shown checkout github repository makefiles mix elixir ship awesome build tool called mix used create compile test manage dependency integrating make file c c library mix enormous value unifying project build super simple mix creates unsurprising directory creates project config lib test create two purpose housing native code compiled form csrc privdir basic mix file look like defmodule serialnifmixfile use mixproject def project app serialnif version elixir deps deps end def application application logger end defp deps end end add new task compilation configure project invoke compilation create new task cleaning configure alias clean execute task allow u execute mix clean mix compile clean execute elixir code mix native code make defmodule serialnifmixfile use mixproject def project app serialnif version elixir compiler make elixir app add make compiler alias alias configure alias deps deps end defp alias execute usual mix clean makefile clean task clean clean cleanmake end def application application logger end defp deps end end make file task defmodule mixtaskscompilemake shortdoc compiles helper csrc def run result errorcode systemcmd make stderrtostdout true mixshellinfo result ok endend defmodule mixtaskscleanmake shortdoc clean helper csrc def run result errorcode systemcmd make clean stderrtostdout true mixshellinfo result ok endenddefmodule serialnifmixfile use mixproject def project app serialnif version elixir compiler make elixir app add make compiler alias alias configure alias deps deps end defp alias execute usual mix clean makefile clean task clean clean cleanmake end def application application logger end defp deps end end make file task defmodule mixtaskscompilemake shortdoc compiles helper csrc def run result errorcode systemcmd make stderrtostdout true mixshellinfo result ok end end defmodule mixtaskscleanmake shortdoc clean helper csrc def run result errorcode systemcmd make clean stderrtostdout true mixshellinfo result ok end end elixir serial device access port next let take look use port access c program manipulates serial device elixir implementation elixir implementation port example pretty simple defmodule serial def init processflag trapexit true port portopen spawn privdirserial packet end def open p device speed portcommand p device portcommand p speed end def write p str portcommand p str end end init function spawn new port compiled c program located privdir second argument say sending packet data prefixed byte length indicator implementation actual open write function also minimal use send command native program second argument packet sent native implementation write example use integer represent invoking write function native implementation str string writing serial device notice read function taking advantage message passing port send data elixir received native implementation c implementation c implementation port little bit complicated include include include include erlcommh include serialh int bytesread int serialbytesread int serialfd char serialbuf void resetstate bytesread serialbytesread strcpy serialbuf void processcommand byte buf int bytesread int fn buf bytesread fn char devicename getstrarg buf devicename bytesread serialfd serialopen devicename else fn serialspeed serialfd getintarg buf bytesread else fn char str getstrarg buf str bytesread serialwrite serialfd str else fprintf stderr valid fn fn else bytesread exit void pollserialdata int serialfd serialbytesread read serialfd serialbuf serialbytesread writecmd byte serialbuf int main byte buf resetstate inputavailable bytesread readcmd buf processcommand buf bytesread serialfd pollserialdata serialfd looking main function first infinite loop check see input available elixir stdin par data based upon byte length indicator executes specific command also check see serial device opened poll available serial data writing stdout see also using stderr error message also used debugging c code elixir needed sake simplicity abstracted away detail parsing command erlcommh manipulating serial port serialh would like view dirty detail find full code github stuck example protocol byte packet since code provided erlang interoperability tutorial fit use case well elixir serial device access nifs makefile since using erlang provided c library type conversion communication erlang vm need make library known gcc erlangpath shell erl eval io format list concat code rootdir ert erlang systeminfo version include init stop noshell cflags g ansi pedantic wall wextra erlangpath elixir implementation elixir implementation nifs example bit complicated serial onload init def init erlangloadnif privdirlibelixirserial ok end def open device speed open stringtocharlist device speed end def read fd read fd end def write fd str write fd stringtocharlist str end def close fd close fd end def open device speed nif library loaded end def read fd nif library loaded end def close fd nif library loaded end def write fd str nif library loaded end end loading module load nif c library wrote replaces open read close write function native implementation also basic wrapper around function public interface guarantee data type expecting c implementation c implementation looking c code nif example include erlnifh include include include include serialh define maxbuflen static erlnifterm open erlnifenv env int arc const erlnifterm argv char path maxbuflen int fd int intspeed enifgetstring env argv path enifgetint env argv intspeed fd serialopen path serialspeed fd intspeed return enifmakeint env fd static erlnifterm read erlnifenv env int arc const erlnifterm argv int char buf erlnifbinary r int re enifgetint env argv fd re read fd re enifallocbinary r strcpy rdata buf return enifmakebinary env r enifallocbinary r return enifmakebinary env r static erlnifterm write erlnifenv env int arc const erlnifterm argv char str maxbuflen int fd size enifgetint env argv fd size enifgetstring env argv str serialwrite fd str return enifmakeint env size static erlnifterm close erlnifenv env int arc const erlnifterm argv int enifgetint env argv fd close fd return enifmakeint env fd static erlniffunc niffuncs open open read read write write close close erlnifinit elixirserial niffuncs null null null null starting bottom use erlnifinit actually invoke erlang vm magic hot swap bare function native implementation first argument match module load nif prefixed elixir example elixirserial niffuncs array mapping function elixir arity counterpart c set let take look implementation one function static erlnifterm open erlnifenv env int arc const erlnifterm argv char path maxbuflen int fd int intspeed enifgetstring env argv path enifgetint env argv intspeed fd serialopen path serialspeed fd intspeed return enifmakeint env fd return something type erlnifterm order get data back elixir argument come form defined erlnifh use enifgetstring enifgetint function convert erlnifterms c data type invoke function convert c data type back elixir data type use enifmakeint function convert back erlnifterm erlnifh library number interesting function enifsend allows native c program send message elixir pid could used message passing send data elixir process instead using function would required threading open whole worm given safety concern nifs bring
350,Lobsters,elixir,Elixir programming,"Elixirconf 2016 slides, videos, links, and sundry",https://github.com/poteto/elixirconf-2016,elixirconf slide video link sundry,join github today sign,dismiss join github today github home million developer working together host review code manage project build software together sign
351,Lobsters,elixir,Elixir programming,Building a web framework from scratch in Elixir,https://codewords.recurse.com/issues/five/building-a-web-framework-from-scratch-in-elixir,building web framework scratch elixir,elixir care following along elixir crash course elixir installed plug plugconn documentation writing macro dry basic template handy templating language precompiling template ecto model way many option testing everything exunit performance binary search benchmark table next step active reading documentation ecto query reference schema reference migration reference plug documentation router doc plugtest documentation eex phoenix framework ecto template deployment,elixir fantastic new functional programming language target erlang vm designed build faulttolerant distributed system numerous exciting usecases one always get lot attention building web application elixir already railslike framework called phoenix today use much simple library called plug write sinatralike web framework scratch care phoenix great framework actually us plug hood work well plugcompatible library tends put feature behind macro obfuscating direct call plug function think understanding way underlying plug library work excellent way learn elixir phoenix help understand macro surface also writing performant code incredibly simple easy plug elixir patternmatching could browse macro definition difficult understand since lot extra code make dsl work properly instead write straightforward code using plug directly build framework scratch know maybe even find prefer simple router build following along already familiar basic syntax great though required best explain trickier part depth case get stuck try taking look elixir crash course need know anything phoenix although assuming programmed web app language framework explain simple concept like header query string follow along guide need elixir installed also need create new project mix new helloplug add cowboy plug ecto sqliteecto mixexs file adding following line def deps cowboy plug sqliteecto ecto end def application application logger sqliteecto ecto cowboy plug end forget run mix depsget done plug set properly write code libhelloplugex file although comfortable standard directory structure cleaner plug plug module responds web request create one need two function defmodule helloplug def init defaultopts ioputs starting helloplug defaultopts end def call conn opts ioputs saying hello plugconnsendresp conn hello world end end called server started called every time new request come two argument conn plugconn connection client contains information request also use send response opts whatever output function change request request option passed module given take look later know whatever return get passed every subsequent finally take look sendresp function accepts three argument connection http status code send body reply send note last line intentional elixir last line function implicitly returned sendresp well rest plugconn function return mutated copy conn important return mutated conn outside function calling know changed connect helloplug cowboy web server running iex mix project directory typing ok plugadapterscowboyhttp helloplug resulting elixir repl browse http time see world browser terminal starting helloplug saying hello saying hello saying hello call function run every time visit web page also use conn object set header def call conn opts ioputs saying hello conn plugconnputrespheader server plug plugconnsendresp hello world end case seen operator b c equivalent c b could rewrite line wanted le idomatic verbose version plugconnputrespheader conn server plug plugconnsendresp hello world argument passed function output previous function inserted specified argument conn plugconnputrespheader server plug equivalent plugconnputrespheader conn server plug also remember last statement function elixir implicitly returned putrespheader sendresp two example function manipulate connection done web programming likely recognize add header response server plug send response world status code ok neither function modify conn directly since variable value elixir immutable broken plugconnputrespheader conn server plug plugconnsendresp conn hello world putrespheader touch conn passed return duplicated modified version conn need mutated conn returned putrespheader go sendresp chain output one function first argument next first example broken code sendresp receiving original conn server header mean server header would sent client number plugconn function manipulating connection detail check plugconn documentation full list connection object sending response contains detail request use powerful pattern matching match based pathinfo path requested split array call different function different page also match method post request call different function get request def call conn opts route connmethod connpathinfo conn end def route get hello conn route hello conn plugconnsendresp hello world end def route get user userid conn route user userid conn plugconnsendresp requested user userid end def route method path conn route called route match conn plugconnsendresp could nt find page sorry end second route show favorite part using extract userid variable url entirely using pattern matching writing macro may want separate router different part application using route syntax rather retyping identical call every router move macro call macro router macro evaluated compile time erlang vm receive code get dry code also reuse macro future project defmodule router defmacro using opts quote def init option option end def call conn opts route connmethod connpathinfo conn end end end end defmodule helloplug use router def route get user userid conn conn plugconnsendresp requested user userid end def route method path conn conn plugconnsendresp could nt find page sorry end end remember call need return modified connection object plug run know changed connection however also make composable call plug within plug instance say want route call user endpoint different plug defmodule userrouter use router def route get user userid conn route user userid conn plugconnsendresp requested user userid end def route post user conn sort database insertion maybe end def route method path conn conn plugconnsendresp could nt find user page sorry end end defmodule websiterouter use router userrouteroptions userrouterinit def route get user path conn userroutercall conn userrouteroptions end def route method path conn conn plugconnsendresp could nt find page sorry end end seen syntax module attribute used userrouteroptions userrouterinit websiterouter compiled store output userrouterinit insert anywhere see userrouteroptions appear compiletime constant module run get option hash use option hash userrouter need case using plug also remember mentioned could sometimes passed option outside could instance use somewhat contrived example maybe want treat two different model user admin almost identically could create one plug initialize twice passing different model option time would return option given function would able see via second parameter whether serve user object admin object plug need could use technique include plug authentication do protection logging instance thirdparty apilogplug module could add dependency update user route use userrouteroptions userrouterinit apiloggeroptions apilogpluginit def route get user path conn conn apilogplugcall apiloggeroptions userroutercall userrouteroptions end basic template point probably going want serve plain text framework could continue write html string manually practical larger webapps fortunately elixir come builtin handy templating language use pretty easily def route get user userid conn pagecontents eexevalfile templatesshowusereex userid userid conn plugconnputrespcontenttype texthtml plugconnsendresp pagecontents end first argument evalfile filename template second map variable able use inside template also need create template project directory templatesshowusereex templating language similar many templating language especially erb doctype html html body user information page p look like requested information user id userid p p also p userid tell everybody user really cool user zero really cool end body html see put sort elixir statement block run adding equal sign like make print result page creates comment sent client note print something page need statement return content block inside need make print instead discarding visit see rendered html page stating requested information user precompiling template template code little inefficient though since every time route called elixir load template file parse template file elixir function run function parse compile template run function every time route called save lot time especially larger frequentlycalled template require eex require eex using macro outside function eexfunctionfromfile defp templateshowuser templatesshowusereex userid def route get user userid conn pagecontents templateshowuser userid conn plugconnputrespcontenttype texthtml plugconnsendresp pagecontents end ecto model phoenix railslike framework talked earlier database model library called ecto fortunately ecto standalone project use update user userid route actually retrieve user data sqlite database configexs file add config helloplug helloplugrepo adapter sqliteecto database also going need create new module module hold function query database defmodule helloplugrepo use ectorepo otpapp helloplug adapter sqliteecto end also need user model defmodule user use ectomodel schema user id field implicit field firstname string field lastname string timestamps end end ecto schema way many option even start covering start using ecto read doc also going need user model actually exist table run mix ectogenmigration createusers generate empty migration update change function def change create table user add firstname string add lastname string timestamps end end run migration mix ectomigrate need modify userrouter actually use user model def route get user userid conn case helloplugrepoget user userid nil conn plugconnsendresp user id found sorry user pagecontents eexevalfile templatesshowusereex user user conn plugconnputrespcontenttype texthtml plugconnsendresp pagecontents end end finally update template list first last name user userfirstname userlastname page p look like requested information user id userid p userfirstname fluffums also let say fluffums awesome end database empty fix jump elixir shell iex mix use ecto insert record iex helloplugrepostartlink iex user user id firstname fluffums lastname cat iex helloplugrepoinsert user user struct something get free create ecto model pas struct repo automatically figure table insert database run web server visit see appear screen success testing everything one coolest feature functional setup incredibly simple test need fancy magic need pas fake conn call function inspect result get back elixir ship unit testing framework called exunit use go indepth nuance testing elixir example plug test defmodule hellotest use exunitcase async true use plugtest websiterouteropts websiterouterinit test return user conn conn get conn websiteroutercall conn websiterouteropts assert connstate sent assert connstatus assert stringmatch connrespbody rfluffums end end use plugtest simply import function plugtest including conn function used creates fake connection pas router performance erlang pattern matching code heavily optimized rather linear search route definition vm actually binary search possibility make route lookup run log n time instead n likely see improvement truly gargantuan number route single router still cool know get faster routing lookup free extra work end using thin layer plug cowboy get performance benefit put project little overhead cowboy run multiple request plug simultaneously since value elixir erlang immutable framework threadsafe default library also generally rothenberg benchmark table comparing various framework benchmark web framework would rank roughly near listing us router work similarly request per second put higher throughput even go based solution gin around request per second benchmark simplistic take database fetching lot common web framework task best give much weight still exciting see simple framework competitive much bigger one shabby considering barely written code considering performance next step one cool sideeffects writing framework scratch get organize directory structure right everything put together global namespace great could improve putting thing submodules subdirectory instance model could go libhelloplugmodels folder could call helloplugmodelsuser instead user could also add macro instance syntax chaining plug together precompiling template clunky also way running plug every single route router could perhaps argument passed using list plug call route calling could also use library like active automatically reload module change reading documentation ecto great reference particular look query reference schema reference migration reference plug documentation great lot concept article based router similarly us erlang pattern matching faster routing however use article since think understanding underlying system work exciting educational also worth taking look doc plugtest testing module saw briefly documentation eex great learning template phoenix framework quite cool website relevant article ecto template deployment although part phoenixspecific plenty concept applicable plugbased framework
352,Lobsters,elixir,Elixir programming,Object Orientation in Ruby and Elixir,http://mikepackdev.com/blog_posts/45-object-orientation-in-ruby-and-elixir,object orientation ruby elixir,erlang elixir object oriented language implemented exercise functional programming objectoriented programmer hilarious library lightning talk vastly different pattern primary concept object orientation simula solid principle basic object drive attrs drive drive x drive x new new modeled o process significant faster receive receive x x receive drive seems disappointed inheritance truck car offroad car drive offroad truck car type record tagged tuples car truck car type car truck offroad truck car truck car polymorphism interchangeable part liskov substitution principle car truck drive drive array sample car truck drive car drive unhandled message cause memory leak asynchrony car color color receive color receive agent send receive genservers actor model celluloid wrapping lamented oop swedish russian,talking mainstream programming language often put two major bucket object oriented programming functional programming programming paradigm oil water article blending two demonstrate technique elixir bit discussion erlang elixir world around topic recently stated elixir object oriented language avdi grimm implemented exercise brian marick functional programming objectoriented programmer originally written clojure even hilarious library lightning talk wojtek mach outofthebox object orientation elixir resource shed light oop elixir nt demonstrate building block comprise working model article build object system elixir scratch bare bone possible elixir code based ruby example goal highlight core concept elixir liken core concept ruby familiarity elixir assumed though build working model meant ideal object system advocating style programming fact erlang community relies vastly different pattern merely exercise learning message passing state management elixir likely several way accomplish effect love hear technique comment primary concept object orientation object orientated functional programming coexisted since dawn modern computing functional programming originated mathematics naturally conceived first object orientation came shortly simula whose goal make state management straightforward literature object orientation rehash core programming concept state behavior polymorphism ruby translates instance variable method duck typing rudiment expanded oo concept like encapsulation solid principle modern object orientated language unnecessarily limiting almost though missing forest tree great technique object orientation written functional style want retaining purity safe concurrency usually want basic object object conjoins state behavior encapsulates state internally expose behavior externally encapsulation important effective mean organizing controlling state behavior mean change state consider following example car ruby car position x ability drive forward drive increment x ruby class car defaultattrs x def initialize attrs attrs defaultattrsmerge attrs end def drive oldx attrs x attrs x put selfclassname attrs color x oldx attrs x end end notice class drive called print name class color attribute change state x variable attrs encapsulated state drive method behavior beautiful class instantiated call drive method nt think internal state x let ruby car carnew color red cardrive car red x cardrive car red x call drive twice internal state x change encapsulation simple powerful write class object elixir primary difference encapsulate state invoke behavior instead encapsulation first class citizen like ruby use recursion represent state instead calling method like ruby pas message elixir defmodule car defaultstate type car x def new state spawnlink fn mapmerge defaultstate state run end end defp run state receive drive newx statex newstate mapput state x newx ioputs statetype statecolor x statex newx run newstate end end end use elixir car carnew color red send car drive car red x send car drive car red x let break elixir code function named new mirror ruby new method could named anything function creates new elixir process using consider equivalent ruby special new method spawning new process created area encapsulate state familiar elixir process think way think operating system process fact modeled o process extremely lightweight significant faster run independent memory space nt bleed fail isolation inside newly created process default attribute merged attribute passed argument recursive function called elixir mapmerge defaultstate state run function core object state recursively passed encapsulating state argument function want update state call function new state let look closely function elixir defp run state receive drive newx statex newstate mapput state x newx ioputs statetype statecolor x statex newx run newstate end end one key component getting work call receive function receive called block current process wait process receives message remember code running new process message passed process unblock run code declared proceeding block proceeding block calculates new state incrementing x new variable updating x map represents state recursively calling function calling recursively process block receive continues recursively indefinitely function decides call anymore longer recurse process dy state garbage collected nonrecursive case represented code let see instantiation message passing look like builtin function used send drive message process twice elixir car carnew color red send car drive car red x send car drive car red x code calling spawn process return process id pid sends message pid using essence calling method ruby originator term object orientation alan kay seems disappointed message passing displaced method invocation major difference message passing method invocation message passing asynchronous later basic object encapsulated state provided behavior change state ruby version hide state instance variable elixir version make state explicit recursive function argument ruby version call method elixir version pass message inheritance beyond state behavior inheritance another core tenet object oriented programming inheritance allows u extend type class new state behavior inheritance first class citizen ruby making easy categorize state behavior subtypes following code palpable rubyists code creates new truck type subtype car add offroad method available truck ruby class truck car def offroad put going offroad end end since inherited car class call drive offroad method instance truck class ruby truck trucknew color blue truckdrive truck blue x truckoffroad going offroad ruby version elixir nt class inheritance elixir first class citizen going require setup ceremony accomplish first represent type subtypes without class observant reader would noticed upon defining car module elixir one default value field named type value car elixir class type represented plain data binary string concept using data represent type concrete class like ruby pervasive functional programming take example record tagged tuples model inherited type elixir use data represent car type truck subtype mimic inheritance behavior method subtype derives parent type maintain instance car delegate message elixir defmodule truck def new state spawnlink fn typedstate mapmerge type truck state parent carnew typedstate mapmerge parent parent typedstate run end end def run state receive offroad ioputs going offroad run state message send stateparent message run state end end end let break code function overriding value type property instantiating new car becomes typed data spawn parent process elixir typedstate mapmerge type truck state parent carnew typedstate need keep parent process around delegate message subtype nt directly respond call function elixir mapmerge parent parent typedstate run function truck module look familiar added new offroad message respond truck process receives message nt understand forward parent car process let see run elixir truck trucknew color blue send truck drive truck blue x send truck offroad going offroad see truck type inherited behavior car type polymorphism polymorphism one object orientation strongest quality programming interchangeable part manufacturing allows u substitute subtypes parent type wherever parent type used addition ruby elixir allows u substitute type another type long responds right method message like inheritance polymorphism adheres liskov substitution principle well established characteristic good object oriented design part solid design principle first polymorphism ruby use car truck instance show interchangeable regard drive method randomly select either instance call drive ruby car carnew color red truck trucknew color blue car truck sampledrive car red x truck blue x array sample method return either car truck instance since duck typed object successfully call drive either another class nt inherit car also contained drive method could substitute instance class well polymorphism finest equally easy elixir instead calling method pas message major difference ruby elixir version select random object process rest virtually identical elixir car carnew color red truck trucknew color blue enumrandom car truck send drive car red x truck blue x polymorphism inherent part elixir though seldom thought way elixir process gladly receive message pas regardless whether something message restriction message passed phantom message simply sit process mailbox behooves mention unhandled message cause memory leak asynchrony intent purpose built major component object oriented system functional language flaw nt use sophisticated elixir tool showcase possible represent pattern elixir one notsosubtle nuance hidden code example would rear head immediately upon actual implementation calling method ruby synchronous passing message elixir asynchronous word calling ruby method pause program execute body method return result method caller blocking synchronous activity passing message elixir nonblocking asynchronous activity elixir send process message immediately return without waiting message received make trivial thing ruby cumbersome elixir take example simply trying return value passed message ruby straightforward ruby class car def color red end end carnewcolor red thing elixir talking message passing calling function return value everything work expected elixir defmodule car def color red end end carcolor red start working process becomes challenging intuitive broken piece elixir code elixir defmodule car def new spawnlink end def run receive color red end end end car carnew send car color color expect sending car process color message would return value red instead return value color return message sent process value returned message handled message passing elixir asynchronous want model synchronous behavior ruby method invocation get little creative since receive block process wait message use context caller whoever call color would need block wait response order continue program like ruby unlike ruby bit ceremony getting work need send caller pid callee callee send message back caller final return value elixir defmodule car def new spawnlink end def run receive color caller send caller color red end end end car carnew send car color self receive color response response end red code passing caller pid callee accessed calling caller wait message callee containing response caller response pattern matched extract value return value caller receive block final response red lot ceremony luckily elixir nice abstraction avoid litany look agent using agent treat code synchronously eliminate lowlevel send receive function elixir defmodule car def new ok car agentstartlink fn color red end car end def color car agentget car fn attrs attrscolor end end end car carnew carcolor car red elixir variety tool help keep code clean programming synchronously one tool genservers useful abstraction around process allow u implement state behavior simplified form much like ruby final thought around asynchrony like mention two thing message passing elixir slower method invocation ruby due delay message sent receiving process handle message passing elixir primitive concurrency construct actor model concurrency option ruby unless using library like celluloid concurrency ruby usually threaded actor model abstraction thread baked elixir provides level concurrency attainable ruby wrapping blended object orientation functional programming throughout course article whether prefer ruby version elixir version place object orientation ruby simple elegant make happy nt provide concurrency control elixir offer programming model pleasant use hand elixir allows u model system object oriented fashion leveraging powerful concurrency control object orientation elixir may may viable approach nt enough data yet draw conclusion worth mentioning functional community us different pattern creator erlang joe armstrong lamented oop due blending state behavior though find mixture inevitable process may commonplace use functional language objected oriented style certainly possible may graceful modeling domain happy coding article generously translated swedish russian
353,Lobsters,elixir,Elixir programming,"Interview to Boyd Multerer, founder of Xbox Live, about Elixir",https://soundcloud.com/elixirfountain/elixir-fountain-boyd-multerer-2016-08-24,interview boyd multerer founder xbox live elixir,,network connection unstable browser outdated
355,Lobsters,elixir,Elixir programming,"Erlang, Elixir, Efene & LFE Buenos Aires Meetup - Sept. 28th @ Inaka's offices",http://www.meetup.com/es/ErlangBA/events/232750618/,erlang elixir efene lfe buenos aire meetup sept inaka office,http proyectociaacomardevwikidokuphp iddesarrollo educiaa educiaanxp,meeting cancelled queridos beamers tenemos fecha para el primer meetup del año será el de setiembre la h en la oficinas de inakaeste año vamos intentar hacer el meetup lo más políglota posible incluyendo erlang elixir efene lfe todo otro lenguaje que corra sobre la beampresentaciones como se hacen la beam mariano guerra una charla que describe como se crea un lenguaje de programacion sobre la maquina virtual de erlang como funciona la maquina virtual que cosas hace facil que cosas dificil todo esto creando paso paso un lenguaje que compila beam bytecode con funcionalidad basica de calculadora con erlang en educiaa sin sistema operativo carlos pantelides presentación convocatoria participar del proyecto de implementar portar erlang la plataforma educiaanxp http proyectociaacomardevwikidokuphp iddesarrollo educiaa educiaanxp comparando erlang con elixir federico carrone el objetivo de la charla e compartir la alegrias dificultades sorpresas que topé al usar elixir como lenguaje principal para programar backend de videojuegos luego de utilizar erlang como principal lenguaje de programación además compararemos la diferencias de cultura dentro de la comunidad haremos un pequeño repaso de algunas herramientas que brinda elixir que se encuentran disponibles en erlang en resumen la idea e comparar los do lenguajes comunidadeslos esperamos todos
356,Lobsters,elixir,Elixir programming,Phoenix Channels vs Rails Action Cable,https://dockyard.com/blog/2016/08/09/phoenix-channels-vs-rails-action-cable,phoenix channel v rail action cable,phoenix rail test designed tsung rail memory leak failing call cleaning connection scalability user per room rail rail phoenix making sense result user per room user per room rail rail phoenix making sense result user per room conclusion sync,dockyard transitioned backend development ruby rail elixir phoenix became clear phoenix better served client need take modern web seen phoenix rail borrow great idea also delighted give back direction rail announced rail would shipping action cable feature take inspiration phoenix channel rail released client existing rail stack asking use action cable realtime feature jump phoenix reliable scalable application planning architecture decision language framework always take measurement prove assumption need measure phoenix channel action cable handle typical application workflow created chat application framework stressed varying level workload test designed measurement used tsung benchmarking client open websocket connection application added xml configuration send specific phoenix rail protocol message open channel established connection publish message hardware used two digital ocean instance client server workflow tsung client connection follows open websocket connection server create single channel subscription connection chat room chosen random periodically send message chat room randomly every simulate messaging across member room server channel code rail phoenix quite simple defmodule chatroomchannel use chatweb channel def join room id params socket ok socket end def handlein publishmsg body body user user socket broadcast socket newmessage body body user user reply ok socket end end class roomschannel applicationcable channel def subscribed topic room rand streamfrom topic end def publishmsg data actioncableserverbroadcast topic body data body username data username started data started end end establishing n number room varying number user per room measured application responsiveness tested performance joining random room browser timing broadcast local browser member room increased number user per room measured change broadcast latency recorded short clip application behavior different load simulates chat app workflow applies equally variety application realtime update visitor reading article streaming feed collaborative editor evaluate result explore number relate different kind application rail memory leak creating rail chat application setting redis deploying application instance immediately observed memory leak application visible refreshing browser tab watching memory grow never freed following recording show action sped searched recently reported bug around area found issue related action cable failing call socketclose cleaning connection patch applied branch updated app unreleased branch reran test memory leak persisted yet isolated source leak given simplicity channel code must within action cable stack leak particularly concerning since rail released time branch unreleased memory leak patch going back greater day scalability set memory leak issue aside proceeded test following scenario max number room supported single server user per room max number room supported single server user per room note phoenix every scenario maxed client server ability open websocket connection giving u user simulate test browser server latency also considered evaluating broadcast latency test user per room rail room user responsiveness speedy room upped room count giving u user rail room user see action cable falling behind availability broadcasting message taking average broadcast user given room application level latency acceptable level performance maxinum room server would somewhere room given user per room phoenix room user maxed client connection see phoenix responds average maxed room client limit tsung box making sense result user per room result show building application small medium sized business company visit app time notification delayed given severe degradation performance room may also hard pinpoint server density planning load load planning horizontal scalability required company per server reliance redis considered central bottleneck horizontal scalability obvious choice ruby came stateless http request see vertical scalability becomes increasingly important stateful connection require dozen hundred server action cable still rely central redis bottleneck pubsub user per room rail room user see action cable start acceptable latency begin quickly fall behind broadcast latency grows message broadcast latency grows longer next upped room count see limit rail room user availability compromised broadcasting user per room action cable unable maintain broadcast load supported room experienced message stop arriving subscription failing establish level consistent performance could get user per room limiting server room user phoenix room user maxed client connection see phoenix responds average maxed room client limit tsung box additionally important note phoenix maintains responsiveness broadcasting user per room test making sense result user per room may thinking application chat app need simple page update test apply equally many scenario imagine information system want publish periodic update page could news site visitor see new comment booking site visitor see people currently viewing hotel test show app receives sudden spike visitor article reader server able keep notification demand popular article well low traffic one booking site imagine hotel across country release discount rate customer jump online deal suddenly need spin extra server maintain booking notification severity delay becomes worse critical functionality application relies notification conclusion memory leak ruled addressed sweetspot action cable today small workload subscriber given topic going beyond mean engineering effort resource must spent managing multiple node optimizing code channel higher workload broadcast dozen subscriber risk availability phoenix shown channel performance remains consistent notification demand increase essential handling traffic spike avoiding overload started realtime rail feature sync several year ago memory leak consistent performance main fear drove look elsewhere find elixir create phoenix railscore team done great job putting realtime story place wrangling ruby lack concurrency feature continue challenge source code instruction running test hardware found
357,Lobsters,elixir,Elixir programming,Elixir Jobs,https://elixir-jobs.org/,elixir job,,
359,Lobsters,elixir,Elixir programming,I Accidentally Some Machine Learning - My Story of A Month of Learning Elixir,http://fredwu.me/post/147855522498/i-accidentally-some-machine-learning-my-story-of,accidentally machine learning story month learning elixir,elixir learning elixir programming elixir programming ruby actorbased concurrency model elixir make writing unit test effortless unit test written minimal friction high visibility toy robot elixir toy robot http githubcomfredwutoyrobotelixir learning phoenix phoenix side project fail much learning extract experience programming phoenix attempted fix ecto changeset hanami trailblazer hex awesome elixir learning machine learning bayesian inference naive bayes random forest simple bayes stemming stemmer learning ruby,month ago inbetween job two week rest recharge get ready new job thought use two week learn something new year ago briefly looked elixir first released wild time interested picking due syntax similarity ruby despite vastly different underlying semantics love ruby weapon choice past year came time learn something new naturally wanted learn something bit different ruby syntaxwise fastforward year mature openminded position welcome elixir embrace rubylike syntax well functional programming mindset open arm learning elixir given strong influence ruby elixir help get nostalgic learning reading another great book dave thomas programming elixir dave thomas original programming ruby instrumental success ruby programming language community west certainly helped greatly widen exposure wonderful world ruby objectoriented programming general php developer learning elixir really fun share developerfriendliness championed ruby also remarkable strength concurrency thanks beam erlang vm many people drawn elixir due ruby influence functional immutability nature actorbased concurrency model would however like call one favourite feature elixir sometimes get overlooked could write unit test using exunitdoctest elixir make writing unit test effortless python programmer writing doctests year ruby due equivalent standard library never writing doctests taken community glad elixir take look code snippet defmodule doc example iex ok ok iex k k iex k k def trimapostrophes word word stringreplaceprefix stringreplacesuffix end end three test case given actually tested exunit provided ask defmodule use exunitcase async true doctest end may think doctests big deal say really enjoying fact unit test written minimal friction high visibility sit implementation rather within big test suite sea file besides u practice tdd religiously time tdd doctests ensures forget adding test case toy robot elixir best way learn something new practice learn instead diving straight complicated system write hello world program thought would dig code test reimplement elixir code test rather infamous toy robot test interviewer must reviewed hundred test ruby know good oo solution look like naturally looking forward rethink problem crack using elixir result http githubcomfredwutoyrobotelixir learner wanted practice many language feature possible included toy robot test code tried different data structure struct list pattern matching data piping agent managing state macro validation rule kept test code small nimble purpose illustrate readability highly expressive language may exercised language feature supervisor protocol point felt could start elixir journey big smile face already learning phoenix admit big part reason got started learning elixir build side project initially wanted simply use ruby rail productive using end decided learning elixir phoenix side project fail much learning extract experience answer question learn new language new framework importantly new programming paradigm drastically increase amount learning could gain please jump phoenix learn elixir properly first year seen far many case people jumping rail without understanding language feature learn phoenix programming phoenix book pretty much bible subject aside official guide written chris mccord author phoenix bruce tate jose valim author elixir experienced rail developer took day two go book largely skimmed chapter channel intend build realtime app ruby developer biggest pain point working rail sizeable ruby mvc project activerecord got frustrated status quo even attempted fix fortunately elixir phoenix ecto one favourite feature ecto concept changeset take look code snippet defmodule mysecretappuser use mysecretappweb model schema user field username string field email string field password string virtual true field encryptedpassword string hasone profile mysecretappprofile timestamps end def changeset struct params struct cast params username email validaterequired username email validatelength username min max validateformat username ra z message alphanumeric underscore validateformat email r uniqueconstraint username uniqueconstraint email end def creationchangeset struct params struct changeset params passwordchangeset params end defp passwordchangeset struct params struct cast params password validaterequired password validatelength password min max encryptpassword end defp encryptpassword changeset case changeset ectochangeset valid true change password password putchange changeset encryptedpassword comeoninbcrypthashpwsalt password changeset end end end function used user need updated whereas used user first created sure achieve similar result rail using custom validators fact practice enforced library framework encouraging one thing seen larger rail apps leaky abstraction viewlevel logic typically sit controller helper globally available worse model phoenix case follows hanami trailblazer many framework introduces view model layer something along line defmodule mysecretappuserview use mysecretappweb view def fullname title firstname lastname end end nutshell phoenix like rail le magical good way faster like elixir ecosystem library concept feel like rubyrails counterpart refined popular hex package familiar ruby counterpart list go sure check awesome elixir community curated elixir library learning machine learning started building foundation side project know usual user management session management etc etc chance came across mention bayesian inference one thing led another soon started looking varies different machine learning algorithm naive bayes random forest subject never come across even heard strong mathematics statistic computer science background however intrigued inspired nonetheless wanted employ machine learning side project best way understand learn machine learning algorithm guessed write one research came conclusion naive bayes one simplest implement great text classification useful side project good accuracy given simplicity fast speed train ride work newly purchased macbook yes one single usbc port built naive bayes library simple bayes writing naive bayes library elixir support following feature let see action shall simplebayesinit simplebayestrain ruby enjoyed using rail activerecord part simplebayestrain ruby ruby community awesome simplebayestrain ruby new framework called hanami promising simplebayestrain ruby please learn ruby learn rail simplebayestrain ruby use rail work simplebayestrain elixir phoenix railslike framework simplebayestrain elixir author rail core member jose valim simplebayestrain elixir phoenix rail many level comparable simplebayestrain elixir phoenix great performance simplebayestrain elixir love elixir simplebayestrain php nt written php year simplebayestrain php php framework laravel inspired rail simplebayesclassify wrote rail code work today see provided reasonable training data naive bayes work extremely well something discovered building simple bayes something called stemming let see another example simplebayesinit stem false simplebayestrain apple buying apple simplebayestrain banana buy banana simplebayesclassify buy apple oops probability sentence buy apple apple banana good know buying buy mean thing stemming come handy let enable stemming run example simplebayesinit stem true simplebayestrain apple buying apple simplebayestrain banana buy banana simplebayesclassify buy apple stemming case correctly identified buy buying thing stemmed root buy include stemming simple bayes wonder let introduce stemmer writing stemmer available elixir elixir beam may known raw performance compared similar stemmer implemented pure ruby elixir version run five time faster stem word compared ruby version learning writing elixir month still heap learn practice far though say experience elixir phoenix fantastic get satisfying pumped feeling got learning ruby rail year ago checked elixir strongly encourage world seems moving concurrency direction increasingly rapid speed including ruby
361,Lobsters,elixir,Elixir programming,Elixir: Announcing GenStage,http://elixir-lang.org/blog/2016/07/14/announcing-genstage/,elixir announcing genstage,check project source code access documentation background creating designing elixir introduce better abstraction working collection stream module foundation enum stream discussed one immediate solution problem genstage genstage dataingestion genstage event dispatching genevent path forward written documentation based prototype built far genstage flow also topic keynote elixirconf akkastreams reactivestreams project apache spark apache beam,today glad announce official release genstage genstage new elixir behaviour exchanging event backpressure elixir process shortterm expect genstage replace use case genevent well providing composable abstraction consuming data thirdparty system blog post cover background led u genstage example use case exploring future release instead looking quick reference check project source code access documentation background one original motivation creating designing elixir introduce better abstraction working collection want provide developer interested manipulating collection path take code eager lazy concurrent distributed let discus simple actual example word counting idea word counting receive one file count many time word appears document using enum module could implemented follows fileread pathtosomefile stringsplit n enumflatmap fn line stringsplit line end enumreduce fn word acc mapupdate acc word end enumtolist solution work fine efficient small file quite restrictive large input load whole file memory another issue solution step build huge list word file effectively start counting large document mean memory usage waste processing time building list traversed right luckily elixir provides solution problem provided quite time stream one advantage stream lazy allowing u traverse collection item item case line line instead loading whole data set memory let rewrite example use stream filestream pathtosomefile streamflatmap fn line stringsplit line end enumreduce fn word acc mapupdate acc word end enumtolist using filestream streamflatmap build lazy computation emit single line break line word emit word one one without building huge list memory enumerated function stream module express computation want perform computation like traversing file breaking word flatmap happens call function enum module covered foundation enum stream another article solution allows u work large datasets without loading memory large file going provide much better performance eager version however solution still leverage concurrency machine one core huge majority machine available today suboptimal solution said could leverage concurrency example elixirconf keynote discussed one immediate solution problem convert part pipeline separate process filestream pathtosomefile streamflatmap fn line stringsplit line end streamasync new enumreduce fn word acc mapupdate acc word end enumtolist idea streamasync would run previous computation separate process would stream message process called enumreduce unfortunately solution le ideal first want avoid moving data process much possible instead want start multiple process perform computation parallel requiring developer place streamasync manually may lead inefficient error prone solution although solution many flaw helped u ask right question streamasync introducing new process guarantee process supervised since exchanging message process prevent process receiving many message need backpressure mechanism allows receiving process specify much handle sending process jumped different abstraction trying answer question finally settled genstage genstage genstage new elixir behaviour exchanging event backpressure elixir process developer use genstage need worry data produced manipulated consumed act dispatching data providing backpressure completely abstracted away developer quick example let write simple pipeline produce event increasing number multiply number two print terminal implementing three stage producer producerconsumer consumer call b c respectively go back word counting example end post let start producer call since producer main responsibility receive demand number event consumer willing handle generate event event may memory external data source let implement simple counter starting given value counter received note module genstage project prefixed experimental namespace example code alias experimentalgenstage top file alias experimentalgenstage defmodule use genstage def init counter producer counter end def handledemand demand counter demand counter ask item emit item set state event enumtolist counter event emit second element tuple third state noreply event counter demand end end b producerconsumer mean explicitly handle demand demand always forwarded producer receives demand b send event b transformed b desired sent c case b receive event multiply number given initialization stored state alias experimentalgenstage defmodule b use genstage def init number producerconsumer number end def handleevents event number event enummap event number noreply event number end end c consumer finally receive event print every second terminal alias experimentalgenstage defmodule c use genstage def init sleepingtime consumer sleepingtime end def handleevents event sleepingtime print event terminal ioinspect event sleep configured time processsleep sleepingtime consumer never emit event noreply sleepingtime end end stage defined start connect ok genstagestartlink starting zero ok b genstagestartlink b multiply ok c genstagestartlink c sleep second genstagesyncsubscribe c b genstagesyncsubscribe b sleep see event printed processsleep infinity soon subscribe stage see item printed terminal notice even though introduced sleep command consumer producer never overflow consumer data communication stage demanddriven producer send item consumer consumer sent demand upstream producer must never send item consumer specified one consequence design decision parallelizing stateless stage like consumer really straightforward ok genstagestartlink starting zero ok b genstagestartlink b multiply ok genstagestartlink c sleep second ok genstagestartlink c sleep second ok genstagestartlink c sleep second ok genstagestartlink c sleep second genstagesyncsubscribe b genstagesyncsubscribe b genstagesyncsubscribe b genstagesyncsubscribe b genstagesyncsubscribe b sleep see event printed processsleep infinity simply starting multiple consumer stage b receive demand multiple stage dispatch event stage running concurrently always picking stage able process item also leverage concurrency opposite direction producer slow stage pipeline start multiple producer consumer subscribe order know consumer receive particular event producer stage depend behaviour called genstagedispatcher default dispatcher genstagedemanddispatcher briefly described collect demand different consumer dispatch one highest demand mean one consumer slow maybe increased sleeping time second receive le item genstage dataingestion one use case genstage consume data thirdparty system demand system backpressure guarantee import data effectively handle demand dispatcher allows u easily leverage concurrency processing data simply adding consumer elixir london meetup livecoded short example show use genstage concurrently process data stored postgresql database queue video genstage event dispatching another scenario genstage useful today replace case developer would used genevent past unfamiliar genevent behaviour event sent event manager proceeds invoke event handler event genevent however one big flaw event manager event handler run process mean genevent handler easily leverage concurrency without forcing developer implement mechanism furthermore genevent handler awkward error semantics event handler separate process simply rely supervisor restarting genstage solves problem producer event manager producer configured use genstagebroadcastdispatcher dispatcher broadcast dispatcher guarantee event dispatched consumer way exceed demand consumer allows u leverage concurrency event manager producer give u much flexibility term buffering reacting failure let see example building event manager producer alias experimentalgenstage defmodule eventmanager use genstage doc start manager def startlink genstagestartlink module ok name module end doc sends event return event dispatched def syncnotify event timeout genstagecall module notify event timeout end callback def init ok producer queuenew dispatcher genstagebroadcastdispatcher end def handlecall notify event queue demand dispatchevents queuein event queue demand end def handledemand incomingdemand queue demand dispatchevents queue incomingdemand demand end defp dispatchevents queue demand event demand item queue queueout queue value event item genstagereply ok dispatchevents queue demand event event else noreply enumreverse event queue demand end end end eventmanager work buffer demand event sent store demand event demand store event queue client try broadcast event syncnotify call block event effectively broadcasted bulk logic function take event queue demand implementing event manager producer configure sort behaviour simply possible genevent much data want queue long event buffered consumer via callback implementing event handler straightforward writing consumer could fact use c consumer implemented earlier however given event manager often defined handler recommended handler subscribe manager start alias experimentalgenstage defmodule eventhandler use genstage def startlink genstagestartlink module ok end callback def init ok start permanent subscription broadcaster automatically start requesting item consumer ok subscribeto eventmanager end def handleevents event state ioinspect event noreply state end end guarantee supervised eventhandler crash supervisor start new event handler promptly subscribe manager solving awkward error handling semantics seen genevent path forward release genstage reached important milestone genstage used event manager way exchange event process often external data source backpressure release also includes genstagestream function allows u consume data genstage stream genstagefromenumerable allows u use enumerable stream like filestream producer closing gap stage stream however far done first moment community step try genstage used genevent past replaced genstage similarly planning implement event handling system give genstage try developer maintain library integrate external data source rabbitmq redis apacha kafka explore genstage abstraction consuming data source library developer must implement producer leave user configure consumer stage get enough feedback genstage included shape part standard library goal introduce genstage phase genevent long term elixir team got started next milestone genstage revisit original problem provide developer clear path take collection processing code eager lazy concurrent distributed seen earlier today allow developer transform eager code lazy introducing stream filestream pathtosomefile streamflatmap fn line stringsplit line end enumreduce fn word acc mapupdate acc word end enumtolist helpful working large infinite collection still leverage concurrency address currently exploring solution named genstageflow allows u express computation similarly stream except run across multiple stage instead single process alias experimentalgenstageflow filestream pathtosomefile flowfromenumerable flowflatmap fn line word stringsplit word end flowreducebykey enumtolist highly optimized version alias experimentalgenstageflow let compile common pattern performance emptyspace binarycompilepattern new filestream pathtosomefile readahead new flowfromenumerable flowflatmap fn line word stringsplit emptyspace word end flowpartitionwith storage ets new flowreducebykey enumtolist flow look computation want perform start series stage execute code keeping amount data transfered process minimum interested genstageflow computation spread across multiple stage written documentation based prototype built far code coming future genstage release also consider genstageflow api mirror function enum stream make path eager concurrent clearer word counting problem fixed data early experiment show linear increase performance fixed overhead word dataset take single core take machine core one core gain simply moving computation stream flow plan benchmark machine core soon excited possibility genstage brings developer new path allows u explore research give try let u know genstage flow also topic keynote elixirconf hope see finally want thank akkastreams reactivestreams project provided u guidance implementing demanddriven exchange stage well apache spark apache beam initiative inspire work behind genstageflow happy coding
362,Lobsters,elixir,Elixir programming,"Learn to Forget, when you learn Erlang",https://www.erlang-solutions.com/blog/learn-to-forget.html,learn forget learn erlang,learn forget inaka erlang trainer erlang developer nutshell sequential erlang concurrent erlang sse write whole system learn point learning book inadequate fashion condensed knowledge emerged famous book behaviour opensource library condensed knowledge workerpool sumorest many others let put library hexpm hexpm furthermore go back blog,learn forget brujo benavides many rolespositions inside erlang solution inaka cto one erlang solution tech lead also erlang trainer sometimes truly erlang developer want share experience learning erlang couple year ago incidentally something also seen time different perspective erlang trainer nutshell thing keep seeing someone learning erlang happened people learning language like haskell instance keep learning thing forget later probably never going use anymore need know want understand concept intrinsically tied philosophy language one thing render many building block forgettable usually seen attached language name itslef erlangotp let show sequential erlang let leave otp aside second start learning erlang usually start sequential erlang right erlang book course tutorial start way erlang functional language one first thing everyone learns write recursive function start database actually list fetch key undefined fetch key key value value fetch key db fetch key db somebody introduces anonymous function course highorder function suddenly use recursion anymore cool kid use list instead fetch key db case list dropwhile fun k k key end db undefined value value end course eventually realize someone else must issue often exactly case function use fetch key db proplists getvalue key db concurrent erlang ok writing sequential erlang easier expected lot thing already written good thing make people choose erlang first place chosen erlang develop system probably concurrency problem rather problem best solved using concurrent language least intuitive first situation described sequential erlang could apply concurrent erlang well start database new dbvalues spawn module init dbvalues init dbvalues loop dbvalues loop db receive fetch key reply proplists getvalue key db end loop db fetch key db db fetch self key receive reply result result end see implement example learn spawn process using erlang variant send receive message database process receives message message receives using internal state build response sends back caller message yeah tiny bit internal logic proplists getvalue key db unique rest pretty generic even caller side everything boil sending message waiting response might guessed lot people faced issue condensed experience helped create thing otp learn work otp behaviour longer need spawn process send message explicitly new dbvalues genserver start module dbvalues init dbvalues ok dbvalues handlecall fetch key db reply proplists getvalue key db db fetch key db genserver call db fetch key terminate ok see suddenly using spawn anymore genserver take care furthermore genserver also take care ton thing even thought yet like server running running node timeouts code upgrade etc point job erlang developer longer spawning process sending message starting server fsms inside supervision tree end building application building whole new kind app building generic enough instance web server rest api web socket even sse support surely app already need write piece code specific system longer think process even server supervisor whatnot hidden behind internal logic erlang application use day certainly write whole system multiple endpoint database connection interactive documentation even sse support without even thinking otp learn point unavoidable question pop end use point learning question every math student ever forever asked logarithm right answer unsurprisingly shape way think building system erlang writing functional code spawning process interchanging message building erlang system thinking term scalability faulttolerance reliability many thing francesco cesarini steve vinoski explain detail book understanding mechanism behind otp process lead creation help gain crucial insight architect system true write web server erlang limited functional programming knowledge almost total lack awareness otp knowingcaring internals building really know capable importantly know system capable also fact even totally use otp knowing linked process behave save countless hour frantical debugging googling stackoverflowing find started genserverin inadequate fashion condensed knowledge important notice something fully realize started teaching erlangotp course otp created orimposed emerged point someone established right way building system erlang contrary otp created multiple already existing system built way working ericsson smart people realized thing writing code time time making mistake fixing saw decided condense knowledge code well course big library set application actually eventually called otp thought process lead gang four write famous book described many common pattern observed several project provided name example making otp common programming pattern identified ended encoded behaviour using actually profiting condensed knowledge year programming building system similar one hand opensource library process described stop otp maybe add many new thing otp anymore thanks thriving opensource community behind erlang still keep collecting condensed knowledge apps library framework allow others well forget certain thing keep constantly library like workerpool sumorest many others result thought process behind otp time people let put library central place share knowledge hexpm learned forget couple internal component find writing piece code encourage create opensource library share hexpm others stop reinventing particular wheel using experience others also turn simple wooden wheel allstar highperformance one keep u rolling faster faster everyday furthermore erlang developer long time described come experience learner teacher well experience colleague friend based pretty certain developer learn erlang love hear learning pattern spice thing brand new language beam town elixir really interested discovering learning process like especially people come erlang background currently trying gather info speaking alchemist know learnt elixir recently please share insight comment plan eventually write post elixir learning experience see difference stay tuned go back blog
364,Lobsters,elixir,Elixir programming,"Benchee 0.3.0 released – formatters, parallel benchmarking & more",https://pragtob.wordpress.com/2016/07/12/benchee-0-3-0-released/,benchee released formatters parallel benchmarking,benchee changelog multiple formatters bencheecsv verbose api parallel benchmarking parallel benchmarking eon contributed change back benchee check benchee wiki print configuration information map instead list tuples line code alvin leon like,yesterday released benchee benchee tool micro benchmarking elixir focussing simple extensible provide good statistic refer changelog detailed information change post look bigger change also give bit new feature change multiple formatters arguably biggest feature benchee easy builtin configure multiple formatters benchmarking suite mean first benchmark run multiple formatters run benchmarking result way get console output corresponding csv file using bencheecsv pain point could either get one needed use verbose api list enumtolist mapfun fn end bencheerun formatters csv file mycsv flatmap fn enumflatmap list mapfun end mapflatten fn list enummap mapfun listflatten end also see new method work opposed also really output bencheecsv us custom configuration option know file write also new formatters access full benchmarking suite including configuration raw run time function definition way configured using configuration option define plugin could graph run time wanted course formatters default builtin console formatter parallel benchmarking another big addition parallel benchmarking elixir feel natural specify parallel key configuration tell benchee many task execute given benchmarking job parallel list enumtolist mapfun fn end bencheerun time parallel flatmap fn enumflatmap list mapfun end mapflatten fn list enummap mapfun listflatten end course want see system behaves load overloading might exactly want stress test system exactly reason leon contributed change back benchee needed benchmark integration test telephony system wrote system test actually interfere using ecto repo wanted see far could push system whole making small change benchee worked perfectly needed course make extremely happy people found adjusting benchee use case simple one main goal benchee even better contributed back want see information detail benchmark parallel check benchee wiki spoiler alert parallel benchmark run slower get acceptable degree system overloaded task execute parallel cpu core take care also deviation skyrocket effect seems significant parallel system default benchee remains parallel mentioned reason print configuration information partly also due parallel change benchee wil print brief summary benchmarking suite executing tobi happy githubbenchee mix run samplesrunparallelexs benchmark suite executing following configuration warmup time parallel estimated total run time benchmarking flatmap benchmarking mapflatten name nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp ip nbsp nbsp nbsp nbsp nbsp nbsp nbsp average nbsp nbsp nbsp deviation nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp median mapflatten nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp flatmap nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp comparison mapflatten nbsp nbsp nbsp nbsp nbsp nbsp flatmap nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp slower done people share benchmark online one easily see configuration ran eg warmup time amount parallel task high therefore result bad also print estimated total run time number job warmup time know enough time go get coffee benchmark finish map instead list tuples also marked breaking change changelog actually breaking main data structure handed bencheerun changed map instead list tuples corresponding data structure changed well important plugins know used list tuples possibility benchmark name would override however benchmark name nonsensical discern result output way feel like much fitting data structure old main data structure list tuples still work might remove expect right required maintain line code make duplicated name longer working real deprecation although one might even call feature last least release first one got community contribution make extremely happy thanks alvin leon like like loading related
365,Lobsters,elixir,Elixir programming,How We Replaced React with Phoenix,https://robots.thoughtbot.com/how-we-replaced-react-with-phoenix,replaced react phoenix,redux phoenix channel investment time turbolinks,year half ago built internal tool companywide announcement originally built backend phoenix frontend react taking advantage redux phoenix channel deliver update browser realtime made great realtime experience also slowed pace development caused fewer people contribute three month ago decided time ditch react go back serverside rendering realtime update browser user interacted application made great experience additional cost instead building feature one place build api ui also meant anyone wanted contribute know react phoenix discouraged others trying contribute another pain point react codebase testing since application react client separate meant make sure fake server response always date practice large problem burn u time reduced confidence test finally wanted people contribute found build feature two place lot work building one trying coordinate frontend backend feature tedious especially true since work application done investment time since already namespaced api place able rewrite page phoenix deploy production without affecting existing react frontend since app largely crud page quick onetoone copy html replacing classname class replacing block place needed javascript took triedandtrue path sprinkling javascript best example liveupdating comment whenever comment created backend broadcast user comment created instead sending json created livehtml channel broadcast html update user javascript code straight application import socket socket const channel socketchannel livehtml channeljoin receive ok function resp consolelog joined successfully resp receive error function resp consolelog unable join resp channelon newcomment payload dataannouncementid payloadannouncementid commentslist append payloadcommenthtml surprisingly small amount javascript power huge piece functionality application strategy generating html server broadcasting client much simpler writing entire frontend javascript functionality also added turbolinks app make page transition nearly seamless let u keep singlepage app feel overall migration relatively painless ended people contribute project month previously year react frontend test much easier write also much reliable since rely payload backend sends matching payload used test although lot people company knew migration happening tell anyone pushed production single person mentioned seeing difference knew application using longer powered react time load page greatly reduced thanks phoenix speed bootstrap large amount data frontend via react end realized proved write phoenix serverrendered application great frontend frameworkpowered single page application end product great write feature faster confidence test easily developer contribute application altogether think huge win project removed frontend framework recently
366,Lobsters,elixir,Elixir programming,Understanding deps and applications in your Mixfile,http://blog.plataformatec.com.br/2016/07/understanding-deps-and-applications-in-your-mixfile/,understanding deps application mixfile,note read official announcement documentation doc exrm prebuilt part elixir library application must included make sure included development test doc optional dependency stay phoenix file connect channel declare application even using release library author take extra care elixir tooling friend standing shoulder announcement elixir summing direct runtime production review,note elixir released improves many point touched article elixir automatically infer list application based dependency information read official announcement journey curious elixir developer come across seemingly simple question time application thirdparty library need declare mixexs file get nittygritty application dependency let first recap basic initialization process elixir otp application essence otp application reusable software component consisting multiple module also depend thirdparty code dependency either library application collection standalone module function process involved active application life cycle supervision tree distinction quite subtle took fully grasp implication application defined application resource file like myappapp metadata file comprised single erlang term includes information needed start application managed mix want dig deeper topic take look documentation create new application mix new myapp brand new mixexs file generated file customizes myappapp assembled mix file dealing elixir world look like defmodule myappmixfile use mixproject def project app myapp version elixir buildembedded mixenv prod startpermanent mixenv prod deps deps end configuration otp application type mix help compileapp information def application application logger end dependency hex package mydep gitpath repository mydep git http githubcomelixirlangmydepgit tag type mix help deps example option defp deps end end see important piece information app name version elixir version requirement addition application function let u explain required boot application application need started locally registered process module represents starting point application also default value application environment running mix help compileapp get information function doc available application behavior abstract initialization process per se pretty extensive helpful well far good thing start get interesting let take look mixexs file new phoenix project first generate application skeleton mix phoenixnew hello add exrm deps including exrm tool generating release defmodule hellomixfile use mixproject def project app hello version elixir deps deps end configuration otp application type mix help compileapp information def application mod hello application phoenix phoenixpubsub phoenixhtml cowboy logger gettext phoenixecto postgrex end defp deps phoenix phoenixpubsub phoenixecto postgrex phoenixhtml phoenixlivereload dev gettext cowboy exrm end end along logger application seen vanilla elixir app application depend upon phoenix http server utility database driver pay close attention deps application list see almost ratio every application relates dep counterpart like cowboy phoenixpubsub postgrex others exception logger prebuilt part elixir exrm phoenixlivereload mismatch confused wondered mixing pun intended library application must included libraryonly application like phoenixhtml gettext included application function need booted start spawning process something turn application function release runtime supervision tree yes listing active application ensures started application including library application also make sure included installable release package support claim see even exrm warns u forget let try removing phoenixhtml cowboy application defmodule hellomixfile def application mod hello application phoenix phoenixpubsub logger gettext phoenixecto postgrex end end make new release mix depsget running dependency resolution getting phoenix hex package checking package http using locally cached package mixenvprod mix release building release mixenvprod dependency directtransitive application following apps added application mixexs phoenixhtml phoenixhtml missing hello cowboy cowboy missing hello continue anyway release may work expected dependency required yn dependency would missing final package bomb certainly want development test doc optional dependency stay might still ask cowboy phoenixhtml control get required automatically phoenix way need worry phoenix single rich dependency actually phoenix framework standpoint none application actually required cowboy strict runtime dependency freely run phoenix app another compatible web server choice phoenix html even gettext strictly required either totally build phoenix app without html output localization consider apionly app example u see phoenix mixexs file cowboy declared optional true phoenixhtml test gettext likewise test reason dependency declared eventually need app must least compatible phoenix version currently use also explains exrm phoenixlivereload kept application list want phoenixlivereload running production since live code reloading exrm tool used exclusively package application business code need know anything cool come phoenixlivereload work development though well start application mix phoenixstart example code available load path phoenixlivereload application started yet start connect channel try starting little phoenix app checking application get loaded iex mix phoenixstart erlangotp source hipe kernelpoll false dtrace info running helloendpoint cowboy using http interactive elixir press ctrlc exit type h enter help iex applicationloadedapplications plug specification convenience composable module web application hex hex list application currently loaded returned call applicationloadedapplications make first request opening http calling applicationloadedapplications see two new application list f phoenixlivereload iex applicationloadedapplications plug specification convenience composable module web application hex hex f vxz f listener phoenixlivereload provides livereload functionality phoenix declare application even using release deploying heroku application requires release packaging whatsoever still worry list application yes definitely suppose need upgrade dependency one used library application become active application eg cache library keep reaper process clean stale data upgrade dep undeclared application runtime bug potentially introduced given guarantee new dependency application get started properly library author take extra care go library regardless open sourcing remember runtime application dependency transitive let say application depends b turn depends c application responsible ensuring c started b unless c optional dependency case author b document pluggable nature optional dependency appropriately even provide code generator applicable phoenix cowboy elixir tooling friend one noticeable benefit elixir toolssupport built around runtime standing shoulder erlang primarily development build time case overlooked announcement elixir recently released definitely check among improvement dependency tracking two new builtin mix task apptree depstree priceless timesavers routine task keeping dependency summing evaluating dependency issue individually boil simple criterion deps function mixfile always add deps direct dependency forget option every environment need optional dependency must set optional true always good document explain supposed included application key application function add application required runtime production said done go well say start home review mixexs anything important missing unused dependency start taking closer look external dependency mixfiles runtime dependency properly required environment take time contribute give back tiny bit might seem worthless first rest assured clever man used say success detail elixirphoenix may also
367,Lobsters,elixir,Elixir programming,Implementing Video Chat in a Phoenix Application with WebRTC,https://hashrocket.com/blog/posts/implementing-video-chat-in-a-phoenix-application-with-webrtc,implementing video chat phoenix application webrtc,http http wwwphoenixframeworkorgdocsinstallation http githubcomchadbradingphoenixwebrtc,chad brading september blog post going cover implement video chat phoenix application webrtc end post enabled two remote client connect engage video conversation use phoenix channel communicate message two client establish remote peer connection webrtc allows client establish direct peer peer connection establish connection need communicate certain information phoenix channel facilitate indepth explanation webrtc work visit http begin let create new app note using phoenix version install instruction visit http wwwphoenixframeworkorgdocsinstallation mix phoenixnew videochat let first create basic call controller handle request webcontrollerscallcontrollerex defmodule videochatcallcontroller use videochatweb controller def index conn params render conn indexhtml end end need create corresponding call view render template webviewscallviewex defmodule videochatcallview use videochatweb view end template include two video element one local stream another remote stream also need button invoke action webtemplatescallindexhtmleex div video id localvideo autoplay video video id remotevideo autoplay video button id connect connect button button id call call button button id hangup hangup button div next need update router redirect call controller change root path pagecontroller callcontroller webrouterex get callcontroller index run mix phoenixserver navigate make sure template rendering correctly place ready set channel create call channel function allow client join channel well function handle incoming event webchannelscallchannelex defmodule videochatcallchannel use phoenixchannel def join call authmsg socket ok socket end def handlein message body body socket broadcast socket message body body noreply socket end end next need define call channel socket handler add following line webchannelsusersocketex webchannelsusersocketex channel call videochatcallchannel ready implement javascript code enable client establish connection first add following line application template enable webrtc method work across different browser chrome firefox opera currently support webrtc webtemplateslayoutapphtmleex script src script example put javascript code appjs let first import socket establish connection call channel webstaticjsappjs import socket socket let channel socketchannel call channeljoin receive ok consolelog successfully joined call channel receive error consolelog unable join note socket imported webstaticjssocketjs take look file see socket created connected also comment delete code attempting join new channel since implemented wire button webstaticjsappjs let localstream peerconnection let localvideo documentgetelementbyid localvideo let remotevideo documentgetelementbyid remotevideo let connectbutton documentgetelementbyid connect let callbutton documentgetelementbyid call let hangupbutton documentgetelementbyid hangup hangupbuttondisabled true callbuttondisabled true connectbuttononclick connect callbuttononclick call hangupbuttononclick hangup begin define client establish connection webstaticjsappjs function connect consolelog requesting local stream navigatorgetusermedia audio true video true gotstream error consolelog getusermedia error error using getusermedia function capture local video stream call callback function gotstream webstaticjsappjs function gotstream stream consolelog received local stream localvideosrc urlcreateobjecturl stream localstream stream setuppeerconnection gotstream setting local stream calling setuppeerconnection webstaticjsappjs function setuppeerconnection connectbuttondisabled true callbuttondisabled false hangupbuttondisabled false consolelog waiting call let server iceservers url stun stunexampleorg peerconnection new rtcpeerconnection server consolelog created local peer connection peerconnectiononicecandidate gotlocalicecandidate peerconnectiononaddstream gotremotestream peerconnectionaddstream localstream consolelog added localstream localpeerconnection setuppeerconnection creates new rtcpeerconnection set callback certain event occur connection ice candidate detected stream added add local video stream peer connection next add call function send message client connected channel local peer connection webstaticjsappjs function call callbuttondisabled true consolelog starting call peerconnectioncreateoffer gotlocaldescription handleerror passing createoffer function following gotlocaldescription callback webstaticjsappjs function gotlocaldescription description peerconnectionsetlocaldescription description channelpush message body jsonstringify sdp peerconnectionlocaldescription handleerror consolelog offer localpeerconnection n descriptionsdp createoffer function created description local peer connection sent description potential client client receives description call following gotremotedescription function webstaticjsappjs function gotremotedescription description consolelog answer remotepeerconnection n descriptionsdp peerconnectionsetremotedescription new rtcsessiondescription descriptionsdp peerconnectioncreateanswer gotlocaldescription handleerror set remote description local peer connection connect remote client reply answer containing description remote client connect back well description sent back forth client also contain stream added peer connection client receives remote stream call following function webstaticjsappjs function gotremotestream event remotevideosrc urlcreateobjecturl eventstream consolelog received remote stream setting remote stream receive video element template also create local description also creating local ice candidate call following function webstaticjsappjs function gotlocalicecandidate event eventcandidate consolelog local ice candidate n eventcandidatecandidate channelpush message body jsonstringify candidate eventcandidate sends information local ice candidate channel potential client client receives description ice candidate call following function webstaticjsappjs function gotremoteicecandidate event callbuttondisabled true eventcandidate peerconnectionaddicecandidate new rtcicecandidate eventcandidate consolelog remote ice candidate n eventcandidatecandidate function add information remote candidate local peer connection channel receives message server need know process message message receives description remote peer connection need call gotremotedescription function description remote ice candidate need call gotremoteicecandidate function implement channel event handler account two scenario webstaticjsappjs channelon message payload let message jsonparse payloadbody messagesdp gotremotedescription message else gotremoteicecandidate message let also include hangup function user close connection stop video chat session webstaticjsappjs function hangup consolelog ending call peerconnectionclose localvideosrc null peerconnection null hangupbuttondisabled true connectbuttondisabled false callbuttondisabled true finally add handleerror function webstaticjsappjs function handleerror error consolelog errorname errormessage navigate back browser open two tab click connect button tab see one created local peer connection added local video stream click call button one tab send description local peer connection peer connection exchange necessary information establish remote connection see video chat session view sample repository http githubcomchadbradingphoenixwebrtc post helpful share others
368,Lobsters,elixir,Elixir programming,Elixir v1.3 released,http://elixir-lang.org/blog/2016/06/21/elixir-v1-3-0-released/,elixir released,andrea leopardi gettext redix language improvement deprecation imperative assignment calendar type sigils access selector mix compiling n file mix xref pragtob written article exploring new compiler found bug existing project better dependency tracking mix apptree depstree plug graphviz phoenix web framework mix escriptinstall environment variable option parser integration exunit mix test stale diffing test type named setup describes summing release note install section getting started guide,elixir brings many improvement language compiler tooling specially mix elixir build tool exunit elixir test framework notable addition new calendar type new crossreference checker mix assertion diffing exunit explore couple enhancement release also welcome andrea leopardi elixir core team contributed greatly release maintains important package community like gettext redix language improvement language improved semantically includes new type apis let see three major feature deprecation imperative assignment elixir warn construct like case friend assign variable accessed outer scope example imagine function called format receives message option must return path alongside message def format message opts path file opts file line opts line relative pathrelativetocwd file message exceptionformatfileline relative line message relative end path message end block implicitly changing value message imagine want move block function clean implementation def format message opts path withfileandline message opts path message end defp withfileandline message opts file opts file line opts line relative pathrelativetocwd file message exceptionformatfileline relative line message relative end end refactored version broken block actually returning two value relative path new message elixir warn case forcing variable explicitly returned case construct furthermore change give u opportunity unify language scoping rule future release calendar type sigils elixir introduces calendar module well new calendar type date used store date year month day given calendar time used store time hour minute second microsecond naivedatetime used store datetimes without timezone year month day hour minute second microsecond given calendar called naïve without timezone datetime may actually exist example daylight saving change whole hour may exist clock move forward particular instant may happen twice clock move backwards datetime used store datetimes timezone year month day hour minute second microsecond time zone abbreviation utc standard offset aim current implementation calendar module type provide base interoperatibility ecosystem instead fullfeatured datetime api release includes basic functionality building new type converting back string elixir also introduces new sigils related type build new date build new time different precision n build naive date time access selector release introduces new accessors make simpler developer traverse nested data structure traversing updating data different way instance given user list language deeply traverse map convert language name uppercase iex user name john language name elixir type functional name c type procedural iex updatein user language accessall name name john language name elixir type functional name c type procedural see new accessors access module mix mix includes new task improve everyday workflow task relies many compiler improvement know code providing static analysis find possible bug code faster compilation cycle compiling n file mix longer announces every file compiles instead output many file compile per compiler output project like gettext compiling file yrl compiling file erl compiling file ex generated gettext app case file taking long compile mix announce example compiling libgettextex taking goal change put increased focus warning emitted compiler case previous behaviour brought back verbose flag compilation threshold file taking long set via longcompilationthreshold option mix xref speaking warning mix includes new task called xref performs cross reference check code one check ability find call module function exist example library code call thismoduledoesnotexistfoo mix xref unreachable able find code let know since check discover possible bug codebase new compiler called xref added run default every time compile code pragtob written article exploring new compiler found bug existing project included mode xref find documentation mode running mix help xref hope tool text editor leverage feature provide useful functionality user helping developer understand code complexity finding bug early better dependency tracking besides xref elixir provides better module tracking generally example previous version changed path dependency elixir would always fully recompile current project release improved tracking algorithm change path dependency file depend dependency recompiled improvement make compilation faster also make working umbrella application much productive previously changing sibling application triggered full project recompilation elixir track sibling application recompile needed mix apptree depstree mix also includes mix apptree mix depstree first list application current project need start order boot ie one listed mixexs second list dependency recursively quick example plug mix apptree plug elixir crypto logger elixir mime elixir format dot option also given generate graph file opened graphviz example output running mix depstree format dot prod phoenix web framework mix escriptinstall mix also includes mix escriptinstall mix escriptuninstall task managing escripts task designed way mimic existing mix archive functionality except archive must used sparingly every new archive installed affect mix performance every new archive loaded mix boot escripts solve managed apart elixirmix installed archive depends current elixir version therefore updating elixir version may break archive fortunately escripts include elixir inside therefore depend elixir system version escripts installed mixescripts must added path environment variable option parser integration elixir includes improvement option parser including optionparserparse optionparserparsehead function raise case invalid unknown switch mix build top functionality provide automatic error reporting solving common complaint invalid option reported mix task example invoking mix test unknown earlier elixir version would silently discard unknown option mix test correctly report error mix test unknown mix could invoke task test error found unknown unknown option note task updated use strict option parsing task like mix compile actually frontend many task effectively assert option valid exunit exunit pack many improvement tooling side better integration external tool well mechanism improve readability test mix test stale exunit build top mix xref provide mix test stale functionality stale flag given mix run test may changed since last time ran mix test stale example saved test file disk mix run file ignore one changed changed library file example libfooex defines foo test invokes function foo directly indirectly also run modify mixexs testtesthelperexs mix run whole test suite feature provides great workflow developer allowing effortlessly focus part codebase developing new feature diffing exunit include diffing output every time developer asserts assert left right test example assertion assert fox jump lazy dog brown fox jump dog fail lazy lh shown red denote removed rh brown rh shown green denote added rh working large nested data structure diffing algorithm make fast convenient spot actual difference asserted value test type exunit includes ability register different test type mean library like quickcheck provide functionality defmodule stringtest use exunitcase async true use propertytestinglibrary property startswith forall stringstartswith end end end end run exunit also report property including amount test property property test failure named setup describes finally exunit includes ability organize test together describe block defmodule stringtest use exunitcase async true describe test uppercase first grapheme assert stringcapitalize test end test lowercase remaining grapheme assert test stringcapitalize test end end end every test inside describe block tagged describe block name allows developer run test belong particular block file across many file mix test describe note describe block nested instead relying hierarchy composition want developer build top named setup example defmodule usermanagementtest use exunitcase async true describe user logged admin setup loguserin settypetoadmin test end describe user logged manager setup loguserin settypetomanager test end defp loguserin context end end restricting hierarchy favor named setup straightforward developer glance describe block know exactly setup step involved summing full list change available release note forget check install section get elixir installed getting started guide learn happy coding
369,Lobsters,elixir,Elixir programming,Tail Call Optimization in Elixir & Erlang – not as efficient and important as you probably think,https://pragtob.wordpress.com/2016/06/16/tail-call-optimization-in-elixir-erlang-not-as-efficient-and-important-as-you-probably-think/,tail call optimization elixir erlang efficient important probably think,bodyrecursive function faster memory efficient especially optimized tailrecursive counter part dave thomas programming elixir writing map implementation easiest readable care accumulator reversing list benchee little verbose equivalent script bencheecsv tailrecursive version slower result million item list josé valim chimed argument order adding following apparently common misconception myth tailrecursive function much faster recursive function list fred hebert remark body recursion may simpler also faster save memory time blog post topic explode clojure koan seems impossible memory consumption tailrecursive version take almost gigabyte memory bodyrecursive version take bit gigabyte gist bodyrecursive function time clojure kaon exercise take megabyte tailrecursive version almost gigabyte bodyrecursive version become faster standard library version bodyrecursive function case bodyrecursive function faster efficient tailrecursive function robert virding creator erlang rightfully highlight assume always proof erlang performance myth section measure puella notifying bodyrecursive function significantly slower tco version seems erlang mapbody version significantly slower elixir mapbody fastfaster thread full post course worth read rightful nitpick paweł pointing version comment benchmarked different variant multiple time new benchmarking script gist sasa juric showing get bytecode elixir function significantly faster bodyrecursive version even stdlib version like,automatic tail call optimization tco great feature elixir erlang everyone tell super fast super cool definitely always aim make every recursive function tailrecursive told bodyrecursive function faster memory efficient especially optimized tailrecursive counter part seems unlikely every beginner book mention tco tell efficient definitely use plus maybe tried bodyrecusion language x call stack blew horrendously slow thought tailrecursive function always better bodyrecursive one day accident wrote none tailrecursive function tco apply someone told eagerly replaced tailrecursive counterpart stopped second benchmarked result surprising say least deep dive topic let take refresher tail call optimization dave thomas programming elixir great book end calling many language add new frame stack large number message might run memory happen elixir implement tailcall optimization last thing function call need make call instead runtime simply jump back start function recursive call argument replace original parameter well let get writing map implementation let write implementation map function one bodyrecursive one tailrecursive add another tailrecursive implementation using reverse one reverse list end one reverse list course functionally equivalent others element order wrote function care ordering might update also added version argument order different see result defmodule mymap def maptco list function enumreverse maptco list function end defp maptco acc head tail function maptco function head acc tail function end defp maptco acc function acc end def maptcoargorder list function enumreverse domaptcoargorder list function end defp domaptcoargorder function acc acc end defp domaptcoargorder head tail function acc domaptcoargorder tail function function head acc end def maptcoconcat acc list function def maptcoconcat acc head tail function maptcoconcat acc function head tail function end def maptcoconcat acc function acc end def mapbody func def mapbody head tail func func head mapbody tail func end def maptconoreverse list function maptco list function end end mapbody function originally wrote tailrecursive last operation method list append operation call mapbody comparing implementation also argue easiest readable care accumulator reversing list code let u benchmark function benchee benchmark run elixir erlang linux mint let map large list add one element list also throw standard library implementation map comparison baseline list enumtolist mapfun fn end bencheerun map tailrecursive fn mymapmaptcoconcat list mapfun end map tco reverse fn mymapmaptco list mapfun end stdlib map fn enummap list mapfun end map simple without tco fn mymapmapbody list mapfun end map tco new arg order fn mymapmaptcoargorder list mapfun end map tco reverse fn mymapmaptconoreverse list mapfun end time warmup tobi happy githubelixirplayground mix run benchtcoblogpostdetailedexs benchmarking map tailrecursive benchmarking map tco benchmarking stdlib benchmarking map tco new arg benchmarking map simple without benchmarking map tco name ip average deviation median map simple without tco stdlib map map tco new arg order map tco reverse map tco reverse map tailrecursive comparison map simple without tco stdlib map slower map tco new arg order slower map tco reverse slower map tco reverse slower map tailrecursive slower benchmarking actually done little verbose equivalent script generates csv ouput console output run using benchee slightly verbose interface feature make possible nicer interface planned visual also graph showcasing result visualized using bencheecsv graphing iteration per second higher better see bodyrecursive function seems fast version standard library reported value faster well within margin error plus median two standard deviation higher standard library version hint possibility worse average may outlier resulting fex garbage collection tailrecursive version slow appending frequently bad idea need go end linked list every time around n main point main point tailrecursive version slower even tailrecursive version reverse list slower bodyrecursive implementation seems like good point interject mention brought comment see significantly larger list tailrecursive implementation get faster check result million item list highly irritating surprising tailrecursive function slightly different argument order significantly faster original implementation almost one consistently faster across number run see implementation thankfully josé valim chimed argument order adding following order argument likely matter generate branching code order argument specially matter performing binary matching order function clause matter although sure measurable empty clause come first last maybe better tailrecursive version please tell result rather staggering repeatable consistent happened apparently common misconception tailrecursive function always faster seems common misconception common enough made list erlang performance myth myth tailrecursive function much faster recursive function note section currently reworked name might changelink might lead directly nearish future quote bodyrecursive list function tailrecursive function call list end use amount memory list list list comprehension many recursive function use amount space tailrecursive equivalent faster depends solarissparc bodyrecursive function seems slightly faster even list lot element architecture tailrecursion faster topic also recently came erlangquestions mailing list talking rework aforementioned erlang performance myth site really worth read fred hebert remark emphasis added case function build new list accumulator whose size equivalent number iteration hence stack nearly data structure say list body recursion may simpler also faster save memory time also blog post topic explode question experience clojure koan expected bodyrecursive function blow call stack given large enough input manage matter tried seems impossible beam vm erlang elixir run differs implementation vms body recursion limited ram erlang recursion limit tail call optimised recursive call tail call limited available ram memory consumption memory consumption let create list one hundred million element map measuring memory consumption done tailrecursive version take almost gigabyte memory bodyrecursive version take bit gigabyte detail found gist well likely large list tail recursive version need create new reversed version accumulator return correct result bodyrecursive function time let recap bodyrecursive version map faster consumes le memory easier read maintain every time well example course let take look dumb function deciding whether number even implemented homage clojure kaon exercise showed call stack blow clojure without recur defmodule number def iseven true def iseven n iseven n end def iseventco n acc true def iseventco acc acc def iseventco n acc iseventco n acc end end number bencheerun iseven fn numberiseven number end iseventco fn numberiseventco number end tobi happy githubelixirplayground mix run benchisevenexs benchmarking iseven benchmarking iseventco name ip average deviation median iseven iseventco comparison iseven iseventco slower tailrecursive version still slower memory running function one hundred million input take megabyte tailrecursive version mind whole elixir process almost gigabyte bodyrecursive version also huge input tailrecursive version took second bodyrecursive function took second larger input faster stark contrast likely time around huge list carried around accumulated boolean number effect bodyrecursive function need save call stack ram much damaging effect need call one hundred million time rerunning map implementation significantly larger list tailrecursive version also become faster standard library version bodyrecursive function see tailrecursive function still faster efficient many use case believe year taught tail call optimization lead fastest recursive function post say tco bad slow say highlight case bodyrecursive function faster efficient tailrecursive function also still unsure tailrecursive function reverse list still slower bodyrecursive version might carry accumulator around maybe also take step back education teaching careful overemphasize tail call optimization tailrecursive function bodyrecursive function viable even superior alternative presented course case writing tailrecursive function absolutely vital robert virding creator erlang rightfully highlight main case tco critical process toploops function never return unless process dy build stack never release get right alternative applies toploop actually composed set mutually calling function alternative sorry pushing critical teach u end take assumption stemming programming environment granted also assume always proof let finish closing word erlang performance myth section choice mostly matter taste really need utmost speed must measure longer sure tailrecursive list function always fastest previously bug iseventco missing caught test calling wrong function thanks puella notifying see next editupdate pointed lobster running erlang session bodyrecursive function significantly slower tco version running believe equivalent code elixir erlang seems erlang mapbody version significantly slower elixir time look need run erlang benchmarking tool confirm though small try mentioned first addendum run shell great idea using little erlang knowledge made something compiled benchmark mapbody fastfaster thread benchmarking fickle wrong done right would still look forward run proper erlang benchmarking tool use benchee erlang time right added comment robert virding regarding process top loop critical tco thanks reading honoured surprised one creator erlang read full post course worth read following rightful nitpick write tail call optimized function rather tailrecursive tail call optimization feature compiler directly attribute function included another version benchmark swap argument order list stay first argument accumulator last argument surprisingly yet version constantly faster tailrecursive implementation still slower body recursive want thank paweł pointing version comment reversed argument order distinguishing factor could make version assignment new accumulator benchmarked different variant multiple time consistently faster although could never reproduce fastest memory consumption example seemed consume le original tailrecursive function bit faster also since reran either way ran freshly released elixir erlang also increased runtime benchmark well warmup get consistent result overall wrote new benchmarking script result shown graph console output added little tco intro might helpful case interested bytecode look like done area expertise yet gist sasa juric showing get bytecode elixir function added josé comment argument order thanks reading commenting added cpu o information pointed comment performance characteristic might differ larger list taking time many element tailrecursive version significantly faster bodyrecursive version even stdlib version updated reflect newer benchee api old api list tuples work anymore like like loading related
370,Lobsters,elixir,Elixir programming,A Language for the Next 10 Years,http://programmingzen.com/2016/06/14/next-programming-language/,language next year,valuable effort kotlin julia rust ask team whatsapp phoenix give try get stuff like,early started career ibm ruby guy alternatively rail guy meeting highprofile engineer presented ruby brought table ibm distinguished engineer stopped track said sound slow love ruby much programmer possibly love programming language engineer conjecture right money ruby emphasis always programmer efficiency execution efficiency generally speaking ruby program significantly slower equivalent program c java lot work done improve ruby performance good degree success terrific enough today world many way yes going employ ruby calculate trillion digit pi use power backend messaging app million user however ruby suit script fine would argue rail still give best bang buck term web framework come large subset crudbased web application ruby lovely many us however ruby language define next ten year beautifully designed simply ideal language tackle challenge increasingly distributed world throw u concurrency name game ruby part limited ability cope despite valuable effort concurrency ruby much better battletested tool fellow ruby developer would like remain relevant next decade highly suggest start looking something new pair ruby main language though fair warning might end replacing ruby main language next ten year highly dependent development context course develop io apps swift language android apps kotlin looking good might shot data science julia sort performance issue could get edge python r system programming rust go worth close look enough generalist dabble many programming domain web developer main language next decade excel distributed environment n machine make request large value n eg iot alone enables scenario come ruby people might argue nodejs personally though afraid ruby spoiled find ruby joy use javascript much looking highlevel language handle concurrency like champ elegant highly readable syntax provides great user experience developer functional short fun functional find functional programming immutable data type significantly better approach thinking problem modeling solution object oriented programming blame past dabbling haskell clojure speaking clojure jvm scala w akka clojure w stm pulsar valid option two clojure one come closer great fit close unfortunately somewhat aesthete coming ruby lisp syntax still feel like downgrade jvm great come dependable concurrency really beat erlang vm ie beam offer ask team whatsapp problem erlang prologlike syntax feel obsolete never seen erlang program said wow joy read refactor worst personally find fairly uninspiring language work thankfully erlang language highly faulttolerant concurrent vm indeed language worth getting excited language elixir elixir fit requirement feel like joy read use like many rubyists first found elixir thought ruby erlang vm due largely familiar syntax turn much fact much erlang well hastily summarize get highly readable elegant concurrent functional programming language fantastic erlang vm ie beam otp integration shared nothing actorbased concurrency metaprogramming via macro polymorphism via protocol whole host nice feature pipeline operator pattern matching docstrings stream mix etc excellent web framework called phoenix fast growing supportive community reminiscent ruby early day rail ruby usage skyrocketed past decade would argue elixir though widely adopted yet well equipped coming ten year give try let know like get stuff like subscribe mailing list receive similar update programming thank subscribing please check email confirm subscription something went wrong related
371,Lobsters,elixir,Elixir programming,Getting started with OpenGL in Elixir,https://wtfleming.github.io/2016/01/06/getting-started-opengl-elixir/,getting started opengl elixir,,defmodule elixiropengl behaviour wxobject use bitwise title elixir opengl size api def startlink wxobjectstartlink module end wxobject behavior callback def init config wx wxnew config frame wxframenew wx wxconstwxidany title size size wxwindowconnect frame closewindow wxframeshow frame opts size size glattrib attriblist wxconstwxglrgba wxconstwxgldoublebuffer wxconstwxglminred wxconstwxglmingreen wxconstwxglminblue wxconstwxgldepthsize canvas wxglcanvasnew frame opts glattrib wxglcanvasconnect canvas size wxwindowreparent canvas frame wxglcanvassetcurrent canvas setupgl canvas periodically send message trigger redraw scene timer timersendinterval self update frame canvas canvas timer timer end def codechange state stop notimplemented state end def handlecast msg state ioputs cast ioinspect msg noreply state end def handlecall msg state ioputs call ioinspect msg reply ok state end def handleinfo stop state timercancel statetimer wxglcanvasdestroy statecanvas stop normal state end def handleinfo update state wxbatch fn render state end noreply state end example input wx wxref wxframe wxclose closewindow def handleevent wx wxclose closewindow state stop normal state end def handleevent wx wxsize size width height state width height resizeglscene width height end noreply state end def terminate reason state wxglcanvasdestroy statecanvas timercancel statetimer timersleep end private function defp setupgl win w h wxwindowgetclientsize win resizeglscene w h glshademodel glconstglsmooth glclearcolor glcleardepth glenable glconstgldepthtest gldepthfunc glconstgllequal glhint glconstglperspectivecorrectionhint glconstglnicest ok end defp resizeglscene width height glviewport width height glmatrixmode glconstglprojection glloadidentity gluperspective width height glmatrixmode glconstglmodelview glloadidentity ok end defp draw glclear bitwisebor glconstglcolorbufferbit glconstgldepthbufferbit glloadidentity gltranslatef gl begin glconstgltriangles gl end ok end defp render canvas canvas state draw wxglcanvasswapbuffers canvas ok end end
372,Lobsters,elixir,Elixir programming,Introducing Benchee: simple and extensible benchmarking for Elixir,https://pragtob.wordpress.com/2016/06/07/introducing-benchee-simple-and-extensible-benchmarking-for-elixir/,introducing benchee simple extensible benchmarking elixir,really love micro benchmarking first time benchee hex great benchee average run time iteration per second standard deviation median designing benchmarking library benchmarkips functional programming series transformation easy let see result flatmap two time fast scenario benchfella bencheecsv get online documentation github repository anything else idea future benchee like,look around blog becomes pretty clear really love micro benchmarking naturally working elixir loving wanted benchmark something sadly existing option found quite satisfy different focus missing statistic lacking documentation thing decided roll like first time course tried extending existing solution long function scarce test coverage lot dead outcommented code rotting pr later decided time create something new without ado please meet benchee course available hex great benchee benchee easy use well documented extended following paragraph benchee run benchmarking function give given amount time compute statistic statistic shine opinion benchee provides average run time ok yawn iteration per second great graph etc higher better opposed average run time standard deviation important value opinion give feeling certain measurement much vary sadly none elixir benchmarking tool looked supplied value median basically middle value distribution often cited value reflects common outcome better average cut outlier never used micro benchmarking tool provided value often asked provide benchmark also give rather nice output console header know example let talk designing benchmarking library design influenced favourite ruby benchmarking library benchmarkips course wanted elixirish spin offer option lot elixir solution used macro wanted something work purely function trick started learn functional programming one thing stuck functional programming series transformation transformation look like benchmarking create basic benchmarking configuration thing like long benchmark run gc enabled etc run individual benchmark record raw execution time compute statistic based raw run time per benchmark format statistic suitable output put formatted statistic console file whatever exactly api benchee look like list enumtolist mapfun fn end bencheeinit time bencheebenchmark flatmap fn enumflatmap list mapfun end bencheebenchmark mapflatten fn list enummap mapfun listflatten end bencheestatistics bencheeformattersconsoleformat ioputs great well super flexible flow nicely beloved elixir pipe operator flexible extensible well like benchee run benchmark sub benchmarking function want moredifferent statistic go use function compute want result displayed different format roll formatter want write result file well go ahead cosmetic easy write plugin convert result json format post web service gather benchmarking result let generate fancy graph course everybody need flexibility people might scared away verboseness also higher level interface us option see condenses one function call efficiently define benchmark list enumtolist mapfun fn end bencheerun time flatmap fn enumflatmap list mapfun end mapflatten fn list enummap mapfun listflatten end let see result seen two different way run benchmark benchee result look like well go tobi happy githubbenchee mix run samplesrunexs benchmarking flatmap benchmarking mapflatten name ip average deviation median mapflatten flatmap comparison mapflatten flatmap slower know much surprise calling map first flattening result significantly faster one pas flatmap unlike ruby flatmap two time fast scenario tell u well think performance programming language might hold true also might bug flatmap faster know need time investigate aside graph nice feature envy benchfella wait got whole extensible architecture right generating whole graph error margin etc might bit tough though got libreoffice machine way quickly feed result would great meet bencheecsv first far benchee plugin substitute formatting output step generate csv file consumed spreadsheet tool choice file fileopen testcsv write list enumtolist mapfun fn end bencheeinit bencheebenchmark flatmap fn enumflatmap list mapfun end bencheebenchmark mapflatten fn list enummap mapfun listflatten end bencheestatistics bencheeformatterscsvformat enumeach fn row iowrite file row end couple click later graph including error margin get well add benchee bencheecsv deps mixexs def deps benchee dev end run mix depsget create benchmarking folder create new mybenchmarkexs information found online documentation github repository anything else well benchee try help try micro benchmark extremely fast function might happen upon beauty warning warning function trying benchmark super fast making time measure unreliable benchee measure individual run rather run couple time report average back measure still correct overhead running n time go measurement also statistical result good based average possible increase input size individual run take reason put pretty well explained measurement would simply unreliable randomness measuring huge impact plus measurement micro second accurate either tried nano second quickly discarded seemed add even overhead benchee try run benchmark n time measure improves situation somewhat add overhead repeatn function benchmark please benchmark higher value idea future benchee version lot work feature thought already gone feature thought decided necessary first release turning offreducing garbage collection especially micro benchmarking affected garbage collection single run much slower others leading sky rocketing standard deviation unreliable measure sadly best knowledge one turn gc beam people shown option could set high memory space reduce chance gc need play auto scaling unit nice instance show average time millisecond benchmark slower write something effect million iteration per second console output fast benchmark better alignment console output right left aligned think right alignment look better help compare result making sure benchee also usable macro benchmark eg function run matter second even minute correlating also provide option specify warmup time elixirerlang jited impact macro benchmark phoenix database impact give measuring memory consumption shot statistic anything missing wishing graph generation plugin generate share graph right away would nice configurable step bencheerun right want use plugin use verbose api benchee benchee gain traction plugins really become thing nice configure high level api like formatter myformatmodule formatter anything like see benchee please get touch let know case give benchee try happy benchmarking like like loading related
373,Lobsters,elixir,Elixir programming,Handling TCP connections in Elixir,http://andrealeopardi.com/posts/handling-tcp-connections-in-elixir/,handling tcp connection elixir,semirealistic example redis brief overview tcp connection erlangelixir first implementation establishing connection sending message resp protocol specification protocol went wrong queuing win specific client block right message demand plot twist eredis comment postgrex mongodb orientdb better handling tcp connection fishcakez connection mongodb driver handling connection connection doc connecting startup backoff pooling poolboy conclusion connection poolboy,elixir frequently used networkaware application core design erlang erlang vm context often need connect external service network example classic web application could connect relational database keyvalue store application run embedded system could connect node network many time connection network service transparent programmer thanks external library eg database driver think interesting know handle connection hand turn useful external library particular service also want understand library work article talk tcp connection since tcp probably common protocol used network application principle describe however similar type connection example connection use udp protocol semirealistic example sake article build almost working driver redis keyvalue store redis server tcp server sends receives message redis us protocol top tcp exchange data without relying common protocol http focus deal tcp connection elixir redis server little side note obviously several erlang elixir library talking redis bear since point coming clever name library going write call redis let get started brief overview tcp connection erlangelixir erlang elixir tcp connection handled using gentcp module article set client connect external tcp server gentcp module also used set tcp server message server sent using message sent server client usually delivered client process erlang message straightforward work see later control message delivered client process value active option tcp socket establish connection tcp server use passing host charlist damn erlang port list option default process call controlling process tcp connection mean tcp message socket delivered need know tcp connection let move first implementation use genserver interface tcp connection need genserver able keep tcp socket genserver state reuse socket commication establishing connection since genserver interface tcp server hold single tcp socket state want always connected tcp server best strategy establishing connection genserver started callback called used start process genserver start work return perfect place u defmodule redis use genserver initialstate socket nil def startlink genserverstartlink module initialstate end def init state opts binary active false ok socket gentcpconnect localhost opts ok state socket socket end end option pas straightforward binary instructs socket deliver message tcp server genserver binary instead erlang string charlists elixir probably want probably efficient choice well active false tell socket never deliver tcp message erlang message genserver process manually retrieve message using genserver flooded message coming tcp server retrieve message ready process sending message genserver connected redis server let send command redis server resp protocol point mention redis binary protocol resp protocol redis us encode decode command response specification protocol short simple understand encourage go read want know purpose article assume full resp encoderdecoder redisresp provides two function encodes list redis command like redisrespencode get mykey decodes binary elixir term like resptogetcommand redisrespdecode resptogetcommand mentioned beginning article use send message tcp socket redis module provide single function send command redis server implementation straightforward defmodule redis def command pid cmd genservercall pid command cmd end def handlecall command cmd socket socket state ok gentcpsend socket redisrespencode cmd mean receive available byte socket ok msg gentcprecv socket reply redisrespdecode msg state end end work ok pid redisstartlink rediscommand pid set mykey rediscommand pid get mykey big problem went wrong long story short blocking code wrote would work fine genserver would used one elixir process happens elixir process want send command redis server elixir process call genserver block waiting response genserver sends command redis server block redis server responds genserver genserver responds elixir process spot problem genserver blocked wait redis server respond fine single elixir process talk genserver instantly becomes terrible process want communicate redis server genserver luckily implement much better solution queuing win probably know callback genserver return result client right away return noreply state tuple reply client using exacly need way client call function genserver block waiting response time way genserver keep work response specific client order continue strategy however need ditch favour receiving tcp message erlang message using active true instead active false connecting redis server active true message tcp socket delivered erlang message form tcp socket message happen elixir process call genserver block waiting response genserver sends command redis server return noreply state block redis server responds genserver receives tcp socket message message genserver handle message callback responding appropriate client see main difference moment genserver sends command redis server moment receives response genserver blocked send command server great last thing need deal genserver supposed respond right request receives tcp message know send back since sure redis responds request sequentially first first use simple queue keep list elixir process waiting response keep queue genserver state enqueueing client make request dequeueing response delivered defmodule redis initialstate socket nil queue queuenew def handlecall command cmd queue queue state send command ok gentcpsend statesocket redisrespencode cmd enqueue client state state queue queuein queue nt reply right away noreply state end def handleinfo tcp socket msg socket socket state dequeue next client value client newqueue queueout statequeue finally reply right client genserverreply client redisrespdecode msg noreply state queue newqueue end end message demand section moved active false socket active true socket order receive tcp data erlang message work fine lead problem tcp server sends genserver lot data since erlang limit message queue process genserver easily flooded message chose use active false reason first place avoid change active true conservative active way one tcp message delivered erlang message socket go back active false set active receive next message process tcp data erlang message one time sure able process remember reactivate socket receive tcp message callback using defmodule redis def handleinfo tcp socket msg socket socket state allow socket send u next message inetsetopts socket active exactly end end plot twist think pattern wrote shocker right pattern described common shared number erlang elixir application pattern applies nicely connection tcp server anything similar matter often used driver database went redis example lot realworld library use pattern talked example eredis one used redis driver erlang built similarly example look comment eredis source basically summary article article expanded version comment know example library roughly follow pattern elixir driver postgresql postgrex mongodb mongodb currently working elixir driver orientdb still public us pattern well must work right better handling tcp connection happily ignored annoying thing deal throughout article error handling keep happily ignoring subset error happen eg empty client queue fails value val newqueue pattern match incomplete message tcp socket however common set error happen dealing tcp connection well tcp error like dropped connection timeouts could try handle kind error luckily u elixir core team member james fish aka fishcakez work awesome library connection library quite young time writing already used mongodb driver mentioned orientdb driver working handling connection connection connection library defines connection behaviour api specified behaviour superset genserver api easy understand integrate existing project doc explain connection great detail gist help implement process peer connects deal peer possibly unavailable connection behaviour defines two additional function genserver one revise return value genserver callback look functionality provided connection make sure read doc want know connecting startup callback implementation performs connection redis server blocking process called return may fine want genserver able anything connected redis server however may called supervisor process specifically designed start genserver case like return ok pid soon possible handling process establishing tcp connection background also like genserver queue message connected redis server behaviour would enable u start genserver without blocking process called blocking subsequent request genserver connected redis connection exactly returning connect info state callback instead ok state make return ok pid instantly also call callback genserver stop genserver processing incoming message connection complete info element connect info state tuple contain information needed connect peer want keep genserver state let change code take advantage defmodule redis use connection initialstate socket nil def startlink need connectionstartlink module initialstate end def init state use nil nt need additional info connect connect nil state end def connect info state opts binary active ok socket gentcpconnect localhost opts ok state socket socket end end big improvement connection allows u make library even better backoff line connect redis server using raise loud alarm bell head ok socket responsible case connection fails reason pattern match fail instead handling error whole genserver blow obvious thing handle result case statement case gentcpconnect localhost opts ok socket ok state socket socket error reason end decide want case error blowing genserver returning error client trivial code would probably want try reconnect tcp server connection rescue make return backoff timeout state tuple called timeout attempt reconnect peer would look like def connect info state opts binary active case gentcpconnect localhost opts ok socket ok state socket socket error reason ioputs tcp connection error inspect reason try one second backoff state end end great thing connection return backoff timeout state almost every callback function handling connection failure become straightforward backoff timeout state returned called backoff first argument let u easily detect reconnections instead first connection deal appropriately example may want implement exponential backoff ie retry one second two second four second possibly maximum number retries pooling one last tip genserver built used smoothly pooling library like famous poolboy plenty literature poolboy around web going describe work show small example first create pool given number genservers using poolboyopts workermodule redis size redisopts ok pool poolboystartlink poolboyopts redisopts checkout worker process redis genservers pool perform operation redis check back pool worker poolboycheckout pool rediscommand worker set mykey ok poolboycheckin pool worker nothing smoother conclusion saw implement genserver work interface tcp server built nonblocking genserver queue client order send multiple command tcp server waiting response server used connection library deal tcp error eg server temporarely unavailable implementing backoff strategy finally briefly looked poolboy used make pool genservers thanks reading
374,Lobsters,elixir,Elixir programming,Elixir School - Lessons about the Elixir programming language,https://elixirschool.com/,elixir school lesson elixir programming language,click redirected,click redirected
375,Lobsters,elixir,Elixir programming,Elixir 1.3’s mix xref working its magic in a real world example,https://pragtob.wordpress.com/2016/06/02/elixir-1-3s-mix-xref-working-its-magic-in-a-real-world-example/,elixir mix xref working magic real world example,release candidate coming elixir mix xref mix xref timexecto opened pr improving test coverage failing test case bug mix xref might biggest impact elixir eco system like,upcoming elixir available release candidate brings along many cool new feature calendar type finally test group exunit favorite new feature discussed lot though also missing coming elixir blog post like show mix xref mix xref word changelog mix includes new task called xref performs cross reference check code one check ability find call module function exist great addition finding bug typo forgot aliasimport compile time frankly thoughthoped elixir already sometimes eg import module even better information mix xref executed default code dependency compiled check warning upgrading test generally capture bug compile time warning even earlier process everything well tested experienced first hand last week took u time trace test failure back bug timexecto opened pr improving test coverage failing test case bug curio mind wanted see mix xref would found call undefined module let see tobi airship githubtimexecto elixir v erlangotp kernelpoll false elixir tobi airship githubtimexecto mix clean tobi airship githubtimexecto mix compile compiling file ex warning undefined protocol function protocol ectodatatype warning undefined protocol function protocol ectodatatype warning function ectotypeblank undefined private warning function ectotypeblank undefined private warning function ectotypeblank undefined private warning function undefined module ectodatetimewithtimezone available warning function ectotypeblank undefined private generated timexecto app found bug hitting ectodatetimewithtimezone undefined source potential bug great hope would never made hex package release mix xref believe mix xref might biggest impact elixir eco system change coming get wrong love test group calendar type update directly improve quality released library development experience sure caught test sadly everybody test rigorously problem reported xref dependency relatively small phoenix app standard phoenix edeliver maybe dependency dependency potential crash bug dead code looming rather avoid hence really excited elixir mix xref like like loading related
376,Lobsters,elixir,Elixir programming,Text Based Elixir Adventures,http://hoelz.ro/blog/elixir-adventures,text based elixir adventure,elixir adventure language month http organization program erlang runtime builtin functionality running different process different machine let pretend working concurrent environment cant coding npc challenge anybody home nontrivial macro continuing elixir comment powered disqus,elixir adventuresfor elixir language month project decided return root way see upon time wrote first program idea space opera rpg retrospect tacky star warsfinal fantasy hybrid still wanted bring idea life way could thus spent good chunk time sophomore year high school spewing morass ifs gotos basic trusty eventually working game short textbased adventure sort demo full game headi recently thought textbased adventure npc roaming seemed natural fit concurrent programming language like elixirhere link finished code http programso central idea textbased village several npc resident created three named alice bob carolsince whole point learning elixir teach think term process broke everything could process relationship look like hover service see description see relationship graph directly represented code map readmapfromfile maptxt clock spawn fn elixirrpgclockmain end locationmanagerproc spawn fn elixirrpglocationmanagermain map end npcmanagerproc spawn fn elixirrpgnpcmanagermain clock locationmanagerproc end evaluatorproc spawn fn elixirrpgevaulatemain locationmanagerproc npcmanagerproc clock end parserproc spawn fn parser evaluatorproc end printerproc spawn send evaluatorproc look printerproc reader parserproc printerprocone side effect thing way idea naturally organize service sort nontrivial program would easy separate service different machine erlang runtime builtin functionality running different process different machine let pretend working concurrent environment ca nt passing process handle process need communicate also serf interesting form dependency injection elixir allows bind process symbol registering would bypass idea neglected register process liked able control exactly talking whomcoding npcsif chance desire revisit project future one first change would make would make changing npc le rooted code current implementation map configured via unicode art file npc needed live module needed tell npc manager program npc around location would go tightly coupled map admittedly point program wanted done challengesthe implementation pretty straightforward however run trouble along wayanybody home biggest problem would sometimes run situation would type command game nothing would happen number process increased number possibility went wrong went usually happened one two thing code would request something another service either would send request nt looking service b service would send response nt look like requestor expectingmy code would forget send response requesting processone case receive would forget continue loop service would diesituation would happen much often two code like look like def client send serviceproc getvalue self receive get value end end def service loop fn loop value receive get requestor send requestor get response value loop loop value incr requestor send requestor incr response value loop loop value end end loop loop endi ended resolving issue liberally sprinkling msg raise unexpected inspect msg receive block causing fantastic stack trace sentreceived something nt adding raise timeout expression receives helped fix issue fix issue made sure service raise supposed exit receive block sure erlang ecosystem offer far sophisicated tool kind thing especially believe kind thing supervisor good forthis raised question however happens erlang process mailbox get bunch message nt select receive mailbox fill could make interesting topic research day nontrivial macrosi learned hard way nontrivial macro bit harder elixir lisp let look example tried make code receive get requestor send requestor get response value loop loop value incr requestor send requestor incr response value loop loop value end look like receive handlemethod get value end handlemethod incr value end endthe tuple handlemethod macro supposed list argument method takesthe first part trying construct tuple go lefthand side first case get requestor splicing symbol variable macro land variable tuple invocation proved le straightforward example let say macro passed tuple look like compiler ast quote foo bar ioputs inspect ast sometimes would see foo elixir bar elixir made thing confusing figured tuple passed triple able construct lh tuple pretty easily feel bit disconnect code ast unlike working macro lispsadly even got working macro ended working turn receive strict go inside strict macro nt even called code rejected may able introduce receivelike special form allows handlemethod within block macro point continuing elixirelixir lot fun work definitely feel sufficiently brainbending would nt mind getting know otp little better nt even get anything fancy like supervisor sure keep toolbelt future project lend concurrent distributed model published please enable javascript view comment powered disqus
377,Lobsters,elixir,Elixir programming,The Elixir of concurrency,http://cfenollosa.com/blog/the-elixir-of-concurrency.html,elixir concurrency,elixir fairly young rail developer erlang vm compared scala course elixir phoenix framework elixir abstraction let crash start getting started madrid elixir meetup aboard elixir express official getting started guide elixir school understanding elixir genserver elixir supervisor conceptual understanding elixir cheat sheet first project vimelixiride elixir example portal game valim elixir koan exercism elixir golf learning elixir excasts elixir sip elixirconf video install elixir phoenix osx phoenix official guide getting help awesome elixir elixir tip elixir status plataformatec elixir post elixir forum irc channel slack mailing list relixir closing thought paradoxa programming learning,may carlos fenollosa elixir fairly young language born rail developer tried create modern language optimized concurrent distributed lightweight process wanted modern rubylike syntax welltested process manager erlang vm result elixir defined dynamic functional language designed building scalable maintainable application correct vague affirmation nt justice power elegancy recently compared move elixir python similar leapfrog moving python java feel like something new modern powerful killer feature nt want renounce python found repl list comprehension super clean syntax decorator elixir brings lightweight supervised process pattern matching fully functional programming language pipe terrific build tool mix never written functional code jump significant took scala course couple year ago needed almost two full week write production code elixir language young stack overflow help kidding big library github small community also come upside people motivated willing help centralized tool like forum irc channel still manageable may even suggest change language upcoming version elixir middle school teacher said ca nt define something stating ist however programming mentioning use case suitable language good way start elixir probably first choice single core software math calculus cpuintensive apps desktop application since high level system programming also picture elixir great web application standalone using phoenix framework really shine building highly scalable faulttolerant network application like chat telecommunication generic web service thanks erlang vm process really tiny one garbage collected low latency communicate sending locationindependent message network using vms run result params spawning managing process effortless thanks abstraction finally elixir basic module also shine plug router managing http request ecto relational database ets mnesia distributed inmemory database many recommend elixir phoenix found backend application enough use plug router phoenix impressive believe mistake jump right without trying base module first recommendation beginner hold phoenix really need elixir novelty pipe operator fantastic approach working state functional manner instead running readlines fopen userinput r uppercase split try readable userinput fopen r readlines uppercase split language clearly designed stand shoulder giant providing modern capability developer elixir abstraction store centralized key value like data instead singleton elixir provides agent keep state memory many process access modify without concurrency issue language spawn process much like thread using spawnlink probably nt want rather use task basically asyncawait gen eric server cool abstraction receives request process spawn helper miniservers process result parallel free task controlled using supervisor hold abstraction child automatically restarts crash finally code contained inside single project manage different apps module hold function package class object module function structs basic data type dependency management straightforward thanks mix build testing handled mix opposed multitools like gradle one really fast much process felt first give time brain eventually think term supervisor manage genservers spawn agent task needed let crash elixir mantra let process crash found shocking counterintuitive explanation make lot sense neither developer want code crash elixir promotes writing bad code however let agree many reason besides bad programming make software crash server run stuff point say connection every second one might crash eventually bug component hardware issue cosmic ray murphy law question event unfortunate unavoidable crash system react bring everything try capture error recover kill crashed process launch another one place example c us approach modern language exception like java python use elixir us suitable environment perfect use case fit elixir concurrent network process elixir single failure never brings system automatically restarts crashed process client instantly retry unless reproducible bug code fresh process finish without issue bottom line single client may unlucky crash point rest system never notice start let get hand dirty reading many site watching hour video following dozen tutorial resource found valuable suggest following order getting started madrid elixir meetup understand spanish best intro elixir otherwise watch aboard elixir express bit outdated comprehensive official getting started guide best current follow start finish including advanced chapter elixir school nice complement official guide thing similar different approach otp help understand better understanding elixir genserver elixir supervisor conceptual understanding two short read yet another explanation otp feature elixir cheat sheet best one first project vimelixiride elixir support vim best plugin suitable beginner elixir example elixir guide cover handy common idiom single page string list concatenate list optional function parameter etc portal game valim complement sample project official guide elixir koan exercism mini exercise use improve elixir agility line elixir golf proposes weekly puzzle solve learning elixir joseph kain ton content mini project example follow top quality excasts elixir sip short screencasts check reference elixirconf video contain interesting talk may overwhelming beginner worth look later install elixir phoenix osx want use phoenix osx may need help phoenix official guide phoenix nt necessary simple web service use plug large project need framework nothing like official guide getting help awesome elixir list elixir resource found many elixir tip elixir status regularly link elixirrelated article video plataformatec elixir post language author share news tip question code try elixir forum first irc channel slack developer would like transition help request mailing list use languagerelated discussion relixir reddit closing thought think moment hope post help beginner get hand language start writing production code soon possible anyone want know elixir fuss difficult explain especially somebody like programming imperative language life recommended elixir friend replied highly concurrent functional language using erlang vm nt something exotic right elixir exotic usecase specific unlike python favorite imperative language ecosystem ca nt recommend elixir everyone everybody spare couple week get started many library common use case missing nothing equivalent numpy matplotlib modern application built top dozen libs everyone time write library code fortunately paradoxa bos make tech decision hacker tinkerer definitely worth look wo nt change perspective like lisp make see writing concurrent code nt need difficult better tooling definitely possible bet elixir foundation devops stack year developer realize future bottleneck wo nt cpu rather number concurrent process connection backend manage elixir need boot another machine network let exotic erlang vm handle rest tag programming learning
378,Lobsters,elixir,Elixir programming,Justin Schneck - Enhanced Embedded Systems with Nerves (ElixirConfEU 2016),https://www.youtube.com/watch?v=118-g0ODfgg,justin schneck enhanced embedded system nerve elixirconfeu,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature justin schneck enhanced embedded system nerve elixirconfeu youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature justin schneck enhanced embedded system nerve elixirconfeu youtube
379,Lobsters,elixir,Elixir programming,Real World Elixir Deployment,http://www.slideshare.net/petegamache/real-world-elixir-deployment,real world elixir deployment,user agreement privacy policy privacy policy user agreement,slideshare us cooky improve functionality performance provide relevant advertising continue browsing site agree use cooky website see user agreement privacy policy slideshare us cooky improve functionality performance provide relevant advertising continue browsing site agree use cooky website see privacy policy user agreement detail
380,Lobsters,elixir,Elixir programming,Max Out Your Programming HP and MP With Elixir,http://hoelz.ro/blog/max-out-your-programming-hp-and-mp-with-elixir,max programming hp mp elixir,max programming hp mp elixir language month elixir learn elixir learning language getting started distinctive feature pattern matching put pin spawn low level abstraction erlang clean consistent syntax macro last month language moving forward phoenix comment powered disqus,max programming hp mp elixirhello welcome back language month april decided try hand language popular ruby community causing quite stir elm community called elixir learn elixir elixir brings interesting feature table built top erlang beam virtual machine mean spawning process extremely lightweight program written elixir encouraged make use many taskfocused process like erlang ok expected process fail unlike erlang however elixir favor rubylike syntax opposed erlang prologinspired one elixir list language learn figured would good way learn organize program around many small process let dig learning languagethe getting started guide official website really good quick introduction language provides good overview mix elixir build tool package manager welldistinctive featureselixir full feature work together make programmer happy pattern matchinglike many functional programming language elixir support pattern matching pattern matching matching string regular expression rather comparing structure data pattern pattern match variable pattern bound part structure matched example def handle ok result ioputs operation succeeded tostring result end def handle error msg ioputs problem occurred tostring msg endelixir allows u define multiple variant handle function execute version whose pattern match allows programmer write focused function handle single situation keep code nice organizedput pin itelixir interesting behavior try pattern match existing variable pattern username password getlogindetails hash hashpassword password exists hash getpasswordhashforuser username language used erlang prolog hash returned getpasswordhashforuser different one returned hashpassword pattern match fail elixir however pattern match bind hash one returned getpasswordhashforuser fortunately elixir provides way express meaning via pin operator exists hash getpasswordhashforuser username nice express elixir first wart language try get hung syntax easy mistakenly silently blow away variable value make match succeed way nt expect opinion pin operator semantics reversed explicitly specify want rebind variablespawnthe important feature elixir least whose goal learn concurrent programming spawn spawn elixir function creating new process give function return give process identifier pid short process elixir mailbox send message via pid way elixir process communicate advantage method communication process crash nt need worry dragging undefined shared state receive message call receive form see bit laterlow level abstraction erlanganother nice feature elixir although syntax different erlang lot semantics close sometimes identical make picking elixir erlang developer easy make interoperability erlang elixir pretty simplevery clean consistent syntaxone thing noticed going tutorial clean regular elixir syntax like said try get caught syntax cleaner syntax simpler rule never hurt one example block like use def form def greeting name hello name enddo block syntactic sugar keyword argument block desugars def greeting name hello nameso block nt special keyword argument keyword argument turn argument happens list regular simple syntax handy developing tooling language support macro like last month language elixir support macro come handy reducing boilerplate creating expressive code one thing found repeating lot writing elixir something along line def myprocess receive end myprocess endso ended making receiveforever macro eliminate lot boilerplate defmacro receiveforever block quote f fn f receive unquote block f f end end f f end end def myprocess receiveforever end endpretty cool huh one quick caveat though code wo nt actually work since macro modifying compilation process need define macro separate module able use code something surprising confusing working macro make certain amount senseone thing concerned writing macro f variable would happen user happened use f variable enclosing code block well never fear elixir macro called hygenic macro essentially mean variable introduced macro nt contaminate generated codemoving forwardi fun idea program going implement elixir feel like two really natural fit digging elixir inspired check erlang otp allows building extremely robust faulttolerant system lot people excited phoenix web framework elixir might end building something right idea come way seems natural pairing using elm frontendfrom experience far elixir fun language work highly recommend trying published please enable javascript view comment powered disqus
381,Lobsters,elixir,Elixir programming,Elixir RAM and the Template of Doom,http://www.evanmiller.org/elixir-ram-and-the-template-of-doom.html,elixir ram template doom,elixir ram template doom evan miller gather script tracing limit le costly phoenix request request template doom parting wisdom phoenix chicago bos dtrace note evanmillerorg twitter r wizard data le time communicate discovery visually back evan home page subscribe r twitter youtube,elixir ram template doom evan miller april attempt convince two line code elixir interesting programming language ever used ready worry code involve quicksort metaprogramming anything like go ok file fileopen tmpsomethingtxt write raw filewrite file rereplace hello goodbye amp code nothing special open file writes short string replacing ampersand hardcoded string html entity amp probably sharp enough write equivalent code favorite language couple minute le code entirely equivalent elixir code least perspective run tracing program like strace dtruss nonelixir code probably see something like write hello usual syscall expect trace elixir program instead see something like writev give strange hexadecimal number point good old write good enough mr fancy pant elixir answer immediately obvious code sample go long way towards explaining unique performance characteristic well anomaly might encounter ever try benchmarking erlang elixirâ html template read tale technical subtlety engineering culminates inmemory rendering template doom gigabyte monster bottom sea end post promise look web server way anyway enough gabbing dive gather get handle thing first revisit stringreplacement code rereplace hello goodbye amp paste code elixir shell see something slightly unexpected hello amp goodbye instead flat string erlang oops say erlang meant elixir creates nested list containing four leaf element add string expect hello amp goodbye first glance may seem like pointless complication see computer think situation look man page writev see mean writes data multiple memory location single system call wrote little dtrace script unpack writev call saw earlier peek elixir code actually system call log script writev return writev data byte hello writev return writev data byte writev return writev data byte amp writev return writev data byte goodbye original hexademical number writev call introduction memory address vector vector contains memory address four memory address represented big hexadecimal number next string address see log elixir writing element nested list separately hello amp goodbye notice anything peculiar memory location one perhaps look like others hello amp goodbye good hexadecimal lay character stated memory address simply rearranging expanding data log boldfacing start address clarity p h e l l g b e see yet nested list string fragment list make new string start make sense three pointer original string plus outoforder pointer replacement string word set modification old string also see extra tiny optimization performed regex engine notice final string us ampersand original string rather replacement string data structure called io list designed leverage writev thus minimize data copy writing disk network language wipe original string copy whole thing missing whole class nocopy latecopy performance optimization course pointer panacea sometimes data copying cheaper pointer juggling use dtrace explore erlang vm implementation see system draw various line attempt balance engineering consideration tracing limit try tracing two line code filewrite file enummap fn foobar end filewrite file enummap fn foobar end attempt write io list file first one foobar repeated time second foobar repeated time might think task result syscalls reality first line code call writev vector element second one flattens io list single blob memory call write concatenated data much language try string slightly longer shorter foobar see trigger simply number element list rather total size resulting string hit element list erlang switch concatenating data contiguous chunk memory poke around vm code see triggered constant smallwritevec dtrace log vector reveals something else writev something might surprise take look writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar notice anything memory address well strain eye mean point different address copy foobar lying around memory interestingly case move foobar literal outside closure elixir code trace code instead foobar foobar filewrite file enummap fn foobar end see end result get rather different trace writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar writev return writev data byte foobar time memory address work hood small string elixir instantiated wherever literal appears code foobar inside closure new string created whenever closure executed foobar outside closure execution closure result new reference string coming say javascript point might seem obvious remember string elixir immutable necessarily expect new instantiation execution code fact rule change string defined byte larger second magic number erlonheapbinlimit vm code big literal appear compiled module allocated shared heap refcounted see memory address trace regardless literal appears code worth noting string literal elixir shell always use smallstring rule complicated might thinking great care foobar got le costly show benchmark going blow mind make question everything thought knew web server performance well everything except great stuff learned article far ready going back something like scene raider lost ark one face melt head explodes simply unsee two elixir template wired excellent phoenix web framework template first iters blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah end template second iters blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah blahblahblahblah end template produce identical output lot blahblahblahblah difference second template insert string length zero middle iteration going believe one template greater throughput get excited caching computed template fragment better close look benchmark output benchmark first template without empty string running test http thread connection thread stats avg stdev max stdev latency reqsec request read socket error connect read write timeout requestssec transfersec benchmark second template empty string running test http thread connection thread stats avg stdev max stdev latency reqsec request read socket error connect read write timeout requestssec transfersec ruhroh inserting empty string template increase performance could learned anything far syscalls matter strace dtrace friend use look template perspective first template produce lot output like writev return writev data byte nblahblahblahblah second template produce output like writev return writev data byte ok first template delivered client tiny byte chunk empty string included second template along http response header flattened one big kilobyte string instead verrrrrrrry interesting tell least little curious going discrepancy traced another compiletime constant erlang vm one known erlsmalliobinlimit determines maximum string size consolidated one big string hardcoded four time value erlonheapbinlimit byte exact string smaller equal limit consolidated larger string preserved writev vector notice template example deliberately contrived byte chunk blahblahblahblah exceed limit get entry writev vector split chunk half true nefarious purpose mysterious empty string resulting chunk limit get consolidated happens computer consolidation greater throughput particular template come cost higher ram usage brings template doom enough information render template doom recently recovered sunken spanish galleon doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom doom end template produce file word doom repeated billion time totaling gb size template consists entirely chunk larger byte chunk compiled refer memory address know server storing million boxed pointer order magnitude gb machine vm topped gb ram usage serving single copy template doom best part make template doom crash server inserting empty string template dare try rather secondbest part best part understand crash email implemented template doom assembly using five molecule ram remember silly benchmark underpowered macbook point exercise empty string template string million time order save help give tool understand going hood system engineering situation call small memory footprint tinychunk writev strategy may better others great cpu caching slabofram may fine exercise starting point exploration parting wisdom memory architecture fit neatly onto problem dynamic template rendering rendering speed killing productivity making customer swim black pool pageload depression take look phoenix chicago bos framework work writev io list well kqueueepoll slash cpu ram usage compared nonerlang system many case obviate need serverside erlang vm clever produce oddity highly informal testing look like erlsmalliobinlimit particular cranked bit perhaps byte guardian vm might consider making tunable compiletime parameter using erlang elixir might want poke around favorite template implementation see using writev hood tracer make quick work task strace linux dtruss o x good start absolutely nothing beat dtrace power see writev trace log might opportunity improving memory architecture keep eye memory location trace output little string reuse go long way finally enjoyed using elixir code example found library could make better use io list particularly regex string module well html entityescaping without io list elixir eagercopying memory like everybody else missing one feature make erlang vm technically interesting note reading evanmillerorg random collection math tech musing liked might also enjoy get new article published via twitter r want look statistical pattern mysql postgresql sqlite database desktop statistic software wizard help analyze data le time communicate discovery visually without spending day struggling pointless command syntax check back evan home page subscribe r twitter youtube
382,Lobsters,elixir,Elixir programming,The Most Object-Oriented Language,http://tech.noredink.com/post/142689001488/the-most-object-oriented-language,objectoriented language,elixir fountain elixir episode erlang objectorientation c catalog said objectorientation email wrote defining objectoriented programming ok object mix httpoison library http http noredink homepage thin elixirifying wrapper hackney otp get score already another plus matter practical objectoriented design ruby james edward gray ii noredink,listening elixir fountain podcast pretty great source interview people played part rise elixir programming languageepisode particularly interesting interview joe armstrong cocreator erlang discussion includes lot detail platform elixir built top ofthere one moment episode surprised joe make comment erlang objectoriented language said elixirwait elixir even object elixir functional programming language yeswhen first picked elixir heard developer comment easy transition ruby similar way early though decided agree syntax ruby inspired sure immutability pattern matching recursion everywhere felt like significantly different beast methen started dig process got deeper joe comment podcast culminated significant ah ha moment let see gain deeper understanding meantwhat objectorientation pretty challenging question developer often seem agree exactly define style programmingthe first book ever read objectoriented programming explained point view c drilled combination three trait encapsulation inheritance polymorphism definition drawn increasing criticism timea likely better source definition term man coined dr alan kay attempt catalog said objectorientation favorite definition come email wrote answer question talk original conception includes description thought object like biological cell andor individual computer network able communicate message messaging came beginning took see messaging programming language efficiently enough useful email culminates definition oop mean messaging local retention protection hiding stateprocess extreme latebinding thingsyou may noticed definition never mention thing like class instance wikipedia talk lot thing defining objectoriented programming view description lot language gone concept heart objectoriented programming seem require bit least according man named styleok object playing semantics definition fun seem like would least need object idea objectoriented programming apply u elixir strictly anything called object let use quick example look havewe create script fetch page web crudely par title print practical value whole point give use code examine elixir normal contextwe begin creating project normal mix new sup titlefetcher creating readmemd creating gitignore creating mixexs creating config creating configconfigexs creating lib creating libtitlefetcherex creating test creating testtesthelperexs creating testtitlefetchertestexs mix project created successfully use mix compile test cd titlefetcher mix test run mix help command sup switch added tell mix go ahead give standard supervisor prepare application running starting said supervisor get u going le effortnow need way fetch web page let add httpoison library dependency project open mixexs make two small tweak defmodule titlefetchermixfile defp deps httpoison end end first change add dependencydefmodule titlefetchermixfile def application application logger httpoison mod titlefetcher end end change add httpoison list application elixir start u application context mean something different normal computer term help think reusable componentwith change place ask mix fetch dependency mix depsget running dependency resolution dependency resolution completed certifi hackney httpoison idna mimerl sslverifyhostname getting httpoison hex package checking package http using locally cached package getting hackney hex package checking package http using locally cached package ready add little bit code time need open libtitlefetcherex contains commented line inside start function look like worker titlefetcherworker need change run code worker task task builtin tool wrapping code elixir process instructed call fetchtitle function bit need add defmodule titlefetcher defp fetchtitle body httpoisonget http wwwnoredinkcom mapget body regexrun r title body capture allbutfirst hd ioputs systemhalt end end code set first pipeline retrieves content noredink homepage second extract print title page call systemhalt shut everything downthe end result probably expect see mix run nohalt compiled libtitlefetcherex noredink make learning grammar fun easy result wanted show though let make code show u little work first know task process managing telling let ask process stuff defmodule titlefetcher defp fetchtitle processregistered enumsort ioinspect body httpoisonget http wwwnoredinkcom mapget body regexrun r title body capture allbutfirst hd ioputs systemhalt end end one new line beginning function print registered process u inspect updated output mix run nohalt compiled libtitlefetcherex hexregistryets hexstate hexsupervisor logger loggersupervisor loggerwatcher mixprojectstack mixstate mixsupervisor mixtasksserver titlefetchersupervisor applicationcontroller codeserver disklogserver disklogsup elixircodeserver elixirconfig elixircounter elixirsup erlprimloader errorlogger ftpsup globalgroup globalnameserver hackneymanager hackneysup hexfetcher httpchandlersup httpchex httpcmanager httpcprofilesup httpcsup httpdsup inetdb inetssup init kernelsafesup kernelsup rex ssllistentrackersup sslmanager sslsup standarderror standarderrorsup tftpsup tlsconnectionsup user noredink make learning grammar fun easy wow kind lot going see thing elixir setup get thing ready code runyou may notice list include mention httpoison dependency httpoison thin elixirifying wrapper erlang http client library called hackney reexamine list find couple hackney process including hackneymanagerwe reached key idea elixir project workinside task called function fetch page content httpoisonget executed process strong reason believe separate hackney process actually fetching wire true process must sent message hood seemingly simple function callslet make another debugging change confirm hunch defmodule titlefetcher defp fetchtitle systrace hackneymanager true body httpoisonget http wwwnoredinkcom mapget body regexrun r title body capture allbutfirst hd ioputs systemhalt end end time line added turn debugging feature otp framework code running top asked message trace hackneymanager process found earlier observe reveals mix run nohalt compiled libtitlefetcherex dbg hackneymanager got call newrequest ref client undefined hackneydummymetrics hackneyssltransport wwwnoredinkcom nil nil nil true nil nil nil undefined start nil normal false false false undefined false nil waiting undefined nil nil nil nil undefined nil dbg hackneymanager sent ok new state noredink make learning grammar fun easy dbg hackneymanager got cast cancelrequest ref bingo hackneymanager process indeed receive message asking grab web page wanted load see hackney eventually sent message back requester containing page contentthis elixir work concern divided process communicate sending message process object world judging evaluate elixir objectoriented meritsget score already ass elixir stack objectoriented language point point using definition mentioned earlier first idea biological able communicate message hope example shown get thing done elixir several language object recommended design tool elixir process essentialwhat idea local retention protection hiding stateprocess often call encapsulation put bluntly enforced process share nothing outside debugging tool law land elixirinheritance elixir concept possible build version top process nothing provided might another plusthere one last point extreme latebinding thing tried shorten idea polymorphism actually thing let sort another examplewe going play around elixir repl iex time let ask elixir print something screen iex ioputs printing terminal printing terminal ok look pretty straightforward want know worksioputs take another argument got default let add iex ioputs processgroupleader explicit explicit ok version say want send output groupleader process thing default u earlier example case repl session groupleader essentially pointing stdout groupleader really return term elixir data type iex pid processgroupleader pid iex ioputs pid process way process way ok paying attention suspect surprised see another process case though really phrase extreme latebinding thing way saying something like want computer sort code actually run need arises language might mean two different kind object could print method computer decides one invoke based object message sent toin elixir kind late dispatch simply sending message kind process understands swap process another one understands message change code run example could capture output ioputs iex ok faketerminal stringioopen ok pid iex ioputs faketerminal go ok iex input output stringiocontents faketerminal go n iex output go n stringioopen creates new process pretend io device understands message receive reply substitute input string capture output written separate string possible elixir care process work internally delivers message code run sorted inside process receives messagesfor language traditionally think objectoriented elixir score surprisingly well different definition process make darn good object matter actually significant language decide crown objectoriented course interesting consider parallel thoughif shift focus right looking elixir code see object pop little different world however neat bit ask objectoriented design skill assuming studied good stuff like practical objectoriented design ruby still much apply expect nice surprisejames edward gray ii engineer noredink
383,Lobsters,elixir,Elixir programming,Writing extensible Elixir with Behaviours,https://www.djm.org.uk/posts/writing-extensible-elixir-with-behaviours-adapters-pluggable-backends/,writing extensible elixir behaviour,enough thing already ecto elixir behaviour behaviour typespec delving deeper pluggable backends interface steve domin bari balic swoosh defining behaviour public contract swoosh adopting behaviour reference github adding extensibility dependency injection via function head dependency injection via mix config achieving advantage taking look github example behaviour wild plug ecto thing watch resorting mocking verb ddl transaction common featuretest callback finishing mammoth email twitter bari follow twitter,let set scene written piece code would like work variety different thing yeah getting properly scientific bare various thing share common trait achieve highlevel result way go working towards result may slightly different often code need use one thing time nt want put egg one basket leave code specific thing throughout entire codebase would nasty would nt ace people could bring thing table extend software without even lifting finger nt day mate ca nt pick one go definitely could happens change mind thing like use thing thought gleaming unicorn actually turn squashed toad worse thing magically disappears puff vcfarted air horrific circumstance would great could simply murder founder swap thing another thing rewrite new thing without change everything already written right enough thing already may grasped getting thing come million flavour let stop vagueness give proper real world example messaging app need send email number delivery option open smtp mandrill sendgrid postmark future saas product etc first example thing delivery method accept deliver email differ achieve cv generator take input web form render given data html pdf markdown latex insert format yet invented etc thing differing document format accept input different thing achieve highlevel result document user take away storage engine take data store database postgresql mysql sqlite etc thing database accept query store data handle varying way yup described ecto scenario pose serious problem u want work damn thing difference present daunting barrier many language solution elixir different enter behaviour elixir behaviour hint name interface multiple thing one need define common behaviour abstraction exactly elixir behaviour definition said abstraction behaviour exist like specification rule book allowing module want enact behaviour follow rule word word allows calling code care common interface therefore blissfully unaware horror lie beneath need swap service calling code wo nt care one look like behaviour defined normal module inside define group function spec must implemented module adopting behaviour function spec defined using callback directive typespec signature way defining function receives return without ado defmodule parser callback parse stringt callback extension stringt end module wish adopt behaviour must explicitly state wish using behaviour parser implement take string return term implement take zilch return list string behaviour usage explicit therefore module adopting behaviour must actively state fact using behaviour somemodule module attribute incredibly handy mean lean compiler warn module following spec update behaviour new signature sure hell compiler tail make sure adopter follow suit delving deeper nt quite grok may help look language versed python post pluggable backends charles leifer great explanation general pattern ruby read philosophy inherit base adapter hope best eek gopher find similarity key difference interface said much easier show behaviour help write extensible code live working example going go deeper email case explained earlier particular steve domin bari balic swoosh email library utilises behaviour provide stack email delivery method also allowing extra one created others plugged defining behaviour public contract let skip real world take look library needed swoosh swoosh allows create email send via bunch delivery option needed abstract common behaviour delivering email let look swooshadapter defmodule swooshadapter moduledoc specification email delivery adapter type module type email swooshemailt typep config keywordt doc delivers email given config callback deliver email config ok term error term end see example slightly longer one documentation swoosh defines bunch type extra readability clarity eg config used alias descriptive keywordt ignore though care callback directive set rule one function delivery abstraction deliver email specification tell u take two argument swooshemail struct config keyword list something return give back idiomatic okerror tuple adopting behaviour time define something take look adapter adopt behaviour ship swoosh first take simple one local client simply delivers email inmemory inbox defmodule swooshadapterslocal behaviour swooshadapter def deliver swooshemail email config swooshemail header messageid id swooshinmemorymailboxpush email ok id id end end really much explain thankfully first adapter explicitly say adopting swooshadapter behaviour go define function exactly signature found behaviour definition remember explicit statement adoption let compiler hard work swoosh devs add extra function mail delivery behaviour module adopt behaviour would updated otherwise application would simply compile fantastic safety net next client sending email via sendgrid long copy reference github note module lot complex defines function along one must worth noting behaviour contract care else defined module function map adopter must simply implement function defined behaviour free like allows complex adapter function common behaviour call function module elsewhere increase readability maintainability adding extensibility learnt define behaviour adopt help u actually want use calling code application number way go using behaviour varying complexity start easiest work way dependency injection via function head going back earlier parser behaviour example doc defmodule document defaultparser xmlparser defstruct body def parse document document opts parser opts keywordpop opts parser defaultparser parserparse documentbody end end use contrived document module created functionbased wrapper parsing behaviour easily switch parser let run pas one argument option cause parser option key unavailable leaving keywordpop fall back defaultparser module supplied module attribute function parser get executed sent string document body great nt want use xmlparser documentparse document parser jsonparser xmlparser jsonparser adopted parser behaviour support function called within parsing wrapper thus swapping parser becomes simple injecting new dependency wrapper function way handling behaviour malleable powerful programmer even allows different part code base use different parser example downside method mean rely user knowing inject dependency require intricate documenting top user want use different dependency different environment calling code get lumped effort working module use would nt nicer could set desired adapter forget dependency injection via mix config thanks mix project configuration solved problem take parser example defmodule document defaultparser xmlparser defstruct body def parse document document config applicationgetenv parserapp module parser config parser defaultparser parserparse documentbody end end see parse function wrapper lost option argument instead calculating parser use based current otp application mix configuration given mix config look like configconfigexs config parserapp document parser jsonparser documentparse wrapper know use jsonparser parsing help u great deal adapter choice longer anchored calling code therefore simple update mix config environmentspecific config swap parser used future though method downside configuration much tied document module due use module module name configenv lookup mean gone able use multiple different parser one throughout code us document module instance one adapter likely enough entire project come across situation need use different adapter bit code segment codebase need send email via sendgrid another part required interact legacy smtp server let go back swoosh achieving advantage luckily u swoosh replicates ecto handle problem programmer required define module somewhere codebase specifies use swooshmailer calling code us module wrapper underlying swooshmailer detail pattern work scope article basic use builtin elixir tell compiler run macro named using file module wish use see exactly swooshmailerusing macro includes wrapper module taking look github mean project configuration swoosh exists two place configconfigexs file config sample samplemailer adapter swooshadapterssendgrid apikey sgxx application code defmodule samplemailer use swooshmailer otpapp sample end way created wrapper module setting mix config create ability use swoosh multiple time different adapter codebase developer define two module use swooshmailer know create publicly extensible code totally wo nt resort murder service heavily rely pull plug end thing wrap example behaviour wild reading already existing code help cement understanding behaviour use two get started plug elixir spec composable web app module actually behaviour someone say created plug fact saying adopted plug behaviour incredible simple module must simply implement function use behaviour actually allow composability plug public api known allows easily plugged together pipeline seen phoenix ecto us myriad thing including storage adapter custom field type association changeset relation database connection postgrex extension migration adapter repo thing watch conclude summarise benefit approach allows loosely coupled code adheres explicit public contract enables programmer extend current functionality explicitly detailing advance interaction occur fact public contract explicit make much easier test without resorting mocking verb said approach perfect problem defining common set interaction plugins essentially saying plugins provide functionality obviously always true situation like find coding lowest common denominator evenfurther reading exercise would recommend nosying around ecto codebase particular handle fact certain database backends provide ddl transaction providing common featuretest callback part behaviour finishing turned bit mammoth post well thanks getting far hopefully something clicked like add anything feel free shoot email catch twitter otherwise share away spread elixir love special thanks bari reading draft big ups enjoy post follow twitter
384,Lobsters,elixir,Elixir programming,hansihe/Rustler -- Safe Rust bridge for creating Erlang NIF functions,https://github.com/hansihe/Rustler,hansiherustler safe rust bridge creating erlang nif function,rustler documentation getting started example feature getting started rustler elixir library rustler elixir library look like supported nifversion community freenode elixirlang slack license,rustler documentation getting started example rustler library writing erlang nifs safe rust code mean way crash beam erlang vm library provides facility generating boilerplate interacting beam handle encoding decoding erlang term catch rust panic unwind c library provides functionality erlang elixir however elixir favored feature safety code write rust nif never able crash beam interop decoding encoding rust value erlang term easy function call type composition making rust struct encodable decodable erlang elixir done single attribute resource object enables safely pas reference rust struct erlang code struct automatically dropped longer referenced getting started easiest way getting started rustler elixir library add rustler elixir library dependency project run mix rustlernew generate new nif project follow instruction already using serde consider using serderustler easily encode decode data type elixir term note previously used rustler need run mix archiveuninstall rustlerinstallerez remove generating nif look like code minimal nif add two number return result rustler nif fn add b b rustler init elixirmath add supported nifversion rustler us erlang systeminfo nifversion detect supported nif version erlangotp system nif compiled possible restrict nif version older version nif compiled older version erlang example target nif version erlangotp defined using environment variable mix compile community find u rustler freenode elixirlang slack license licensed either option contribution unless explicitly state otherwise contribution intentionally submitted inclusion work defined license shall dual licensed without additional term condition
385,Lobsters,elixir,Elixir programming,Debugging techniques in Elixir,http://blog.plataformatec.com.br/2016/04/debugging-techniques-in-elixir-lang/,debugging technique elixir,iexpry iexpry doc debugger debbuger doc troubleshooting heuristic traverse module source attribute,common first experience debugging new language printing value terminal elixir different use however elixir also provides approach debugging blog post show option debugger iexpry name pry old friend ruby ecosystem different behavior elixir let create new project mix try mix new example cd example let write sample code libexampleex require iex defmodule example def doublesum x iexpry hardwork x end defp hardwork x x end end start new iex session invoke new function iex mix interactive elixir press ctrlc exit type h enter help iex exampledoublesum built top iex although traditional debugger since step add breakpoints forth good tool nonproduction debugging run caller process blocking caller allowing u access binding variable verify lexical information access process information finish pry session calling respawn start new iex shell find information iexpry doc debugger need breakpoint feature use debugger module ship erlang let make change example didactic defmodule example def doublesum x hardwork x end defp hardwork x x x x end end start debugger iex mix erlangotp source hipe kernelpoll false dtrace compiled libexampleex interactive elixir press ctrlc exit type h enter help iex debuggerstart ok pid iex intni example module example iex intbreak example ok iex exampledoublesum started debugger graphical user interface must opened machine called intni example prepare module debugging added breakpoint line intbreak example call function see process break status debugger process blocked add new breakpoint monitor window inspect code see variable navigate step debugger option command instruction use take look debbuger doc information troubleshooting may problem executing intni example example iex intni example invalid beam file abstract code elixirexample upcoming erlang version debugger heuristic traverse module source attribute applied latest erlang version update debugger manually following step download file interl pr compile erlc interl overwrite libdebuggerebinintbeam erlang installation new compiled file next post see tracing technique block caller process tool using debug elixir application
387,Lobsters,elixir,Elixir programming,nerves - craft bulletproof firmware in the stunningly productive elixir language,http://nerves-project.org/,nerve craft bulletproof firmware stunningly productive elixir language,,
388,Lobsters,elixir,Elixir programming,Extensible Design with Protocols,http://blog.drewolson.org/extensible-design-with-protocols/,extensible design protocol,extensible design protocol introduction protocol scrivener ecto example poison interface consider protocol judiciously,march extensible design protocol wrote code week reinforced power protocol tool software design term mean many thing world software let clarify using protocol mean mechanism used language elixir clojure etc achieve polymorphism used properly protocol allow provide user code set standard behavior well clear contract implementing behavior standard custom type post provide introduction protocol describe several us protocol lead extensible design example post written elixir equally useful language elixir credit clojure inspiration implementation protocol introduction protocol protocol mechanism achieving polymorphism say plainly protocol let call single function set function allowing subject function dictate way function implemented know know still confusing concrete also provide example protocol feel similar interface language like java consists least two piece first definition protocol essentially template function must implemented type protocol act suppose like introduce protocol determines collection empty protocol could look something like defprotocol empty def empty collection end protocol single function called empty u actually use protocol must provide implementation list map defimpl empty list def empty true def empty false end defimpl empty map def empty map case mapkeys map true false end end end two implementation place test see map list empty emptyempty false emptyempty true emptyempty foo bar false emptyempty true exciting get interesting add implementation custom structs application code suppose implemented redblacktree reason defmodule redblacktree defstruct node def size rbtree implementation go end end implement empty protocol custom struct defimpl empty redblacktree def empty rbtree redblacktreesize rbtree end end check see redblacktree empty way check list map emptyempty redblacktree matter use write better library application code story time week working prep library scrivener upcoming major release ecto pull request came unrelated work someone interested extending scrivener paginate list well ecto query goal scrivener keep library small focused idea excited concerned wanted provide library could focus functionality needed allowing individual community easily extend library need protocol rescue suppose pagination code scrivener originally looked something like defmodule scrivener spec paginate ectoqueryt configt paget def paginate query config scrivenerpage entry findentries query config totalpages findtotalpages query config end end see function spec take ectoquery config return page page struct contains entry well information total number page current page number etc work great new pr came focused adding pagination list concerned need add kind pattern matching around first argument stuck maintaining pagination logic every type database collection sun hit protocol made simple change defprotocol scrivenerpaginater spec paginate configt paget def paginate pageable config end defmodule scrivener spec paginate configt paget def paginate pageable config scrivenerpaginaterpaginate pageable config end end defimpl scrivenerpaginater ectoquery spec paginate ectoqueryt configt paget def paginate query config scrivenerpage entry findentries query config totalpages findtotalpages query config end end single change mean library massively easier extend giving none existing functionality individual asked adding list pagination free work without needing change scrivener could release new functionality companion library could imagine code looking something like defimpl scrivenerpaginater list spec paginate configt paget def paginate list config scrivenerpage entry findentries list config totalpages findtotalpages list config end end including companion library user scrivener interact via exact api passing list instead ecto query powerful indeed example two great example using protocol extensible apis poison json library builtin enum module poison implement json encoding via protocol called poisonencoder library ship implementation applicable standard type map list etc allows easily implement encoders custom type enum module elixir standard library another great example function enum module implemented term enumerable protocol mean implement enumerable protocol custom collection get functionality enum free interface protocol similar interface one extremely important distinction interface author must rely consumer code implement interface domain object protocol author implement protocol existing standard custom type well allowing implement protocol type deem applicable mean able introduce protocol scrivener codebase without ask ecto team implement protocol fundamentally protocol allow safe extension existing code even owned author protocol interface hand force user api implement functionality directly domain object achieve polymorphism hard overestimate impact subtle distinction consider protocol judiciously urge consider protocol mechanism providing extensibility library application code however important overuse temptation generalize early protocol everpresent problematic elixir victim initially providing protocol like map list keywords eventually removing protocol entirely saying use use protocol extensibility making data operation generic working concrete type treat data type
391,Lobsters,elixir,Elixir programming,Phoenix and Elm – Making the Web Functional,https://www.youtube.com/watch?v=XJ9ckqCMiKk,phoenix elm making web functional,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature erlang factory sf keynote phoenix elm making web functional youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature erlang factory sf keynote phoenix elm making web functional youtube
392,Lobsters,elixir,Elixir programming,Phoenix is modular,http://theerlangelist.com/article/phoenix_is_modular,phoenix modular,learned phoenix actually quite modular phoenix plug plug plugbuilder implemented plug count visit measure processing time sends stats graphite trimming phoenix commit reusing desired phoenix piece phoenixrouter plugrouter phoenixtemplate point learning tip,day ago saw question elixirlang channel initial cringe number moving part phoenix need get hello world coincidentally day received mail developer briefly touched phoenix really like elixir seem find happiness phoenix much magic happening lot dsl syntax diverts simplicity elixir really giving clear picture thing work hood instance endpoint router pipeline controller simplify endpoint pipeline controller one thing say sympathize sentiment first looked phoenix overwhelmed amount concept one need grasp spending time framework started making sense began see purpose concept quickly became convinced phoenix provides reasonable building block satisfy typical need furthermore learned phoenix actually quite modular nice trim preference though opinion usually needed fact possible run phoenix powered server without router controller view template article show provide tip learning phoenix first briefly touch relationship phoenix plug phoenix plug phoenix owes modularity plug many phoenix abstraction endpoint router controller implemented plug let quickly recap idea plug request arrives plug library create plugconn struct aka conn struct bundle various field describing request eg ip address client path header cooky together field describing response eg status body header conn struct initialized plug call function handle request task code take conn struct return transformed version populated output field plug library us underlying http library example cowboy return response fineprint variation concept relevant discussion essentially request handler function take conn transforms particular function take two argument conn arbitrary option called plug additionally plug module implement two function provides option take conn option return transformed conn request handler implemented chain plug help plugbuilder since plug basically function request handler boil chain function threading conn struct function take conn processing produce transformed version next function chain invoked job plug chain various task logging pluglogger converting input example plughead transforms head request get producing output eg plugstatic serf file disk also easy write plug example authenticate user perform custom action example site implemented plug count visit measure processing time sends stats graphite typically last function chain core handler performs requestspecific processing data manipulation computation produce response come phoenix endpoint router controller plug request arrives endpoint specifies common plug eg serving static file logging session handling default last plug listed endpoint router request path mapped controller yet another plug chain trimming phoenix since piece phoenix plug plug basically function nothing stop removing part chain thing need basic phoenix web app endpoint let see example create simple hello world web server based phoenix server rely router controller view template first need generate new phoenix project mix phoenixnew simpleserver noecto nobrunch nohtml option specify want omit ecto brunch html view generated project already make generated code thinner default version still piece removed done commit important change purged plug endpoint reducing defmodule simpleserverendpoint use phoenixendpoint otpapp simpleserver end request end endpoint nothing every request result error consequence removing default stuff router controller view template anymore default behaviour magic disappeared u recreate manually handling request simple defmodule simpleserverendpoint use phoenixendpoint otpapp simpleserver plug render def render conn opts plugconnsendresp conn hello world end end phoenixpowered hello world le line code bad reusing desired phoenix piece since phoenix modular fairly easy reintroduce part needed example want log request simply add following plug endpoint plug plugrequestid plug pluglogger want use phoenix router add plug myrouter myrouter built top phoenixrouter perhaps prefer plug router simply implement myrouter plugrouter let see different example instead shaping string manually reuse phoenix template support write eex template first create webtemplatesindexhtmleex file html body hello world body html relying phoenixtemplate compile template webtemplates folder single module defmodule simpleserverview use phoenixtemplate root webtemplates end call simpleserverviewrender indexhtml produce output string defmodule simpleserverendpoint use phoenixendpoint otpapp simpleserver plug render def render conn opts conn plugconnputrespcontenttype texthtml plugconnsendresp simpleserverviewrender indexhtml end end finally need set encoder html format configexs configexs config phoenix formatencoders html phoenixhtmlengine output rendered precompiled eex template still router controller phoenix view used find complete solution worth noting throwing default stuff also lost many benefit phoenix simple server serve static file log request handle session parse request body live reload also work course reintroduce feature need point honest usually recommend fully sliceddown approach impression default code generated mix phoenixnew sensible start web project sure spend time understanding flow request role endpoint router view template think worth effort end day chris frequently said phoenix aim provide battery included experience framework bound inherent complexity say super complex though need take time let sink good go one investment expensive one said simpler need overwhelmed many different phoenix concept throwing stuff might help hopefully obvious phoenix quite tunable understand plug fairly easy grasp request handled phoenix tweaking server need matter removing plug want opinion evidence good flexible design step spelled project code everything explicit tweak please learning tip learning phoenix still small task especially new elixir otp elixir journey start phoenix need learn new language adapt functional programming understand beam concurrency become familiar otp learn plug phoenix probably ecto none task rocket science obviously quite lot ground cover taking many new thing overwhelm even best u done one possible approach full bottomup focus first elixir learn building block familiarize functional programming move vanilla process otp behaviour notably genserver supervisor finally otp application gain confidence need understand plug phoenix specific easier built solid foundation suggesting need fully master one phase moving next one think building solid understanding basic concept make easier focus next stage benefit approach get steady incremental progress understanding concurrency easier wrestle language grasping phoenix easier already confident elixir otp plug downside reach final goal end probably interested phoenix want build scalable distributed realtime web server spend lot time transforming list plain recursion passing message process even able handle basic request take commitment endure first period prefer see tangible result immediately could consider twopass bottomup approach version could first go excellent official getting started guide elixir phoenix site get speed swiftly reading hundred page book though get much depth plus side able experiment prototype much earlier learning process start refining knowledge second pas perhaps reading book watching video reading official doc course many strategy take choose work best whichever way choose overwhelmed amount material try somehow split learning path smaller step take new topic gradually hard impossible learn everything process take time opinion effort definitely worth gain happy customer erlangotpelixirphoenix think stack give benefit
393,Lobsters,elixir,Elixir programming,How to build stable systems — An incomplete opinionated guide.,https://medium.com/@jlouis666/how-to-build-stable-systems-6fe9dcf32fc4,build stable system incomplete opinionated guide,build stable system incomplete opinionated guide preparation process people system planning factor app setup development picking database jepsen picking programming language configuration operation,build stable incomplete opinionated guidepreparationthe first decision easily important one ideology developer control software way around manager control software product owner control software developer people control software write itthe second decision small unit work control better solve minuscule subset full problem space first get deployed production large project die use initial small unit work ruthless test bed later explorationit responsibility developer always control software staple everything else measured bug occur dictate work schedule developer fix deadline draw close dictate work schedule developer software quality finish thus deadline hit deploy part software control fully roll back thing tany change software made succinctly quickly move system one stable point next err side fewer thing well mistake deployed alter production data make prohibitely expensive fix worst case rewrite year worth data wasted timethe software written series project project small selfcontained known point done people project project never longer month time every project win condition success criterion make project able worka project start small seed hour concentrated work lay core kernel rest project prototype viability system whole seed fails project aborted try new knowledge everything simplified cut seed kernel goal show feasability project whole make everyone confident projecta project usually single gamble something never done high riskreward gamble picking new programming language gamble using new framework gamble using new way deploy application gamble control risk knowing gambled stable part software prepared reroll mulligan gamble come unfavorablyevery project start list thing solve project many thing list sound desirable limiting scope help build needed focus define future extension project put separate project later onknow position project infrastructure component close core requires testing slower development attention error know general level testing business none aim getting smoketests place component adding test test core component leaf componentsknow experiment whole project experiment mike williamsmake experiment carry small analysis starting project proper flag analysis preplanning work real project tell everyone r right solutionknow code quality part interact guard look bad apisknow data quality data interact data requires several pass laundromat use chance project abandoned data cleanany project top existing system need transition plan gradually get current point new system big bang deployment tend associated lot risk good reason gamble wellestablished setting understand data source going updated gradually slide one data source next connecting multiple data source ondemand porting definitely optionthe developer always controlprocess peopleyou pick part agilexpscrumkanbanthisyearsfad work team kill everything elsedevelopment digital people working home efficient people working office avoid method require physical presence office thank year everyone hire world company office india germany sfprefer asynchronous communication email irc slack avoids interruption make easier catch later create hiding spot office people want work undisturbed managerdroids disturb themnot everyone drink coffee respect people different people love pair programming solving thing keyboard people tire interaction know different people team like work code basehours chair front keyboard equate hour productivity many solution come away keyboard flexibility work hour work place must productive people brilliant people offswitch brain flip leave work hold single parent three triathlonzealotin team individual member make mistake let learn mistake get solving problemsystem planningthe system built production system built toy accidentally throw fence put production later system built production consumption think configure system production think external dependency limit make system easy operate maintainyou build system factor appyour system flat set module loose coupling module one responsibility manages rest software module communicate loosely via protocol mean party communication changed long still speak protocol way design protocol future extension design module independence design module could ripped placed another system still workavoid deep dependency hierarchy breed tight coupling avoid monstermodules break apart avoid mess microscopic module well always remember power copying function thus breaking dependency fewer dependency time winin communication chain end point intelligence intermediary pas data exploit parametricity mulitple level build system opaque blob data accepted passed avoid intermediary parsing interpreting data code data change time parametric data simplifies changeyou supervisionrestart strategy write erlang already write erlang build scaffolding either inside application fine granularity via operating system coarse granularity system prefer ratcheting method via idempotence known stable state system attempt ratchet next step computation succeeds verify consistency stabilize step failure abort try essentially system stateless computation stateful ratchet flank especially important besteffort delivery mechanism distributed system unique id message mean always retry said message case timeout sure rerun receiving system receiver keep log already doneconstruct system always catch point time avoids building system separate mode online processing offline catching duplicating complicating code pathfollow unix principle tool one thing well avoid temptation add functionality build sibling tool insteaddefine capacity system front amount load targeting normal engineered operation load peak system operate nominally setupfirst build empty project add empty project continuous integration deploy empty project staging new project user also make deploy directly machine production setup line work start building application need arise add necessary configuration deployment chain wellcontinuous integration produce artifact artifact built code selfcontained fashion reliance host environment save simple setup seek preconfigure system need external dependency deploying save fiery situation later artifact deployed staging production pick context environment context configures configuration file disk consul etcd dns one downloaded err simple side use advanced technology early onthe artifact reproducible lock dependency specific tagsversions make upgrading dependency decision part aim build reproducible vendor everything control outside factor making sudden change application use messing buildthe artifact contains everything running software either binary directory tree containing binary binary statically linked go binary ocaml binary haskell ghc binary erlangelixir release good example artifact artifact also packed deployment information read deployment system usingtry make production deploy take le minute buttonpushtooperationalonthefirstinstancebuild default library include every application write library contains debuggingtracing utility tool gathering exporting metric way application become bot chat network let every application use librarydevelopmentcorrectness important fastelegant important fastcode quality important fastfast really importantthere goodenough point define starting optimize beyond point software fast fast part often separable mundane partsmeasure optimization algorithm data structure know change desired impactbuild system collect metric run ship metric central point analysis read gil tene work hdrhistogram use tool timeuse dirty trick respect tooling sleeve unit test property based test type system static analysis profiling really reason avoid tool help alleviate bug early late bug exponentially expensive remove chance altering production datathe software built run multiple different environment preferably unix embrace diverse culture landscape run change time lockdown specific platform often problemif ever run window screwed locked single vendor live die quality toolingdiscussions code formatting mostly pointless one defines standard haphazardly everyone follow suit go everyone run go fmt instance discussion overunderstand error kernel system part absolutely correct part lenient correctness separate error kernel isolate focus testing effort accordinglyuse load regulation border system order avoid overload situation regulate load inside reject work much going better give service select fail giving service everyoneuse circuit breaker break cascading dependency failure also indispensable maintenance needed since manually trippedpicking databaseed default text editor postgresql default databaseunless dataset terabyte pick postgresql need mongodblike functionality create jsonb column learn data postgres move learned postgres authoritative storage export elasticsearch postgres preheat data store postgres load increase run read replica postgres use pgbouncermost new database give dubious consistency security guarantee especially immature variant work call maybe fashion may accidentally fail store data particularly true network partition distributed database consult latest finding kyle kingsbury jepsen project use guide needed guaranteesmany newcomer database market narrow performance profile work well within narrow band use fail miserably try use outside narrow band put loadpressure handlebe vary start using complex transactional behavior make hard move away database design long run especially need distributed operation isolate complex transactional interaction part store usually money look idempotent ratcheting method alternative possiblepicking programming languageto get robust system pick erlang somewhere inside system language support robustness principle needed stable operationif pick erlang reimplement idea erlang avoid monoculture code written c java mean project able easily project become incredibly hard try healthy mix different language offer varying tradeoff maximizes chance picking language fare well problem spaceknow weakness language python well suited massive concurrency erlang work problem requiring raw computational power ocaml immature parallel execution story go fare well problem need good abstraction capability complex failure modesa language succeed way automatically deploy ease deployment tooling must place useall project language notwithstanding use tool configuring building make make call given language choice build tool common language continuous integration deployment make use make target project organization make easy onboard new people replay work ci tool also document build softwareconfigurationthe artifact come default configuration everything need different picked context prefer factor apps pick configuration environment variable persistent data life outside artifact path dedicated disk dedicated quota application log default location never log constant amount disk space predetermined rotation set upthe artifact path writable applicationuse different credential production staging avoids misconfiguration isolate network staging production staging deploy kill production environment deny developer laptop easy access production environment make jump hoopsavoid temptation early etcdconsulchubby setup unless large need fully dynamic configuration system file downloaded boot suffice many casesoperationsoptimize sleep system must avoid waking people middle night cost operation well developersthe system must able gracefully degrade perception partially degraded system often work whereas perception nonresponsive system failed use avoid waking people middle nightthe system run monit supervise upstart systemd rcng smf like never run tmuxscreen operating system gracefully restarts failing application giving upconsider using split stack software away system stack avoids work old software make easier move stack machine typesit always safe kill application control event amazon decides ward destroy rack randomly application must gracefully stop start given command booting active request option time must spent make work gracefully stopping internal part opposite order starteddevelopers usually never log production host every log file shipped indexed outside system every interesting metric developer work staging host enough information shipped reconstruct error without production access timemetrics often show failure occur oddoneout customer abuse system certain weird way often everyone use system line understand system spike around particular customer make fault handling proactive venture load increase extreme value become commonthe way make change production host redeploy way make change staging host redeploythe world elastic spinning new machine jail zone cheap use operation rebuild data center flip switch load balancer make easy roll back downgrade deployment gradually switch traffic new code high risk see fare letting take full load overprovision machine around risky deployment fix problem scale later software operates better wayit tempting handle production deployment error rolling forward time risk spinning control always way take step back want deploy production many time day group stable host hand rollbackdocker mature feb avoid production matures currently docker time sink fulfilling promise change time know adopt
397,Lobsters,elixir,Elixir programming,Comparing Elixir and Erlang variables,http://blog.plataformatec.com.br/2016/01/comparing-elixir-and-erlang-variables/,comparing elixir erlang variable,case numbered variable summing,sometimes erlang programmer worried elixir variable may source hidden bug article discus concern show variable erlang produce related hidden bug eliminated elixir start short disclaimer elixir mutable variable rebinding mutability often associated storage elixir value stored changed erlang example mutable variable could look f f explicitly using mutable keyword eg let mutable x would allow u change value inside inner loop equivalent list comprehension inside enummap observe change loop mutability possible elixir erlang without using explicit storage like process ets back track article explore potential hidden bug changing code bug exist erlang elixir variable provide implicit behaviour elixir rebinds implicitly erlang pattern match implicitly bug may show developer add remove variable without mindful context let see example imagine following elixir code foobar code usefoobar foobar happens introduce foobar snippet foobar newly added line foobar code usefoobar foobar code would work fine compiler would even warn newly added foobar unused would happen however new line introduced foobar definition foobar code foobar newly added line usefoobar foobar semantics may potentially changed wanted usefoobar use first foobar variable indeed careless change may cause bug let check erlang given code foobar code usefoobar foobar happens introduce foobar definition foobar newly added line foobar old line error code usefoobar foobar erlang code crash runtime instead silently continuing certainly improvement still mean introducing variable erlang requires u certify variable matched later foobar longer assigned matched happens introduce definition foobar code foobar newly added line error usefoobar foobar time new line crash word due implicit matching erlang need worry code introducing variable also need mindful code introducing previous code cause future variable become implicit match word far elixir requires mindful later code introduction variable erlang requires know previous code introduction variable one benefit erlang far code may crash explicitly match however thing get complicated considering case expression case let say want match new value inside case elixir would write case someexpr ok safevalue performsomethingsafe performsomethingunsafe end would happen accidentally introduce safevalue variable elixir case statement safevalue newly added line code case someexpr ok safevalue performsomethingsafe performsomethingunsafe end nothing code work fine due rebinding let see happens erlang case someexpr ok safevalue performsomethingsafe performsomethingunsafe end happens introduce variable safevalue newly added line code case someexpr ok safevalue performsomethingsafe performsomethingunsafe end silently introduced potentially dangerous bug code erlang implicitly match may accidentaly perform unsafe operation first clause longer bind safevalue match similar bug happens erlang matching existing variable remove imagine working elixir code safevalue code case someexpr ok safevalue performsomethingsafe performsomethingunsafe end elixir explicitly match remove definition safevalue code even compile let see working version erlang one safevalue code case someexpr ok safevalue performsomethingsafe performsomethingunsafe end remove safevalue variable first clause bind safevalue instead matching silently changing behaviour code another bug elixir approach shielded u case point elixir requires analyse following code introducing variable failing may cause bug matching variable always safe due rebinding use explicit match erlang requires analyse previous code introducing variable sure match assignment failing cause runtime crash requires analyse following code introducing variable sure change later case semantics failing may cause bug requires analyse following code removing variable sure change later case semantics failing may cause bug numbered variable beginning mentioned someone may introduce new variable foobar elixir code change code semantics variable already used later however case desired example elixir foobar foobar foobar foobar foobar code usefoobar foobar erlang code usefoobar happens want introduce new version foobar elixir foobar foobar foobar foobar foobar foobar foobar newly added line code usefoobar foobar code work erlang code usefoobar must changed developer introduces new variable forgets change later code semantics changed introducing bug rebinding elixir would particularly troubling change miss one variable since code emit unused variable warning even prone error adding intermediate step say say benefit numbered variable code could use example code usefoobar somethingelse however would consider code poor practice nothing name hint different case variable name would reflect part code would prefer use one team much better giving explicit name instead versioned one summing elixir erlang variable provide implicit behaviour rebinding pattern matching respectively require care adding removing variable existing code therefore elixir source hidden bug shown erlang source similar bug different situation erlang requires previous knowledge context introducing new variable elixir requires knowledge way circumvent bug language either forbidding explicitly providing rebinding pattern match operation none language possible react article saying happen code truth happen even small function hand mean writing code erlang elixir going lead bug software erlang developer writing robust software decade quirk exist language endup internalized programmer get experienced exactly happen code come end day language guarantee safely change code without caring context always hidden bug example language like clojure javascript ruby variable function name exist namespace introducing variable may change semantics function call since erlang elixir provide two namespaces one variable another function shielded particular hidden bug furthermore type system compiler warning test suite technique help solve problem language may also provide pattern like elixir pipe operator help convert repetitive code readable le errorprone version least hope put rest claim elixir variable somehow unsafer erlang one viceversa thanks joe armstrong saša juric james fish chris mccord bryan hunter sean cribbs anthony ramine reviewing article providing feedback
398,Lobsters,elixir,Elixir programming,Elixir 1.2 Released,https://github.com/elixir-lang/elixir/blob/v1.2.0/CHANGELOG.md,elixir released,changelog elixir erlang support language improvement getting started experience workflow improvement rebar support enhancement elixir exunit iex logger mix bug fix kernel iex mix exunit soft deprecation warning emitted kernel mix,changelog elixir brings enhancement bug fix performance improvement elixir elixir relies many feature erlang requiring least erlang upgrading erlang therefore necessary upgrading elixir erlang support brought many feature specific erlang highlight map scale dozen million key therefore usage module dict hashdict discouraged deprecated future release instead use map similarly set hashset deprecated favor mapset compilation time faster due improvement elixir erlang compiler dialyzer emits le false negative warning thanks new annotation available erlang compiler language improvement release includes four notable language improvement addition multi aliasesimportsrequire alias myapp foo bar baz support variable map key key value support pin operator map key function clause key value key value fn key ok end addition special form match multiple expression ok content fileread myfileex re binding codeevalstring content ok re improvement aim make language consistent expressive getting started experience improving language also improved parser compiler even aware language construct emitting warning common pitfall like piping expression without parenthesis defining unsafe variable also introduced helper iex allows developer retrieve information data type help newcomer explore language value providing experienced developer crucial information value introspecting workflow improvement umbrella application able share build configuration file aim drastically reduce compilation time umbrella project adding following configuration umbrella app mixexs file buildpath build configpath configconfigexs finally mix consolidate protocol default able consolidate parallel cache consolidation result providing best performance across environment without affecting compilation time downside change implementing protocol exclusively part test suite inside test directory wo nt picked happens compilation case consolidation disabled setting consolidateprotocols false project config great addition top faster compilation time achieved migrating erlang rebar support rebar gaining adoption erlang community mix able fetch compile rebar dependency feature currently experimental therefore optin rebar dependency ask mix use rebar compile passing manager option configured mix prompt install rebar yet available enhancement elixir application add retrieve application specification application add retrieve application given module belongs base optimize encode decode operation time enum use faster autoseeding rand instead random enum add genserver add shutting server reliably io add color related function ioansi kernel support multiple alias alias import require use example alias myapp foo bar baz kernel add struct similar raise invalid key kernel warn doc typedoc moduledoc attribute redefined kernel warn nonvariables used effect kernel mark quoted expression generated avoiding false positive dialyzer kernel allow variable map key creation key value match key value kernel allow pin operator fn clause left side comprehension kernel introduce special form allows matching right side parameter kernel warn right hand side provide expression kernel warn elixir compiled different endianness one currently available runtime kernel warn variable used defined exclusively nested context kernel warn piping expression without parenthesis macro add performs pre postwalk macro add process add stream add string introduce stringreplace prefix suffix leading trailing first two replace first occurrence given match string last two replace occurrence given match string support stringequivalent perform nfd nfc normalization system add systemtimeoffset systemmonotonictime systemsystemtime systemconverttimeunit systemuniqueinteger system allow remove variable specifying nil value task add spawn supervised task without linking caller process task introduce task raise error task queried nonowning process instead waiting forever exunit exunit allow one test raise multiple error goal enable tool ecosystem emit multiple failure report test exunit support tag report foo bar include value tag foo bar whenever test fails iex iex allow iexwithwerl set window always run werl mode iex display type doc moduletype moduletypearity iex add helper print information data type iex show source code snippet whenever request pry given process logger logger add file logger metadata mix mix cache always consolidate protocol mix add warntestpattern mix test warn potentially misconfigured test file mix introduce mixquiet environment variable configures underlying mix task output error message mix introduce mixdebug environment variable print information task run mix validate git option warn conflicting ref branch tag mix new umbrella application share configuration build file mix add experimental support rebar mix warn optional dependency conflicting option another dependency mix raise readable error message parsertools available mix add build flag mix depsclean dep remove artifact build bug fix kernel access improve error message using access nonvalid keyvalue structure kernel raise conflicting except given import kernel change envfile file set given function kernel make kernelparallelrequire aware warningaserrors kernel improve error message invalid dodo macro ensure respect operator precedence using access operator path crash expanding path go beyond root example pathexpand string ensure unicodeconversionerror contain invalid string error message iex iex start apps recompile helper nostart given iex avoid copying data evaluating every expression iex mix mix always run nonrecursive task umbrella root mix ensure rebar project work directory name contain nonlatin character mix ignore directory inside apps umbrella mixexs file mix ensure mix used path dependency app name different path basename mix ensure dependency wo nt crash updating git repository hex repository git version respect semver mix run remote converger dependency diverged mix ensure umbrella dependency across environment loaded parent depsgetdepsupdate exunit exunit include file line compilation error doctests soft deprecation warning emitted kernel dict dict hashdict soft deprecated favor map keyword deprecated favor map deprecated favor set set hashset soft deprecated favor mapset mix mix soft deprecated favor
400,Lobsters,elixir,Elixir programming,Introducing new open-source tools for the Elixir community,https://engineering.pinterest.com/blog/introducing-new-open-source-tools-elixir-community,introducing new opensource tool elixir community,win learn,win learn pinterest growing learning experimentation believe spirit exploration inside pinterest wall learn success epic failure
401,Lobsters,elixir,Elixir programming,Phoenix 1.1 Released,https://groups.google.com/forum/#!topic/phoenix-core/TBacwj0U7rY,phoenix released,,use google group discussion please enable javascript browser setting refresh page
402,Lobsters,elixir,Elixir programming,Elixir block keywords,http://thepugautomatic.com//2015/12/elixir-block-keywords/,elixir block keywords,elixir block keywords elixir macro turn elixir macro macro,elixir block keywordswritten december tagged elixir macrosexploring elixir tried defmodule example def foobar else endendexamplefoobar ioputs true else ioputs false endand worked well sense code run output true false going let try another experiment ioinspect true else false endturns languagelevel syntactic sugar eg desugars plain keyword list explains code would output true false equivalent toexamplefoobar ioputs true else ioputs false keyword list evaluated even passed function like keyword list would includes evaluating ioputs function callsnow full list block keywords elixir source go completely crazy ioinspect else b catch c rescue e endso available function like examplefoobar example use every branch evaluated time macro rescueelixir macro get access syntax tree piece code without code evaluated first slice dice code return another syntax tree evaluatedelixir ifdoelse macro using keyword listsjust fun could make macro randomly executes one two branch always run branch defmodule mymacro defmacro pick else afterblock randomseed ostimestamp option enumrandom option afterblock endenddefmodule example require mymacro def run mymacropick iowrite dog else iowrite cat ioputs end endendexampleruni nt used silly experiment picture handy dsl though apply anything interesting please let know comment
403,Lobsters,elixir,Elixir programming,Phoenix is not Rails,https://dockyard.com/blog/2015/11/18/phoenix-is-not-rails,phoenix rail,plan transition company elixir phoenix development going primarily rail phoenix powered application similarity difference application matter singleton matter startup shutdown source source source matter monitoring introspection programming phoenix book request lifecycle benchmark matter easy understand matter easy test matter easy share code channel million client single server matter web evolving phoenix chat app running natively browser iphone apple watch matter fast performance le dependency action cable bring heavy list dependency faye celluloid eventmachine redis name naming matter easy learn asset brunch matter future firstclass transpilers matter livereload essential feature wrapup,yearly recap last december brian went public plan transition company elixir phoenix development throughout year found smooth transition team going primarily rail phoenix powered application surface phoenix share familiar convention rail let folk jump new application contribute early project way greater mastery complete mastery take bit practice knowing shared convention similarataglance feature enticed ruby team get involved many delighted get running quickly unfortunately also led wrong assumption phoenix likeness rail causing miss important difference around core philosophy common ruby community say rail developer ruby developer expect happen phoenix although phoenix course introduces abstraction ultimately writing phoenix application writing elixir application testing phoenix code testing elixir function post aim address idea comparing similarity difference phoenix rail matter similarity phoenixcore team come railsheavy background natural borrow great idea rail brings table focus productivity client server side provide default directory structure although phoenix simply relies structure imposed elixir application mvc framework phoenix functional twist architecture though router sitting top provide default stack relational database rail postgresql phoenix promote security best practice default stack ship default toolkit writing running test difference similarity come major difference structure application recover failure debug system talk remote client phoenix take approach runtimes offer embrace elixir otp convention phoenix phoenix application component greater application infrastructure deviation rail effect throughout stack application thing phoenix application phoenix project first foremost elixir application relies phoenix provide part functionality mean one way build run deploy application elixir way matter singleton rail single application accessible via railsapplication rail run show starting application configuration even running command line task inherent limitation approach run two rail application side side need sharing need carefully break apart engine learn new set rule phoenix nothing global monolith new phoenix application include one endpoint one router one pubsub server free add global state global server break application piece infrastructure grows matter startup shutdown elixir convention structure project small composable application started stopped unit trail usually go like using phoenix example every application specification may specify module invoke application initialized def application mod phoenix application plug poison logger eex end source module specified function module invoked defmodule phoenix def start type args phoenixsupervisorstartlink end end source function must return identifier supervised process phoenixsupervisorstartlink source similar flow happens stopping application consequence matter using phoenix every application contained startstop mechanism stark contrast rail initialization extremely complex requires extension hijack single sequential initialization flow rail app rail c loading development environment rail irb main railsapplicationinitializerslength snippet code ruby block spread around multiple file nonspecified order control initialization logic extremely important know exactly app running keep boot time fast matter monitoring introspection relying application gain supervision fault tolerance introspection running system easily view application running unit whole tool like observer beauty project start single application may may broken multiple application naturally running single node service oriented architecture pay upfront cost runtime built tried true pattern fact cover example upcoming chapter programming phoenix book request lifecycle phoenix provides fantastic performance box benchmark prove requestresponse lifecycle phoenix differs greatly approach rail take rack matter easy understand explicit implicit almost always phoenix favor explicitness stack example generating phoenix application see plug request go libmyappendpointex rail segregate rack middleware sideloaded part application phoenix make plug explicit instant ataglance look request lifecycle viewing plug endpoint router defmodule myappendpoint use phoenixendpoint otpapp myapp socket socket myappusersocket plug plugstatic myapp gzip false w cs image j plug plugrequestid plug pluglogger plug plugparsers parser urlencoded multipart json pas plug plugmethodoverride plug plughead plug plugsession store cookie plug myapprouter end request start endpoint flow explicit plug base middleware handed router plug router applies plug handing controller guessed plug single level abstraction throughout entire stack make reasoning request lifecycle clear possible also allows easy thirdparty package integration simplicity plug contract let compare two similar looking controller see phoenix functional approach plug make code easier understand controllerrb beforeaction finduser def show post userpostsfind params id end def finduser user userfind params userid end controllerex plug finduser def show conn id id post connassignsuser assoc post repoget id render conn showhtml post post end defp finduser conn assign conn user repoget user connparams userid end unless seasoned rail developer know show call render showhtml implicitly even called explicitly would know instance variable copied controller instance view instance layer complexity realize first getting rail development convention configuration good thing threshold implicit behavior sacrifice clarity phoenix optimizes clarity way think strike perfect balance easy use apis beyond object oriented programmer must aware implicit state instance params hash request object instance variable set beforeaction filter phoenix everything explicit conn bag data line communication webserver pas along pipeline function called plug transforming connection sending response needed matter easy test functional programming plug contract make testing controller isolation integration testing entire endpoint matter passing conn plug pipeline asserting result additionally controller action phoenix function without implicit state need test controller isolation call function test sends user found conn mycontrollershow conn id notfound assert connstatus end stumbling setting controller instance thanks functional programming need fully integration test endpoint phoenix call pipeline function test show user conn get conn assert id jsonresponse conn ok end phoenix view follow principle controller function implicit data sneaking matter easy share code endup relying controller instance variable method method wrote run rail controller easily moved rack middleware relies many controller internals since plug function know coming know going one abstraction entire http stack whether endpoint router controller example let say want apply adminauthentication plug admin request well special dashboardcontroller use plug router controller level abstraction defmodule myapprouter pipeline browser plug fetchsession plug protectfromforgery end pipeline admin plug adminauthentication end scope get dashboard dashboardcontroller end scope admin pipethrough browser admin plugged route scope resource order ordercontroller end end defmodule myappdashboardcontroller plug adminauthentication plugged controller def show conn params render conn showhtml end end since use plug level stack plug adminauthentication plug router controller finegrained request rule rail would inherit admincontroller clarity transformation apply request lost track inheritance tree find rule applied phoenix router pipeline make concern request explicit channel phoenix day one built take challenge modern highly connected realtime web channel bring transport agnostic realtime connection application scale million client single server deviate rail historically realtime feature secondclass matter web evolving phoenix channel target web beyond browser web evolving include connected device phone watch smart toaster one browser need framework evolve changing new protocol alike channel transport agnostic native channel client available io android window platform see action phoenix chat app running natively browser iphone apple watch matter fast performance le dependency rail recent entry realtime feature action cable bring heavy list dependency faye celluloid eventmachine redis name phoenix run erlang virtual machine phoenix get realtime feature box runtime runtime distributed allowing phoenix skip operational dependency like redis orchestrate pubsub message across server naming phoenix impose strict naming convention like see rail matter easy learn phoenix tie module name filename rail requires userscontroller located file named userscontrollerrb agree convention like good phoenix care tight restriction instead promote sane default flexible individual requirement naming also creates lot confusion people learn rail first try write ruby application rail depends constmissing require file based upon class name convention file path knowing require file regular ruby application bit mystery programmer looking move knowledge outside rail phoenix includes web directory put controller view etc exists code reloading purpose give refreshdrivendevelopment phoenix also impose singular plural naming rule rail naming rule confuse beginner advanced developer alike model use singular name controller use plural one url helper mix phoenix consistently us singular rule elixir code may use plural name table router path explicitly written system boundary asset phoenix us tool named brunch default handling static asset allows bring javascript build tool instead building one specific framework like rail asset pipeline phoenix also leverage channel layer provide livereload change box matter future phoenix promotes instead coffeescript supporting box new project coffeescript served noble purpose push industry forward firstclass transpilers clear way forward matter livereload essential feature phoenix ship live reload box soon change j cs file automatically reloaded browser add feature development workflow one live without wrapup regardless background find phoenix borrows great idea came using elixir carve path take modern web
404,Lobsters,elixir,Elixir programming,Guts of Phoenix websocket channels,http://zohaib.me/guts-of-phoenix-channels/,gut phoenix websocket channel,major component transport channel pubsub transport web socket handled cowboy channel pubsub named process group change made reaching million websockets blog post chris resource,knew phoenix framework could handle lot simultaneous websocket client result chris posted amazed piqued interest phoenix framework web socket layer actually work started looking code amazed little code accomplished lot used right thing post going look phoenix channel designed major component following major component make whole phoenix channel transport basic abstraction sits middle socketcommunication layer channel channel includes channel created developer associated genserver created phoenix pubsub pubsub publisher subscriber responsible broadcasting message socket associated particular topic transport transport communication layer responsible receiving message client passing channel receiving message channel send back client phoenixsockettransport module doc responsibility verbatim implementing transport behaviour establishing socket connection handling incoming message handling outgoing message managing channel providing secure default case phoenix come two type transport one us websocket long polling transport allows abstract away upper layer ie channel receives sends message channel need call right function transport module let handle raw work communication example nt want use phoenix framework website system want receive message database create another transport implement getting message database passing onto channel allows abstraction channel top design extensible new protocol arrives future change make create new transport configure endpoint rest remains web socket handled magic actually maintaining raw websocket connection done cowboy cowboy http server used phoenix along serving regular http request cowboy also implement websocket protocol handle websocket connection using cowboy implement cowboywebsockethandler behaviour follows called websocket connection initiated defcallback init called handle message client defcallback websockethandle called handle erlangelixir message defcallback websocketinfo called socket connection terminates defcallback websocketterminate phoenix implement behavior phoenixendpointcowboywebsocket module act like intermediary cowboy transport implemented phoenixtransportswebsocket websocket transport us phoenixtransportswebsocketserializer serializer deserializes json phoenixsocketmessage serializes reply channel json sends client channel channel two component one channel behavior implemented developer second channel genserver spawned phoenix consumes developer written module responsible communicating transport receiving sending transport listening request send message broadcasted receiving message transport call handlein channel return reply payload socket sends message transport relay client receiving request send broadcasted message client call handleout channel return reply payload socket sends message transport job sending client pubsub pubsub designed interesting code involved le expected pubsub used broadcasting message socket associated topic channel genserver subscribes topic pubsub whenever someone publishes broadcast message topic pubsub sends subscriber channel genserver turn send client using transport pubsub work across multiple node pubsub leverage erlang named process group create named group process process group maintained across node distribution handled erlang example create process group named foobar get list process assigned node send message phoenix genserver spawned new topic node responsible receiving message node broadcast channel genserver subscribed topic local node local pubsub genserver phoenixpubsublocal us ets store pid local channel genserver subscribe topic broadcast request sent local pubsub retrieves local pid topic sends message channel genserver local pubsub register channel genserver group let handle broadcast message directly reason think allows le node node message passing hence throttling network broadcast n number message sent across node n number node cluster pubsub layer created simple even though distributed leverage awesome capability library already provided erlang change made reaching million websockets completed post great blog post garry optimization made order reach million web socket connection among multiple optimization one relevant post instead one pubsub genserver ets table team changed pool pubsub genserver different ets table channel subscribed pubsub sharded among pool based pid way pubsub become bottleneck thanks chris taking look post published hope help gaining insight working phoenix suggest read source code delight resource
405,Lobsters,elixir,Elixir programming,Elixir is NOT Ruby,http://zeroclarkthirty.com/2015-11-01-elixir-is-not-ruby.html,elixir ruby,model idiom information philosophy supervisor genservers joe armstrong thesis reading learn erlang great good,elixir recent rise totally unknown still definitely unknown mentioned hushed tone noticed morecommonthanitshouldbe assertion elixir basically ruby despite resemblance initial pas language environment programming idiom stark difference model difference start execution model ruby one move monolithic call stack manipulating object one grab call stack thread fiber threadsfibers sharing heap nearly every programming language virtual machine existence us model elixir every language beam virutal machine built around process process goofy unfortunately loaded name independent unit execution o process o thread defining feature process memory independence asynchronicity execution process heap vm collect process garbage independently one process know manipulate memory owned another process communicate message passing mechanism copy data sender heap receiver process scheduled executed concurrently vm certain point beam able take advantage many core allocate execute code parallel idiom program elixir program functional style article bear detail quick dirty involves fairly straightforward idea profound effect one program computer function primary abstraction including data immutability data data mapped one value new value rather mutating place basis expression rather statement nearly code return value referential transparency value input function return output value every time elixir pure functional language one must interact outside world functional programming elixir theoretical dream elixir functional practical benefit confers programmer busy building concurrent system could say born way erlang beam invented ensure profitability ericsson guaranteeing reliability flagship telephone switch rather prove soundness typesystem ruby functional feature notably module higherorder method like map reduce procsblockslambdas ruby however anything mandate even encourage immutability data lead practice perfectly idiomatic ruby like using method inside higherorder function sideeffect object using getters setter mutate object state rather operate value idiom ruby overwhelmingly mutate state amount ruby code seen concurrent application level vanishingly small given prominence pattern others nt difficult see exception community seems abandoned point despite rail threadsafety web application mostly rely app server fork n application instance process proxing request expense memory economy information ruby concurrency difficult elixir computation concurrent start whether like emergent behavior idiom code reflect even many simple program take advantage concurrency well nt much difficult elixir paraphrase quote ca nt remember author ca nt recall programming language nt useful feature list useful behavior idiom encourage ruby elixir encourage behavior different prank call ballet philosophy elixir ruby coming two headspace overlap section different heritage different design goal language place value known ruby community programmer happiness see surface level aesthetic appearance succintness general lack ceremony expressiveness etc appears effort community devote documentation great rail guide paving way excellent elixir language documentation come courting beginner valued member community rather timesink scorned none surprising elixir brings number former prominent ruby programmer obvious talent user experience aside divergence tooling experience better significantly elixir mix hex tool ruby combo rubygems rvmrbenv bundler rake crack form look elixir erlang erlang elixir runtime come family whose main concern reliability consistency concurrency community obsessed failure understanding preparing embracing thing fall apart aspect language environment revel failure concept process supervisor genservers give leg code pattern emphasize early failure elixir language environment built system must run month year decade without maintenance recommend joe armstrong thesis curious point erlang traditionally traction among telecom industrial embedded gaming lowlatencyhighio application due reliability bent ruby justifiably concern found adoption accordingly ruby hugely popular among solo developer consultancy startup beginner programmer generally concerned timetomarket shortterm roi rather maintenance elixir poised walk ruby bacon fuse two mentality system run year enjoyable build nethack clone reading something rustled highly recommend fred hebert learn erlang great good best text understand make erlang environment distinct whatever experience elixirerlang promise fred book profound experience learning lisp haskell probably practical book erlang language tool book find elixir elixir erlang almost friction taking understanding thing like process otp learn erlang applying elixir context one absolutely learn elixir combination fred book elixir guidesdocumentationsource code
406,Lobsters,elixir,Elixir programming,The Road to 2 Million Websocket Connections in Phoenix,http://www.phoenixframework.org/blog/the-road-to-2-million-websocket-connections,road million websocket connection phoenix,road million websocket connection phoenix started run benchmark server chrismccordphoenixchatapplication gazlerphoenixchatexample rackspace gb io rackspace onmetal io client tsung documentation first connection first connection first real benchmark http commit observing change observer http commit need machine know ets type gabiz voicelayer pull request need even machine mobileoverlord live help commit,road million websocket connection phoenix posted november gary rennie paying attention twitter recently likely seen increasing number regarding number simultaneous connection phoenix web framework handle post document technique used perform benchmark started couple week ago trying benchmark number connection managed get connection local machine convinced number posted irc see anyone benchmarked phoenix channel turned member core team found number provided suspiciously low beginning journey run benchmark server benchmark number simultaneous web socket open time first thing required phoenix application accept socket test used slightly modified version chrismccordphoenixchatapplication available gazlerphoenixchatexample key difference afterjoin hook broadcast user joined channel removed measuring concurrent connection want limit number message sent future benchmark test performed rackspace gb io machine ram core rackspace kindly let u use server benchmark free charge also let u use onmetal io ram showed core htop one additional change may want make remove checkorigin confprodexs mean application connected regardless ip addresshostname used start server git clone run mixenvprod mix depsget mixenvprod mix depscompile mixenvprod mix phoenixserver validate working visiting client running client used tsung tsung opensource distributed load testing tool make easy stress test websockets well many protocol way tsung work distributing using host name example first machine called assigned ip etchosts machine also etchosts important run client different machine phoenix application benchmark result true representation running machine tsung configured using xml file read particular value documentation config file used however number lowered reflect number client bigger test used client start connection second maximum connection connection open websocket join room lobby topic sleep second used large sleep time wanted keep connection open see responsive application client connected would stop test manually instead closing websockets config type disconnect xml version doctype tsung system tsung loglevel debug version client client host cpu usecontrollervm false maxusers client host cpu usecontrollervm false maxusers client host cpu usecontrollervm false maxusers client server server host serveripaddress port type tcp server load arrivalphase phase duration unit second user maxnumber arrivalrate unit second arrivalphase load option option name portsrange min max option session session name websocket probability type tswebsocket request websocket type connect path socketwebsocket websocket request request subst true websocket type message topic room lobby event phxjoin payload user tsuserserver getuniqueid ref websocket request var incr thinktime value session session tsung first connection tsung provides web interface port used monitor status test chart really interested test similtaneous user first time ran tsung machine tsung phoenix chat application running locally tsung would often crash happens see web interface mean chart show unimpressive connection first connection set machine remotely attempted benchmarking time getting connection least tsung crash reason systemwide resource limit reached verify ran ulimit n returned would explain could get connection point onwards following configuration used configuration took u way million connection sysctl w sysctl w ulimit n sysctl w sysctl w sysctl w sysctl w sysctl w first real benchmark talking tsung irc chris mccord creator phoenix contacted let know rackspace set instance u use benchmark got work setting server following config file http running dedicated one machine phoenix two running tsung first real benchmark ended connection image two line chart line top labeled user line bottom labeled connected user increase based arrival rate test used arrival rate user per second soon result josé valim case commit first improvement big one got connection observing change first improvement realized going blind way could observe happening luckily use erlang ship observer used remotely used following technique http open remote observer chris able use observer order process size mailbox timer process message mailbox due phoenix heartbeat every second ensure client still connected luckily cowboy already take care commit result looked like actually killed pubsub supervisor using observer image explains drop end second performance gain result concurrent connection using tsung machine need machine two problem image one reach full number client timing two actually generate connection per tsung client technically per ip address chris good enough really see limit unless could generate load stage rackspace given u box actually another machine could use using powerful machine tsung client limited connection may seem like waste better machine idling chris set another box u another possible connection ran benchmark got connected client big problem actually connect machine work probably hardware issue decided try running phoenix machine instead surely would issue reaching connection limit right wrong result almost identical chris thought pretty good chris tweeted result called night know ets type achieving fairly easy performance gain sure could performance gain magnitude wrong aware time colleague gabi zuniga gabiz voicelayer looking issue weekend commit gave u best performance gain far see diff pull request also provide convenience local etsnew local bag namedtable public local etsnew local duplicatebag namedtable public additional character made chart look like increase number concurrent connection also allowed u increase arrival rate made subsequent test much faster difference bag duplicatebag duplicatebag allow multiple entry key since socket connect one pid using duplicate bag cause issue u maxed around connection point box memory ready really test larger box need even machine justin schneck mobileoverlord informed u irc company live help would set additional server rackspace u use additional server precise set machine set threshold tsung million connection new milestone easily achieved machine time justin finished setting box convinced million connection possible unfortunately case new bottleneck started appearing million connection connection good enough right wrong time hit subscriber started getting regular timeouts asking subscribe single pubsub server also notice large increase broadcast time taking broadcast subscriber justin interested internet useful thing wanted see could optimize broadcast subscriber since see real use case level idea shard broadcast chunking subscriber parellizing broadcast work trialed idea reduced broadcast time back still pesky subscribe timeouts limit single pubsub server single ets table chris started work pool pubsub server realized could combine justin broadcast sharding pool pubsub server ets table sharded subscriber pid pool pubsub server managing ets table per shard let u reach subscriber without timeouts maintain broadcast change commit refined merging master million connection time thought optimization made another idea pitched leading huge improvement performance million figure pleased however quite max machine yet made effort toward reducing memory usage socket handler addition benchmark performing particular set benchmark set exclusively around number simultaneous open socket chat room million user awesome especially message broadcast quickly typical use case though future benchmarking idea one channel x user sending message x channel user sending message running phoenix application across multiple node simulation sending random number message user arriving leaving randomly behave like real chat room improvement discovered benchmark test made available upcoming release phoenix keep eye information future benchmark test phoenix continue push boundary modern web
407,Lobsters,elixir,Elixir programming,Elixirscript: Elixir to JS,https://github.com/bryanjos/elixirscript,elixirscript elixir j,elixirscript elixirestree documentation current release requirement usage example application elixirscript todo example library elixirscript react starter kit elixirscript starter kit development communication elixirscript contributing contributingmd,elixirscript goal convert subset full set elixir code javascript providing ability write javascript elixir done taking elixir ast converting javascript ast javascript code done using elixirestree library documentation current release requirement erlang greater elixir greater must compiled erlang greater node greater development usage add dependency deps mixexs elixirscript xx add elixirscript list mix compiler mixexs also add elixirscript configuration def project app myapp add elixirscript compiler compiler mixcompilers elixirscript elixirscript configuration elixirscript entry module also list module input myentrymodule output path either path j file directory output privelixirscriptbuildelixirscriptbuildjs end run mix compile example application elixirscript todo example library elixirscript react starter kit elixirscript starter kit development clone repo git clone git githubcom bryanjoselixirscriptgit get dependency make deps compile make test make test communication elixirscript elixirlang slack contributing please check contributingmd
408,Lobsters,elixir,Elixir programming,Embedded Elixir in Action,https://www.youtube.com/watch?v=kpzQrFC55q4,embedded elixir action,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature elixirconf embedded elixir action garth hitchens youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature elixirconf embedded elixir action garth hitchens youtube
409,Lobsters,elixir,Elixir programming,The UNIX Philosophy and Elixir as an Alternative to Go,http://lebo.io/2015/06/22/the-unix-philosophy-and-elixir-as-an-alternative-to-go.html,unix philosophy elixir alternative go,unix philosophy elixir alternative go stated webassembly elixir run minimum server minimum engineer prose phoenix ecto,unix philosophy elixir alternative go june done web programming length time might feel like start new era year using framework like django rail language like python ruby php use old requestresponse cycle lack better term basically request come server client server render html web page sends back client pattern dominant year ago due ajax json numerous framework embrace clientside rendering like ember angular knockout backbone recently react many case still using framework language illsuited known year ruby python slow willing put however turn server rest apis supposed deliver json numerous client many time find alternative see lot competitor trying fill void people crazy enough use rust nim haskell work see interest jvm based language like scala clojure jvm actually handle threading exceptionally well far language hear discussed derided javascript via node go thing language neither especially pretty javascript prior complete shit lot way lot misguided judgment today based former experience modern reality language become personally stated think javascript perfectly acceptable language especially use super set like typescript advantage fast relatively already used browser though may changing year webassembly asynchronous nature allows handle modern web apps page pretty well thing though javascript also flaw syntactically pretty noisy ugly additionally much appreciate fact continually evolving standardization process keep getting bigger bigger addition necessary make language usable many finger pie e standardization seen concern expressed language become especially bloated already something concern well best thing usually singular driving force behind sure j whether maintain microsoft google mozilla others involved process blessing curse finally javascript handle modern web well perfect request something especially cpuheavy every single user application waiting thankfully promise eliminated callback hell still fundamentally covering working around j core semantics j ever get proper threading better handle issue web worker form ipc soon delegated concurrency model along python referencing gil aware aysncio handful language truly concurrency day one go goroutines channel large part appeal aspect made popular alternative existing language ecosystem include raw speed simple yet dynamic feeling typing ability compile binary finally simplicity discussion go last part seems dividing line often overlooked many people still using modern language like haskell look go aghast language lacking featurewise understand possibly limit hand actually listen lot go user primary selling point language small understand day whatever facility lack overcome brute force enough code quite boring work done programming esoteric language ignorant user blub many gousers portrayed silly partisan language war decade working number language want something simple something fit head compromise willing make sure many user go way said tried writing web app go exactly entertaining nice formhandling library used python ruby yeah nearly good try writing validation function different form input probably run limitation type system find certain thing express way could language came database handling get verbose model get ugly tag json database whatever else ideal situation ready embrace simplicity writing web apps already pretty menial work go exacerbates many simple task language discussion go get mocked lot initially marketed system language idea go would used place c c seen absurd perhaps rightly go devs since stated surprised see lot go convert dynamic language like python c c term system language used isolation make much sense seen within context massive server process google make perfect sense truthfully go still make sense lot apps foundational stuff like docker small command line apps within wheelhouse appropriate somewhere however extrapolated idea go good language writing web apps believe case element true system programming language however might fit bill language snob looking something simpler get excited assuming read title piece know talking elixir elixir light rubyish layer syntax compiles run beam erlang vm erlang created ericsson powered system incredible time decade go elsewhere deeper explanation make possible erlang process lightweight hundred thousand spawned true elegant concurrency allows situation like whatsapp run minimum server minimum engineer want get far concurrency thing mainly others much better erlangelixir better language really need know want touch quality elixir want modern language elixir functional immutable support pattern matching like case statement steroid explanation begin touch much impact entire manner coding also support macro mean core language remain small user extend syntax support pattern designer never dreamed said rubyish syntax syntax matter really tried designing acceptable lisp rather acceptable syntax prose think really cool small core functional nature elixir strike unintentional true heir scheme throne truly intrigue elixir despite fact modern language quite small read language guide hour pretty good grasp core concept love much rather spend cognitive cycle figuring solve problem instead figuring construct language used also lead much quicker mastery use construct time get intuitively much faster use construct time getting think much polyglot future able get away using single language becoming le le reality use elixir rest api probably still need call python script language certain task key however elixir framework like phoenix library like ecto seems like much better fit tool web development many option thing elixir well connecting postgres database turning json unix philosophy work stage people willing leave behind thousand library existing language search better alternative elixir seems stronger choice go simple language elixir brings many feature make grow programmer help program grow elegantly future
410,Lobsters,elixir,Elixir programming,Elixir concepts for Go developers,https://texlution.com/post/elixir-concepts-for-golang-developers/,elixir concept go developer,elixir concept go developer disclaimer elixir elixir valim power erlang joy ruby soft immutability pattern matching pattern matching switch statement steroid atom process v goroutines actor model lightweight thread main entity directly addressable csp supervisor structs protocol composition inheritance pipe operator macro macro dsl could driven development standard library otp phoenix phoenix chris mccord plug ecto phoenix channel beam different jvm final thought go see note see note official getting started guide aboard elixir express repo plataformatec,elixir concept go developer disclaimer getting started guide played language mean expert take write grain salt goal condense highlight hour research something consume minute help decide elixir could interest elixir elixir emerging new language run beam erlang virtual machine complete erlang interoperability share building block rubylike syntax ton syntactic sugar created valim core rail contributor attracting lot rubyists erlangers attempt combine power erlang joy ruby soft immutability elixir try proper functional language proper functional language data immutable set variable change great benefit tricky people imperative mindset like mine usually supposed work around recursion function call elixir brings middle ground offering form soft immutability reuse variable name interactive elixir iex iex look like mutation actually syntactic sugar anything get passed reference first keep getting also see elixir dynamically typed repl although language compiled pattern matching elixir like erlang many functional language pattern matching killer feature radically change way code look elixir operator actually used matching side interactive elixir iex iex b iex c b teapot teapot iex c teapot iex c b teapot try match b matcherror match right hand side value teapot iex c b teapot rebind teapot program try match sequence pattern one click binding variable along way reduces massively need ifelse think switch statement steroid go beyond wil use declare different behavior function depending pattern signature input parameter match isthree fn ioputs yes number num ioputs number num num ioputs number num end iex isthree yes number ok iex isthree number ok iex isthree number ok atom equivalent iotaindexed constant go programming language call symbol used place label patten match iex imanatom imanatom iex imanatom imanatom imanatom iex imanatom anotheratom matcherror match right hand side value anotheratom iex ioputs hello world hello world ok many function return atom ok along result indicate success error message otherwise pattern match result decide different scenario process v goroutines process elixirerlang equivalent goroutines go lightweight thread execution independent system thread elixir implement erlang actor model lightweight thread main entity directly addressable spawn elixir process get pid use send message process process pattern match message received decide elixir actorbased hello world ex parent self pid iex spawnlink fn send parent msg hello world end pid iex receive msg content ioputs content end hello world ok channel communication completely transparent process fact multiple vms connected mesh network send message transparently process computer network multiple process bundled process group allowing send message whole group order distribute load since network transparent process debate microservices v monolith switch model minimal effort actor model contrast go csp model communication channel main addressable entity goroutines anonymous addressed directly supervisor supervisor process watch process get restarted crash reason also allow start stop inflight part program get idea function counted number wanted supervise dummy go supervisor implementation would something like package main import fmt time func main instead go count go supervisor count select func count int fmtprintf dn timesleep timesecond panic pretend something broke func supervisor fn func int args int func defer func err recover err nil fmtprintln panic recovered fn args fmtprintln restarting process timesleep timesecond course extreme oversimplification elixirerlang supervisor builtin much sophisticated allowing different restart policy etc usually combined supervision tree application keep several level resiliency structs protocol structs elixir look similar structs go although deep syntactic sugar around map give elixir certain objectoriented flavor keeping functional spirit pattern match struct property like would map value protocol similar go interface protocol implementation struct method elixir like go seems follow composition inheritance principle pipe operator oh go hold spirit unix pipe elixir literally pipe language make big difference readability specially functional language operator take value left use first argument function right something like tostring multiplyby fetchanumber written like fetchanumber multiplyby tostring bringing back order execution reading direction syntactic sugar actually macro could created macro macro syntactic sugar ã la carte macro system go beyond simple template elixir program internally represented lispesque threeelement tuples function metadata argument access ast compile time iex quote sum sum iex quote context elixir import kernel iex quote ioputs hello alias alias false io put hello make elixir great language meta programming dsl extend language whatever think missing encouraged abuse macro use attack new problem domain socalled could driven development wiicjdd tempting standard library otp elixir nice clean standard library contrast erlang standard library vast phpesque inconsistency crown jewel open telecommunication platform library made distributed system telco industry otp collection well thought building block resilient distributed system extent made erlang special find aforementioned supervisor release management monitoring generic server implementation distributed keyvalue store even distributed relational database built top phoenix phoenix created chris mccord another rubyist high productivity web framework aim rail elixir full featured framework plug specification middleware interface core everything accompanied ecto ormish database access layer try mimic rail productivity focus rail clone leveraging instead elixirotp feature try go even beyond web use phoenix channel builtin socket library plugable transport layer already javascript swift objc c java integration beam mentioned beam vm elixir run scared word virtual machine different jvm low memory footprint noticeable garbage collection pause designed relatively performant shine come low latency sits somewhere half way javago pythonruby come raw computing performance example happily run raspberry pi deployment worry otp provides release artifact selfcontained package dependency includes need scp server run like would go binary final thought personally find elixir interesting someone like failed grok anything functional javascript look like great opportunity study paradigm still feeling home pattern matching pipe operator make declarative code easy read write also opportunity study otp lesson learned many year building resilient distributed system see taking part market many ruby shop jumping ruby go performance boost said see using team building big application least without precommit hook forbidding macro definition wrote go good thing let people express elixir wiicjdd represents end spectrum macro system ultimate freedom speech tool wanted come witty metaphor valim willy wonka covering erlang enough sugar make look tasty open everyone appetite macro chocolate factory wondering many developer fall chocolate river despite warning could articulate anything decent see going perhaps wrong though language new tell think understand elixir design goal need look background people behind problem faced career afaik neither valim mccord erlang developer trying create better erlang rubyists working web development agency see note try achieve better ruby without notorious scalability shortcoming piggybacking erlang distributed goody see note bringing erlangers along way language aim broad scope think important keep perspective sold actually want learn language aside official getting started guide fully recommend hour long workshop chris mccord aboard elixir express repo oct pointed plataformatec valim employer company backing elixir development much web development business cover backend development soa etls etc oct comment author trying make elixir better ruby personal impression valim say elixir better ruby classify elixir better ruby sure ruby main language elixir part workresearch creating elixir exactly broaden experience much possible get mileage ecosystem bring biased view elixir better ruby better erlang language
411,Lobsters,elixir,Elixir programming,Flirting with Elixir,http://eng.localytics.com/flirting-with-elixir/,flirting elixir,michael macasek elixirconf elixir exactly elixir nine nine uptime erlang telco stuff phoenix ecto faster rail ok downside engineer like elixir easier mix iex exunit eex exrm exdoc localytics like elixir next,fellow localytics engineer michael macasek got back elixirconf pumped thing people elixir incredible heard talk distributed computing selfhealing architecture embedded system web development last time saw much enthusiasm new tech back ruby rail rocket preparing launch loved saw hated nt see jose valim dabbling elixir conference meeting community knew elixir take exactly elixir programming language run erlang virtual machine elixir creator jose valim famously said looked erlang loved saw hated nt see built language erlang strength plus nicer syntax mature toolchain elixir erlang strength fewer weakness erlang pictured language around since opensourced known powering telecommunication system achieved nine nine typo erlang telco stuff nope erlang built create system fast responsive reliable wellsuited messaging system high velocityvolume bigdata system web application etc example phoenix web framework elixir gaining serious traction touted nextgeneration replacement rail complete elegant orm called ecto support websockets box measured faster rail way javascript evolved beyond webbrowser root elixir built top erlang evolve similar way ok downside elixir magic reason may right tech use case fast c java cpuintensive workload probably want write desktop app gui elixir community thirdparty libs still small growing relatively new hiring elixir programmer may difficult engineer like elixir elixir pleasure use functional make testing debugging concurrency easier expressive rubylike syntax complete magical pipeline operator reinforces pipeline data paradigm also got polished suite language tool versatile build tool superpowered repl show documentation load code reloads code autocompletes elixir erlang function test builtin test framework templating library lib allows trivially version build production release doc firstclass citizen elixir ecosystem brought exdoc clicked link noticed beautiful thorough documentation diving elixir ecosystem like unboxing something apple localytics like elixir process three billion data point day backend system must highthroughput faulttolerant always responsive erlang breadandbutter secret sauce highlyavailable distributed system open telecom platform otp library abstraction make building system straightforward elixir wrap otp interops rest erlang ecosystem zero overhead elixir give u erlang battletested library abstraction writing concurrent code experience running production run several hightraffic rail apps require bellsandwhistles respectable production code includes background job cache multiple application server monitoring system etc elixir allows u replace piece infrastructure single technology single repo using elixir concept umbrella project since dealing single technology easier debug le code manage otp make trivial write code alert u thing go wrong restarts thing last known good state elixir also compatible erlang mindblowing observer tool allows detailed remote debugging wrapped gui dev ever jump hoop see app observerstart change world also considerable performance gain phoenix lot faster rail mean use cheaper hardware support equivalent traffic next still early exploration elixir localytics language gone viral among developer considering breaking monolithic backend service using channel web dashboard realtime data feed ramp looking forward watching contributing budding elixir community inclined elixir resource help get started
412,Lobsters,elixir,Elixir programming,Thinking About Function Signatures in Elixir,http://rob.conery.io/2015/10/07/thinking-about-function-signatures-in-elixir/,thinking function signature elixir,pattern matching taking step back tell need building flexibility keyword list keyword list end result,one thing adjust want structure function call elixir forced upon pattern matching good thing deciding pattern early really helpful consider function def chargecustomer id amount description card currency usd end might think writing elixir function required defaulted get twitch used get ruby time something elegant taking step back method call bit long also bit wobbly lack better word first thing consider function used think something like def processcheckout args verifycart argscart chargecustomer createinvoice debitinventory emptycart sendemail end operator simply chain call together sending result one function another also semipseudocode would likely transaction involved consider going passed chargecustomer function result verifycart likely cart good scan start realize passing information along require greater thought lighter function simple parameter structure tell need one way pas single argument along arrity elixirspeak using tuples ok cart passing qualifier first tuple position setup pattern matching much nicer way get later get u half way chargecustomer function need lot cart need kind payment method well description amount currency pulled cart tweaking parameter list thus def chargecustomer ok cart card end look little strange two thing setting first parameter ok cart making sure whatever function calling delivering back good result second parameter card required add additional definition handle error pas along error chain def chargecustomer error err error err def chargecustomer ok cart card end two solid pattern match good function structure flexible building flexibility keyword list pattern matching key writing flexible code massage later instance using gateway like stripe might want pas card token along rather card information might using paypal express checkout paypal token need flexible structure flex pattern matching using keyword list second argument def chargecustomer error err error err def chargecustomer ok cart card card end def chargecustomer ok cart token token end def chargecustomer ok cart paypal paypal end one method match based payment type would work pipeline like def processcheckout args verifycart argscart chargecustomer token createinvoice debitinventory emptycart sendemail end two really neat thing happening first inject argument piped function call whatever add placed end parameter list verifycart return ok cart get passed chargecustomer token passed second position keyword list syntactic sugar brace removed real world payment information would passed argument would probably pas argspayment like end result thinking pattern matching functional interop lead naturally towards keeping thing flexible light writing little library wrote weekend started focus le writing individual function entire module together found adhering tuple option argument structure worked really well keep saying learning stuff found better pattern sound learn build fast faulttolerant application elixir traditional boring tutorial get ebook epub mobi well hour worth tightlyedited lovingly produced elixir content learn elixir elixir helping new fictional job development lead aerospace
413,Lobsters,elixir,Elixir programming,How To Learn a New Programming Language While Maintaining Your Day Job and Still Being There For You,http://rob.conery.io/2015/10/06/how-to-learn-a-new-programming-language-while-maintaining-your-day-job-and-still-being-there-for-your-family/,learn new programming language maintaining day job still,first two package hex happily working full time also ample time dive elixir series little win programmed system using plpgsql give permission downer fad asshole everything fad long enough time scale sound like complete asshole job marketuse casewhat always win define damn curve decide execute must execute sign weekly newsletter series little win skip goal task creating new project spelled quick google search task writing test stuff actively ignore right string date number getting footing directly pragmatic programmer dave thomas programming elixir package called timex data structure database brain exploded successfully query postgresql ongoing thing finding idiom summary,typically write lifehack post question come repeatedly last week find time learn elixir must nice work family p first certainly expert elixir finding way language pushed first two package hex weekend really good time also married father two happily working full time full time really pluralsight also ample time dive elixir thought would share come right series little win set win tiny little task led tiny little win next thing knew thinking elixir series little win write enough post combination lifehack stuff well tangible step took course two week become reasonably proficient language apply whatever language like elixir programming language learned counting html cs pascal vbscriptvba sqlplpgsql c ruby javascript particular order could argue whether sql really programming language programmed system using plpgsql say p anyway onward give permission make decision waffle say stupid shit including fad oldyoungfat job market something come along replace later could go get idea downer serve derail inspiration make sound toxic toxic fad asshole people said every single language learned save pascal sql workhorse language around forever everything fad long enough time scale say word aloud sound like complete asshole might right language referring might go away year still sound like toxic asshole let aware word impact others mostly asshole anything sit sideline call people name let hitch wagon whatever star like better industry everchanging evermoving need move need move aside job marketuse casewhat opening door solving problem even nothing amount stretched brain exercised ability solve problem always win simply go wrong trying learn something learn might find creating something fun solving problem elegant way bring back day job learned ruby brain exploded idea created subsonic number project inspired language never know could happen year time ruby javascript much market year ago neither java net ahead curve define damn curve decide decide let execute get nitty gritty detail need focus importance execution go decision made say ho hum get maybe weekend nope must execute literally minute day lunch hour night code instead fucking xbox coming next set win little task building one win top another creating cadence build unless commit put elixir time calendar every day treat appointment need keep underserves much time investing career time question execute simple step move beyond dreaming actually might sound silly one demonstration commitment way little win follow mover shaker twitter sign weekly newsletter install slack subscribe language team read post question stack overflow write blog post kind thing exploration requires fearless see let write code series little win suck programmer important give incompetence lack confidence decided learn elixir gave time execute question became exactly goal nice also destructive set idea going skip goal let execute good time task creating new project much easier could c net file new project pick flavor project ruby single file way nicely structured set directory little wild west doable node npm init myproject elixir spelled quick google search mix new myproject project mix new myproject creating readmemd creating gitignore creating mixexs creating config creating configconfigexs creating lib creating libmyprojectex creating test creating testtesthelperexs creating testmyprojecttestexs mix project created successfully use mix compile test cd myproject mix test run mix help command took minute reading second point lot first thing notice last line find help say something project readmemd gitignore test directory config setup nice learned lot executed little win stop go play xbox task writing test created initial project write test thing get kind nut even dabbled language yet let get control one need small win make easy test directory look inside see two file myprojecttestexs testhelperexs tell u something file extension elixir ex ex seen project setup something write later little win myprojecttestexs file likely throw away great hack concept test helper u nice looking inside test file see myproject cat testmyprojecttestexs defmodule myprojecttest use exunitcase test truth assert end end somewhat familiar syntax apply rule language construct clean feel rubyish like like ruby think write test defmodule myprojecttest use exunitcase test truth assert end test name assert rob rob end end kind dumb test want watch fail hopefully learned something rather huge need figure run test remember created project said run mix help command let start mix created project u probably run test myproject mix help mix run default task current mix run mix appstart start registered apps mix archive list archive mix archivebuild archive project ez file mix archiveinstall install archive locally mix archiveuninstall uninstall archive mix clean delete generated application file mix cmd executes given command mix compile compile source file mix deps list dependency status mix depsclean remove given dependency file mix depscompile compile dependency mix depsget get date dependency mix depsunlock unlock given dependency mix depsupdate update given dependency mix executes task separated comma mix escriptbuild build escript project mix help print help information task mix hex print hex help information mix hexbuild build new package version locally mix hexconfig read update hex config mix hexdocs publishes doc package mix hexinfo print hex information mix hexkey hex api key task mix hexoutdated show outdated hex deps current project mix hexowner hex package ownership task mix hexpublish publishes new package version mix hexregistry hex registry task mix hexsearch search package name mix hexuser hex user task mix loadconfig load persists given configuration mix local list local task mix localhex install hex locally mix localrebar install rebar locally mix new create new elixir project mix phoenixnew create new phoenix application mix run run given file expression mix test run project test iex mix start iex run default task good grief lot stuff actively ignore right shortcircuit become overloaded give right insecurity talked big fad right bottom need mix test run project test boom myproject mix test compiled libmyprojectex generated myproject app test name myprojecttest assertion failed code rob rob lh rob rh rob stacktrace finished second load test test failure radical learned much little win elixir compiled language testing project also compiles case sensitivity builtin string hooray assertion failed informative way lh mean left hand side rh right hand side see failed two win move feeling pretty damn happy string date number getting footing part might seem obvious indeed also requires book type learning resource besides google kind thing tend go directly pragmatic programmer search elixir find great set book one stand amazing dave thomas programming elixir book simply wonderful recommend enough usually read programming book like read order make sense learning basic type operator data structure found dave lead fun read recommend highly elixir functional language book start function made primitive element like string number date etc like know work read work play around little project write test see thing work specifically string find language wart handle string mutability regex branch get footing understanding basic type might need learn data structure method call either way slice learn little time concatenating string using basic regex run replacement match string syntactic sugar date found rather quickly datetime story elixir bit limited need work thing installing package called timex also found access stuff erlang directly lot people bookmarked thing come back still done data structure database first set experiment little win took week built win harder became get focused fight constantly want jump finish line build stuff take lot effort stop stay focused felt pretty good basic project went together time work basic list data structure brain exploded elixir functional language aspect completely foreign surprise really tried hard could control firehose concept coming eventually gave let wash read book way knowing would pick read quite time point stared mess concept floor decided pick one dive setting little win higher concept beyond basic specifically using recursion iterate list perform operation using list comprehension meaningful way using pipe operator problem typically kind thing demoy need grasp something real modified list successfully query postgresql using recursion iterate list perform operation using list comprehension meaningful way using pipe operator able roll list data meant something using type test began understand win piling ongoing thing finding idiom neat thing elixir voluntary idiom people use like callback structure node make life easy required function parameter come first listed optional parameter passed using keyword list function result typically tuple structure indicates happened like ok returndata error message pattern matching allows control flow application elegant way writing smaller concise function piping together make programming lot fun idiom right call level work begin little win shift learning building exactly started feel pretty good way thing going summary feeling anxious post want tell wish time sound fun need make money ask work young vibrant industry expect thing stay innovator make positive change give time go little win learn build fast faulttolerant application elixir traditional boring tutorial get ebook epub mobi well hour worth tightlyedited lovingly produced elixir content learn elixir elixir helping new fictional job development lead aerospace
414,Lobsters,elixir,Elixir programming,Elixir 1.1 Released,https://github.com/elixir-lang/elixir/releases/tag/v1.1.0,elixir released,http enhancement elixir eex exunit iex logger mix bug fix elixir eex exunit logger mix soft deprecation warning emitted elixir deprecation elixir reload reload,official announcement http enhancement elixir application add applicationfetchenv cli add support werl window bashlike shell dict add behaves similar deprecated access protocol dict add enum add enum inline common map usage enum function performance file add work like able return symlink information ie traverse symlinks file add integer add inspect add safe option make safe default meaning failure inspecting wo nt trigger failure instead wrapped exception properly formatted io support fenced code block ioansidocs genserver add expands genserver dispatch proper pid kernel longer include crypto syntaxtools dependency former needed encrypted debug info therefore add crypto dependency manually latter longer used kernel raise varalias syntax used expand atom compile time previously emitted warning kernel improve generation argument name function signature kernel special form kernel warn variable underscore used kernel allow underscore binary octal hex literal kernel warn module attribute variable string number used code expression effect kernel support uxxxx u x string char list map unicode codepoints list add module improve name inference function signature documentation metadata process add process allow list spec set introduce mapset data type new data type us map behind scene useful storing dozen item erlang future version map efficiently support large collection meant main set abstraction elixir stream add string support calculation jaro distance string usually name via used mix support mean feature task exist string add split string stream stringio added flush output stringio device task introduce check task still executing shutdown otherwise tuple add uri default port added w w schema uri add eex eex add trim option eex automatically trim left side right side space new line preceedfollow exunit exunit add number skipped test exunit output exunit make timeout configurable whole test suite via timeout configuration exunit allow moduledoc filteredskipped doctests exunit provide builtin log capturing functionality exunit allow assertreceivetimeout refutereceivetimeout configured exunit application exunit allow test skipped tag skip tag skip reason exunit add test without implementation missing block automatically fail test also automatically tagged notimplemented allowing skipped exunit increase default stacktrace depth value also configurable exunit improve formatting assertraise error message mismatch exunit improve formatting assertreceive using pinned variable iex iex support iexpry remsh remote debugging iex add helper show documentation behaviour module callback function iex provide tab completion alias allow alias like foobarbaz autocomplete even foobar defined iex provide helper building pid number logger logger support printing pid ref logger metadata logger allow logger metadata removed pdict setting nil logger add application configuration translatorinspectopts logger customize state message formatted translating otp error report logger automatically include current application metadata compiled via mix mix mix check elixir version right archive installation provide feedback mismatch mix allow rebar dependency mixexs compiled mix mix allow rebar dependency specified via path mix also consider subdirectory config directory mix allow dynamic configuration mix project storing config agent mix support style git ref rebarconfig file mix recompile compile time dependency mix project considerably speed recompilation time elixir project mix warn configuring application available mix add mix profilefprof easy code profiling mix abort dependency conflicting definition mix fully recompile project elixir scm change mix allow checksum checked archive install via option mix add mix localpublickeys safely manage installation hex rebar dependency bug fix elixir cli ensure logger message flushed executing command code delegatelocalsto failed delegate chosen module many situation messed stacktraces option therefore replaced import code store documentation line metadata returned exception fail calculating exception message even message invalid file ensure receive return universal time previously would work local time monotonically increasing could present issue script time shown user time local given argument float support complete scientific notation kernel expand argument module body kernel throw syntax error undefind atomalias syntax foobar kernel improve error message ca nt compile target directory writeable kernel allow capture nonsymbolic operator like others kernel raise heredoc terminal accidentally found middle line without escaping kernel nt warn missing import nothing imported kernel raise arity bigger given capture operator macro properly convert capture module accept nonelixir module name protocol guarantee derived protocol go instead map range restrict range integer fix diverse bug value included range false positive regex fix splitting empty string regexes trim set true return empty list called empty string trim enabled regex fix nt discard escape character stream ensure suspending consume unecessary item given enumerable eex eex allow eex interpolation also apply inside quotation exunit exunit skipped test correctly count towards total test result returned exunit fix bug failure inspecting data structure retrieving error message could bring whole exunit runner exunit change semantics evaluated code assertrefute example assert nil someexpr raise expected expression still evaluates falsy value exunit report proper line number doctest failure logger logger include metadata use runtimeonly metadata behaviour mix mix use safer http protocol instead git github dependency mix ensure automatic protocol consolidation via consolidateprotocols triggered umbrella apps mix raise wildcard given importconfig match file mix application buildembedded set true require explicit compilation step mix also remove consolidated protocol mix clean mix ensure exclude mix test concatenates test helper excludes soft deprecation warning emitted elixir behaviour module behaviour deprecated instead defcallback one simply use callback instead defmacrocallback one simply use macrocallback enum deprecated favor kernel x inside string charlists deprecated favor uxxxx u x value emitted x unfortunately wrong byte currently emits codepoints u meant correctly map codepoints x fixed future map byte regex ungreedy option r deprecated favor u standard regular expression language deprecation elixir access implementing access protocol deprecated access protocol relies code server development test mode protocol consolidation applied generated bottleneck working multiple process access protocol invoked hundred time uncommon note access module opts key syntax affected deprecated underlying protocol dispatch kernel xhex deprecated favor situation former used favor latter latter always cleaner kernel giving true false deprecated undocumented behaviour string passing empty string startswith contains endswith dubious behaviour deprecated help developer identify possible bug source code perform action time signed another tab window reload refresh session signed another tab window reload refresh session
415,Lobsters,elixir,Elixir programming,Phoenix 1.0 – the Elixir framework for the modern web just landed,http://www.phoenixframework.org/blog/phoenix-10-the-framework-for-the-modern-web-just-landed,phoenix elixir framework modern web landed,phoenix framework modern web landed success story company using phoenix production many thanks josé valim plug ecto phoenixcore lance halvorsen jason stiebs eric meadowsjönsson sonny scroggin realtime web beyond browser justin schneck eoin shanaghy david stump productivity short term long term shortterm productivity ecto longterm productivity next register elixirconf getting started phoenix guide,phoenix framework modern web landed posted august chris mccord year half work commits release phoenix place phoenix set take world whether building apis application network service native device written elixir get beautiful syntax productive tooling fast runtime along way many success story company using phoenix production two elixirconf showed phoenix progress many thanks jump great thing phoenix offer owe thanks people helped make possible josé valim though try downplay effort josé paved way phoenix level contribution simply amazing wrote elixir bootstrapped phoenix plug library opened database access ecto contributed thousand line code phoenix along way crafted elixir release helped build community pleasure part thank phoenixcore core team devoted many night weekend get today whether lance halvorsen writing lovely phoenix guide jason stiebs helping flesh initial channel layer eric meadowsjönsson working hexpm making sure graceful fallback older browser sonny scroggin contributing many area training newcomer people helped make phoenix today realtime web beginning phoenix focused taking realtime web goal make realtime communication trivial writing rest endpoint realized goal channel second clip collaborative editor give sense possible video channel give multiplexed connection server bidirectional communication phoenix also abstract transport layer longer concerned user connected whether websocket longpolling custom transport channel code remains write code abstracted socket phoenix take care rest even cluster machine message broadcasted across node automatically phoenix javascript client also provides api make clientserver communication beautifully simple look like beyond browser web framework phoenix target traditional browser application socalled web evolving need framework evolve phoenix transcends browser connecting browser iphones android handset smart device alike justin schneck eoin shanaghy david stump helped phoenix realize goal writing channel client objc swift c java appreciate enables justin demo phoenix chat application running apple watch iphone web browser powered native phoenix channel client productivity short term long term addition high connectivity phoenix give comfortable feature set get running quickly productive team software shortterm elixir leverage tried true pattern longterm project success maintainability erlang runtime designed system run many year minimal downtime using pattern runtime innovation deploy system selfheal support hotcode uploading capability known support million connected user box phoenix provides shortterm productivity project generation mix phoenixnew myapp livereload development make change template view asset see result immediately browser postgres mysql mssql mongodb resource ecto integration resource generator mix phoenixgenhtml user user name string age integer bootstrap project learn in out phoenix best practice precompiled view layer eex template lightning fast response time often measuring microsecond channel realtime communication longterm productivity next getting started strong stable core place building channel presence feature internationalization sure register elixirconf october find yet unannounced plan beyond phoenix neat thing happening elixir ecosystem josé valim also hosting phoenix webinar sept talk phoenix answer viewer question getting started join fun phoenix guide take basic get running quickly new elixir resource get speed jumping phoenix amazing ride getting started let show world elixir phoenix
417,Lobsters,elixir,Elixir programming,"asdf - extendable version manager for Ruby, Elixir, Erlang & Node.js",http://github.com/HashNuke/asdf,asdf extendable version manager ruby elixir erlang nodejs,asdfvm manage multiple runtime version single cli tool extendable via plugins doc asdfvmcom use asdfvm documentation please head documentation site information contributing contributingmd repo contributing section doc site community question github issue stackoverflow tag,asdfvm manage multiple runtime version single cli tool extendable via plugins doc asdfvmcom asdfvm cli tool manage multiple language runtime version perproject basis like gvm nvm rbenv pyenv one simply install language plugin use asdfvm single cli multiple language consistent command manage language single global config keeping default one place single toolversions config file per project support existing config file nodeversion nvmrc rubyversion easy migration automatically switch runtime version traverse directory simple plugin system add support language choice shell completion available common shell bash zsh fish documentation please head documentation site information contributing see contributingmd repo contributing section doc site community question github issue report bug raise feature request asdf core team stackoverflow tag see existing q asdf core team watch tag addition helpful community
418,Lobsters,elixir,Elixir programming,The Little Schemer in Elixir - exercises,https://github.com/jwhiteman/a-little-elixir-goes-a-long-way,little schemer elixir exercise,little schemer elixir note scheme http http downloadracketlangorg http wwwccsneueduhomematthiasbtls elixir note book note toy con magnificent number game oh gawd full star shadow friend relation lambda ultimate value http githubcomjwhitemanlighthousescheme,little schemer elixir repo contains exercise algorithm little schemer ported elixir well module contains scheme solution easy comparison also provided unit test could run test clone project cd repo directory run play around module repl run note scheme new recursion perhaps coming ruby definitely want buy book work pick http want run scheme code give dr racket try http downloadracketlangorg available mac linux window scheme code exercise run racket without problem official little schemer site http wwwccsneueduhomematthiasbtls worth checking extra pdf additional exercise found book elixir note elixir nt scheme exercise nt translate well others quite thing take work scheme trivial elixir due pattern matching case tried stick spirit exercise case tried leverage power pattern matching best ability hope variety make overall project valuable got interesting solution like see included create pull request except one two example made attempt make use elixir concurrency primitive book note table content general outline toy basic car con cdr basic recursion using simple list con magnificent list building basic filtering mapping number game true title working list number basic math oh gawd full star working list list shadow building first simple evaluator friend relation working set lambda ultimate currying continuation passing style combinator value build basic scheme elixir working book give enough knowledge get started building scheme interpreter mine http githubcomjwhitemanlighthousescheme bon appétit
419,Lobsters,elixir,Elixir programming,We all are going to meet in the Elixir world,http://codetunes.com/2015/we-all-are-going-to-meet-in-the-elixir-world/,going meet elixir world,elixir world piotr solnica successful company fail ruby rail elixirconfeu railsconf actioncable successful erlang vm incredible performance devs excited already ecto phoenix video recording kraków,snowball effect started ball remains quite small still big enough seen reach full speed soon nt want find avalanche start preparing today see going elixir world feel atmosphere perfectly written blog post piotr solnica rail may kill ruby many smart people leaving ruby already left ruby know many people already miss somebody told twitter happen maybe expert leave railsruby sorry given technology make expert leave serious technical issue longer understand happens industry time time successful company fail lecture given ed catmull pixar still valid guess valid forever hit strong thinking case nokia biggest strongest innovative company mobile phone industry easily eaten alive apple android phone two three year rest agony think could ruby rail necessary watch lecture nt yet instructive wo nt list wrong decision made people leaving notice time time twitter blog wo nt quit silently list constantly grow promise nt get wrong wo nt say rail bad framework ruby bad language still love learned lot thanks made huge improvement since first day joining ruby community world moving forward rail going fulfill need question attended elixirconfeu april time railsconf happening dhh announcing actioncable learned company moved multiple tool single one elixir attendee came ruby world spoke many speaking way looking something better tired rail monolithic design struggling thread safety heavy process elixir seems perfect solution u tired rubists beautiful syntax functional paradigm successful erlang vm incredible performance dozen smart people behind tip iceberg reason lot devs excited already need catch exception go back java whatever conference heard story guy able stop worrying cache completely elixir fast painful first sight migration missing tool also ease building support replacing better toolset saw real enjoyment possibility pleasure hacking around eg playing lego robot enjoyed every talk inspiring conference ever attended love fail fast strategy love pattern matching love pipe operator love ecto phoenix love compilator runtime error love erlang process easy run something background next year definitely going berlin elixirconfeu hope ready share success story watch video recording kraków dive language wo nt regret never want go back
420,Lobsters,elixir,Elixir programming,Elixir Streams,http://blog.drewolson.org/elixir-streams/,elixir stream,elixir stream wrote example standard library stream doc stream construction building api stream wrap,june elixir stream previously wrote explicitness elixir one favorite way language embrace explicitness distinction eager lazy operation collection time use enum module performing eager operation collection transformedmappedenumerated immediately use stream module performing lazy operation stream module provides many operation enum used stream describing future computation rather action taken immediately conveniently stream also implement enumerable protocol meaning use function within enum realize stream eagerly forcing computation take place using function inside enum see example example mix iex session elixir file help demonstrate concept example extremely simple example using streammap function iex streammap stream enum fun function used iex session help understand return value see stream struct returned detail important see storing function applied future rather actually performing computation data immediately force computation using enumtolist function iex streammap enumtolist look another example give u idea advantage stream provide traditional collection time operate range elixir range implemented stream meaning build large range without immediately realizing iex streammap number enumtake number number important thing understand example using streammap represent transform range item ever performing computation enumtake function asks item mean stream perform computation first item range extremely useful way represent computation large even infinitely large set data tractable way stream composable meaning perform arbitrary number computation stage efficiently large collection iex streamfilter streammap number enumtake number number standard library stream standard library provides several stream box already seen range quickly discus commonly used stream filestream function provides line default byte file form stream pleasant way consume file data myfiletxt filestream streammap streamwithindex streammap fn line line end enumtake ioinspect first line program lazily strip newline end line file add index beginning line take first line print asked first line file could extremely large program would still efficient another commonly used function return stream iostream might expect provides stream interface thing standard make previous program operate standard rather file iostream stdio line streammap streamwithindex streammap fn line line end enumtake ioinspect elixir fooex myfiletxt first line final example geneventstream function creates stream event genevent manager detail genevent beyond scope post say subject function interested read doc stream construction seen stream provided standard library elixir also provides several function stream module allow construct stream take look start simple constructor get progressively complex streamrepeatedly simple stream constructor build infinite stream calling provided function time item requested stream make infinite stream iex streamrepeatedly fn end enumtake next streamiterate take initial value function function called previous item stream starting initial value expected return next item make stream positive integer iex streamiterate enumtake talk streamunfold function complex also allows creating flexible stream unfold take two argument initial value generator function generator function called accumulator expected return tuple nextelement newaccumulator nextelement value represents next item stream newaccumulator passed generator function subsequent call use streamunfold make infinite stream fibonacci sequence fib streamunfold fn b b b end fib enumtake ioinspect note accumulator represents two number sequence need number generate next number last constructor function look streamresource function well suited building stream around external resource called providing best understood example use wrap api building api stream many resource provided api return paginated result want make pagination simple efficient consumer library invisible also performed actually need result given page first create github gateway module responsible communicating github api use httpoison http communication defmodule githubgateway use httpoisonbase endpoint http def endpoint endpoint end defp processurl url endpoint url end defp processrequestheaders header header authorization basic credential end defp credential config accesstoken xoauthbasic end defp config applicationgetenv myapp module end end gateway module assumes configured application personal access token response github contain two attribute relevant api link header request body link header tell u next page result exists request body json serialized collection result create module generates stream around api response given url use poison json parsing defmodule githubresultstream alias githubgateway def new url streamresource fn fetchpage url end fn end end defp fetchpage url response gatewayget url item poisondecode responsebody link parselinks responseheaders link item link next end def parselinks nil end def parselinks linksstring link stringsplit linksstring enummap link fn link name regexrun r rel az link url regexrun r link shorturl stringreplace url gatewayendpoint name shorturl end enuminto end defp processpage nil nil halt nil end defp processpage nil nextpageurl nextpageurl fetchpage processpage end defp processpage item nextpageurl item nil nextpageurl end end lot code focus piece piece def new url streamresource fn fetchpage url end fn end end new function return stream built using streamresource function provided fetch first page process page fetch new page necessary empty empty nothing clean look fetchpage next defp fetchpage url response gatewayget url item poisondecode responsebody link parselinks responseheaders link item link next end fetchpage use httpoisonbased gateway previously shown fetch url provided parse json body poison parse link header map link name url detail link parsing important finally look processpage defp processpage nil nil halt nil end defp processpage nil nextpageurl nextpageurl fetchpage processpage end defp processpage item nextpageurl item nil nextpageurl end processpage function three clause clause executed determined tuple passed function known pattern matching clause expected return tuple first element contains list item add stream second item value accumulator next call processpage look clause individually defp processpage nil nil halt nil end first clause handle case item next link mean reached last page added item stream stop paginating return special value halt tell streamresource stream ended defp processpage nil nextpageurl nextpageurl fetchpage processpage end second clause invoked case consumed item page nonnil next page link follow case fetch next page process defp processpage item nextpageurl item nil nextpageurl end third final clause case invoked item add stream return item first element tuple adding stream return tuple nil nextpageurl accumulator saying need item next url ok looked code required paginate github api response example little advanced others seen remarkably small amount code provide invisible lazy pagination arbitrary response github api finally use githubresultstream module expose nice api user fetching repository organization defmodule github alias githubresultstream def repos organization resultstreamnew orgs organization repos end end use new api fetch name repository elixirlang organization elixirlang githubrepos streammap fn repo repo fullname end enumtake elixirlangelixir remind reading code lazy meaning consume first page result get first name enumerablelike api allows user familiar thing result example could build stream name repository elixirlang tryghost organization using streamflatmap elixirlang tryghost streamflatmap streammap fn repo repo fullname end enumtake elixirlangelixir lazy efficient paginates result need pretty amazing wrap hope give sense power flexibility provided stream facility use library
421,Lobsters,elixir,Elixir programming,Monads in Elixir,http://zohaib.me/monads-in-elixir-2/,monad elixir,monad monadex maybe error reader writer state getting dependency operator monad maybe error railway oriented programming elixir reader writer state repo reference monad monadex three useful monad,post monad expect already know post see use monad elixir using already created library monad great way handling side effect functional language make code much readable maintainable composable elixir language bundled monad even powerful construct ie meta programming using metaprogramming add monad program use way feel like part language multiple monad library available elixir explored two library think complete implementation relatively monad monad monadex great library think monadex complete library required function use monad using rmiesmonad macro provided rmiesmonad feel like part language chain case robbronmonadex create anonymous function chain explore rmiesmonad library post see use following monad maybe error reader writer state getting dependency issue rmiesmonad library example wo nt work fixed issue include following dependency till send pull request fix go main repo monad git http githubcomzabiraufmonadgit branch develop operator bind bind operator like haskell instead pipe operator work bind operator specific block discus type bind operator f f b f b take wrapped value f function take value return wrapped value f b bind applies value wrapper function get another wrapped value currently operator functorfmap applicativeapply interested available monadex library monad let see example monad provided monadex library maybe maybe monad simplest return value either something nothing represented case something somevalue case nothing nothing nt create structs function defmodule examplemaybe require monadmaybe maybe import maybe division operator return something successfull otherwise case failure return nothing def mydiv return nothing maybefail nil end def mydiv numerator denominator return something result maybereturn numeratordenominator end sum always return something def mysum b return result maybereturn ab end def output x case isnothing x true ioputs value gotten false x fromjust ioputs end end successful scenario def opeartor maybep act bind val maybep maybereturn mysum mydiv end output val output end scenario division zero done def val maybep maybereturn mysum mydiv end output val output value gotten end end use monadp end block use bind operator function chained using becomes bind operator block function used return either something created maybereturn something return nothing using maybefail nil error error monad similar maybe monad instead nothing return error reason represented case valid value ok value case error error errorreason error monad missing required function extract value error structure depend directly structure let see example similar maybe monad example defmodule exampleerror require monaderror error import error division operator return ok result successfull otherwise case failure return error reason def mydiv return error reason errorfail division zero allowed end def mydiv numerator denominator return ok result errorreturn numeratordenominator end def mysum b sum always return ok result errorreturn ab end def output x case x error reason ioputs error reason ok value ioputs value end end successful scenario def opeartor errorp act bind operator val errorp errorreturn mysum mydiv end output val output end scenario division fails due division zero def val errorp errorreturn mysum mydiv end output val output error division zero allowed end end function used error monad return either ok something created errorreturn something return error reason using errorfail reason monad one recreated post railway oriented programming elixir use instead recreating hence making error handling much easier elegant reader reader monad used pas around context across function composition example reader monad include dependency injection want pas external dependency across function passing configuration passing user request reader monad pass whatever want silently ie nt make argument get value anytime function let see example defmodule examplereader require monadreader reader import reader create greeting string getting name argument getting greeting reader monad def greeting name value reader read readerm block readerm getting greeting calling ask function greeting ask return greeting name end end greeting hello put exclamation mark otherwise add end string def done input readerm greeting ask case greeting hello true return input false return input end end end add new line whatever string get def addnewline input return input n end output hello zohaib n def use run function call put value execute function value context compose function using operator act bind operator readerp block run hello readerp return zohaib greeting done addnewline end end output welcome zohaibn def run welcome readerp return zohaib greeting done addnewline end end end use return function want composition want read value context readerm end block ask value variablename ask simple compose function use readerp end block use pipe operator compose function use run function first argument passed across function second argument function composition function writer writer monad name suggests ie allows write value good example using writer monad log operation let see example defmodule listwriter use monadwriter called writer monad started initialize def initial end called whenever put new value writer def combine new acc acc new end end defmodule examplewriter import listwriter return sum write log writer def mysum b want write call tell created writer block defined listwriter case listwriterm listwriterm tell adding b return ab end end return subtraction write log writer def mysubtraction b listwriterm tell subtracting b return ab end end output adding subtracting def run writer monad calling run pas function composition function operator becomes bind p block writer defined listwriter listwriterp block run listwriterp return mysum mysubtraction end end end create module implement method required writer monad example created listwriter implement two required function initial combine new acc initial initialize structure value written combine new acc write new value acc accumulated value module defined external module used way use function use listwriterm end block use tell write value turn call combine function add value structure function use return return whatever want compose function chaining using pipe operator listwriterp end block output adding subtracting first elment result function second element list log wrote state state monad similar reader monad along reading value also write value hence maintaining side effect across function functional maintainable way defmodule examplestate require monadstate state import state return sum increment state def mysum b use get read state use put write state function called statem block statem x get put return ab end end return subtraction increment state def mysubtraction b statem x get put return ab end end output def call run run state monad run statep return mysum mysubtraction end end end monad use statem end block function want read write state call variablename get get state put newstate update state example pas increment function called end output first value output composition second state end get example git repo reference monad monadex three useful monad
422,Lobsters,elixir,Elixir programming,Sanity Tests,http://blog.drewolson.org/sanity-tests/,sanity test,sanity test wikipedia elixir exspec exunit freezing migration ecto activerecord migration valid test file use,may sanity test common test plethora definition sanity test different wikipedia say following subject sanity test determines whether possible reasonable proceed testing implies sanity test sort determine testing even make sense however think sanity testing breaking fourth wall codebase believe sanity testing test assumption codebase rather behavior code found sanity testing extremely useful saving time allowing future contributor avoid common pitfall well codifying codebase convention make concept sanity test explicit example elixir codebase working recently note test use exspec library add simple bddlike syntax exunit freezing migration many application use library interact database tool often provide facility codifying database schema modifying time pass concept generally called short elixir ecto library provides migration feature similar activerecord migration file live codebase version control system often several member team modifying migration time fine long migration yet run production environment run production however would like ensure migration codebase never change future want make change migration need write brand new migration perform change write sanity test enforce rule defmodule myappsanitytest use exspec migrationhashes describe frozen migration change deployed glob pathjoin dir priv repo migration enumeach pathwildcard glob fn filename file pathbasename filename expectedhash migrationhashes file expectedhash hash filename fileread assert hash expectedhash end end end end defp cryptohash erlangbinarytolist enummap iolibformat listflatten erlanglisttobitstring end end test iterates migration within privrepomigrations filename specified migrationhashes verifies file content expected value new release project created migration released added migrationhashes map team member accidentally modifies migration already deployed test fail gently reminded create new migration valid test file accidentally created test file elixir test directory named properly either forget end test filename testexs remember correct filename accidentally use ex extension rather ex error particularly painful manifest simply running test file prime candidate sanity test write one defmodule myappsanitytest use exspec describe test file check test file named properly exclusion w testhelperexs testglob pathjoin dir badfiles testglob pathwildcard enummap enumreject filedir enumreject stringendswith testexs enumreject fn path enumany exclusion match path end assert badfiles end end defp match string pattern isbinary pattern stringendswith string pattern end defp match string pattern stringmatch string pattern end end find test file exclude properly named ending testexs also exclude file explicitly named exclusion list exclusion either string literal specifying explicitly end excluded name regexs match number file allows u exclude file test like testhelperexs follow convention ending testexs accidentally add test file malformed name sanity fail saving u countless hour lot frustration use hope two example convey usefulness sanity test tool saving time well conveying pattern idiom next time think believe consider writing sanity test stop making mistake future
423,Lobsters,elixir,Elixir programming,"Reducees: Elixir's abstraction for eager or lazy operations, in-memory or I/O",http://blog.plataformatec.com.br/2015/05/introducing-reducees/,reducees elixir abstraction eager lazy operation inmemory io,recursion elixir elixir functional programming language introducing iterators introducing reducer reducer reference type take implementation introducing iteratees attended talk jessica kerr scalazstream monadreader issue introduces iteratees introducing reducees eager v lazy enum stream enum stream,elixir provides concept collection may inmemory data structure well event io resource collection supported enumerable protocol implementation abstraction call reducees article outline design decision behind abstraction often exploring idea haskell clojure scala eventually led u develop new abstraction called reducees focusing specially constraint performance characteristic erlang virtual machine recursion elixir elixir functional programming language run erlang vm example article written elixir although introduce concept bit bit elixir provides linkedlists list hold many item pattern matching easy extract head first item tail rest list iex ht iex h iex empty list match pattern ht ht matcherror match right hand side value suppose want recurse every element list multiplying element let write double function defmodule recursion def double ht h end def double end end function recursively traverse list doubling head step invoking tail could define similar function wanted triple every element list make sense abstract current implementation let define function called map applies given function element list defmodule recursion def map ht fun fun h map fun end def map fun end end double could defined term map follows def double list map list fn x x end end manually recursing list straightforward really compose imagine would like implement functional operation like filter reduce take list introduce set dictionary queue language would like provide operation instead manually implementing operation data structure better provide abstraction allows u define operation work different data structure next step introducing iterators idea behind iterators ask data structure next item data structure longer item emit let implement iterators list time using elixir documentation doctests detail expect iterators work defmodule iterator doc step need return tuple containing next element payload invoked next time around iex next iex next iex next iex next done def next ht h end def next done end end implement map top next def map collection fun mapnext next collection fun end defp mapnext h fun fun h mapnext next fun end defp mapnext done fun end since map us next function long implement next new data structure map future function work box brings polymorphism desired downside besides ideal performance quite hard make iterators work resource event io etc leading messy errorprone code trouble resource something go wrong need tell resource closed want leave file descriptor database connection open mean need extend next contract introduce least one function called halt halt called iteration interrupted suddenly either longer interested next item example someone call take collection retrieve first five item error happened let start take def take collection n takenext next collection n end invoked every step defp takenext h n n htakenext next n end reach collection finished defp takenext done n end reach took cared finishing defp takenext value halt value invoke halt sideeffect resource end implementing take somewhat straightforward however also need modify map since every step user supplied function fail therefore need make sure call halt every possible step case failure def map collection fun mapnext next collection fun end defp mapnext h fun try fun h rescue e invoke halt sideeffect resource case failure reraise halt raise e endmapnext next fun end defp mapnext done fun end elegant performant furthermore error prone forget call halt particular point endup dangling resource may never closed introducing reducer long ago clojure introduced concept reducer since elixir protocol heavily inspired clojure protocol excited see take collection processing instead imposing particular mechanism traversing collection iterators reducer sending computation collection collection applies computation announcement thing know apply function collection collection instead using next function reducer expect reduce implementation let implement reduce function list defmodule reducer def reduce ht acc fun reduce fun h acc fun end def reduce acc fun acc end end reduce easily calculate sum collection def sum collection reduce collection fn x acc x acc end end also implement map term reduce list however reversed end requiring u reverse back def map collection fun reversed reduce collection fn x acc fun x acc end call erlang reverse implemented c performance listsreverse reversed end reducer provide many advantage conceptually simpler faster operation like map filter etc easier implement iterators one since recursion pushed collection instead part every operation open door parallelism operation longer serial contrast iterators conceptual change required support resource collection last bullet important u collection one applying function need change map support resource need implement reduce pseudoimplementation reducing file line line def reduce file acc fun descriptor fileopen file try reducenext ioreadline descriptor acc fun fileclose descriptor end end defp reducenext line descriptor acc fun reducenext ioreadline descriptor fun line acc fun end defp reducenext done acc fun acc end even though file reducer us something look like iterator best way traverse file map function perspective care operation used internally furthermore guaranteed file closed reducing regardless success failure however two issue implementing reducer proposed clojure elixir first operation like take implemented purely functional way example clojure relies reference type take implementation may issue depending languageplatform certainly clojure issue elixir sideeffects would require u spawn new process every time take invoked another drawback reducer collection one controlling reducing implement operation like zip requires taking one item collection suspending reduction taking item another collection suspending starting resuming first one least purely functional way reducer achieve goal single abstraction work efficiently inmemory data structure resource however limited amount operation support efficiently purely functional way continue looking introducing iteratees code mesh first heard iteratees attended talk jessica kerr first minute described exactly mind moment iterators reducer indeed limitation solved scalazstream talk jessica started explore scalazstream solves problem eventually leading u monadreader issue introduces iteratees experiment prototype iteratees working elixir iteratees instruction going source reducing function telling next step collection processing defmodule iteratee doc enumerates collection given instruction instruction cont fun tuple given function invoked h entry collection otherwise done given instruction halt acc mean nothing process collection halt def enumerate ht cont fun enumerate fun h end def enumerate cont fun fun done end def enumerate halt acc halted acc end end enumerate defined write map def map collection fun done acc enumerate collection cont mapper fun listsreverse acc end defp mapper acc fun fn h cont mapper fun h acc fun done done acc end end enumerate called cont mapper mapper receive h done defined enumerate mapper function either return cont mapper new mapper function done acc collection told new item emitted monadreader publication defines iteratees teaching fold reduce new trick precisely done example map return cont mapper could returned halt acc would told collection halt take could implemented iteratees would send cont instruction longer interested new element finally returning halt iteratees allow u teach reduce new trick much harder grasp conceptually function implemented iteratees time slower elixir compared reducer counterpart fact even harder see iteratees actually based reduce since hide accumulator inside closure mapper function case also cause performance issue elixir mapped element collection need generate new closure becomes expensive mapping filtering taking item multiple time asked could keep learned iteratees maintaining simplicity performance characteristic reduce introducing reducees reducees similar iteratees difference clearly map reduce operation create closure traverse collection let implement reducee list defmodule reducee doc reduces collection given instruction accumulator function instruction cont acc tuple given function invoked next item accumulator instruction halt acc mean nothing process collection halt def reduce ht cont acc fun reduce fun h acc fun end def reduce cont acc fun done acc end def reduce halt acc fun halted acc end end reducee implementation map cleanly original reduce implementation difference accumulator always wrapped tuple containing next instruction well addition halt checking clause implementing map requires u send instruction reduce def map collection fun done acc reduce collection cont fn x acc cont fun x acc end listsreverse acc end compared original reduce implementation def map collection fun reversed reduce collection fn x acc fun x acc end listsreverse reversed end difference implementation accumulator wrapped tuples effectively replaced closure iteratees twoitem tuples reducees provides considerably speed term performance tuple approach allows u teach new trick reducees example initial implementation already support passing halt acc instead cont acc use implement take top reducees def take collection n n acc reduce collection cont n fn x acc count takeinstruction count xacc end listsreverse acc end defp takeinstruction halt defp takeinstruction n cont accumulator given reduce hold list collect result well number element still need take collection taken last item count halt collection end day abstraction ship elixir solves requirement outlined far simple fast work inmemory data structure resource collection support take zip operation purely functional way eager v lazy elixir developer mostly need worry underlying reducees abstraction developer work directly module enum provides series operation work collection example iex enummap fn x x end function enum eager map operation receives list immediately return list none le take long u add lazy variant operation iex streammap fn x x end stream function stream lazy store computation performed traversing collection desired computation expressed addition stream module provides series function abstracting resource generating infinite collection word elixir use abstraction provide eager lazy operation accepts inmemory data structure resource collection conveniently encapsulated enum stream module allows developer migrate one mode operation needed p enormous thank jessica kerr introducing iteratees pairing code mesh also thanks jafar husein conversation code mesh team behind rx exploring next finally thank james fish pater hamilton eric meadowsjönsson alexei sholik countless review feedback prototype regarding elixir future
425,Lobsters,elixir,Elixir programming,Indiegogo: Record All LambdaConf 2015 Talks,https://www.indiegogo.com/projects/record-all-lambdaconf-2015-talks,indiegogo record lambdaconf talk,,
426,Lobsters,elixir,Elixir programming,The need for timezone awareness,http://www.creativedeletion.com/2015/05/10/the-need-timezones.html,need timezone awareness,pitfall time computer software validate datetime place observes dst code take dst account calendar utc user time zone tz database measuring interval two datetimes adding another timezone timezone aware default calendar,good way avoid pitfall time computer software explicit timezones use library handle timezones software used single timezone might think timezones necessary think aware timezone necessary situation people assume statement true probably need use timezone aware datetime library need validate datetime utc nonutc datetime location observes daylight saving time dst instance europe north america make software operates single timezone really need timezone library likely timezone observes daylight saving time hard validate given point time without validate datetime place observes dst code take dst account timezone aware datetime library compare one timezone another also know dst happens timezone following happens country observe dst spring hour usually skipped clock set forward hour simply exist wall time end user work local time want make sure time entered valid enough simply check march might valid time timezones timezone aware timezone library validate example calendar elixir date time library designed wall time valid one timezone another datetimefromerl europelondon ok calendardatetime day hour min timezone europelondon datetimefromerl europecopenhagen error invaliddatetimefortimezone furthermore entered date time switch dst usually autumn time ambiguous need compare entered datetime datetimes need ask user entered datetime clock set back datetimefromerl europecopenhagen ambiguous calendarambiguousdatetime possibledatetimes calendardatetime abbr cest stdoff calendardatetime abbr cet stdoff utc user time zone even user system timezone probably want server software work utc utc ambiguity timezones user entered future datetime want alerted hour compare server time entered datetime issue alert one hour order compare utc entered datetime need know timezone timezone mean simply integer utc offset certain date utc offset change want timezone name tz database americanewyork measuring interval two datetimes imagine user enters two datetimes march march need find much time two usually difference would exactly three hour timezones spring forward event clock set forward one hour took place two datetimes zone difference two datetimes two hour three quite big difference user like people watch set utc would need know timezone entered time belong order calculation correctly timezone library handle iex atfour datetimefromerl europestockholm iex atone datetimefromerl europestockholm iex datetimediff atfour atone ok second two hour case example really check timezone us dst switch back forth dst input wall time timezone library handle rest adding another timezone far example timezone awareness necessary even one user us one timezone suddenly need software used people one timezone course easier software already taken timezones account timezone aware default made calendar made sure api designed timezone awareness default datetime explicitly tell library timezone belongs create valid datetime struct either provide valid timezone name use another module called naivedatetime naïve sound bit le confidence inspiring datetime take longer type purpose hope name alone make people think twice using datetime case get away ignoring timezones dst really sure know working date time easy rocket science either secret dst mean hour skipped repeated programmer ignore live consequence use library handle
427,Lobsters,elixir,Elixir programming,Elixir - The next big language for the web,http://www.creativedeletion.com/2015/04/19/elixir_next_language.html,elixir next big language web,elixir language obscurity default choice erlang handling ten thousand concurrent connection one machine seen challenging game server infrastructure handled erlang elixir pipe operator immutability functional programming concurrency git subversion web framework phoenix μs programmer happiness beautiful code déjà vu book language,article explain think elixir language make big impact world web development obscurity default choice first short tale another language went largely unknown well known started using ruby classmate university release web framework could write software much fewer line code java combination ruby new web framework felt much better web development using php client wanted redo ecommerce site convinced rewrite ruby use new framework called rail ever since programming ruby professionally back could look download graph rail ruby obvious rail driving downloads ruby rail took ruby obscurity year later even many nonprogrammers heard web framework interesting see quickly rail went used handful people itframework default choice startup needed web based software traded stock market market cap billion dollar one twitter twitter experiencing tremendous growth user traffic decided change core part infrastructure ruby scala way scala handle concurrency made easier twitter handle growth erlang ericsson equipment mounted lighthouse cabo polonio uruguay view lighthouse cabo polonio uruguay another language functional even longer history handling massive concurrency erlang made ericsson allow better development telephony application use data phone likely data going equipment ericsson run erlang ever thought phone operator disconnect everyone phone call order apply software update erlang made allow phone switch system run continuously support hotswapping software update software running whatsapp hundred million user platform handling ten thousand concurrent connection one machine seen challenging whatsapp individual server million concurrent connection million connection single server handled erlang erlang also popular game server million user play multiplayer game game server infrastructure handled erlang title call duty game war erlang platform many advantage serving reliable scalable internet application proven track record around decade popular choice web development think part erlang easy get running new website think language hard learn often people take path least resistance erlang syntax look bit strange used looking language c java javascript php ruby perl etc thing like package management build tool metaprogramming unicode handling web framework straight forward language ruby elixir area addressed elixir elixir creator josé valim said liked everything saw erlang hated thing see elixir package management system macro easy use build tool unicode handling elixir language run erlang vm benefit mature battle proven system use existing erlang library performance penalty elixir add bunch nicety one pipe operator difference erlang elixir syntax syntax matter especially ruby developer elixir syntax familiar immutability functional programming elixir functional language immutability worked immutable data realized beneficial even single threaded programming mutability brings uncertainty program execute miss mutability functional programming immutability help clarify thing make easier reason code concurrency another strong point elixir concurrency concurrency stay several reason mention trend hardware cpu core cpu manufacturer going improve single core performance rate instead adding core also world concurrent want end user software service needlessly wait response single threaded software busy language concurrency bit pain dangerous hard synchronization mutable state forking native process also often slow us lot memory concurrency erlang elixir versus language bit like branch git v subversion subversion complicated never git lot easier time elixir easy create new process performs well situation call straightforward integral part platform require separate library note erlangelixir process native process much light weight scheduled erlang beam virtual machine web framework phoenix popular web framework elixir right creator elixir rail core member creator phoenix also background working rail desire simply recreate rail elixir mean phoenix also relatively easy get started rail set certain minimum standard regard one exciting feature real time capability channel javascript client elixir server cluster single visitor website process server real time connection open possibility present traditional web framework way seeing μs microsecond symbol web server log sub response time quite nice efficiency speed important end user experience also mean le waste energy money server programmer happiness beautiful code language faster ruby still good reason use instance ruby java nice language work relatively quickly write concise code maybe java code could perform better many case java code would fun quick write easily maintainable argument buying powerful server make reasonable tradeoff case make choice elixir feel like trade joy speed development performance reliability concurrency benefit erlang vm elixir provides erlang benefit performance reliability without giving productivity benefit ruby déjà vu like ruby year ago feel new platform much better solution gut feeling rational argument back another similarity dave thomas also excited elixir written book language everything aligned elixir next new big thing web development last year ruby python popular choice web think likely year elixir instead goto language new web project
429,Lobsters,elixir,Elixir programming,Panel on language design with the creators - Erlang Factory '15,http://www.youtube.com/watch?v=oZwfi8JZ3kU,panel language design creator erlang factory,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature erlang factory sf panel discussion youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature erlang factory sf panel discussion youtube
430,Lobsters,elixir,Elixir programming,Erlang Factory SF 2015 - Jose Valim - What Elixir is about,http://www.youtube.com/watch?v=Lqo9-pQuRKE,erlang factory sf jose valim elixir,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature erlang factory sf jose valim elixir youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature erlang factory sf jose valim elixir youtube
431,Lobsters,elixir,Elixir programming,Railway Oriented Programming in Elixir,http://zohaib.me/railway-programming-pattern-in-elixir/,railway oriented programming elixir,scott wlaschin r p rop handle error helper macro putting together validate request get user update db send email return http message could next hex gist reference railway oriented programming f fun profit,would great world everything ran without error validating input user handling various kind error ranging database access file access network issue reality software written program case handling erros much increase codebase manifold make life maintainer hell yet something done even simplest program changed handle various kind error make code inelegant started learning functional programming breeze write software without introducing common bug error handling still reality wondering error handling done elegant way stumbled upon talk scott wlaschin describe railway oriented programming rop great design pattern follow allows create functional program handle error yet readable code error handling request validaterequest getuser updatedbfromrequest sendemail returnhttpmessage code error handling request validaterequest map getuser tee updatedbfromrequest trycatch sendemail returnhttpmessage handle error typical application contains data set operation performed usually error imperative language handled try catch checking operation function returned expected return error cause lot defensive coding adding lot code hence making difficult reason let take handle error functional paradigm better way let say function return either ok data case success return error failure reason case failure call function twotrack function chain function case error dont want execute rest function instead bypass railway metaphor work really well railway track take case success switch track case failure elixir awesome good support currying function like haskell f macro let see create operator allows u switch track chain twotrack function defmacro left right quote fn case unquote left ok x x unquote right error expr expr end end end end operator macro call bind operator create anonymous function check data ok call next function otherwise bypass calling function go next step way error place track bypass function end get error handle way chain multiple function handle error end logging returning error helper macro creating twotrack function let face function bad function always trust return valid thing valid thing never throw error create another macro always change output function success twotrack function output defmacro map args func quote fn result unquote args unquote func ok result end end end call function change output ok result format chained function bind operator request namenotblank map nametrim example nametrim function call stringrstrip name request return updated request know always result success hence create singletrack function twotrackfunction using map macro deadend function function something meaningful wont return anything meaningful want chain function request validate updatedb sendemail example updatedb function update db return something dont want pas sendemail function create tee macro call deadend function return input back output defmacro tee args func quote fn unquote args unquote func ok unquote args end end end tee macro call function return input back chaining would follows request validate tee updatedb sendemail function throw exception function still throw error dont return twotrack output ie ok error create another helper macro change function throw exception twotrack output uncreatively name trycatch defmacro trycatch args func quote fn try ok unquote args unquote func rescue e error e end end end end macro try rescue case exception convert exception error pattern case success convert ouput ok pattern putting together macro let see chain multiple function different behaviour using bind operator following function perform request user validate request twotrack function validates request value get user onetrack get user update db deadend update db return anything chained function hence deadend function whose output dont care send email throw exception send email standard function throw exception return http message twotrack convert function appropriate http message request validaterequest map getuser tee updatedb trycatch sendemail returnhttpmessage helper kind helper macrosfunction well supervisor macrofunction allows handle success error input instead bypassing error think term helper would able make code easy understand much maintainable could next think would great hex package provides kind helper macro function make rop much easier elixir anyone leverage project currently created gist contains macro disclaimir started learning metaprogramming elixir might better way implementing macro thing let know think love hear reference railway oriented programming f fun profit would recommend go talk interested rop nt convered thing
432,Lobsters,elixir,Elixir programming,An Empathetic Functional Language,http://blog.drewolson.org/an-empathetic-functional-language/,empathetic functional language,empathetic functional language natural syntax inviting community extraordinarily involved creator tooling peeling onion otp great book rubber meet road work,march empathetic functional language writing elixir code year never excited prospect language community language young promising many smart people getting involved hell trajectory language released merely month ago wondering specifically elixir pulled prompted involvement community word empathy specifically empathy user empathy demonstrated variety way many extensively discussed natural syntax inviting community extraordinarily involved creator tooling like discus something different becoming apparent significant time using language peeling onion one powerful way elixir show empathy user creating layer abstraction natural path learning language emerges via layer slowly introduces new user increasingly different challenging powerful concept interesting many language succeed teaching newcomer guiding learning process believe interesting elixir also posse many characteristic traditionally thought challenging elixir functional language state though pattern representing statelike thing concurrent language us actor model message passing homoiconic yet even feature language manages make learning process feel natural talk concrete example dove elixir way many via interactive shell iex allowed toy around syntax call function define simple module next created standalone file elixir conveniently provides ex extension script run directly compilation happens inline let try complex idea even build little script real job created project standard directory structure used dependency provided mix hex time yet dip toe terrifying water known otp finally confidence earlier success started reading working otp concept elixir provides borrowing wrapping concept erlang successful even though failed previous attempt learn otp erlang confidence grew elixir tool support remain steadfast face truly new concept still write many macro luckily great book available empathy language everpresent learning process standard library clear well documented community helpful many great learning resource fundamentally language never seemed force learn many new thing time pushed language asked appropriate amount return small challenge always seemed give return investment put learning positive reinforcement cycle exhilarating empowering ride rubber meet road empathetic reinforcement cycle manifest elixir community many way language project structure allow individual participate project heavily relies otp without knowing single thing elixir project tend use otp backbone building familiar abstraction easier broad spectrum developer comprehend work provide pattern newcomer comprehend quickly use make meaningful contribution exciting tool community hard positive language helping push forward within week getting involved built small internal application work elixir surprised number contribution teammate deep experience functional language others never used functional language elixir allowed provide simple clear familiar pattern willing contributor could follow regardless prior programming paradigm experience best part though hook set becomes exciting challenging learn complex powerful aspect functional programming elixir watereddown functional programming language quite opposite focus empathy concert attribute however feel unique wonderful update removed reference elixir functional language
433,Lobsters,elixir,Elixir programming,"Build and test a JSON API with Phoenix, an Elixir framework",https://robots.thoughtbot.com/testing-a-phoenix-elixir-json-api,build test json api phoenix elixir framework,updated blog post phoenix phoenix guide elixir mix getting started ecto ectomigration doc exunitcasetemplate elixir buildpack,note guide written phoenix part may longer work using newer version using newer version phoenix check updated blog post let build json api serf list contact writing using elixir phoenix phoenix framework written elixir aim make writing fast low latency web application enjoyable possible go installing elixir phoenix see phoenix guide get started erlang ferrari wrapped sheet metal old beater immense power many people look ugly used whatsapp handle billion connection many people struggle unfamiliar syntax lack tooling elixir fix built top erlang beautiful enjoyable syntax tooling like mix help build test work application efficiently phoenix build top elixir create low latency web application environment still enjoyable blazing fast application enjoyable development environment longer mutually exclusive elixir phoenix give response time phoenix often measured microsecond instead millisecond discussed might want build something framework let build something see getting started phoenix website see create new app called hellophoenix using phoenix exercise phoenix app setup let start writing test let create file testcontrollerscontactcontrollertestexs defmodule hellophoenixcontactcontrollertest use exunitcase async false use plugtest alias hellophoenixcontact alias hellophoenixrepo alias ectoadapterssql setup sqlbegintesttransaction repo onexit fn sqlrollbacktesttransaction repo end end test index return list contact contactsasjson contact name gumbo phone repoinsert listwrap poisonencode response conn get apicontacts sendrequest assert responsestatus assert responserespbody contactsasjson end defp sendrequest conn conn putprivate plugskipcsrfprotection true hellophoenixendpointcall end end write setup function wrap ecto call transaction ensure database always empty start test test would expect use plugtest give u access function creating test connection test insert new contact wrap list encode create new connection send request assert response successful body contains list contact encoded json run mix test see error undefined expand struct hellophoenixcontact mean yet created model let use ecto hooking postgres database ecto us repository saving retrieving data database phoenix already come repo set default configuration make sure postgres username password correct configdevexs configtestexs let see new mix task get ecto running mix h grep ecto see number task use let create dev test database add first model create dev database mix ectocreate create test database env mixenvtest mix ectocreate let add schema contact webmodelscontactex defmodule hellophoenixcontact use ectomodel schema contact field name field phone timestamps end end next create migration mix ectogenmigration createcontacts newly generated migration write defmodule hellophoenixrepomigrationscreatecontacts use ectomigration def change create table contact add name add phone timestamps end end end default column type ecto migration string see else check ectomigration doc run mix ectomigrate create new table test mixenvtest mix ectomigrate let get api endpoint route look like apicontacts webrouterex defmodule hellophoenixrouter use phoenixrouter pipeline api plug accepts json end scope api hellophoenix pipethrough api resource contact contactcontroller end end coming rail note apicontactsjson result found expected set appropriate request header pinch apicontacts formatjson recommended trailing format param added performance reason http header already enable functionality run mix test see still need contactcontroller undefinedfunctionerror undefined function module hellophoenixcontactcontroller available let create controller webcontrollerscontactcontrollerex defmodule hellophoenixcontactcontroller use hellophoenixweb controller alias hellophoenixrepo alias hellophoenixcontact plug action def index conn params contact repoall contact render conn contact contact end end first make sure get contact repoall contact render json function automatically imported call use hellophoenixweb controller check webwebex see else imported run mix test test pas quite yet undefinedfunctionerror undefined function module hellophoenixcontactview available need view render json view handle output json right pretty simple future could change send based user permission example let create file webviewscontactviewex defmodule hellophoenixcontactview use hellophoenixweb view def render indexjson contact contact contact end end use pattern matching set return contact phoenix automatically encode array contact json use view function customize json presented cover later post point run mix test test pas let check hellophoenixweb webwebex cleanup app bit open file see controller function already alias hellophoenixrepo def controller quote auto generated import macro function controller need use phoenixcontroller auto inserted app generated alias repo convenience alias hellophoenixrepo import router helper generate path like apicontactspath conn import hellophoenixrouterhelpers end end mean controller remove alias hellophoenixrepo let use exunitcasetemplate clean test bit testtesthelperexs add exunitstart defmodule hellophoenixcase use exunitcasetemplate alias ectoadapterssql alias hellophoenixrepo setup sqlbegintesttransaction repo onexit fn sqlrollbacktesttransaction repo end end using quote alias hellophoenixrepo alias hellophoenixcontact use plugtest remember change defp def ca nt used test def sendrequest conn conn putprivate plugskipcsrfprotection true hellophoenixendpointcall end end end end adding code using make function alias available every test make remove alias test replace use hellophoenixcase defmodule hellophoenixcontactcontrollertest use hellophoenixcase async false removed alias since already included hellophoenixcase also removed setup macro test index return list contact contactsasjson contact name gumbo phone repoinsert listwrap poisonencode response conn get apicontacts sendrequest assert responsestatus assert responserespbody contactsasjson end also removed function definition end seen create test phoenix json api also learned cleanup file make easier use module controller test future using hellophoenixweb exunitcasetemplate deploy app heroku elixir buildpack
