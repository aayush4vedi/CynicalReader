ID,Source,Tag_Code,Tag_Name,Title,Url,ProcessdedTitle,WeightedContent,Content
1,Lobsters,d,D programming,Porting a Golang and Rust CLI tool to D,https://pingfrommorocco.blogspot.com/2020/08/porting-golang-and-rust-cli-tool-to-d.html,porting golang rust cli tool,paulo henrique cuchi shared experience writing command line tool rust go comment source code github end using local environment manual interactive installer editor support one blog post visuald package management rpassword getpass support recommendation library graphqld request ufcs error handling discussion websockets continuous integration memory usage redditor skocznymroczny experimental memory management methodology binary size built go build ldflags w conclusion curl,day ago programming subreddit paulo henrique cuchi shared experience writing command line tool rust go tool question client side project hashtrack hashtrack expose graphql api client track certain twitter hashtags get real time list relevant tweet prompted comment decided write port demonstrate used achieve similar goal try keep structure one used blog post source code github end using main reason original blog post compared statically typed language like go rust made honorable mention nim crystal nt mention fall category think make interesting comparison also like language mentioned various blog post local environment manual lengthy page download install reference compiler dmd window user get installer macos user use homebrew ubuntu simply add apt repository perform normal apt installation get dmd also dub package manager installed rust idea easy would get running surprised easy run interactive installer took care rest add cargobin path think probably restarted console change take effect editor support wrote hashtrack vim without much difficulty probably familiarity everything go standard library documentation open time occasionally used symbol nt import right package called function wrong argument note far standard library concerned import std everything disposal third party library though curious state tooling looked plugins favourite ide intellij idea found one installed also instealled dcd dscanner cloning respective repos building configuring idea plugin point right path shout author blog post explaining process ran issue first fixed updating ide plugin one problem could nt recognize package kept marking possibly undefined later discovered put module nameofthepackage top file order recognized think still bug nt recognize length least machine opened issue github follow curious window heard good thing visuald package management dub defacto package manager fetch installs dependency http codedlangorg project needed http client nt feel like using curl ended fetching two dependency request dependency cachetools dependency reason though fetched twelve dependency think dub us internally sure rust downloaded lot crate probably rust version code feature mine example fetched rpassword tool hide password character type terminal much like python getpass function one many thing nt code added getpass support linux thanks recommendation also added terminal text formatting thanks escape sequence copied original go source code library little knowledge graphql idea begin graphql search codedlangorg led relevant library aptly named graphqld looking though struck vibed plugin actual client thing inspecting network request firefox realized project could mimic graphql query mutation would send http client response json object parse tool provided stdjson package mind started looking http client settled request simple use http client importantly one reached certain level maturity copied outgoing request network inspector pasted separate graphql file imported sent appropriate variable bulk functionality put graphqlrequest structure wanted inject different endpoint configuration requirement project struct graphqlrequest string operationname string query jsonvalue variable config configuration jsonvalue tojson return jsonvalue operationname jsonvalue operationname variable variable query jsonvalue query string tostring return tojson toprettystring response send auto request request requestaddheaders authorization configurationget token return requestpost configurationget endpoint tostring applicationjson snippet session package following code handle authentication struct session config configuration void login string username string password auto request createsession username password auto response requestsend responsethrowonfailure string token responsejsonbody data object createsession object token str configurationput token token graphqlrequest createsession string username string password enum query import createsessiongraphql linesplitter join n auto variable sessionpayload username password tojson return graphqlrequest createsession query variable configuration struct sessionpayload string email string password todo make template mixin something jsonvalue tojson return jsonvalue email jsonvalue email password jsonvalue password string tostring return tojson toprettystring spoiler alert never todo go like main function creates config struct command line argument injects session struct implement functionality login logout status command createsession method construct graphql request reading actual request appropriate graphql file passing variable along nt want pollute source code graphql mutation query moved graphql file import compilation help enum import latter requires compiler flag point stringimportpaths default view login method sole responsibility sending http request handling response case handle potential error though thoroughly store token config file really nothing glorified json object throwonfailure method part core functionality request library actually helper function quick dirty error handling void throwonfailure response response responseissuccessful error responsejsonbody string error responseerrors throw new requestexception errorsjoin n since support ufcs throwonfailure response syntax rewritten responsethrowonfailure make integrate seemlessly builtin method like send may abused feature throughout project error handling pretty much favor exception come error handling rationale explained detail one thing like unhandled error eventually get reported unless explicitely silenced able get away simplistic error handling example line string token responsejsonbody data object createsession object token str configurationput token token response body nt contain token object object leading throw exception bubble main function explode face user using go would careful handling error every stage honest since annoying write err null every time call function would tempted ignore understanding go however primitive would nt surprised compiler barked anything error return value feel free correct wrong rust style error handling explained original post interesting nt think anything like standard library discussion implementing third party library websockets want quickly mention nt use websockets implement watch command tried using vibed websocket client could nt get work hashtrack backend kept closing connection ended dropping favor polling even though frowned upon client work since tested another websocket server might come back future continuous integration ci set two build job normal build feature branch release master provide optimized build form downloadable artifact memory usage ran usrbintime v hashtrack list command measure memory usage explained original article nt know memory usage depends hashtags logged user follows result built dub build b release maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes bad ran go rust version hashtrack user got result go built go build ldflags w maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes rust built cargo build release maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes edit redditor skocznymroczny recommended test ldc gdc addition dmd result ldc built dub build b release adding colored output getpass maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes garbage collection also support smart pointer recently experimental memory management methodology inspired rust really sure well feature integrate standard library decided let gc handle memory think result pretty good considering nt memory consumption mind writing code binary size rust built cargo build release built dub build b release built dub build b release go built go build go built go build ldflags w conclusion think solid language writing command line tool like nt reach external dependency often standard library needed thing like parsing command line argument handling json unit testing making http request curl available standard library third party package standard library lack need think still room improvement area bright side invented mentality want easily make impact open source contributor definitely like ecosystem reason would use
3,Lobsters,d,D programming,"xmake v2.3.6 released, Support fortran compilation and go/dlang package dependences","https://github.com/xmake-io/xmake/wiki/xmake-v2.3.6-released,-Support-fortran-compilation-and-go-dlang-package-dependences",xmake released support fortran compilation godlang package dependence,introduction new feature fortran language compilation support fortran example zig language experimental support http githubcomziglangzig zig example go dependency package cross compilation support go example dlangdub dependency package support,version focus improvement support language fortran compilation support experimental support zig language thirdparty dependency package support crosscompilation support golangdlang although xmake focus cc build support language support xmake also make improvement time time main purpose replace official build system support mixed compilation cc better serve cc project cc project still occasionally call code interface language mixed call language cuda dlang objc swift asm etc xmake still provides basic compilation support addition regarding cc also support header file dependency format new sourcedependencies xxxjson output v preview version reliable stable multilanguage header file dependency detection introduction new feature fortran language compilation support starting version fully supported use gfortran compiler compile fortran project quickly create empty project based fortran using following command xmake create l fortran console test xmakelua content follows addrules modedebug moderelease target test setkind binary addfiles src code example viewed fortran example zig language experimental support note present language xmake still experimental support stage perfect example supported window dynamic library compilation linuxmacos yet supported please evaluate use use following configuration method try experience least console static library program linuxmacos still run addrules modedebug moderelease target test setkind binary addfiles src zig window support please refer issue mentioned zig earlier dynamic library support pitfall dynamic library generated zig automatically append see issue http githubcomziglangzig addition lay pit personally feel lot pit still experimental stage time look later example see zig example go dependency package cross compilation support new version xmake continues make improvement go build support crosscompilation go example compile window program macos linux xmake f p window addition new version also initially support thirdparty dependency package management go addrules modedebug moderelease addrequires go githubcomsirupsenlogrus alias logrus addrequires go golangorgxsysinternalunsafeheader alias unsafeheader isplat window addrequires go golangorgxsyswindows alias syshost else addrequires go golangorgxsysunix alias syshost end target test setkind binary addfiles src go addpackages logrus syshost unsafeheader however still imperfection example cascading dependency package must manually configured present bit cumbersome need improved future example see go example dlangdub dependency package support xmake also support dlang dub package management quickly integrate dlang thirdparty dependency package addrules modedebug moderelease addrequires dub log alias log addrequires dub dateparser alias dateparser addrequires dub emsicontainers alias emsicontainers addrequires dub stdxallocator alias stdxallocator addrequires dub mircore alias mircore target test setkind binary addfiles src addpackages log dateparser emsicontainers stdxallocator mircor
4,Lobsters,d,D programming,Visual D 1.0.0 released,https://forum.dlang.org/thread/rdpuh1$2u9p$1@digitalmars.com,visual released,arafel permalink reply arafel,posted rainer schuetzein reply arafelpermalinkreplyrainer schuetzeposted reply arafel arafel wrote rainer schuetze wrote hello passed year anniversary public availability recently finally time release version visual visual studio extension add language support v find installer http rainersgithubiovisualdvisualdstartpagehtml highlight release semantic engine based dmd front end enabled default updated low memory run window switch back legacy engine debugger extension mago evaluate struct class property method field debugoverview debugexpanded debugtextview customize debugger display mago even display forward range list currently rather slow disabled default see debugger option bar top edit window display current edit scope allows faster navigation within source file need dmd based engine ever wondered navigate type variable declared auto inference clicking identifier tool tip intellisense jump definition dmd based engine see http rainersgithubiovisualdvisualdversionhistoryhtml complete list change cheer rainer look great could see window installers though first sight seems win chance would work vscode linux vscodium even built manually indeed window visual studio code different platform visual studio sure microsoft named easily confused
6,Lobsters,d,D programming,dlang adds borrowchecker,https://dlang.org/changelog/2.092.0.html#ob,dlang add borrowchecker,cli switch removed added support mangling c gnu abi tag gcc standard c library module constructor destructors extern deprecated violation issue deprecation default prototype ownershipborrowing system pointer scope prototype ob system core ob principle design tracked pointer pointer state lifetime pointer state transition limitation bug class reference associative array reference tracked borrowing reading nonowner pointer pointer readwritten nested function exception lazy parameter quadratic behavior mixing memory pool variadic function argument added make storage class mean validate printf scanf variant argument format specifier environment variable supported reproducible build,cli switch revertimport transitioncheckimports removed switched already anything deprecated compiler longer recognized added support mangling c gnu abi tag gnu abi tag feature added gcc order fully support standard c library dmd recognize special uda gnuabitag declared coreattribute publicly aliased object one need import anything use abi tag low level feature user need interact used bind c library need particular required bind std string targeting higher dmd switch externstd used following way extern c gnuabitag tagonstruct struct mystruct gnuabitag multiple tag function mystruct func one gnuabitag present symbol time order array entry matter sorted output uda effect higher passed compiler default ignore uda uda applied extern c symbol applied namespaces module constructor destructors extern deprecated module constructor destructors shared could marked different linkage extern would affect mangling since mangling simple predictable small chance conflict two kind constructordestructors declared similar condition example third module constructor module line third module constructor module b also line would mangling unlikely bug triggered practice affected symbol trigger deprecation message violation issue deprecation default available since first switch recently switch feature fully functional built example starting release code would trigger error passed compiler also trigger deprecation message without behavior switch unchanged error still issued aim make impossible safe code refer destructed object practice function method returning ref parameter might required qualify method parameter return hinted compiler struct foo int x ref int method return thisx ref int identity ref int v return v case uncommenting return annotation appease compiler complete description found prototype ownershipborrowing system pointer ownershipborrowing aka ob system pointer guarantee dereferenced pointer pointing valid memory object scope prototype ob system prototype ob system adapted initially pointer dynamic array class reference ref pointer field aggregate adding support add complexity change nature hence deferred later raii object safely manage memory covered ob whether pointer allocates memory using gc storage allocator immaterial ob distinguished handled identically system active function annotated live attribute applied semantic processing done purely check violation ob rule new syntax added change made code generated live function call non live function called function expected present live compatible interface although checked non live function call live function argument passed expected follow live convention ob system detect error dereferencing pointer invalid state one active pointer mutable memory object detect attempt dereference null pointer possibly null pointer unworkable current method annotating type nonnull pointer core ob principle ob design follows following principle memory object exist either exactly one mutating pointer multiple nonmutating readonly pointer design single mutating pointer called owner memory object transitively owns memory object memory object accessible ie memory object graph since sole pointer memory object safely manage memory change shape allocate free resize without pulling rug pointer mutating may point multiple readonly pointer memory object graph safely read without concerned memory object graph changed underfoot rest design concerned pointer become owner read pointer invalid pointer core ob principle maintained time tracked pointer pointer tracked declared live function function parameter local variable variable function tracked even live one analysis interaction function depends entirely function signature internals parameter const tracked pointer state pointer one following state undefined pointer invalid state dereferencing pointer error owner owner sole pointer memory object graph owner pointer normally scope attribute pointer scope attribute initialized expression derived tracked pointer owner owner pointer assigned another owner pointer former enters undefined state borrowed borrowed pointer one temporarily becomes sole pointer memory object graph enters state via assignment owner pointer owner enters lent state last use borrowed pointer borrowed pointer must scope attribute must pointer mutable readonly readonly pointer acquires value owner readonly pointer live readonly pointer acquired owner readonly pointer must scope attribute also must pointer mutable lifetime lifetime borrowed readonly pointer value start first read initialized assigned value end last read value also known nonlexical lifetime pointer state transition pointer change state one operation done storage allocated local variable stack place pointer undefined state initialization treated assignment assignment source target pointer change state based state type storage class passed function parameter change state function return treated initialization passed ref function parameter treated assignment borrow readonly depending storage class type parameter returned function passed value function parameter treated assignment parameter implicitly passed ref closure variable nested function address pointer taken treated assignment whoever receives address address part memory object graph taken treated assignment whoever receives address pointer value read part memory object graph treated assignment whoever receives pointer merging control flow reconciles state variable based state edge limitation prototype lot aspect dealt yet wo nt prototype show good design bug expect lot bug please report bugzilla tag ob keyword necessary report limitation enumerated class reference associative array reference tracked presumed managed garbage collector borrowing reading nonowner pointer owner tracked leak pointer borrower considered owner initialized pointer live void uhoh scope p malloc scope const pc malloc nt seem make much sense pointer scope perhaps resolved making error pointer readwritten nested function tracked live void ohno auto p malloc void sneaky free p sneaky free p exception analysis assumes exception thrown live void leaky auto p malloc pitcher free p one solution use scope exit live void watertight auto p malloc scope exit free p pitcher use raii object call nothrow function lazy parameter considered quadratic behavior analysis exhibit quadratic behavior keeping live function smallish help mixing memory pool conflation different memory pool void xmalloc sizet void xfree void void ymalloc sizet void yfree void auto p xmalloc yfree p detected mitigated using typespecific pool u umalloc void ufree u v vmalloc void vfree v auto p umalloc vfree p perhaps disabling implicit conversion void live function variadic function argument argument variadict function like printf considered consumed safe nt seem practical likely need revisiting added previewin make storage class mean scope const although technically defined const scope storage class never implemented preview switch implementation done storage class choice purely input function parameter without previewin two declaration equivalent void fun int x void fun const int x previewin two declaration equivalent void fun int x void fun scope const int x validate printf scanf variant argument format specifier follows specification printf scanf printf take generous rather strict view compatiblity example unsigned value formatted signed specifier scanf take strict view compatiblity diagnosed incompatibility incompatible size cause argument misalignment deferencing argument pointer insufficient number argument struct argument array slice argument nonpointer argument specifier nonstandard format undefined behavior per per c standard extra argument ignored attempt made fix argument format string order use nonstandard printfscanf format easy workaround printf kn value const format kn printf formatptr value error detected portability issue instance string printf sn slength sptr printf dn ssizeof ulong u scanf lld cn u replaced string printf sn cast int slength sptr printf zdn ssizeof ulong u scanf llu cn u printflike scanflike function detected prefixing pragma printf printflike function pragma scanf scanflike function addition pragma function must conform following characteristic extern c extern c format parameter declared const char format parameter immediately precede nonv function immediately precede valist parameter last parameter v variant printf scanf enables automatic detection format string argument argument list checking v format string implemented yet environment variable sourcedateepoch supported environment variable sourcedateepoch used reproducible build unix timestamp second since described dmd correctly recognize set date time timestamp token accordingly
7,Lobsters,d,D programming,The Naked Truth About Writing a Programming Language (2014),https://digitalmars.com/articles/b90.html,naked truth writing programming language,work design implementation explains lowering runtime library prototype acknowledgement,january written walter bright career designing programming language writing compiler great joy source satisfaction perhaps help others observation decide design implement professional programming language course book length topic hit highlight avoid topic well covered elsewhere work first lot work year work wandering desert odds success heavily stacked strongly selfmotivated going happen need validation encouragement others going happen fortunately project major dollar investment break fail even fail depending far project got look pretty good resume good career design one thing abundantly clear syntax matter matter awful lot like styling car styling appealing simply matter hot performance syntax need something target audience would like trying go something seen make language adoption much tougher sell like go mix familiar syntax aesthetic beauty got look good screen going spend plenty time looking look awkward clumsy ugly taint language couple thing perhaps surprisingly suggest consideration false god minimizing keystroke maybe mattered programmer used paper tape matter small language like bash awk larger application programming time spent reading much writing reducing keystroke goal course suggesting large amount boilerplate good idea easy parsing hard write parser arbitrary lookahead look language compromised save line code parser remember spend lot time staring code come first mentioned still context free grammar minimizing number keywords metric silly see cropping repeatedly million word english language think looming shortage use good judgement thing true god context free grammar really mean code parseable without look thing symbol table c famously context free grammar context free grammar besides making thing lot simpler mean ides syntax highlighting without integrating compiler front end ie third party tool become much likely exist redundancy yes grammar redundant heard people say statement terminating necessary compiler figure true nonredundancy make incomprehensible error message consider syntax redundancy random sequence character would valid program error message even possible good syntax need redundancy order diagnose error give good error message tried true absent strong reason best stick tried true grammatical form familiar construct really cut learning curve language increase adoption rate think people hate language swap operator precedence save feature generally seen also signal user new always principle taken dictum use good judgement language design principle blindly followed lead disaster principle rarely orthogonal frequently conflict lot like designing house making master closet bigger mean master bedroom get smaller finding right balance getting past syntax meat language semantic processing meaning assigned syntactical construct spending vast bulk design implementation lot like organ body sight unseen think unless going wrong lot glory semantic work whole point language semantic phase compiler optimization code generation collectively called back end two pass challenging complicated love working stuff grumble got spend time issue instead unless really like take fairly unhinged programmer delight arcanum thing recommend taking common sense approach use existing back end jvm clr gcc llvm course always set glorious digital mar back end implementation best implement hope least set right direction first tool beginning compiler writer often reach regex regex wrong tool lexing parsing rob pike explains reasonably well close famous quote jamie zawinski people confronted problem think know use regular expression two problem somewhat controversial bother wasting time lexer parser generator socalled compiler compiler waste time writing lexer parser tiny percentage job writing compiler using generator take much time writing one hand marry generator matter porting compiler new platform generator also unfortunate reputation emitting lousy error message mentioned error message big factor quality implementation language user see tempted put error message like bad syntax perhaps consider taking career chartered accountant instead good error message surprisingly hard write often discover bad error message work tech support email philosophy error message handling print first message quit course simplest approach work surprisingly well compiler follow message bad practical programmer ignores first one anyway holy grail find actual error one compile pas leading guess programmer intended repair syntax tree continue everpopular approach tried indefatigably decade miserable failure compiler seems always guess wrong subsequent message fixed syntax tree ludicrously wrong poisoning approach much like floating point nan handled operation nan operand silently result nan applying error recovery construct leaf error occurred considered erroneous additional error message emitted hence compiler able detect multiple error long error section code dependency approach using compiler pleased result else user care hidden part compiler speed hear compiler speed matter lot fact compile speed often first thing hear ask company tipped balance choosing reality compiler pig blow people away language show compiles fast hitting return key compile command wan na know secret making compiler fast mean screaming blinding lightning fast send sase tell ok ok set naked greed aside let use profiler sound easy right trite even raise hand routinely use profiler honest everyone say profiler manual remains pristine shrink wrap astonished programmer never use profilers great competitive advantage never cease pay dividend tool simply must using valgrind suspect valgrind almost singlehandedly saved c c oblivion heap enough praise tool saved errorprone sorry as untold number frustrating hour git github many tool transformative provide automated backup enable collaborative work project people world also provide complete history every line code came case legal issue automated testing framework compiler enormously complicated beast without constant testing revision project reach point advance bug improvement added add coverage analyzer show test suite exercising code automated documentation generator project course built ddoc transformative ddoc documentation random correlation code often nothing ddoc two brought sync bugzilla automated bug tracking tool great leap forward pathetic older scheme email folder system simply scale programmer far le tolerant buggy compiler used addressed aggressively head lowering one semantic technique obvious hindsight took andrei alexandrescu point called lowering consists internally rewriting complex semantic construct term simpler one example loop foreach loop rewritten term loop rest code deal loop turned uncover couple latent bug loop implemented nice win also used rewrite scope guard statement term tryfinally statement etc every case found semantic processing win implementation turn special case rule language prevent rewriting might good idea go back revisit language design time find commonality handling semantic construct opportunity reduce implementation effort bug runtime library rarely mentioned critical need write runtime library major project serve demonstration language feature work better good critical thing get right io performance program spend lot time io slow io make whole language look bad benchmark c stdio language elegant lovely io apis run half speed c io going attractive memory allocation high percentage time program spent mundane memory allocation get wrong peril transcendental function ok lied nobody care accuracy transcendental function care speed proof come trying port runtime library different platform discovering underlying c transcendental function often fail accuracy test library test suite c library function also often poor job handling arcanum ieee floating point bestiary nan infinity subnormal negative etc compensated implementing transcendental function transcendental floating point code pretty tricky arcane write recommend finding existing library license adapt common trap people fall standard library filling trivia trivia sand clogging gear dead weight carried around forever general rule explanation function line implementation code function likely trivia booted prototype done got great prototype new language next come hardest part new language fail every nascent rock band play shopping mall high school dance dive bar etc slowly building audience language mean preparing presentation article tutorial book language going programmer meeting conference company anywhere show get used public speaking even find enjoy enjoy lot one huge thing favor global reach internet instantly reachable global audience another favorable thing programmer meeting conference etc looking great content love talk new language new programming idea etc experience audience friendly give lot constructive feedback course almost certainly forced reevaluate cherished feature language reengineer hey went eye open acknowledgementsthanks andrei alexandrescu advice draft
9,Lobsters,d,D programming,Interfacing D with C: Arrays and Functions (Arrays Part 2),https://dlang.org/blog/2020/04/28/interfacing-d-with-c-arrays-and-functions-arrays-part-two/,interfacing c array function array part,previous post explored difference array c function declaration anatomy array dynamic array static array passing array c conclusion great place start,post part ongoing series working c project previous post explored difference array declaration initialization post take next step declaring calling c function take array parameter array c function declaration using c library extremely easy time thing work exactly one would expect saw previous article subtle difference working c function expect array necessary fully understand difference straightforward common way declaring c function accepts array parameter use pointer parameter list example hypothetical c function void int arr array int passed function matter declared eg pointer using c array syntax like int int b using lingo c programmer array decay pointer mean purpose function call b pointer first element array passed function typically function like implementer expect array terminated marker appropriate context example string c array char terminated character look string v c string future post necessary without character implementation way know element array last one sometimes function simply documented expect certain length either comment function name eg expect exactly element another option require length array separate argument void int arr sizet len none approach foolproof receives array end marker shorter documented receives array actual length shorter len door open memory corruption array take possibility account making much easier avoid problem even safety feature foolproof calling c function le common way array parameter may declared c void int arr void int arr void int arr static altough parameter declared using c array syntax boil exact function signature aforementioned pointer decay bracket provides special enforcement compiler arr still efectively pointer int unknown length serf documentation function expects implementation rely array nine element difference static added declaration tell compiler function must take array least nine element could nine fewer also rule null pointer problem necessarily enforced depending c compiler use might see warning enabled compiler might complain tested current compiler article see actually reporting error one provide warning behavior c compiler matter side need concerned declaring function appropriately call crash unexpected result effectively could declare like extern c void int arr void int arr sizet len void int arr void int arr void int arr thing mean consider alternative declaration extern c void int arr void int arr void int arr consequence taking approach answer yes mean default int case understand need first explore innards array anatomy array previous article showed make distinction dynamic static array int int dynamic array static array property ptr length may indexed using syntax key difference dynamic array dynamic array usually allocated heap though requirement case memory allocated would need initialized memory allocated via new malloc allocator array literal uninitialized null dynamic array aggregate type contains two property member something like struct dynamicarray sizet length sizet ptr word dynamic array essentially reference type pointerlength pair serving handle refers element memory address contained ptr member every builtin type sizeof property take find system sizet uint system sizet ulong short size handle cumulative size array element static array static array generally allocated stack declaration stack space allocated nine int value initialized intinit default initialized point allocated space although two property dynamic array implementation detail differ static array value type value element given declaration nine int element indicate intsizeof length property compiletime constant never change ptr property though readable compile time also constant never change even lvalue mean impossible make point somewhere else implementation detail must pay attention cut paste c array declaration source module passing array c let go back declaration c give implementation void int arr int printf dn arr naïve declaration extern c void int void main int say naïve never right answer compiling window cl c native tool command prompt visual studio followed dmd running show following output compiler error declaration pefectly valid extern c indicates function us cdecl calling convention calling convention affect way argument passed function function symbol mangled case symbol either calling convention like window different mangling scheme declaration still valid fact function marked extern c something necessary creating library called language also linker error dmd calling system linker case microsoft linkexe linker used system c c compiler mean linker special knowledge function know call symbol need linked implementation since type number parameter mangled symbol name linker happily link matching symbol find way thing would c program tried call c function declared incorrect parameter list c function expecting single pointer argument instead receiving two value array length followed array pointer moral story c function array parameter declared using array syntax like int declared accept pointer change source following recompile using command line need recompile c file extern c void int void main int aptr note use aptr error try pas array argument pointer expected one special exception string literal cover next article series array ptr property must used instead story similar void int arr void int arr static remember int static array dynamic array following match c declaration void int void int try c implementation void int arr int printf dn arr implementation extern c void int void main int likely crash depending system rather passing pointer array code instead passing nine array element value consider c library something like typedef float void dostuff mat generally writing binding c library good idea keep interface c library translated like following alias float extern c void dostuff sixteen float passed dostuff every time called function take parameter one solution int case declare function take pointer however better c allows function called array fewer element expected anything int case usually accompanied length parameter c side anyway c function take typedef type like usually length parameter rely caller get right better void dostuff ref match api implementor intent compiler guarantee array passed dostuff static float array element since ref parameter pointer hood c side rewrite example extern c void ref int void main int conclusion time interfacing c c api declaration example code copied verbatim time time care must taken account exceptional case saw previous article carelessness declaring array variable usually caught compiler article show case c function declaration interfacing c requires care writing c code next article series look mixing string c string program pitfall may arise meantime steven schveighoffer excellent article slice great place start detail array thanks walter bright átila neve valuable feedback article
10,Lobsters,d,D programming,"Andrei Alexandrescu on D, Go, and Rust",https://www.quora.com/Which-language-has-the-brightest-future-in-replacement-of-C-between-D-Go-and-Rust-And-Why,andrei alexandrescu go rust,,please enable javascript refresh page continue
11,Lobsters,d,D programming,DustMite: The General-Purpose Data Reduction Tool,https://dlang.org/blog/2020/04/13/dustmite-the-general-purpose-data-reduction-tool/,dustmite generalpurpose data reduction tool,observation made enter dustmite highly sophisticated predictor refactored problem merkle tree polynomial hash exponentiation squaring susceptible thuemorse string generating assembler code problem goal conflicted address change place walter bright secret weapon aggregating writes contiguous string one io operation brief instant andrej mitrovic suggested,around particularly adventurous developer enjoys mixing language feature interesting way may run one compiler bug two implementation bug inevitably part using cuttingedge programming language run one step proceed generally follows reduce failing program minimal selfcontained example add description happens expect happen post bug tracker nine year ago observation made filing fixing compiler bug disproportionate amount time spent first step program stop compiling blue bug stop reproducing code taken context manually paring large codebase repeatedly cutting code checking bug still occurs becomes tedious repetitive task fortunately tedious repetitive task computer good tricked usually writing program enter dustmite first version basic operation simple tool take input data set reduce directory containing source code exhibit particular compiler bug oracle mundanely test script take input variation data set produce yesorno answer whether input still satisfies sought property reproducing particular compiler bug dustmite output local minimum variation data set reach consecutively trying remove part data set saving result oracle approves compiler bug example mean removing bit code required reproduce problem hand dustmite efficient attempted remove thing linebyline characterbycharacter order maximize chance finding good reduction input parsed tree according syntax input file tree node consists head string child list node pointer tail string technically redundant head tail make representing construct performing reduction much simpler parenbracket pair node arranged binary tree optimization additionally node may list dependency dependency relationship essentially mean node removed node removed constraint representable using tree structure described used allow reducing thing list trailing item delimiters allowed removing function parameter corresponding argument entire code base case source code declaration statement subexpressions get tree node removed one go unneeded parser dustmite us source code intentionally simple need handle potentially invalid code want bug reduction tool also crash top compiler dustmite see simple program algorithm decides order node queued potential deletion dustmite implement several call strategy fundamentally strategy interface statei resulti ie reduction chosen next depends previous reduction result default inbreadth strategy visit node ascending depth order row row start top long find new reduction dustmite today support quite option current version probably interesting j reason dustmite task inherently parallelizable reduction chosen next tree version reduction applied depends previous reduction result dustmite work around putting unused cpu core work lookahead using highly sophisticated predictor guess result current reduction based assumption calculates next reduction guess right great get use result otherwise work wasted implementing meant strategy needed copyable state refactored imperative style state machine unfortunately although highly expected feature implemented four year ago initial implementation rather underwhelming dustmite still much work main thread wasted much cpu time rescanning data set tree every reduction problem bad high core count lookahead mode even slower singlethreaded mode recently set resolve inadequacy following obstacle stood way problem hashing slow oracle service ie running test script usually expensive dustmite keep track cache previously attempted reduction outcome help tree transformation result change output strategy retry reduction successive iteration hash tree used cache key however calculating requires walking entire tree every time slow large input would possible make hash calculation incremental one approach would merkle tree node hash hash child hash however suboptimal case eg empty leaf node c erudite ivan kazmenko blesses u answer polynomial hash representing string polynomial possible use modulo arithmetic calculate incremental fixedsize hash cache subtree hash per node node hold cumulative hash length number theory staggered first recruited assistance feep went draft implementation could begin working final version first improvement replacing naive exponentiation algorithm exponentiation squaring ctfe allowed precomputing table compiletime faster calculation classical method next matter modulo initially used integer overflow modulo arithmetic ie however ivan cautioned using power two modulo make algorithm susceptible thuemorse string long ago experimenting using long multiplicationdivision cpu instruction multiplying one machine word another yield result two machine word high low part viceversa division allows generating assembler code specific type function template instantiated though dustmite use unsigned variant fall back using integer overflow hashing algorithm implemented remained mark dirty node child content edited incrementally recalculate hash needed dependency posed small obstacle time implemented simply array pointer dependency node within tree know get parent mark dirty well however easily overcome adding parent pointer node well thought got work next problem problem copying tree time current version tree representing data set part global state applying reduction implemented twice clumsy faster le complicated making copy entire tree change one part test reduction however requirement proper lookahead otherwise would unable test reduction based result past test predicted positive outcome nearly anything separate thread one issue tree internal pointer copy would require updating pointer within tree point new copy new tree easy childrenparent pointer since reliably visit every pointer exactly quite dependency also implemented simple pointer node would keep track map node copied order update dependency pointer one way solve would change representation node reference pointer index node array way copying tree would simple dup however large input meant many node wanted see possible avoid iterating every node tree ie n every reduction possible would mean would copy modified node parent leaving rest tree inplace reusing copy child goal conflicted existence parent pointer parent would point towards either old new root resolve ambiguity every node would copied result way handled dependency needed rethought editing tree copy write involves copying edited node parent internal pointer next best thing array index referencing node series instruction reach node tree root address representation address chose bit string represented linked list list node hold child index depth starting deep end representation arranged tree rootside end shared mimicking structure tree containing node reduced data thus allowing u reuse memory minimize allocation node hold address would make unmovable need stored outside main tree address work object point need remain mean longer simply remove child tree address going second child would become invalid first child removed rewriting affected address every tree edit course impractical lead u introduction node serve preserve index child follow one possible reduction type involves moving subtrees around tree also redirects tombstone see address attached change place finally move forward fixing optimizing lookahead well implementing incremental rehashing way compatible mutable global current tree variable gone save simply take tree root argument applyreduction apply reduction tree return resulting tree original tree remains unchanged copy modified part tree whatever reference entity applyreduction entity origroot ref reduction r biggest hurdle behind u round applying walter bright secret weapon performance metric started look like going deeper would likely involve using osspecific io apis rewriting gc mere speedup increase computational power may seem underwhelming reason predictor prediction form complete binary tree doubling number parallel job give speed roughly job job far result depend reduction performed ymmv certain artificial test case one optimization pictured yielded speedup dustmite try keep cpu core busy time prediction turn false lookahead job based become wasted work dustmite start new lookahead task reduction outcome resolved perhaps ideally dustmite would keep starting new job kill soon discovers based misprediction crossplatform process group management phobos standard library something left future version work still done main thread moving worker thread actually make thing slower due global gc lock still remains one last place dustmite iterates every tree node per reduction saving tree disk could read test script seems unavoidable first could actually avoided caching node full text content within node opted leave one related improvement using lockingbinarywriter aggregating writes contiguous string one io operation increase memory usage much dramatic decrease execution time even optimized one allocation per reduction polynomial hashing give u every node total length free brief instant dustmite processed reduction subo n time one addition worth mentioning andrej mitrovic suggested switch would replace removed text whitespace would allow searching exact line number test script time addition posed significant challenge needed way keep removed node tree exclude future removal attempt new tree representation became much easier also allowed creating following animation conclusion like bring dustmite good reducing compiler test case wiki list idea finding source ambiguous misleading compiler error message eg error fileline information pointing inside standard library alternative much slower also much thorough method verifying unit test code coverage line code executed mean necessary dustmite made remove code affect execution unit test similarly complete test coverage used reducing source tree minimal tree includes support enabled unittests used create version program library testdefined subset feature obfuscate mode obfuscate code identifier used preparing submission proprietary code bug tracker fuzz mode new feature help find bug compiler tool creating random program using fragment program input dustmite limited program kind program input split option tell dustmite parse reduce kind file dustmite successfully handled following scenario reducing c program parser support conly syntax reducing python program using indent split mode reducing large commit minimal diff using diff split mode reducing commit list git bisect insufficient due problem introduced across single commit reducing large data set minimal one resulting code coverage purpose creating test suite many remember today version dustmite readily available major distribution usually part drelated package happy favorite tool one aptget pacman away pc discovering problem elegantly reduced away dustmite always exciting hoping find useful
12,Lobsters,d,D programming,Tracing D Applications,https://dlang.org/blog/2020/03/13/tracing-d-applications/,tracing application,http based approach standard library tracingwritefd pro except betterc mode package con profile performance memory consumption debuggerbased approach process debugged code tracinggdbd separate file called tracegdb convenience variable pro watchpoints catchpoints con see gdb manual vladimir panteleev dmdprof usdtbased approach open source licensed gpl using bpftrace linux ebpf usdt library code tracingusdtd mixed called bpftracebt pro con conclusion prettyprinting feature pretty printing lowlevel clean code recompilation restart usage complexity thirdparty tool cross platform overhead production ready,one time another application development need make decision application work like wrong different technique help decide logging tracing profiling different one way look like know exactly event interested make decision use logging know exactly event need make decision forced collect many event use tracing need collect event analyze derive new information use profiling article focus tracing developing application use tracing monitor characteristic run time example estimate performance memory consumption several option mean provided programming language example using writef aka printf debugging debugger using script remote tracing osspecific tracing framework linux ku probe usdt probe linux kernel event performance event window etc article following contrived example used help illustrate three case focusing linux example code article found github repository http foreach counter totalcycles randomly generate one three kind event event event cast event uniform perform job benchmark cpu execution time switch event case eventone dosomework break case eventtwo dosomework break case eventthree dosomework break default assert dosomework simulates cpuintensive job using druntime threadsleep method common pattern application run cycle every iteration performs job depending application state see application three code path caseone casetwo casethree need trace application run time collect information timing writefbased approach using writefln phobos standard library trace application naive useful nevertheless code tracingwritefd case eventone auto sw stopwatch autostartno swstart dosomework swstop writefln tevent took counter event swpeek break trivial approach stopwatch standard library used measure execution time code block interest compile run application command dub tracingwritefd look output running examplewritef event one took m μs hnsecs event one took m μs hnsecs event two took sec m μs hnsecs event two took m μs hnsecs price need compile tracing code binary need manually implement collection tracing output disable need mean size binary increase summarize pro might phobos available employ except betterc mode tracing output displayed human readable format look nice output duration thanks jonathan davis stddatetime package source code portable easy use thirdparty tool required con application must rebuilt restarted order make change inappropriate application server lowlevel access application state noise code due addition tracing code unusable due lot debug output overhead large hard use production approach suitable early stage development le useful final product although tracing logic fixed well defined approach used productionready applicationslibraries example approach suggest stefan koch tracing dmd frontend profile performance memory consumption debuggerbased approach debugger case gdb advanced mean trace application need modify application change tracing methodology making useful production instead compiling tracing logic application breakpoints set debugger stop execution breakpoint developer use large arsenal gdb functionality inspect internal state inferior gdb term usually refers process debugged possible case use phobos directly helper available moreover access register unavailable case writef debugging let take look code tracinggdbd first event case caseone dosomework break see tracing code much cleaner tracing logic placed separate file called tracegdb consists series command block configured execute specific breakpoints like set pagination set print address break command set eventone currclock continue end break command set eventone currclock eventone printf tevent one took sn counter printclock eventone continue end run quit first line pagination switched enables scrolling need press enter q continue script execution current console fill second line disables showing address current breakpoint order make output le verbose breakpoints set line followed list command command end label executed gdb stop breakpoints breakpoint line configured fetch current timestamp using helper dosomework called one line get current timestamp dosomework executed fact line empty line source code gdb smart enough set breakpoint next available line eventone convenience variable store timestamps calculate code execution time currclock printclock long helper let u prettify formatting mean phobos last two command script initiate debugging quit debugger finished build run tracing session use following command dub build tracinggdbd single gdb commandtracegdb tracinggdb grep event tracegdb name gdb script tracinggdb name binary use grep make gdb output look like writefln output easier comparison pro code clean contains tracing code need recompile application change tracing many case enough simply change gdb script need restart application used production sort overhead ifwhen tracing little tracing watchpoints catchpoints used instead breakpoints con using breakpoints case may inconvenient annoying impossible gdb prettyprinting provides le pretty output lack full phobos support compared writef approach sometimes gdb available production point setting breakpoints gdb inconvenient based fact use address line number function name see gdb manual using address low level inconvenient line number ephemeral easily change source file edited script broken annoying using function name convenient stable useless need place tracing probe inside function good example using gdb tracing vladimir panteleev dmdprof usdtbased approach far two way trace application complimentary way unify advantage two approach avoid drawback course answer yes fact several way achieve hereafter one discussed usdt userland statically defined tracing unfortunately due historical reason linux tracing ecosystem fragmented rather confusing plain simple introduction get ready invest much time want understand domain first wellknown fullfledged tracing framework dtrace developed sun microsystems open source licensed gpl yes strace ltrace around long time limited eg let trace happens inside function call today dtrace available solaris freebsd macos oracle linux dtrace available linux distribution initially licensed cddl relicensed gpl linux tracing ecosystem everything open source disadvantage case resulted fragmentation several toolsframeworksetc able solve problem different way somehow sometimes interoperate using bpftrace high level tracing language linux ebpf usdt probe provided usdt library let start code tracingusdtd case caseone mixin usdtprobe dlang caseone kind dosomework mixin usdtprobe dlang caseonereturn kind break mixed two probe start end code interest look similar first example using writef huge difference logic defined two probe nop instruction mean probe almost zero overhead use production second great advantage change logic application running impossible using writef approach since using bpftrace need write script called bpftracebt define action performed probe usdt tracingusdt dlang caseone last caseone nsecs usdt tracingusdt dlang caseonereturn last caseone tmp nsecs period tmp last caseone printf tevent caseone took msn counter period last caseone tmp timing hist period first statement action block trigger usdt probe compiled tracingusdt executable includes path executable dlang provider name caseone probe name probe hit global indicated sign associative array last update current timestamp element caseone store time moment code start running second action block defines action performed caseonereturn probe hit first check corresponding element last associative array already initialized needed application may already running script executed case caseonereturn probe fired caseone calculate much time code execution took output store histogram called timing begin end block top bpftracebt define action performed beginning end script execution nothing initialization finalization build run example dub build tracingusdtd single gdc tracingusdt run example background sudo bpftrace bpftracebt start tracing session output attaching probe event casethree took m event casethree took m event casetwo took m event caseone took m event caseone took m event casethree took m event casetwo took m event casethree took m event caseone took m event casetwo took m event caseone took m event casethree took m event caseone took m event casethree took m event casetwo took m event caseone took m event casetwo took m event casetwo took m c timing session output line instead tracingusdt started bpftrace script first two event lost also necessary kill example typing ctrlc tracingusdt completes bpftrace script stop execution ouputs content timing map histogram histogram say onetime code execution take m ten time m seven time m builtin statistic make using bpftrace easy pro provides lowlevel access code register memory etc minimal noise code need recompile restart changing tracing logic almost zero overhead effectively used production con learning usdt hard particularly considering state linux tracing ecosystem requires external tool frontends o specific note gdb support usdt probe since version use modify tracegdb script set breakpoints using usdt probe instead line number eas development eliminates need synchronize line number source code modification futher reading conclusion feature writef gdb usdt pretty printing mean phobos libs mean prettyprinting limited builtins lowlevel yes yes clean code yes sort recompilation yes restart yes usage complexity easy easy advanced thirdparty tool debugger tracing system front end cross platform yes sorta o specific overhead large none ignored even production production ready sometimes possible sometimes impossible yes feature description pretty printing important tracing output read human ignored case intermachine data exchange lowlevel mean access lowlevel detail traced binary eg register memory clean code characterizes whether additional tracing code unrelated application business logic would required recompilation determines necessary recompile changing tracing methodology restart determines necessary restart application changing tracing methodology usage complexity indicates level development experience may required utilize technology thirdparty tool describes tool provided standard language distribution required use technology cross platform indicates technology used different platform without change overhead cost using technology production ready indicates technology may used production system without consequence
13,Lobsters,d,D programming,wc in D: 712 Characters Without a Single Branch,https://dlang.org/blog/2020/01/28/wc-in-d-712-characters-without-a-single-branch/,wc character without single branch,beating c line haskell wc hacker news program phobos standard library performance search claim functional programming give functional programming haskell run money bit range struct literal documentation uniform function call syntax ufcs use template like bidirectional range author symmetry investment exceld dpp autowrap libmir,reading beating c line haskell wc found hacker news thought could better wrote wc program consists one file line character import stdstdio writefln file import stdalgorithm map fold splitter import stdrange walklength import stdtypecons yes import stduni bycodepoint struct line sizet char sizet word struct output sizet line sizet word sizet char output combine output line b pure nothrow return output alines awords bwords achars bchars line toline char l pure return line lbycodepointwalklength lsplitterwalklength void main string args auto f file args output f byline yeskeepterminator map l toline l fold combine output writefln u u u olines owords ochars args sure using phobos standard library phobos awesome ship every compiler program contain single statement haskell wc implementation several statement program apart main function contains three tiny function could easily put functionally one range chain probably would exceeded character per line major codesmell performance wc faster coreutils wc took minute write mine search walklength forgot name file line byte coreutils haskell appd m m m m m m bigtxt m m m m m m vbigtxt m m memory file coreutils haskell appd bigtxt vbigtxt haskell wc faster big file absolutely using thread small file gnu coreutils still beat competition stage version likely io bound fast enough anyway claim one language faster another spend chunk time optimizing microbenchmark likely going beat competition real life claim functional programming give functional programming haskell run money bit range range abstraction consume iteration without consuming underlying collection one technically range struct class adheres one handful range interface basic form inputrange requires function void popfront two member property front bool empty generic type element range iterates range special way object range given foreach statement compiler little rewrite foreach e range rewritten auto r range rempty rpopfront auto e rfront auto e infers type equivalent e given knowledge building range used foreach easy struct iota int front int end property bool empty const return thisfront thisend void popfront thisfront unittest import stdstdio foreach iota writeln iota simple range function generator underlying collection iterates integer front end step one snippet introduces little bit syntax property bool empty const property attribute allows u use function empty way member variable calling function without parenthesis trailing const mean modify data instance call empty builtin unit test print number another small feature lack explicit constructor struct iota two member variable type int foreach statement test create iota instance constructor take two ints struct literal compiler see struct matching constructor ints assigned struct member variable top bottom order declaration relation three member really simple empty false front guaranteed return different element next one iteration call popfront calling popfront value empty might changed true mean element iterate call front valid according inputrange documentation front legally evaluated evaluating empty would equaled false front evaluated multiple time without calling popfront otherwise mutating range object underlying data yield result every evaluation using foreach statement loop general really functional book let say want filter uneven number iota range could put inside foreach block would make worse would nicer range take range predicate decide element okay pas along struct filter iota input bool function int predicate iota input bool function int predicate thisinput input thispredicate predicate thistestanditerate void testanditerate thisinputempty thispredicate thisinputfront thisinputpopfront void popfront thisinputpopfront thistestanditerate property int front return thisinputfront property bool empty const return thisinputempty bool iseven int return unittest foreach filter iota iseven writeln filter really simple take one iota function pointer construction filter call testanditerate pop element iota either empty predicate return false idea passed predicate decides filter keep property front empty forward iota thing actually work popfront pop current element call testanditerate implementation filter sure new loop testanditerate rewriting recursion silly opinion make great use right tool job functional programming fine dandy lot time sometimes bit inline assembly would necessary nicer use call filter still look nice assuming used reading left right filter come iota even though executed iota pipe operator uniform function call syntax ufcs expression implicitly converted first parameter function function called like member function type expression lot word know example help string foo string return world unittest string foo hello string b hello foo assert b example show two call function foo assert indicates call equivalent mean iota filter example ufcs allows u rewrite unit test unittest foreach iota filter iseven writeln implementing maptransform range possible every reader sure filter made abstract use template work nothing conceptually new course different kind range like bidirectional range guess allows small tip bidirectional range two new primitive called back popback range type well understand input range demonstrated twice pretty much know p clear implement filter map fold standard library phobos everything every need look stdalgorithm stdrange author robert schadek received master degree computer science university oldenburg master thesis titled dmcd distributed multithreading caching compiler work building compiler scratch computer science phd student university oldenburg phd research focus quorum system combination graph since happily using day job working symmetry investment symmetry investment symmetry investment global investment company office hong kong singapore london business since successfully spinning major new yorkbased hedge fund symmetry seek engage intelligent risktaking create value client partner employee derive edge capacity generate winwins broadest sense winwin fundamental ethical strategic principle generating winwins create unique solution reconcile perspective usually seen incompatible opposite encompass best side offer integrate fixedincome arbitrage global macro strategy novel way invent develop technology focus potential humanmachine integration build system machine best supporting people people best creating collaborative meritocracy culture individual contribution serf personal collective goal rewarded accordingly value ownership thinking cooperative team spirit selfrealisation community people symmetry investment active participant community since sponsored development exceld dpp autowrap libmir various project started symmetry autumn code hosted dconf london
14,Lobsters,d,D programming,The power of reflection,https://atilaoncode.blog/2020/01/22/the-power-of-reflection/,power reflection,cppcon design instrospection mocking framework python extension native code error handling like work done github like,cppcon overheard someone ask everyone keep talking reflection actually need year also would difficulty understanding would useful year writing hard imagine life without serialisation obvious usecase almost always first one anyone come pressed example lot like design instrospection allows one write mocking framework start seeing application everywhere favourite way use make compiler write code let say one want write python extension native code toplevel python function must corresponding c function well c abi least look something like pyobject myfunc pyobject self pyobject args pyobject kwargs return result lot detail take care error handling managing ref count likelihood conversion python type since case one usually interested calling existing prewritten code make available python tedious even shown boilerplate initialise python module register function code two simple function end looking like thinking clicking link make sigh imagine making call real codebase would look like better import autowrap mixin wrapdlang libraryname mylib module module mymodule module myothermodule code compiled generate python extension shared library expose every function marked export module mymodule myothermodule python function even convert name camelcase snakecase exception thrown become python exception structs class become python class original function take string able pas python string user code modulo bug work code shown code need written setting build system take work two feature used ability reflection compiletime therefore know function module type take return able mix string compiletime boilerplate written user inserted inline written hand compiler heavy lifting imagine bos pleased result want also make code avaiable excel user code change one bit line also work excel trick telling build system depend autowrap excel dub package instead autowrap python instead snakecase function one get pascalcase per excel convention api functionality different implementation code write user curious see done github like like loading related
15,Lobsters,d,D programming,D at 20,https://www.youtube.com/watch?v=p22MM1wc7xQ,,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature youtube
16,Lobsters,d,D programming,My Vision of D’s Future,https://dlang.org/blog/2019/10/15/my-vision-of-ds-future/,vision future,forum memory safety step right direction safe easy concurrency make default implementation language second none reflection easier interop c dconf talk fast development time string interpolation token string enable draft dip,andrei alexandrescu stepped deputy leader programming language asked take role going forward needle say say anyway pretty big shoe fill still settling new role community figuring want thing thing even none happens vacuum either since walter need board well asked forum write blog post dream way forward like happen near future memory safety gc hear exclaim yes also system programming language value type pointer meaning today memory safe step right direction memory safe unless programmer optout via know trusted block function includes transitioning safe default safe easy concurrency mostly actor model eliminates lot problem would otherwise naturally occur need finalize shared make everything safe well make default implementation language static reflection code generation capability make ideal candidate implement codebase need called several different language environment eg python excel r traditionally done specifying data structure rpc call interface definition language idl translating supported language wire protocol go along none necessary one write production code library automagically make code callable language add possible easy write code run fast faster alternative win front second none reflection instead disparate way getting thing done fragmented apis trait stdtraits custom code like library centralizes reflection need great api currently working easier interop c mentioned dconf talk c success enjoyed far making transition c virtually seamless want current c programmer legacy codebases easily able start writing code wrote dpp quite yet might make language change accommodate going forward fast development time think need ridiculously fast interpreter skip machine code generation linking default way running unittest block faster feedback programmer compiling code runtime performance andor ship binary final user would also enable repl string interpolation initially think seems make sense string mixins code generation one greatest strength token string enable visually pleasing block code actually string string interpolation would make vastly easier use happens draft dip pipeline came long walk lake geneva love know community think pet peeve pet feature would think would help hinder going forward
17,Lobsters,d,D programming,Beating std::visit Without Really Trying,https://pbackus.github.io/blog/beating-stdvisit-without-really-trying.html,beating std visit without really trying,sum type implementation programming language blog post reddit comment methodology pbackusvariantcomparison result c c helper template suggests algebraic sumtype explains conclusion falling pit success,one current project sum type implementation programming language bill zero overhead compared handwritten c sound theoretical reason think true never actually sat verified empirically really getting optimal performance thought also curious see effort stacked next variant algebraic especially reading blog post reddit comment challenge faced c implementation could library sumtype particular better methodology answer question designed simple program implemented c c algebraic sumtype using natural idomatic code language library goal find well productiongrade optimizing compiler would handle sum type implementation typical use compiler chose clang clang ldc use llvm backends program compiled optimization level test program following thing defines empty struct type named defines sum type member one type defines function take instance sum type argument return unique integer possible type sum type hold illustration sake c version slightly abridged include variant source http encppreferencecomwcpputilityvariantvisit template class t struct overloaded t using t operator template class t overloaded t overloaded t struct struct using examplevariant std variant int dovisit examplevariant v return std visit overloaded val return val return val return val return v compiling program used objdump disassemble compared generated assembly version dovisit code used along command used compilation disassembly available github repository pbackusvariantcomparison result c c version us union enum tag sum type implementation switch statement visit function straightforward obvious implementation use writing code hand without worrying making generic make good baseline compare version dovisit cmp edi check type index inbounds jae movslq edi rax mov eax get result global array af retq error path push rax mov edi mov esi bb mov ecx mov edx callq ca assertfail might expect compiler able optimize entire thing single array lookup compact fact code calling libc assertionfailure function take space actual logic c c version us std variant std visit overloaded helper template cppreferencecom allow passing set labmda function visitor standardlibrary code expect welloptimized best brightest c developer around make dovisit std examplevariant sub rsp mov rdi rax mov rsp c shr rax mov ecx cmp rcx rax check type index inbounds je mov rsp rcx mov rsp lea rsp rdi lea rsp rsi callq call function pointer global array add rsp retq error path callq throwbadvariantaccess main thing notice unlike c version compiler able inline individual visitor function instead generates indirect call function pointer stored global array individual lambda function course consist single mov followed return enough c expert understand implementation std visit guess case maybe optimizer give many layer templatemetaprogramming gunk regardless bad news fan zerocost abstraction since clear overhead compared c assembly update reddit user matthieum suggests function pointer likely blame algebraic version us sum type implementation standard library phobos rather create dedicated sum type phobos developer opted make algebraic thin wrapper around variant equivalent std choice turn farreaching repercussion see int dalgebraicdovisit examplealgebraic jmpq int stdvariantvisitimpl true examplealgebraic int stdvariantvisitimpl true examplealgebraic push rbx sub rsp cmp rip rdi check uninitialized variant c je go error path mov rdi rbx part repeated time type movq rsp prepare argument variantnhandler lea rsp rdi xor esi esi xor edx edx callq rbx variantnhandler get typeinfo current type mov rsp rsi mov rip rdi get typeinfo callq objectopequals compare typeinfos mov eax ecx mov eax load return value eax test cl cl check objectopequals returned true jne go return checking je none type matched assert false add rsp pop rbx retq error path mov rip rdi get classinfo variantexception callq dallocclass allocate variantexception mov rax rbx mov rip rax initialize variantexception vtable mov rax rbx movq rbx mov rip rax initialize variantexception movups rax movups rbx movups rax movups rax movups rax movups rax movups rbx movups rbx movups rbx movups rbx lea rip rdx get message variantexception mov esi mov rbx rdi callq variantexceptionctor mov rbx rdi callq dthrowexception lea rip rsi get error message assert mov edi mov edx callq call runtime assert function good part ldc able inline lambda body visitimpl bad part well everything else algebraic implemented using variant rely runtime type information typeinfo check type current value us typeinfo rather integer index like c c version check ca nt condensed single array lookup even jump table finally nt enough typeinfo comparison requires virtual method call objectopequals beyond obvious pessimizations thing stand sheer volume generated code order magnitude larger c c version significant bloat normal error path bad isolation since put unnecessary pressure instrution cache also mean potential optimization opportunity exposed inlining c c version dovisit wo nt available code using algebraic sumtype version us implementation sum type sumtype rely runtime type information instead us powerful compiletime reflection metaprogramming capability try generate code close c version possible let see well int dsumtypedovisit examplesumtype push rax movsbq rsp rax get type index stack cmp rax check type index inbounds b jae lea rip rcx load address global array mov rcx eax get result global array pop rcx retq error path lea rip rdx get error message mov edi mov esi callq switcherror turn almost exactly c version single array lookup plus code error handling fact far tell difference way function argument passed c version able avoid spilling anything stack whereas version push pop beginning end respectively still think fair say true zerocost abstraction claim zero overhead compared handwritten c justified update reddit user explains purpose pushpop pair adjust alignment stack pointer conclusion creating zerooverhead generic sum type easy even nt c one libc developer bunch dummy course working significant handicap c source code variant terrifyingly complex order get result shown author use every template metaprogramming trick book clearly result immense effort skilled programmer contrast source code sumtype almost embarrassingly simple reason match sumtype equivalent std visit able optimize code c switch statement literally switch statement static foreach loop inside generate case honest nt even thinking optimization coded sumtype wanted make sure interface nice figured could worry performance later make easy write simple straightforward code compiler understands ended falling pit success beating std visit entirely accident
18,Lobsters,d,D programming,DMD 2.088.0 Released,https://dlang.org/blog/2019/09/06/dmd-2-088-0-released/,dmd released,ready download shiny changleog binding compliant new utility form new function news symmetry autumn code participant general forum google summer code come end gsoc project page donate amount directly hr fund campaign send hr fund get dconf tshirt dlang swag emporium waiting,newest dmd rolled assembly line ready download total contributor fixed bug introduced major change version compiler always looking big ticket item new dmd release highlight blog workaday release showing anything shiny changleog much runofthe mill maintenance deprecation removal behavior adjustment important welcome make great reading blog said handful useful addition point one actually big deal come c interop std string std vector thanks work manu evans performing advocating c interoperability get big boost release binding std string std vector druntime module corestdcppstring corestdcppvector respectively one caveat std string binding anyone intending use must aware compiling linux dmd make use gcc library linker compatibility issue using modern version std string compliant contains interior pointer illegal incompatible move semantics work around pas g compile application resolved future work move constructor complete new utility language get interesting new compiletime trait form getlocation given symbol trait return tuple containing file name line number column number symbol appears source code open door informative debug logging error reporting beyond functionality already available via file line sure folk find us standard library utility module stdfile provides lot convenience function working file unit new function getavailablediskspace give directory path window path directory file posix give number byte available path news symmetry autumn code participant mentor hard work laying milestone milestone officially kick september expect see weekly update participant general forum google summer code come end five student submitted work end august find information project view code submission gsoc project page congratulation participated language foundation currently discussion put human resource fund use finalizing ldc support io android hopefully detail report front near future meantime please help u raise hr fund even higher important work waiting done require much money throw donate amount directly hr fund campaign use special campaign set send hr fund get dconf tshirt return speaking tshirts thanks everyone made purchase dlang swag emporium helped u raise far go general fund yet dropped waiting got tshirts sticker coffee mug update coming soon easy way support favorite programming language
19,Lobsters,d,D programming,Symmetry Autumn of Code (SAoC) projects selected,https://dlang.org/blog/2019/08/25/saoc-2019-projects-and-participants/,symmetry autumn code saoc project selected,symmetry autumn code project multilevel intermediate representation support ldc mlir project readme implement dip expand support c stl container project github geared toward end implementation dip dpp linux kernel header edi staniloiu razvan nitu create ci infrastructure measuring progress performance solve dependency hell link one version project cumbersome introduces new difficulty getting way,last sunday august deadline symmetry autumn code application received total eight application number saw last year time around able accept three five applicant participating application reviewed five member saoc committee member independently ranked application order preference point assigned based ranking top five application accepted get detail project behalf language foundation saoc team like publicly thank eight applicant taking time submit application also like thank laeeth isharc symmetry investment sponsoring event year five saoc committee member volunteering time throughout event john colvin mathias lang átila neve robert schadek ethan watson monitoring progress project milestone report ultimately select one participant receive extra payment allexpense paid trip dconf project multilevel intermediate representation support ldc according mlir project readme common intermediate representation intended unify infrastructure required execute high performance machine learning model tensorflow similar ml framework roberto rosmaninho primary project goal provide ldc compiler new level abstraction support integration mlir ecosystem roberto working computer science major undergraduate research assistant federal university mina gerais brazil mentor project nicholas wilson implement dip expand support c stl container suleyman sahmi main goal advance existing work interface c stl container project github geared toward end manu evans laeeth isharc working blocked lack implementation dip along issue abi name mangling first intends implement dip resolve several related dmd bug use remaining time expand support c stl suleyman selftaught programmer morocco already become contributor dmd dpp linux kernel header dpp tool allows module directly include c c header currently unable work linux kernel header cristian becerescu aim fix able time remaining work improvement refinement dpp including ironing issue might c library header community brings attention cristian computer science engineering student university politehnica bucharest fortunate two mentor project form edi staniloiu razvan nitu create ci infrastructure measuring progress performance max haughton british physic student taking task creating mechanism measure various property ecosystem deterministic manner includes property compilation time compiletime memory usage profiling compiler determine performance also intends extend runtime performance forming set benchmark profile phobos druntime version compiler solve dependency hell link one version project project dependency turn rely different version library step must taken reconcile version difference order successfully compile even possible cumbersome introduces new difficulty tiberiu lepadatu aim solve problem dependency hell making possible compile project multiple version library considered crucial first step making phobos available via dub registry tiberiu stranger contributed core project past likely working sebastian wilzbach mentor getting way saoc participant spend next three week preparing get project started compiling milestone research without mentor searching one thing officially kick september milestone deadline falling month january year expecting participant make weekly update forum also encourage spend time irc slack discourse get know community discus project find inspiration solving challenge face encourage member community show support help keep motivation project improve ecosystemwe fortunate opportunity along participation currently ongoing google summer code get much done without need raise money dig human resource fund willing help project succeed personal level looking forward working five programmer coming month seeing make end successful symmetry autumn code
20,Lobsters,d,D programming,Bug bounties for D language,https://www.flipcause.com/secure/cause_pdetails/NjI2Njg=,bug bounty language,browser nt let u start session window please open new tab finish form successfully,browser nt let u start session window please open new tab finish form successfully
21,Lobsters,d,D programming,"Models of Generics and Metaprogramming: Go, Rust, Swift, D and More",http://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/,model generic metaprogramming go rust swift,model generic metaprogramming go rust swift rust c template haskell zig terra overview basic idea defining entire data structure macro boxing typeerased boxed generic wikipedia article java generic inferred boxed generic uniform representation interface implement language using multiple approach interface vtables interface container swap method objectoriented programming sorting function reflection dynamically typed language look lot like vtables reflection info listed wikipedia creator worked highperformance java vm dictionary passing haskell type class first class module add mechanism make parameter implicit swift witness table without monomorphization without allocating everything uniform representation annotated implement abi stability intensional type analysis monomorphization generating source code genny string mixins string mixins rust procedural macro rust procedural macro macro wrap function logging call syntax tree macro template haskell nim macro ocaml ppx lisp special infrastructure migrate parse tree parsing quotation experimental library try replicate interface provided reflection template feature called concept compile time function terra like implement optimizing compiler domain specific language simple function java go rust generic machine code monomorphization,model generic metaprogramming go rust swift domain programming common want write data structure algorithm work element many different type generic list sorting algorithm need comparison function different programming language come sort solution problem pointing people existing general feature useful purpose eg c go generic system powerful become turingcomplete eg rust c post going take tour generic system many different language implemented start language without special generic system like c solve problem show gradually adding extension different direction lead system found language one reason think generic interesting case simple case general problem metaprogramming writing program generate class program evidence describe three different fully general metaprogramming method seen extension different direction space generic system dynamic language like python procedural macro system like template haskell staged compilation like zig terra overview made flow chart system discus give overview post contain everything fit together basic idea let say programming language without generic system want make generic stack data structure work data type problem function type definition write work data size copied way generally act way two idea get around find way make data type act way data structure make multiple copy data structure slight tweak deal data type correct way two idea form basis two major class solution generic boxing monomorphization boxing put everything uniform box act way usually done allocating thing heap putting pointer data structure make pointer different type act way code deal data type however come cost extra memory allocation dynamic lookup cache miss c corresponds making data structure store void pointer casting data void allocating heap data already heap monomorphization copy code multiple time different type data want store way instance code directly use size method data working without dynamic lookup produce fastest possible code come cost bloat code size compile time code minor tweak compiled many time c corresponds defining entire data structure macro calling type want use overall tradeoff basically boxing lead better compile time hurt runtime performance whereas monomorphization generate fastest code take extra time compile optimize different generated instance also differ extended extension boxing allow dynamic behavior runtime monomorphization flexible different instance generic code differ also worth noting larger program performance advantage monomorphization might canceled additional instruction cache miss extra generated code school generic many direction extended add additional power safety different language taken interesting direction language like rust c even provide option boxing let start example basic boxing approach go type stack struct value interface func stack push value interface thisvalues append thisvalues value func stack pop interface x thisvalues len thisvalues thisvalues thisvalues len thisvalues return x example language use basic boxing c void go interface pregenerics java object pregenerics objectivec id typeerased boxed generic problem basic boxing approach depending language often need cast value correct type every time read write data structure nothing stop u putting element different type structure could allow bug manifest runtime crash solution problem add generic functionality type system still using basic boxing method exactly runtime approach often called type erasure type generic system erased become type like object hood java objectivec started basic boxing later added language feature generic type erasure even using exact collection type compatibility optional generic type parameter see following example wikipedia article java generic list v new arraylist vadd test string cast integer integer integer vget run time error list string v new arraylist string vadd test integer vget type error compilationtime error inferred boxed generic uniform representation ocaml take idea even uniform representation primitive type require additional boxing allocation like int needing turned integer go arraylist java everything either already boxed represented pointersized integer everything one machine word however garbage collector look data stored generic structure need tell pointer integer integer tagged using bit place valid aligned pointer never bit leaving bit range ocaml also type inference system write function compiler infer generic type possible annotate lead function look like dynamically typed language let first head tail head inferred type list inferred type read function list element type something type encodes relation return type list type type interface different limitation basic boxing approach boxed type completely opaque fine data structure like stack thing like generic sorting function need extra functionality like typespecific comparison function number different way implementing runtime exposing language technically different ax implement language using multiple approach however seems like different language feature mostly lend towards implemented certain way language extension take advantage strength chosen implementation mean mostly two family language based around different runtime approach vtables dictionary passing interface vtables want expose typespecific function sticking boxing strategy uniform way working everything make sure uniform way find typespecific function want object approach called using vtables shortened virtual method table nobody us full name implemented offset zero every object generic structure pointer table function pointer consistent layout table allow generic code look pointer typespecific function way every type indexing certain pointer fixed offset interface type implemented go dyn trait object implemented rust cast type interface type something implement creates wrapper contains pointer original object pointer vtable typespecific function interface however requires extra layer pointer indirection different layout sorting go us interface container swap method instead taking slice comparable interface would require allocating entire new slice interface type would sort original slice objectoriented programming object oriented programming language feature make good use power vtables instead separate interface object contain vtables objectoriented language like java vtable pointer start every object javalike language system inheritance interface implemented entirely object vtables well providing additional feature embedding vtables every object also solves earlier problem needing construct new interface type indirection unlike go java sorting function use comparable interface type implement reflection vtables difficult compiler also generate table type information like field name type location allows accessing data type code inspect data type used add reflection feature language used implement thing like serialization pretty printing arbitrary type extension boxing paradigm tradeoff requires one copy code requires lot slow dynamic lookup lead slow serialization performance example language reflection feature use serialization thing include java c go dynamically typed language reflection powerful lot different metaprogramming task one thing create new type edit type information existing value add ability well make default access modification syntax go reflection end dynamically typed language incredibly flexibility metaprogramming language like python ruby come effectively superpowered reflection system used everything tristan dynamic language work implement everything hash table may say well hash table good data structure implementing editable type information table also interpreter like cpython thing look high performance jit like implement thing look lot like vtables reflection info hidden class vtables reflection info object layout similar might see java vm capability object change new vtable runtime coincidence nothing ever coincidence person listed wikipedia creator previously worked highperformance java vm dictionary passing another way implementing dynamic interface associating vtables object pas table required function pointer along generic function need approach way similar constructing gostyle interface object call site table passed hidden argument instead packaged bundle one existing argument approach used haskell type class although ghc ability kind monomorphization optimization inlining specialization dictionary passing also used ocaml explicit argument form first class module proposal add mechanism make parameter implicit swift witness table swift make interesting realization using dictionary passing also putting size type move copy free table provide information required work type uniform way without boxing way swift implement generic without monomorphization without allocating everything uniform representation still pay cost dynamic lookup boxingfamily implementation pay save allocation memory cacheincoherency cost swift compiler also ability specialize monomorphize inline generic within module across module function annotated inlinable avoid cost want presumably using heuristic much would bloat code functionality also explains swift implement abi stability way allows adding rearranging field structs although provide frozen attribute opt dynamic lookup performance reason intensional type analysis one way implement interface boxed type add type id fixed part object like vtable pointer would go generate function interface method effectively big switch statement type implement interface method dispatch correct typespecific method aware language use technique c compiler java vms something similar use profileguided optimization learn certain generic call site mostly act object certain type replace call site check common type static dispatch common type usual dynamic dispatch fallback case way branch predictor predict common case branch taken continue dispatching instruction static call monomorphization alternative approach boxing monomorphization monomorphization approach need find way output multiple version code type want use compiler multiple phase representation code pass compiled theoretically copying stage generating source code simplest approach monomorphization copying stage first representation source code way compiler even generic support user language like c go compiler support generic sometimes c use preprocessor define data structure macro header include multiple time different defines go script like genny make code generation process easy downside duplicating source code lot wart edge case look depending language also give compiler lot extra work parsing type checking basically code many time depending language tool method generic ugly write use like write one inside c macro every line end backslash type function name need type name manually concatenated onto identifier avoid collision string mixins code generation something going though generate code using fully powered programming language also us representation user already know language implement generic way also include clean way code generation address general metaprogramming use case covered generic system like serialization clearest example string mixins enable generating code string using full power middle compile rust procedural macro similar example representation one step compiler rust procedural macro take token stream input output token stream providing utility convert token stream string advantage approach token stream preserve source code location information macro directly paste code user wrote input output token user code cause compiler error macro output error message compiler print correctly point file line column broken part user code macro generates broken code error message point macro invocation example use macro wrap function logging call make mistake implementation wrapped function compiler error point directly mistake file rather saying error occurred code generated macro syntax tree macro language take step offer facility consuming producing abstract syntax tree ast type macro written language example include template haskell nim macro ocaml ppx nearly lisp one problem ast macro want require user learn bunch function constructing ast type well base language lisp family language address making syntax ast structure simple direct correspondence constructing structure still tedious thus language mention form quote primitive provide fragment code language return syntax tree quote primitive also way splice syntax tree value like string interpolation example template haskell using ast construction function genfn name q exp genfn f x newname x lame varp x appe vare f vare x using quotation splicing genfn name q exp genfn f x vare f x one disadvantage procedural macro syntax tree level instead token level syntax tree type often change addition new language feature token type remain compatible example ocaml ppx system need special infrastructure migrate parse tree language version used macro whereas rust library add parsing quotation utility write procedural macro style similar syntax tree macro rust even experimental library try replicate interface provided reflection template next type generic pushing code generation little compiler template found c way implementing generic specify template parameter type function instantiate template specific type type substituted function function type checked make sure combination valid template class mymax b return b b template class struct pair value int main mymax pair int p would give u compile error inside mymax pair invalid operand mymax p p one problem template system include template function library user instantiates wrong type may get inscrutable compile error inside library similar happen library dynamically typed language user pass wrong type interesting solution similar popular library dynamic language use helper function check type valid error message clearly point helper fail example note signature generally better syntax provide template parameter going use isnumeric function stdtraits import stdtraits optional without get error inside like c also included doc participates overloading mymax b isnumeric return b b struct pair value void main mymax pair int p would give compile error saying pair int pair int nt match available instance mymax b isnumeric mymax p p feature called concept serf purpose except design like defining interface type constraint compile time function template number extension allow use feature like compile time function evaluation static basically make template act like function take compile time set parameter return nongeneric runtime function make template fully featured metaprogramming system far understand modern c template similar power le clean mechanism language take generic compile time function concept run even like zig fn stack comptime type type return struct item len usize const self pub fn push self self item zig using language compile time runtime function split based parameter marked comptime another language us separate similar language meta level called terra terra dialect lua allows construct lower level clike function inline manipulate meta level using lua apis well quoting splicing primitive function makestack local struct stack item pointer len int terra stack push item end return stack end terra crazy level metaprogramming power allows thing like implement optimizing compiler domain specific language simple function implement interface object system java go library small amount code save generated runtimelevel code dependencyfree object file rust generic next type monomorphized generic course move code generation one step compiler type checking mentioned type insidethelibrary error get c like error get dynamically typed language course basically one type type template parameter like dynamic language mean fix problem adding type system meta level multiple type type static checking support operation use generic work rust language level also work swift haskell rust need declare trait bound type parameter trait like interface language declare set functionality provided type rust compiler check body generic function work type conforming trait bound also allow use functionality type declared trait bound way user generic function rust never get compile error inside library function instantiate compiler also type check generic function fn mymax partialord b b else b struct pair value fn main mymax let p pair pair value would give compile error saying partialord implemented pair mymax p p language level similar kind type system need implement generic interface support using boxing approach generic rust support using system rust even added uniform syntax v impl sometrait parameter get monomorphized v dyn sometrait parameter us boxing property also allows compiler like swift haskell ghc monomorphize optimization even though default boxing machine code monomorphization logical next step monomorphized generic model pushing compiler backend like copy source code template annotated placeholder generic type generate machine code placeholder typespecific part stamp template quickly memcpy patch like linker work downside monomorphized copy specially optimized optimizer lack duplicate optimization compilation way faster could even make code stamper tiny jit get included binary stamp monomorphized copy runtime avoid bloating binary actually aware language work way idea came writing natural extension taxonomy exactly kind thing hoped exercise hope post give clearer picture generic system different language fit together coherent taxonomy prompt think direction conceptspace might find new cool programming language
22,Lobsters,d,D programming,Ownership and borrowing in D,https://dlang.org/blog/2019/07/15/ownership-and-borrowing-in-d/,ownership borrowing,ownership data flow analysis dfa common subexpressions borrowing principle folding ownershipborrowing conclusion rprogramming subreddit hacker news,nearly nontrivial program allocate manage memory getting right becoming increasingly important program get ever complex mistake get ever costly usual problem memory leak failure free memory longer use double free freeing memory useafterfree continuing refer memory already freed challenge keeping track pointer responsible freeing memory ie owning memory pointer merely referring memory active scope common solution garbage collection gc owns memory periodically scan memory looking pointer memory none found memory released scheme reliable common use language like go java tends use much memory strictly necessary pause slow code inserted write gate reference counting rc object owns memory keep count many pointer point count go zero memory released also reliable commonly used language like c objectivec rc memory efficient needing slot count downside rc expense maintaining count building exception handler ensure decrement done locking needed object shared thread regain efficiency sometimes programmer cheat temporarily refer rc object without dealing count engendering risk done correctly manual manual memory management exemplified c malloc free fast memory efficient language help using correctly entirely programmer skill diligence using using malloc free year bitter endless experience rarely make mistake anymore sort thing programming shop rely note said rarely never solution le rely faith programmer right faithbased system scale well memory management issue proven difficult audit difficult coding standard prohibit use memory allocation fourth way ownership borrowing memory efficient performant manual management mechanically auditable recently popularized rust programming language downside form reputation rethink one composes algorithm data structure downside manageable rest article outline ownershipborrowing ob system work propose fit originally thought would impossible spending lot time thinking found way fit much like fit functional programming transitive immutability function purity ownership solution owns memory object ridiculously one pointer pointer must owner responsible releasing memory cease valid follows pointer memory object owner point pointer data structure data structure therefore form tree also follows pointer copied moved f void g p f q p value p moved q copied g p error p invalid value moving pointer data structure allowed struct p f f q sp error ca nt two pointer sp mark sp invalid trouble one would need runtime mark supposed compiletime solution attempting simply flagged error owning pointer fall scope also error void h p f error forgot release p necessary move pointer somewhere else void g void h p f g p move g g problem neatly solves memory leak useafterfree problem hint make clearer replace f malloc g free tracked compile time function using data flow analysis dfa technique like used compute common subexpressions dfa unravel whatever rat nest gotos happen borrowing ownership system described sound little restrictive consider struct void car void bar struct f f scar moved car sbar error invalid make work scar would way moving pointer value back scar return way borrowing work scar borrows copy duration execution scar invalid execution becomes valid scar return struct member function take reference accommodate borrowing enhancement taking argument ref borrows also support scope pointer also natural fit borrowing void g scope f p f g p g borrows p g p use p g return function take argument ref pointer scope allowed escape ref pointer fit right borrow semantics borrowing way fulfills promise one pointer memory object exists one time work borrowing enhanced little insight ownership system still safe multiple const pointer long mutable pointer const pointer neither release memory mutate mean multiple const pointer borrowed owning mutable pointer long owning mutable pointer used const pointer active example f void g p f p becomes owner scope const q p borrow const pointer scope const r p borrow another one g p error p invalid q r scope g p ok principle distilled notion memory object behaves one two state exists exactly one mutable pointer exist one const pointer careful reader notice something peculiar wrote mean weasel wording skullduggery going yes computer language full dirty deed hood like money deposit bank account actually apologize rude shock anyone different read first bit necessary exposition folding ownershipborrowing scheme incompatible way people normally write code break pretty much every program existence break easily fixed way break badly redesign algorithm ground yup sure except secret weapon function attribute turn semantics ownershipborrowing aka ob system run perfunction basis usual semantic pas run careful reader may noticed new syntax added restriction existing code history using function attribute alter semantics example adding pure attribute cause function behave pure enable ob semantics function attribute live added mean ob added code incrementally needed time resource permit becomes possible add ob critical keeping project fully functioning tested releasable state mechanically auditable much project memory safe manner add list many memorysafe guarantee pointer stack escaping necessary thing done strict ob reference counted memory object whole point rc object multiple pointer since rc object memory safe built correctly work ob without negatively impinging memory safety built ob solution attribute function like system system much safety checking turned course ob also turned system code rc object implementation hide ob checker ob code rc object look ob checker like obeying rule problemo number library type needed successfully use ob conclusion article basic overview ob working much comprehensive specification always possible missed something hole waterline far looking good exciting development looking forward getting implemented discussion comment walter see discussion thread rprogramming subreddit hacker news
23,Lobsters,d,D programming,DMD 2.087.0 Released,https://dlang.org/blog/2019/07/05/dmd-2-087-0-released/,dmd released,courtesy contributor changelog detail digital mar downloads page ending beginning two issue bug tracker write blog transitional period via static constructor dip phobos dip first improvement proposal phobos compiles issue tracker explicitly choose lld linker window linker optlink digital mar c c compiler omf object format pdf specification coff format release dmd mingw compiler markdown support ddoc ddoc originally designed dlangorg website dconforg site programming list supported feature putting use supporting development human resource fund wekaio seeded fund see recent blog post open collective page read recent blog post,latest release digital mar compiler dmd available version mark closed bugzilla issue major change courtesy contributor see changelog detail related link visit digital mar downloads page get release package platform one change release end transitional period regarding import another involves certain compiler switch compilation phobos also something developer window find useful option documenting code ddoc ending beginning upon time two related compiler issue reported bug tracker remained year beyond measure actually shy decade bug allowed symbol sometimes accessed inside scope supposed visible eventually bug fixed two switch introduced help user maintain existing code transtionimport caused code compile old incorrect behavior transitioncheckimport would report occurences erroneous behavior code base steven schveighoffer write blog time good read anyone interested detail dmd transitional period transitionimport transitioncheckimports switch longer effect henceforth existing code compiling transitionimport code break new release still relying old buggy behavior one period end another begin new deprecation give warning initializing immutable global data via static constructor like immutable int bar static bar behavior deprecated static constructor destructors called per thread given immutable global data implicitly shared across thread rather threadlocal like normal variable data like bar would overwritten every time new thread spawned fix ensure static constructor also shared across thread immutable int bar shared static bar static constructor destructors marked shared invoked per process rather per thread dip phobos dip first improvement proposal submitted dip process transformed informal wikibased approach formal managed approach structured review period proposed feature called scoped pointer intended provide mechanism guarantee reference escape lexical scope unfortunately document remained sort limbo proposed feature implemented evolved eventually implementation diverged proposal degree dip marked superseded retired feature flag available time bit tricky use given standard library could compiled dmd true phobos compiles programmer easily make use feature given still preview mode yet seen enough widespread use please surprised uncover bug please report bug find issue tracker squashed soon possible explicitly choose lld linker window beginning dmd shipped selfcontained support development window possible walter bright made use existing platform library linker optlink already shipping digital mar c c compiler unfortunately optlink support omf object format output dmd window incompatible greater window ecosystem primarily built around pe coff output see pdf specification microsoft build tool pe coff known mscoff universe microsoftspecific version coff format eventually walter added mscoff support dmd later development required developer microsoft linker platform library installed past meant installing either visual studio microsoft build tool package along window sdk recent year installing visual studio community edition would provide everything necessary compiling optlink would ignored favor microsoft linker release dmd compiler began shipping llvm linker lld set platform library derived ship mingw compiler wrapper library visual c runtime point forward given window compiler would search microsoft installation found fallback bundled linker library installed first time dmd selfcontained output window interestingly never selfcontained platform dmd relies system linker library presence given source complaint dependence m linker new set put pace kink ironed dmd make possible explicitly select bundled mscoff import library lld linker via command line switch markdown support ddoc ddoc originally designed macrobased system documenting source code use expanded beyond scenario year since section dlangorg website created ddoc dconforg site ali çehreli used write book programming support markdownlike syntax requested forum available dmd currently preview mode requires previewmarkdown flag difference flavor markdown may familiar sure read list supported feature putting use supporting development much blood sweat tear went every release compiler provided volunteer work within constraint knowledge skill experience mother limiter time task yet fit within bound volunteer constraint require dedicated effort strike list end like remind everyone raising money human resource fund use bring folk specifically tackle difficult task wekaio seeded fund generous contribution community member thrown resource pot gratitude language foundation need still dconf tshirts anyone want throw hr fund well dman shirt dconf registration discount able willing donate see recent blog post topic detail make sure donate correct campaign order get shirt want another reminder want become gold donor personal sponsor open collective page separate hr fund read recent blog post avoid confusion please either ensure email address included profile contact directly let know otherwise send dman shirt
24,Lobsters,d,D programming,D as a C Replacement,https://theartofmachinery.com/2019/04/05/d_as_c_replacement.html,c replacement,sway wayland compositor rust good c replacement programming language c story format string work custom type support compiletime checking format string article c member function pointer runtime change needed convert real c program betterc slice walter bright written pointerlength pair problem c compile time function evaluation ctfe many function evaluated compile time guard popular myth c c useful compiler optimisation faq benefit keyword read safed article advantage making metaprogramming le interesting compiletime reflection compiletime checked bit flag enum using metaprogramming code preprocessor manifest constant template module normal article explaining exactly adhoc binding dub registry derelict project bindbc project dpp tool,sircmpwn main developer behind sway wayland compositor recently wrote blog post think rust good c replacement know like programming language either become c replacement c story story like lot system story one time c goto language programming one day realised c program kept reimplementing thing c dynamic array better string polymorphic class etc tried using c instead first loved raii class generic made programming fun even better promise read book c learned master thing like template metaprogramming become almighty god system programming code would amazing learning eventually opposite effect hindsight code actually got worse fell love remember reading scott effective c realising really ineffective c c code broken face c might fiddly use kind elegance rarely word hear c involved apparently lot exc c programmer end going back c case discovered also perfect use feel lot like c c meant example superficial think representative take simple c program include stdioh int main printf n return version using c standard library include iostream int main std cout std endl return idiomatic version import stdstdio void main writef n said superficial example think show general difference philosophy c wanted make difference even clearer use example needed iomanip c update unlike c format string work custom type stefan rohe also pointed support compiletime checking format string using metaprogramming feature unlike c builtin compiler special casing used custom code article c member function pointer happens also good explanation origin good read programming language nerd like tl dr everyone else c member function pointer supposed feel like lowlevel feature like normal function pointer complexity diversity implementation mean really high level complexity implementation subtlety rule author explains implementation several c compiler including favorite elegantly simple digital mar c implementation everyone else way dmc compiler written walter bright invented class template core feature c designed someone spent heck lot time thinking c spec thing could simpler walter said experience implementing c template made consider including realised need complex quick tour point view incrementally improving c betterc compiler support betterc switch disables runtime highlevel feature depend example c code translated directly betterc import corestdcstdio extern c int main printf n return dmd betterc exampled example resulting binary look lot like equivalent c binary fact rewrote c library betterc could still link code compiled c version work without change walter bright wrote good article walking change needed convert real c program betterc actually need betterc switch write clike code needed special case simply runtime let point favourite feature still work betterc static assert allows verifying assumption compile time static assert knuminducers system code often make assumption alignment structure size thing static assert possible document assumption trigger compilation error someone break adding struct member something slice typical c code full pointerlength pair common bug go sync slice simple superuseful abstraction range memory defined pointer length instead code like bufferp offset bufferlen offset got update use muchlessbugprone alternative buffer buffer offset slice nothing pointerlength pair firstclass syntactic support update walter bright written pointerlength pair problem c compile time function evaluation ctfe many function evaluated compile time long factorial int n pure assert n n long ret foreach j ret j return ret statically allocated array size calculated compile time permutation factorial knumthings permutationtable scope guard code one part function often coupled cleanup code later part failing match code correctly another common source bug especially multiple control flow path involved scope guard make simple get stuff right p malloc free called current scope exit scope exit free p put whatever statement loop early return like even multiple scope guard scope nested scope cleanup routine called needed right order also support raii using struct destructors const immutable popular myth const c c useful compiler optimisation walter bright complained every time thought new constbased optimisation c eventually discovered work real code made change const semantics added immutable read const faq pure functional purity enforced written benefit pure keyword safe safed subset forbids risky language feature like pointer typecasts inline assembly code marked safe enforced compiler use feature risky code limited small percentage application need read safed article like hinted earlier metaprogramming got bad reputation among c programmer advantage making metaprogramming le interesting programmer tend useful fun puzzle great support compiletime reflection case compiletime reflection solve problem runtime reflection compiletime guarantee compiletime reflection also used implement runtime reflection truly needed need name enumerated type array enum state stopped starting running stopping string statenames trait allmembers state thanks metaprogramming standard library many nice typesafe tool like compiletime checked bit flag enum written using metaprogramming betterc code preprocessor okay nonfeature feature equivalent preprocessor sane usecases replaced native language feature like manifest constant template includes proper module support mean break free limitation old include hack normal clike code written compiled normal code without betterc switch difference normal code linked runtime support higherlevel feature obvious one garbage collection objectoriented class people confused runtime something like java virtual machine wrote article explaining exactly spoiler like c c runtimes feature even runtime compiled much different compiled c sometimes like write throwaway code say experiment new linux system call something used think best language plain old c always use natively support includeing c code nice apis lot preprocessor craziness like linux usually write adhoc binding many popular c library maintained binding found dub registry derelict project newer bindbc project also tool automated binding including awesome dpp tool brings include support directly code update post got lot attention people never heard interested learning recommend
25,Lobsters,d,D programming,Frictionless D Adoption for the Masses,https://www.youtube.com/watch?v=79COPHF3TnE&list=PLIldXzSkPUXWORGtUrnTo2ylziTHR8_Sq&index=13,frictionless adoption mass,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature dconf frictionless adoption mass átila neve youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature dconf frictionless adoption mass átila neve youtube
26,Lobsters,d,D programming,Porting a Golang and Rust CLI tool to D,https://pingfrommorocco.blogspot.com/2020/08/porting-golang-and-rust-cli-tool-to-d.html,porting golang rust cli tool,paulo henrique cuchi shared experience writing command line tool rust go comment source code github end using local environment manual interactive installer editor support one blog post visuald package management rpassword getpass support recommendation library graphqld request ufcs error handling discussion websockets continuous integration memory usage redditor skocznymroczny experimental memory management methodology binary size built go build ldflags w conclusion curl,day ago programming subreddit paulo henrique cuchi shared experience writing command line tool rust go tool question client side project hashtrack hashtrack expose graphql api client track certain twitter hashtags get real time list relevant tweet prompted comment decided write port demonstrate used achieve similar goal try keep structure one used blog post source code github end using main reason original blog post compared statically typed language like go rust made honorable mention nim crystal nt mention fall category think make interesting comparison also like language mentioned various blog post local environment manual lengthy page download install reference compiler dmd window user get installer macos user use homebrew ubuntu simply add apt repository perform normal apt installation get dmd also dub package manager installed rust idea easy would get running surprised easy run interactive installer took care rest add cargobin path think probably restarted console change take effect editor support wrote hashtrack vim without much difficulty probably familiarity everything go standard library documentation open time occasionally used symbol nt import right package called function wrong argument note far standard library concerned import std everything disposal third party library though curious state tooling looked plugins favourite ide intellij idea found one installed also instealled dcd dscanner cloning respective repos building configuring idea plugin point right path shout author blog post explaining process ran issue first fixed updating ide plugin one problem could nt recognize package kept marking possibly undefined later discovered put module nameofthepackage top file order recognized think still bug nt recognize length least machine opened issue github follow curious window heard good thing visuald package management dub defacto package manager fetch installs dependency http codedlangorg project needed http client nt feel like using curl ended fetching two dependency request dependency cachetools dependency reason though fetched twelve dependency think dub us internally sure rust downloaded lot crate probably rust version code feature mine example fetched rpassword tool hide password character type terminal much like python getpass function one many thing nt code added getpass support linux thanks recommendation also added terminal text formatting thanks escape sequence copied original go source code library little knowledge graphql idea begin graphql search codedlangorg led relevant library aptly named graphqld looking though struck vibed plugin actual client thing inspecting network request firefox realized project could mimic graphql query mutation would send http client response json object parse tool provided stdjson package mind started looking http client settled request simple use http client importantly one reached certain level maturity copied outgoing request network inspector pasted separate graphql file imported sent appropriate variable bulk functionality put graphqlrequest structure wanted inject different endpoint configuration requirement project struct graphqlrequest string operationname string query jsonvalue variable config configuration jsonvalue tojson return jsonvalue operationname jsonvalue operationname variable variable query jsonvalue query string tostring return tojson toprettystring response send auto request request requestaddheaders authorization configurationget token return requestpost configurationget endpoint tostring applicationjson snippet session package following code handle authentication struct session config configuration void login string username string password auto request createsession username password auto response requestsend responsethrowonfailure string token responsejsonbody data object createsession object token str configurationput token token graphqlrequest createsession string username string password enum query import createsessiongraphql linesplitter join n auto variable sessionpayload username password tojson return graphqlrequest createsession query variable configuration struct sessionpayload string email string password todo make template mixin something jsonvalue tojson return jsonvalue email jsonvalue email password jsonvalue password string tostring return tojson toprettystring spoiler alert never todo go like main function creates config struct command line argument injects session struct implement functionality login logout status command createsession method construct graphql request reading actual request appropriate graphql file passing variable along nt want pollute source code graphql mutation query moved graphql file import compilation help enum import latter requires compiler flag point stringimportpaths default view login method sole responsibility sending http request handling response case handle potential error though thoroughly store token config file really nothing glorified json object throwonfailure method part core functionality request library actually helper function quick dirty error handling void throwonfailure response response responseissuccessful error responsejsonbody string error responseerrors throw new requestexception errorsjoin n since support ufcs throwonfailure response syntax rewritten responsethrowonfailure make integrate seemlessly builtin method like send may abused feature throughout project error handling pretty much favor exception come error handling rationale explained detail one thing like unhandled error eventually get reported unless explicitely silenced able get away simplistic error handling example line string token responsejsonbody data object createsession object token str configurationput token token response body nt contain token object object leading throw exception bubble main function explode face user using go would careful handling error every stage honest since annoying write err null every time call function would tempted ignore understanding go however primitive would nt surprised compiler barked anything error return value feel free correct wrong rust style error handling explained original post interesting nt think anything like standard library discussion implementing third party library websockets want quickly mention nt use websockets implement watch command tried using vibed websocket client could nt get work hashtrack backend kept closing connection ended dropping favor polling even though frowned upon client work since tested another websocket server might come back future continuous integration ci set two build job normal build feature branch release master provide optimized build form downloadable artifact memory usage ran usrbintime v hashtrack list command measure memory usage explained original article nt know memory usage depends hashtags logged user follows result built dub build b release maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes bad ran go rust version hashtrack user got result go built go build ldflags w maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes rust built cargo build release maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes edit redditor skocznymroczny recommended test ldc gdc addition dmd result ldc built dub build b release adding colored output getpass maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes maximum resident set size kbytes garbage collection also support smart pointer recently experimental memory management methodology inspired rust really sure well feature integrate standard library decided let gc handle memory think result pretty good considering nt memory consumption mind writing code binary size rust built cargo build release built dub build b release built dub build b release go built go build go built go build ldflags w conclusion think solid language writing command line tool like nt reach external dependency often standard library needed thing like parsing command line argument handling json unit testing making http request curl available standard library third party package standard library lack need think still room improvement area bright side invented mentality want easily make impact open source contributor definitely like ecosystem reason would use
28,Lobsters,d,D programming,"xmake v2.3.6 released, Support fortran compilation and go/dlang package dependences","https://github.com/xmake-io/xmake/wiki/xmake-v2.3.6-released,-Support-fortran-compilation-and-go-dlang-package-dependences",xmake released support fortran compilation godlang package dependence,introduction new feature fortran language compilation support fortran example zig language experimental support http githubcomziglangzig zig example go dependency package cross compilation support go example dlangdub dependency package support,version focus improvement support language fortran compilation support experimental support zig language thirdparty dependency package support crosscompilation support golangdlang although xmake focus cc build support language support xmake also make improvement time time main purpose replace official build system support mixed compilation cc better serve cc project cc project still occasionally call code interface language mixed call language cuda dlang objc swift asm etc xmake still provides basic compilation support addition regarding cc also support header file dependency format new sourcedependencies xxxjson output v preview version reliable stable multilanguage header file dependency detection introduction new feature fortran language compilation support starting version fully supported use gfortran compiler compile fortran project quickly create empty project based fortran using following command xmake create l fortran console test xmakelua content follows addrules modedebug moderelease target test setkind binary addfiles src code example viewed fortran example zig language experimental support note present language xmake still experimental support stage perfect example supported window dynamic library compilation linuxmacos yet supported please evaluate use use following configuration method try experience least console static library program linuxmacos still run addrules modedebug moderelease target test setkind binary addfiles src zig window support please refer issue mentioned zig earlier dynamic library support pitfall dynamic library generated zig automatically append see issue http githubcomziglangzig addition lay pit personally feel lot pit still experimental stage time look later example see zig example go dependency package cross compilation support new version xmake continues make improvement go build support crosscompilation go example compile window program macos linux xmake f p window addition new version also initially support thirdparty dependency package management go addrules modedebug moderelease addrequires go githubcomsirupsenlogrus alias logrus addrequires go golangorgxsysinternalunsafeheader alias unsafeheader isplat window addrequires go golangorgxsyswindows alias syshost else addrequires go golangorgxsysunix alias syshost end target test setkind binary addfiles src go addpackages logrus syshost unsafeheader however still imperfection example cascading dependency package must manually configured present bit cumbersome need improved future example see go example dlangdub dependency package support xmake also support dlang dub package management quickly integrate dlang thirdparty dependency package addrules modedebug moderelease addrequires dub log alias log addrequires dub dateparser alias dateparser addrequires dub emsicontainers alias emsicontainers addrequires dub stdxallocator alias stdxallocator addrequires dub mircore alias mircore target test setkind binary addfiles src addpackages log dateparser emsicontainers stdxallocator mircor
29,Lobsters,d,D programming,Visual D 1.0.0 released,https://forum.dlang.org/thread/rdpuh1$2u9p$1@digitalmars.com,visual released,arafel permalink reply arafel,posted rainer schuetzein reply arafelpermalinkreplyrainer schuetzeposted reply arafel arafel wrote rainer schuetze wrote hello passed year anniversary public availability recently finally time release version visual visual studio extension add language support v find installer http rainersgithubiovisualdvisualdstartpagehtml highlight release semantic engine based dmd front end enabled default updated low memory run window switch back legacy engine debugger extension mago evaluate struct class property method field debugoverview debugexpanded debugtextview customize debugger display mago even display forward range list currently rather slow disabled default see debugger option bar top edit window display current edit scope allows faster navigation within source file need dmd based engine ever wondered navigate type variable declared auto inference clicking identifier tool tip intellisense jump definition dmd based engine see http rainersgithubiovisualdvisualdversionhistoryhtml complete list change cheer rainer look great could see window installers though first sight seems win chance would work vscode linux vscodium even built manually indeed window visual studio code different platform visual studio sure microsoft named easily confused
31,Lobsters,d,D programming,dlang adds borrowchecker,https://dlang.org/changelog/2.092.0.html#ob,dlang add borrowchecker,cli switch removed added support mangling c gnu abi tag gcc standard c library module constructor destructors extern deprecated violation issue deprecation default prototype ownershipborrowing system pointer scope prototype ob system core ob principle design tracked pointer pointer state lifetime pointer state transition limitation bug class reference associative array reference tracked borrowing reading nonowner pointer pointer readwritten nested function exception lazy parameter quadratic behavior mixing memory pool variadic function argument added make storage class mean validate printf scanf variant argument format specifier environment variable supported reproducible build,cli switch revertimport transitioncheckimports removed switched already anything deprecated compiler longer recognized added support mangling c gnu abi tag gnu abi tag feature added gcc order fully support standard c library dmd recognize special uda gnuabitag declared coreattribute publicly aliased object one need import anything use abi tag low level feature user need interact used bind c library need particular required bind std string targeting higher dmd switch externstd used following way extern c gnuabitag tagonstruct struct mystruct gnuabitag multiple tag function mystruct func one gnuabitag present symbol time order array entry matter sorted output uda effect higher passed compiler default ignore uda uda applied extern c symbol applied namespaces module constructor destructors extern deprecated module constructor destructors shared could marked different linkage extern would affect mangling since mangling simple predictable small chance conflict two kind constructordestructors declared similar condition example third module constructor module line third module constructor module b also line would mangling unlikely bug triggered practice affected symbol trigger deprecation message violation issue deprecation default available since first switch recently switch feature fully functional built example starting release code would trigger error passed compiler also trigger deprecation message without behavior switch unchanged error still issued aim make impossible safe code refer destructed object practice function method returning ref parameter might required qualify method parameter return hinted compiler struct foo int x ref int method return thisx ref int identity ref int v return v case uncommenting return annotation appease compiler complete description found prototype ownershipborrowing system pointer ownershipborrowing aka ob system pointer guarantee dereferenced pointer pointing valid memory object scope prototype ob system prototype ob system adapted initially pointer dynamic array class reference ref pointer field aggregate adding support add complexity change nature hence deferred later raii object safely manage memory covered ob whether pointer allocates memory using gc storage allocator immaterial ob distinguished handled identically system active function annotated live attribute applied semantic processing done purely check violation ob rule new syntax added change made code generated live function call non live function called function expected present live compatible interface although checked non live function call live function argument passed expected follow live convention ob system detect error dereferencing pointer invalid state one active pointer mutable memory object detect attempt dereference null pointer possibly null pointer unworkable current method annotating type nonnull pointer core ob principle ob design follows following principle memory object exist either exactly one mutating pointer multiple nonmutating readonly pointer design single mutating pointer called owner memory object transitively owns memory object memory object accessible ie memory object graph since sole pointer memory object safely manage memory change shape allocate free resize without pulling rug pointer mutating may point multiple readonly pointer memory object graph safely read without concerned memory object graph changed underfoot rest design concerned pointer become owner read pointer invalid pointer core ob principle maintained time tracked pointer pointer tracked declared live function function parameter local variable variable function tracked even live one analysis interaction function depends entirely function signature internals parameter const tracked pointer state pointer one following state undefined pointer invalid state dereferencing pointer error owner owner sole pointer memory object graph owner pointer normally scope attribute pointer scope attribute initialized expression derived tracked pointer owner owner pointer assigned another owner pointer former enters undefined state borrowed borrowed pointer one temporarily becomes sole pointer memory object graph enters state via assignment owner pointer owner enters lent state last use borrowed pointer borrowed pointer must scope attribute must pointer mutable readonly readonly pointer acquires value owner readonly pointer live readonly pointer acquired owner readonly pointer must scope attribute also must pointer mutable lifetime lifetime borrowed readonly pointer value start first read initialized assigned value end last read value also known nonlexical lifetime pointer state transition pointer change state one operation done storage allocated local variable stack place pointer undefined state initialization treated assignment assignment source target pointer change state based state type storage class passed function parameter change state function return treated initialization passed ref function parameter treated assignment borrow readonly depending storage class type parameter returned function passed value function parameter treated assignment parameter implicitly passed ref closure variable nested function address pointer taken treated assignment whoever receives address address part memory object graph taken treated assignment whoever receives address pointer value read part memory object graph treated assignment whoever receives pointer merging control flow reconciles state variable based state edge limitation prototype lot aspect dealt yet wo nt prototype show good design bug expect lot bug please report bugzilla tag ob keyword necessary report limitation enumerated class reference associative array reference tracked presumed managed garbage collector borrowing reading nonowner pointer owner tracked leak pointer borrower considered owner initialized pointer live void uhoh scope p malloc scope const pc malloc nt seem make much sense pointer scope perhaps resolved making error pointer readwritten nested function tracked live void ohno auto p malloc void sneaky free p sneaky free p exception analysis assumes exception thrown live void leaky auto p malloc pitcher free p one solution use scope exit live void watertight auto p malloc scope exit free p pitcher use raii object call nothrow function lazy parameter considered quadratic behavior analysis exhibit quadratic behavior keeping live function smallish help mixing memory pool conflation different memory pool void xmalloc sizet void xfree void void ymalloc sizet void yfree void auto p xmalloc yfree p detected mitigated using typespecific pool u umalloc void ufree u v vmalloc void vfree v auto p umalloc vfree p perhaps disabling implicit conversion void live function variadic function argument argument variadict function like printf considered consumed safe nt seem practical likely need revisiting added previewin make storage class mean scope const although technically defined const scope storage class never implemented preview switch implementation done storage class choice purely input function parameter without previewin two declaration equivalent void fun int x void fun const int x previewin two declaration equivalent void fun int x void fun scope const int x validate printf scanf variant argument format specifier follows specification printf scanf printf take generous rather strict view compatiblity example unsigned value formatted signed specifier scanf take strict view compatiblity diagnosed incompatibility incompatible size cause argument misalignment deferencing argument pointer insufficient number argument struct argument array slice argument nonpointer argument specifier nonstandard format undefined behavior per per c standard extra argument ignored attempt made fix argument format string order use nonstandard printfscanf format easy workaround printf kn value const format kn printf formatptr value error detected portability issue instance string printf sn slength sptr printf dn ssizeof ulong u scanf lld cn u replaced string printf sn cast int slength sptr printf zdn ssizeof ulong u scanf llu cn u printflike scanflike function detected prefixing pragma printf printflike function pragma scanf scanflike function addition pragma function must conform following characteristic extern c extern c format parameter declared const char format parameter immediately precede nonv function immediately precede valist parameter last parameter v variant printf scanf enables automatic detection format string argument argument list checking v format string implemented yet environment variable sourcedateepoch supported environment variable sourcedateepoch used reproducible build unix timestamp second since described dmd correctly recognize set date time timestamp token accordingly
32,Lobsters,d,D programming,The Naked Truth About Writing a Programming Language (2014),https://digitalmars.com/articles/b90.html,naked truth writing programming language,work design implementation explains lowering runtime library prototype acknowledgement,january written walter bright career designing programming language writing compiler great joy source satisfaction perhaps help others observation decide design implement professional programming language course book length topic hit highlight avoid topic well covered elsewhere work first lot work year work wandering desert odds success heavily stacked strongly selfmotivated going happen need validation encouragement others going happen fortunately project major dollar investment break fail even fail depending far project got look pretty good resume good career design one thing abundantly clear syntax matter matter awful lot like styling car styling appealing simply matter hot performance syntax need something target audience would like trying go something seen make language adoption much tougher sell like go mix familiar syntax aesthetic beauty got look good screen going spend plenty time looking look awkward clumsy ugly taint language couple thing perhaps surprisingly suggest consideration false god minimizing keystroke maybe mattered programmer used paper tape matter small language like bash awk larger application programming time spent reading much writing reducing keystroke goal course suggesting large amount boilerplate good idea easy parsing hard write parser arbitrary lookahead look language compromised save line code parser remember spend lot time staring code come first mentioned still context free grammar minimizing number keywords metric silly see cropping repeatedly million word english language think looming shortage use good judgement thing true god context free grammar really mean code parseable without look thing symbol table c famously context free grammar context free grammar besides making thing lot simpler mean ides syntax highlighting without integrating compiler front end ie third party tool become much likely exist redundancy yes grammar redundant heard people say statement terminating necessary compiler figure true nonredundancy make incomprehensible error message consider syntax redundancy random sequence character would valid program error message even possible good syntax need redundancy order diagnose error give good error message tried true absent strong reason best stick tried true grammatical form familiar construct really cut learning curve language increase adoption rate think people hate language swap operator precedence save feature generally seen also signal user new always principle taken dictum use good judgement language design principle blindly followed lead disaster principle rarely orthogonal frequently conflict lot like designing house making master closet bigger mean master bedroom get smaller finding right balance getting past syntax meat language semantic processing meaning assigned syntactical construct spending vast bulk design implementation lot like organ body sight unseen think unless going wrong lot glory semantic work whole point language semantic phase compiler optimization code generation collectively called back end two pass challenging complicated love working stuff grumble got spend time issue instead unless really like take fairly unhinged programmer delight arcanum thing recommend taking common sense approach use existing back end jvm clr gcc llvm course always set glorious digital mar back end implementation best implement hope least set right direction first tool beginning compiler writer often reach regex regex wrong tool lexing parsing rob pike explains reasonably well close famous quote jamie zawinski people confronted problem think know use regular expression two problem somewhat controversial bother wasting time lexer parser generator socalled compiler compiler waste time writing lexer parser tiny percentage job writing compiler using generator take much time writing one hand marry generator matter porting compiler new platform generator also unfortunate reputation emitting lousy error message mentioned error message big factor quality implementation language user see tempted put error message like bad syntax perhaps consider taking career chartered accountant instead good error message surprisingly hard write often discover bad error message work tech support email philosophy error message handling print first message quit course simplest approach work surprisingly well compiler follow message bad practical programmer ignores first one anyway holy grail find actual error one compile pas leading guess programmer intended repair syntax tree continue everpopular approach tried indefatigably decade miserable failure compiler seems always guess wrong subsequent message fixed syntax tree ludicrously wrong poisoning approach much like floating point nan handled operation nan operand silently result nan applying error recovery construct leaf error occurred considered erroneous additional error message emitted hence compiler able detect multiple error long error section code dependency approach using compiler pleased result else user care hidden part compiler speed hear compiler speed matter lot fact compile speed often first thing hear ask company tipped balance choosing reality compiler pig blow people away language show compiles fast hitting return key compile command wan na know secret making compiler fast mean screaming blinding lightning fast send sase tell ok ok set naked greed aside let use profiler sound easy right trite even raise hand routinely use profiler honest everyone say profiler manual remains pristine shrink wrap astonished programmer never use profilers great competitive advantage never cease pay dividend tool simply must using valgrind suspect valgrind almost singlehandedly saved c c oblivion heap enough praise tool saved errorprone sorry as untold number frustrating hour git github many tool transformative provide automated backup enable collaborative work project people world also provide complete history every line code came case legal issue automated testing framework compiler enormously complicated beast without constant testing revision project reach point advance bug improvement added add coverage analyzer show test suite exercising code automated documentation generator project course built ddoc transformative ddoc documentation random correlation code often nothing ddoc two brought sync bugzilla automated bug tracking tool great leap forward pathetic older scheme email folder system simply scale programmer far le tolerant buggy compiler used addressed aggressively head lowering one semantic technique obvious hindsight took andrei alexandrescu point called lowering consists internally rewriting complex semantic construct term simpler one example loop foreach loop rewritten term loop rest code deal loop turned uncover couple latent bug loop implemented nice win also used rewrite scope guard statement term tryfinally statement etc every case found semantic processing win implementation turn special case rule language prevent rewriting might good idea go back revisit language design time find commonality handling semantic construct opportunity reduce implementation effort bug runtime library rarely mentioned critical need write runtime library major project serve demonstration language feature work better good critical thing get right io performance program spend lot time io slow io make whole language look bad benchmark c stdio language elegant lovely io apis run half speed c io going attractive memory allocation high percentage time program spent mundane memory allocation get wrong peril transcendental function ok lied nobody care accuracy transcendental function care speed proof come trying port runtime library different platform discovering underlying c transcendental function often fail accuracy test library test suite c library function also often poor job handling arcanum ieee floating point bestiary nan infinity subnormal negative etc compensated implementing transcendental function transcendental floating point code pretty tricky arcane write recommend finding existing library license adapt common trap people fall standard library filling trivia trivia sand clogging gear dead weight carried around forever general rule explanation function line implementation code function likely trivia booted prototype done got great prototype new language next come hardest part new language fail every nascent rock band play shopping mall high school dance dive bar etc slowly building audience language mean preparing presentation article tutorial book language going programmer meeting conference company anywhere show get used public speaking even find enjoy enjoy lot one huge thing favor global reach internet instantly reachable global audience another favorable thing programmer meeting conference etc looking great content love talk new language new programming idea etc experience audience friendly give lot constructive feedback course almost certainly forced reevaluate cherished feature language reengineer hey went eye open acknowledgementsthanks andrei alexandrescu advice draft
35,Lobsters,d,D programming,"Andrei Alexandrescu on D, Go, and Rust",https://www.quora.com/Which-language-has-the-brightest-future-in-replacement-of-C-between-D-Go-and-Rust-And-Why,andrei alexandrescu go rust,,please enable javascript refresh page continue
39,Lobsters,d,D programming,The power of reflection,https://atilaoncode.blog/2020/01/22/the-power-of-reflection/,power reflection,cppcon design instrospection mocking framework python extension native code error handling like work done github like,cppcon overheard someone ask everyone keep talking reflection actually need year also would difficulty understanding would useful year writing hard imagine life without serialisation obvious usecase almost always first one anyone come pressed example lot like design instrospection allows one write mocking framework start seeing application everywhere favourite way use make compiler write code let say one want write python extension native code toplevel python function must corresponding c function well c abi least look something like pyobject myfunc pyobject self pyobject args pyobject kwargs return result lot detail take care error handling managing ref count likelihood conversion python type since case one usually interested calling existing prewritten code make available python tedious even shown boilerplate initialise python module register function code two simple function end looking like thinking clicking link make sigh imagine making call real codebase would look like better import autowrap mixin wrapdlang libraryname mylib module module mymodule module myothermodule code compiled generate python extension shared library expose every function marked export module mymodule myothermodule python function even convert name camelcase snakecase exception thrown become python exception structs class become python class original function take string able pas python string user code modulo bug work code shown code need written setting build system take work two feature used ability reflection compiletime therefore know function module type take return able mix string compiletime boilerplate written user inserted inline written hand compiler heavy lifting imagine bos pleased result want also make code avaiable excel user code change one bit line also work excel trick telling build system depend autowrap excel dub package instead autowrap python instead snakecase function one get pascalcase per excel convention api functionality different implementation code write user curious see done github like like loading related
40,Lobsters,d,D programming,D at 20,https://www.youtube.com/watch?v=p22MM1wc7xQ,,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature youtube
42,Lobsters,d,D programming,Beating std::visit Without Really Trying,https://pbackus.github.io/blog/beating-stdvisit-without-really-trying.html,beating std visit without really trying,sum type implementation programming language blog post reddit comment methodology pbackusvariantcomparison result c c helper template suggests algebraic sumtype explains conclusion falling pit success,one current project sum type implementation programming language bill zero overhead compared handwritten c sound theoretical reason think true never actually sat verified empirically really getting optimal performance thought also curious see effort stacked next variant algebraic especially reading blog post reddit comment challenge faced c implementation could library sumtype particular better methodology answer question designed simple program implemented c c algebraic sumtype using natural idomatic code language library goal find well productiongrade optimizing compiler would handle sum type implementation typical use compiler chose clang clang ldc use llvm backends program compiled optimization level test program following thing defines empty struct type named defines sum type member one type defines function take instance sum type argument return unique integer possible type sum type hold illustration sake c version slightly abridged include variant source http encppreferencecomwcpputilityvariantvisit template class t struct overloaded t using t operator template class t overloaded t overloaded t struct struct using examplevariant std variant int dovisit examplevariant v return std visit overloaded val return val return val return val return v compiling program used objdump disassemble compared generated assembly version dovisit code used along command used compilation disassembly available github repository pbackusvariantcomparison result c c version us union enum tag sum type implementation switch statement visit function straightforward obvious implementation use writing code hand without worrying making generic make good baseline compare version dovisit cmp edi check type index inbounds jae movslq edi rax mov eax get result global array af retq error path push rax mov edi mov esi bb mov ecx mov edx callq ca assertfail might expect compiler able optimize entire thing single array lookup compact fact code calling libc assertionfailure function take space actual logic c c version us std variant std visit overloaded helper template cppreferencecom allow passing set labmda function visitor standardlibrary code expect welloptimized best brightest c developer around make dovisit std examplevariant sub rsp mov rdi rax mov rsp c shr rax mov ecx cmp rcx rax check type index inbounds je mov rsp rcx mov rsp lea rsp rdi lea rsp rsi callq call function pointer global array add rsp retq error path callq throwbadvariantaccess main thing notice unlike c version compiler able inline individual visitor function instead generates indirect call function pointer stored global array individual lambda function course consist single mov followed return enough c expert understand implementation std visit guess case maybe optimizer give many layer templatemetaprogramming gunk regardless bad news fan zerocost abstraction since clear overhead compared c assembly update reddit user matthieum suggests function pointer likely blame algebraic version us sum type implementation standard library phobos rather create dedicated sum type phobos developer opted make algebraic thin wrapper around variant equivalent std choice turn farreaching repercussion see int dalgebraicdovisit examplealgebraic jmpq int stdvariantvisitimpl true examplealgebraic int stdvariantvisitimpl true examplealgebraic push rbx sub rsp cmp rip rdi check uninitialized variant c je go error path mov rdi rbx part repeated time type movq rsp prepare argument variantnhandler lea rsp rdi xor esi esi xor edx edx callq rbx variantnhandler get typeinfo current type mov rsp rsi mov rip rdi get typeinfo callq objectopequals compare typeinfos mov eax ecx mov eax load return value eax test cl cl check objectopequals returned true jne go return checking je none type matched assert false add rsp pop rbx retq error path mov rip rdi get classinfo variantexception callq dallocclass allocate variantexception mov rax rbx mov rip rax initialize variantexception vtable mov rax rbx movq rbx mov rip rax initialize variantexception movups rax movups rbx movups rax movups rax movups rax movups rax movups rbx movups rbx movups rbx movups rbx lea rip rdx get message variantexception mov esi mov rbx rdi callq variantexceptionctor mov rbx rdi callq dthrowexception lea rip rsi get error message assert mov edi mov edx callq call runtime assert function good part ldc able inline lambda body visitimpl bad part well everything else algebraic implemented using variant rely runtime type information typeinfo check type current value us typeinfo rather integer index like c c version check ca nt condensed single array lookup even jump table finally nt enough typeinfo comparison requires virtual method call objectopequals beyond obvious pessimizations thing stand sheer volume generated code order magnitude larger c c version significant bloat normal error path bad isolation since put unnecessary pressure instrution cache also mean potential optimization opportunity exposed inlining c c version dovisit wo nt available code using algebraic sumtype version us implementation sum type sumtype rely runtime type information instead us powerful compiletime reflection metaprogramming capability try generate code close c version possible let see well int dsumtypedovisit examplesumtype push rax movsbq rsp rax get type index stack cmp rax check type index inbounds b jae lea rip rcx load address global array mov rcx eax get result global array pop rcx retq error path lea rip rdx get error message mov edi mov esi callq switcherror turn almost exactly c version single array lookup plus code error handling fact far tell difference way function argument passed c version able avoid spilling anything stack whereas version push pop beginning end respectively still think fair say true zerocost abstraction claim zero overhead compared handwritten c justified update reddit user explains purpose pushpop pair adjust alignment stack pointer conclusion creating zerooverhead generic sum type easy even nt c one libc developer bunch dummy course working significant handicap c source code variant terrifyingly complex order get result shown author use every template metaprogramming trick book clearly result immense effort skilled programmer contrast source code sumtype almost embarrassingly simple reason match sumtype equivalent std visit able optimize code c switch statement literally switch statement static foreach loop inside generate case honest nt even thinking optimization coded sumtype wanted make sure interface nice figured could worry performance later make easy write simple straightforward code compiler understands ended falling pit success beating std visit entirely accident
45,Lobsters,d,D programming,Bug bounties for D language,https://www.flipcause.com/secure/cause_pdetails/NjI2Njg=,bug bounty language,browser nt let u start session window please open new tab finish form successfully,browser nt let u start session window please open new tab finish form successfully
46,Lobsters,d,D programming,"Models of Generics and Metaprogramming: Go, Rust, Swift, D and More",http://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/,model generic metaprogramming go rust swift,model generic metaprogramming go rust swift rust c template haskell zig terra overview basic idea defining entire data structure macro boxing typeerased boxed generic wikipedia article java generic inferred boxed generic uniform representation interface implement language using multiple approach interface vtables interface container swap method objectoriented programming sorting function reflection dynamically typed language look lot like vtables reflection info listed wikipedia creator worked highperformance java vm dictionary passing haskell type class first class module add mechanism make parameter implicit swift witness table without monomorphization without allocating everything uniform representation annotated implement abi stability intensional type analysis monomorphization generating source code genny string mixins string mixins rust procedural macro rust procedural macro macro wrap function logging call syntax tree macro template haskell nim macro ocaml ppx lisp special infrastructure migrate parse tree parsing quotation experimental library try replicate interface provided reflection template feature called concept compile time function terra like implement optimizing compiler domain specific language simple function java go rust generic machine code monomorphization,model generic metaprogramming go rust swift domain programming common want write data structure algorithm work element many different type generic list sorting algorithm need comparison function different programming language come sort solution problem pointing people existing general feature useful purpose eg c go generic system powerful become turingcomplete eg rust c post going take tour generic system many different language implemented start language without special generic system like c solve problem show gradually adding extension different direction lead system found language one reason think generic interesting case simple case general problem metaprogramming writing program generate class program evidence describe three different fully general metaprogramming method seen extension different direction space generic system dynamic language like python procedural macro system like template haskell staged compilation like zig terra overview made flow chart system discus give overview post contain everything fit together basic idea let say programming language without generic system want make generic stack data structure work data type problem function type definition write work data size copied way generally act way two idea get around find way make data type act way data structure make multiple copy data structure slight tweak deal data type correct way two idea form basis two major class solution generic boxing monomorphization boxing put everything uniform box act way usually done allocating thing heap putting pointer data structure make pointer different type act way code deal data type however come cost extra memory allocation dynamic lookup cache miss c corresponds making data structure store void pointer casting data void allocating heap data already heap monomorphization copy code multiple time different type data want store way instance code directly use size method data working without dynamic lookup produce fastest possible code come cost bloat code size compile time code minor tweak compiled many time c corresponds defining entire data structure macro calling type want use overall tradeoff basically boxing lead better compile time hurt runtime performance whereas monomorphization generate fastest code take extra time compile optimize different generated instance also differ extended extension boxing allow dynamic behavior runtime monomorphization flexible different instance generic code differ also worth noting larger program performance advantage monomorphization might canceled additional instruction cache miss extra generated code school generic many direction extended add additional power safety different language taken interesting direction language like rust c even provide option boxing let start example basic boxing approach go type stack struct value interface func stack push value interface thisvalues append thisvalues value func stack pop interface x thisvalues len thisvalues thisvalues thisvalues len thisvalues return x example language use basic boxing c void go interface pregenerics java object pregenerics objectivec id typeerased boxed generic problem basic boxing approach depending language often need cast value correct type every time read write data structure nothing stop u putting element different type structure could allow bug manifest runtime crash solution problem add generic functionality type system still using basic boxing method exactly runtime approach often called type erasure type generic system erased become type like object hood java objectivec started basic boxing later added language feature generic type erasure even using exact collection type compatibility optional generic type parameter see following example wikipedia article java generic list v new arraylist vadd test string cast integer integer integer vget run time error list string v new arraylist string vadd test integer vget type error compilationtime error inferred boxed generic uniform representation ocaml take idea even uniform representation primitive type require additional boxing allocation like int needing turned integer go arraylist java everything either already boxed represented pointersized integer everything one machine word however garbage collector look data stored generic structure need tell pointer integer integer tagged using bit place valid aligned pointer never bit leaving bit range ocaml also type inference system write function compiler infer generic type possible annotate lead function look like dynamically typed language let first head tail head inferred type list inferred type read function list element type something type encodes relation return type list type type interface different limitation basic boxing approach boxed type completely opaque fine data structure like stack thing like generic sorting function need extra functionality like typespecific comparison function number different way implementing runtime exposing language technically different ax implement language using multiple approach however seems like different language feature mostly lend towards implemented certain way language extension take advantage strength chosen implementation mean mostly two family language based around different runtime approach vtables dictionary passing interface vtables want expose typespecific function sticking boxing strategy uniform way working everything make sure uniform way find typespecific function want object approach called using vtables shortened virtual method table nobody us full name implemented offset zero every object generic structure pointer table function pointer consistent layout table allow generic code look pointer typespecific function way every type indexing certain pointer fixed offset interface type implemented go dyn trait object implemented rust cast type interface type something implement creates wrapper contains pointer original object pointer vtable typespecific function interface however requires extra layer pointer indirection different layout sorting go us interface container swap method instead taking slice comparable interface would require allocating entire new slice interface type would sort original slice objectoriented programming object oriented programming language feature make good use power vtables instead separate interface object contain vtables objectoriented language like java vtable pointer start every object javalike language system inheritance interface implemented entirely object vtables well providing additional feature embedding vtables every object also solves earlier problem needing construct new interface type indirection unlike go java sorting function use comparable interface type implement reflection vtables difficult compiler also generate table type information like field name type location allows accessing data type code inspect data type used add reflection feature language used implement thing like serialization pretty printing arbitrary type extension boxing paradigm tradeoff requires one copy code requires lot slow dynamic lookup lead slow serialization performance example language reflection feature use serialization thing include java c go dynamically typed language reflection powerful lot different metaprogramming task one thing create new type edit type information existing value add ability well make default access modification syntax go reflection end dynamically typed language incredibly flexibility metaprogramming language like python ruby come effectively superpowered reflection system used everything tristan dynamic language work implement everything hash table may say well hash table good data structure implementing editable type information table also interpreter like cpython thing look high performance jit like implement thing look lot like vtables reflection info hidden class vtables reflection info object layout similar might see java vm capability object change new vtable runtime coincidence nothing ever coincidence person listed wikipedia creator previously worked highperformance java vm dictionary passing another way implementing dynamic interface associating vtables object pas table required function pointer along generic function need approach way similar constructing gostyle interface object call site table passed hidden argument instead packaged bundle one existing argument approach used haskell type class although ghc ability kind monomorphization optimization inlining specialization dictionary passing also used ocaml explicit argument form first class module proposal add mechanism make parameter implicit swift witness table swift make interesting realization using dictionary passing also putting size type move copy free table provide information required work type uniform way without boxing way swift implement generic without monomorphization without allocating everything uniform representation still pay cost dynamic lookup boxingfamily implementation pay save allocation memory cacheincoherency cost swift compiler also ability specialize monomorphize inline generic within module across module function annotated inlinable avoid cost want presumably using heuristic much would bloat code functionality also explains swift implement abi stability way allows adding rearranging field structs although provide frozen attribute opt dynamic lookup performance reason intensional type analysis one way implement interface boxed type add type id fixed part object like vtable pointer would go generate function interface method effectively big switch statement type implement interface method dispatch correct typespecific method aware language use technique c compiler java vms something similar use profileguided optimization learn certain generic call site mostly act object certain type replace call site check common type static dispatch common type usual dynamic dispatch fallback case way branch predictor predict common case branch taken continue dispatching instruction static call monomorphization alternative approach boxing monomorphization monomorphization approach need find way output multiple version code type want use compiler multiple phase representation code pass compiled theoretically copying stage generating source code simplest approach monomorphization copying stage first representation source code way compiler even generic support user language like c go compiler support generic sometimes c use preprocessor define data structure macro header include multiple time different defines go script like genny make code generation process easy downside duplicating source code lot wart edge case look depending language also give compiler lot extra work parsing type checking basically code many time depending language tool method generic ugly write use like write one inside c macro every line end backslash type function name need type name manually concatenated onto identifier avoid collision string mixins code generation something going though generate code using fully powered programming language also us representation user already know language implement generic way also include clean way code generation address general metaprogramming use case covered generic system like serialization clearest example string mixins enable generating code string using full power middle compile rust procedural macro similar example representation one step compiler rust procedural macro take token stream input output token stream providing utility convert token stream string advantage approach token stream preserve source code location information macro directly paste code user wrote input output token user code cause compiler error macro output error message compiler print correctly point file line column broken part user code macro generates broken code error message point macro invocation example use macro wrap function logging call make mistake implementation wrapped function compiler error point directly mistake file rather saying error occurred code generated macro syntax tree macro language take step offer facility consuming producing abstract syntax tree ast type macro written language example include template haskell nim macro ocaml ppx nearly lisp one problem ast macro want require user learn bunch function constructing ast type well base language lisp family language address making syntax ast structure simple direct correspondence constructing structure still tedious thus language mention form quote primitive provide fragment code language return syntax tree quote primitive also way splice syntax tree value like string interpolation example template haskell using ast construction function genfn name q exp genfn f x newname x lame varp x appe vare f vare x using quotation splicing genfn name q exp genfn f x vare f x one disadvantage procedural macro syntax tree level instead token level syntax tree type often change addition new language feature token type remain compatible example ocaml ppx system need special infrastructure migrate parse tree language version used macro whereas rust library add parsing quotation utility write procedural macro style similar syntax tree macro rust even experimental library try replicate interface provided reflection template next type generic pushing code generation little compiler template found c way implementing generic specify template parameter type function instantiate template specific type type substituted function function type checked make sure combination valid template class mymax b return b b template class struct pair value int main mymax pair int p would give u compile error inside mymax pair invalid operand mymax p p one problem template system include template function library user instantiates wrong type may get inscrutable compile error inside library similar happen library dynamically typed language user pass wrong type interesting solution similar popular library dynamic language use helper function check type valid error message clearly point helper fail example note signature generally better syntax provide template parameter going use isnumeric function stdtraits import stdtraits optional without get error inside like c also included doc participates overloading mymax b isnumeric return b b struct pair value void main mymax pair int p would give compile error saying pair int pair int nt match available instance mymax b isnumeric mymax p p feature called concept serf purpose except design like defining interface type constraint compile time function template number extension allow use feature like compile time function evaluation static basically make template act like function take compile time set parameter return nongeneric runtime function make template fully featured metaprogramming system far understand modern c template similar power le clean mechanism language take generic compile time function concept run even like zig fn stack comptime type type return struct item len usize const self pub fn push self self item zig using language compile time runtime function split based parameter marked comptime another language us separate similar language meta level called terra terra dialect lua allows construct lower level clike function inline manipulate meta level using lua apis well quoting splicing primitive function makestack local struct stack item pointer len int terra stack push item end return stack end terra crazy level metaprogramming power allows thing like implement optimizing compiler domain specific language simple function implement interface object system java go library small amount code save generated runtimelevel code dependencyfree object file rust generic next type monomorphized generic course move code generation one step compiler type checking mentioned type insidethelibrary error get c like error get dynamically typed language course basically one type type template parameter like dynamic language mean fix problem adding type system meta level multiple type type static checking support operation use generic work rust language level also work swift haskell rust need declare trait bound type parameter trait like interface language declare set functionality provided type rust compiler check body generic function work type conforming trait bound also allow use functionality type declared trait bound way user generic function rust never get compile error inside library function instantiate compiler also type check generic function fn mymax partialord b b else b struct pair value fn main mymax let p pair pair value would give compile error saying partialord implemented pair mymax p p language level similar kind type system need implement generic interface support using boxing approach generic rust support using system rust even added uniform syntax v impl sometrait parameter get monomorphized v dyn sometrait parameter us boxing property also allows compiler like swift haskell ghc monomorphize optimization even though default boxing machine code monomorphization logical next step monomorphized generic model pushing compiler backend like copy source code template annotated placeholder generic type generate machine code placeholder typespecific part stamp template quickly memcpy patch like linker work downside monomorphized copy specially optimized optimizer lack duplicate optimization compilation way faster could even make code stamper tiny jit get included binary stamp monomorphized copy runtime avoid bloating binary actually aware language work way idea came writing natural extension taxonomy exactly kind thing hoped exercise hope post give clearer picture generic system different language fit together coherent taxonomy prompt think direction conceptspace might find new cool programming language
49,Lobsters,d,D programming,D as a C Replacement,https://theartofmachinery.com/2019/04/05/d_as_c_replacement.html,c replacement,sway wayland compositor rust good c replacement programming language c story format string work custom type support compiletime checking format string article c member function pointer runtime change needed convert real c program betterc slice walter bright written pointerlength pair problem c compile time function evaluation ctfe many function evaluated compile time guard popular myth c c useful compiler optimisation faq benefit keyword read safed article advantage making metaprogramming le interesting compiletime reflection compiletime checked bit flag enum using metaprogramming code preprocessor manifest constant template module normal article explaining exactly adhoc binding dub registry derelict project bindbc project dpp tool,sircmpwn main developer behind sway wayland compositor recently wrote blog post think rust good c replacement know like programming language either become c replacement c story story like lot system story one time c goto language programming one day realised c program kept reimplementing thing c dynamic array better string polymorphic class etc tried using c instead first loved raii class generic made programming fun even better promise read book c learned master thing like template metaprogramming become almighty god system programming code would amazing learning eventually opposite effect hindsight code actually got worse fell love remember reading scott effective c realising really ineffective c c code broken face c might fiddly use kind elegance rarely word hear c involved apparently lot exc c programmer end going back c case discovered also perfect use feel lot like c c meant example superficial think representative take simple c program include stdioh int main printf n return version using c standard library include iostream int main std cout std endl return idiomatic version import stdstdio void main writef n said superficial example think show general difference philosophy c wanted make difference even clearer use example needed iomanip c update unlike c format string work custom type stefan rohe also pointed support compiletime checking format string using metaprogramming feature unlike c builtin compiler special casing used custom code article c member function pointer happens also good explanation origin good read programming language nerd like tl dr everyone else c member function pointer supposed feel like lowlevel feature like normal function pointer complexity diversity implementation mean really high level complexity implementation subtlety rule author explains implementation several c compiler including favorite elegantly simple digital mar c implementation everyone else way dmc compiler written walter bright invented class template core feature c designed someone spent heck lot time thinking c spec thing could simpler walter said experience implementing c template made consider including realised need complex quick tour point view incrementally improving c betterc compiler support betterc switch disables runtime highlevel feature depend example c code translated directly betterc import corestdcstdio extern c int main printf n return dmd betterc exampled example resulting binary look lot like equivalent c binary fact rewrote c library betterc could still link code compiled c version work without change walter bright wrote good article walking change needed convert real c program betterc actually need betterc switch write clike code needed special case simply runtime let point favourite feature still work betterc static assert allows verifying assumption compile time static assert knuminducers system code often make assumption alignment structure size thing static assert possible document assumption trigger compilation error someone break adding struct member something slice typical c code full pointerlength pair common bug go sync slice simple superuseful abstraction range memory defined pointer length instead code like bufferp offset bufferlen offset got update use muchlessbugprone alternative buffer buffer offset slice nothing pointerlength pair firstclass syntactic support update walter bright written pointerlength pair problem c compile time function evaluation ctfe many function evaluated compile time long factorial int n pure assert n n long ret foreach j ret j return ret statically allocated array size calculated compile time permutation factorial knumthings permutationtable scope guard code one part function often coupled cleanup code later part failing match code correctly another common source bug especially multiple control flow path involved scope guard make simple get stuff right p malloc free called current scope exit scope exit free p put whatever statement loop early return like even multiple scope guard scope nested scope cleanup routine called needed right order also support raii using struct destructors const immutable popular myth const c c useful compiler optimisation walter bright complained every time thought new constbased optimisation c eventually discovered work real code made change const semantics added immutable read const faq pure functional purity enforced written benefit pure keyword safe safed subset forbids risky language feature like pointer typecasts inline assembly code marked safe enforced compiler use feature risky code limited small percentage application need read safed article like hinted earlier metaprogramming got bad reputation among c programmer advantage making metaprogramming le interesting programmer tend useful fun puzzle great support compiletime reflection case compiletime reflection solve problem runtime reflection compiletime guarantee compiletime reflection also used implement runtime reflection truly needed need name enumerated type array enum state stopped starting running stopping string statenames trait allmembers state thanks metaprogramming standard library many nice typesafe tool like compiletime checked bit flag enum written using metaprogramming betterc code preprocessor okay nonfeature feature equivalent preprocessor sane usecases replaced native language feature like manifest constant template includes proper module support mean break free limitation old include hack normal clike code written compiled normal code without betterc switch difference normal code linked runtime support higherlevel feature obvious one garbage collection objectoriented class people confused runtime something like java virtual machine wrote article explaining exactly spoiler like c c runtimes feature even runtime compiled much different compiled c sometimes like write throwaway code say experiment new linux system call something used think best language plain old c always use natively support includeing c code nice apis lot preprocessor craziness like linux usually write adhoc binding many popular c library maintained binding found dub registry derelict project newer bindbc project also tool automated binding including awesome dpp tool brings include support directly code update post got lot attention people never heard interested learning recommend
50,Lobsters,d,D programming,Frictionless D Adoption for the Masses,https://www.youtube.com/watch?v=79COPHF3TnE&list=PLIldXzSkPUXWORGtUrnTo2ylziTHR8_Sq&index=13,frictionless adoption mass,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature dconf frictionless adoption mass átila neve youtube,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature dconf frictionless adoption mass átila neve youtube
52,Lobsters,d,D programming,GCC 9.1 Released,https://gcc.gnu.org/ml/gcc/2019-05/msg00024.html,gcc released,gcc project gcc released http http http wwwgnuorgorderftphtml http gccgnuorg http gccgnuorgprojectscxxstatushtml http gccgnuorgonlinedocslibstdcmanualstatushtml http gccgnuorgonlinedocslibstdcmanualstatushtml http http,mail archive gcc gccgnuorg mailing list gcc project gcc released jakub jelinek jakub redhat dot com gcc gcc dot gnu dot org date fri may subject gcc released replyto jakub jelinek jakub redhat dot com proud announce next major release gnu compiler collection want boost software fresh new compiler new language feature various new optimization improvement old optimization gcc gcc major release containing substantial new functionality available gcc previous gcc release release support longer marked experimental c frontend implement full language already previous gcc major version implemented c standard library support almost complete c frontend library also numerous draft feature gcc new frontend language gcc newly partial openmp support almost complete openacc support optimization side link time interprocedural optimization made scalable various usability improvement gcc diagnostics gcc feature various new warning code compiled successfully older gcc version might require source change see http detail see http information change gcc release available ftp server listed http wwwgnuorgorderftphtml release subdirectory encounter difficulty using gcc please contact directly instead please visit http gccgnuorg information getting help driving leading free software project gnu compiler collection would possible without support many contributor mention developer especially regular tester user contribute high quality list individual large thank individually please consider donation gnu toolchain fund support continued development gcc see http gccgnuorgprojectscxxstatushtml http gccgnuorgonlinedocslibstdcmanualstatushtml http gccgnuorgonlinedocslibstdcmanualstatushtml see http see http
53,Lobsters,d,D programming,Project Highlight: DPP,https://dlang.org/blog/2019/04/08/project-highlight-dpp/,project highlight dpp,appropriate linkage attribute binding c derelict collection binding successor project bindbc tool like dstep exist átila neve casual announcement compiler wrapper blog post successfully compiling header enabled default rundlangio rundlangio átila recently wrote unitthreaded library created stefan koch ongoing work newctfe presentation dconf london plenty time register language foundation youtube channel,designed beginning abi compatible c translate declaration c header file module link directly corresponding c library object file true direction long function code annotated appropriate linkage attribute day possible bind c even objectivec binding c easy sometimes bit tedious particularly done hand speak personally originally implemented derelict collection binding hand though slapped together automation ported successor project bindbc everything maintained hand tool like dstep exist work well enough though come limitation require careful attention massaging output tediousness enemy productivity several page discussion generated átila neve casual announcement week dconf possible include c header code dpp compiler wrapper parse source file dpp extension expand place include directive encounter translating c c symbol pas result compiler dmd default say átila motivated project day cisco wanted use ended choosing c task hand c could include relevant header way whereas language really somehow translate header transitive dependency somehow tried dstep failed miserably fact preprocessor nearly always needed properly use c api wanted remove one advantage c wrote dpp example presented blog post accompanying initial announcement stdlibdpp include stdioh include stdlibh void main printf hello worldn ptr enum numints auto ints cast int malloc intsizeof numints scope exit free ints foreach int numints ints printf ints ptr ints printf n ptr three month later dpp successfully compiling juliah header allowing julia language embedded program following month enabled default rundlangio c support fairly solid though perfect although preprocessor macro support one dpp key feature macro translated expand cc code fragment parse actual code yet make sense context guess macro parameter string ints quoted string one programmatically determine define foo meant c cast know c macro name function work neither got bug report push stdlibdpp code block rundlangio read output see example translation difficulty c story challenging átila recently wrote one problem faced one managed solve others remain dpp translate c template specialisation reference type reference type exist know translate anything depends sfinae also exist know class reference type way java class reference type function parameter annotated ref accept argument reference come variable declaration equivalent c lvalue reference declarator eg int someref despite difficulty átila persists holy grail able include c standard library header difficult currently concentrating much easier problem first able successfully translate c header much simpler library happens use standard library type std string std vector std map usual suspect idea treat type dpp currently handle opaque binary blob focusing instead production library type member function sound simple practice run issue llvm ir ldc abi issue dmd mangling issue fun create instance c stdlib type pas back c function take reference std string give one find hacky way pas slice c function though cool plus side found feature particularly helpful implementing dpp though say harder recall since point mostly take advantage granted first thing came mind combination builtin unit test token string unittest shouldcompile c q struct foo int q static assert typeof fooi int almost selfexplanatory first parameter shouldcompile c code header second code compiled translating c header token string allow editor highlight code inside fact c syntax similar let use c code well also found help contract garbage collector libclang c library hardly abstraction invariant enforcement node ast represented libclang cursor several kind contract allowed document enforce runtime kind cursor function expects preventing bug also libclang certain place requires client code manually manage memory gc make wrapper api never concern development exposed bug dmd frontend tried using sumtype separate branch dpp first convert libclang ast entity type actually enforced compile time instead run time unfortunately caused switch compiling code since sumtype behaves differently separate compilation triggering previously unseen frontend bug unit testing us unitthreaded library created augment builtin unit testing feature advanced functionality achieve library make use compiletime reflection feature dpp lot unit test given number test wrote dpp compiling take long time exacerbated unittest known issue using unitthreaded runner would speed compilation lose feature better compiletime reflection required made faster perhaps see joy stefan koch ongoing work newctfe completed átila speaking dpp may part presentation dconf london conference run may write still plenty time register make watch livestream link provided forum day conference see video talk language foundation youtube channel dconf complete
54,Lobsters,d,D programming,Memoization in the D Programming Language,https://dlang.org/blog/2019/03/30/memoization-in-the-d-programming-language/,memoization programming language,standard library phobos standard library memoizing property http githubcomvportonmemoizedlang template mixin string mixins,programming language provides advanced facility structuring program logically almost like python ruby high performance higher reliability static typing contract programming article describe use template mixins memoization automatically remember function property result stdfunctionalmemoize standard library first way built straight phobos standard library easy use import stdfunctional import stdstdio float docalculations writeln calculation return value calculation apply template memoize function docalculations alias docalculationsonce memoize docalculations alias docalculationsonce docalculations calculation done call docalculationsonce calculation would printed useful long slow calculation situation like create single window screen memoization even possible memoize function argument float float float writeln calculation return value calculation apply template memoize function alias memoize void main string args writeln writeln writeln output calculation calculation see calculation repeated argument value memoizing struct class property found another way memoize involves caching property struct class property zeroargument reading oneargument writing member function sometimes twoargument nonmember function differ syntax deemed elegant cache property struct class rather cache member function return value code easily changed memoize member function instead property always convert zeroargument member function property bother source also install http githubcomvportonmemoizedlang use program module memoize mixin template cachedproperty string name string basename name mixin private typeof basename name cache mixin private bool name iscached false mixin property typeof basename name n name iscached return name cache n name iscached true n return name cache basename n used like either structs class choice import memoize struct property float x return mixin cachedproperty x assert sx specify explicit name cached property import memoize struct property float x return mixin cachedproperty x x cachedproperty template mixin template mixins insert declaration template body directly current context case template body composed string mixins guess string mixin generates code compile time string struct property float x return mixin cachedproperty x turn struct property float x return private typeof x xcache private bool xiscached false property typeof x x xiscached return xcache xiscached true return xcache x set xcache x unless xiscached also set xiscached true retrieving x idea originates following python code class cachedproperty object version property cache value access call underlying function set value dict future access recall property def init self f selffname fname selff f def get self obj owner assert obj none call instanceformat selffname ret objdict selffname selff obj return ret way memoization yet involve caching return value function argument victor porton open source developer math researcher christian writer earns living programmer
55,Lobsters,d,D programming,The joys of translating C++’s std::function to D,https://atilaoncode.blog/2019/03/07/the-joys-of-translating-cs-stdfunction-to-d/,joy translating c std function,program translate c header pragma mangle bug could ctfe like,wrote program translate c header translating c actually challenging thought even got learn thing know language even though known year problem encountered minor though extent knowledge resolved modulo bug c much larger language effort considerably expect hard however blog want talk interesting translate std function hand first issue language would relies template specialisation template typename class function nt definition anywhere template typename r typename args class function r args way constraining std function template accept function type perhaps surprisingly c syntax type function take two ints return double double int int doubt people see outside c standard library template still confusing think double int int type obtained deferencing pointer type double int int far know language c support partial template specialisation however two immediate problem function keyword syntax function type mitigate name issue calling symbol function instead however affect name mangling meaning nothing actually link pragma mangle tell compiler mangle symbol std function template mangling instantiated let worry later call template function second issue worked around c using funptr double int int alias funptr double function int int c using funtype double int int alias funtype typeof funptrinit c function type type one get deferencing function pointer unlike c currently syntax write directly first attempt helper automate getting alias function type template functiontype r args alias ptr r function args alias functiontype typeof ptrinit struct function struct function functiontype r args r args work probably due bug preventing helper template functiontype working intended let forget template constraint extern c std struct function import stdtraits returntype parameter alias r returntype alias args parameter c r operator args const r opcall args const void main alias funptr double function double alias funtype typeof funptrinit function funtype f double result f compiles link undefined reference std function operator double const looking symbol object file using nm see g emitted dmd trying link expected name mangling issue related renaming symbol could manually add pragma mangle tell mangle operator double double template instantiation solution scale ctfe constexpr speak c rescue snip pragma mangle opcallmangleoffixmangling r opcall args const elsewhere file scope string fixmangling string str import stdarray replace return strreplace going abuse compiletime power mangleof property compiletime string tell u symbol going mangled pas string fixmangling function evaluated compiletime fed back compiler telling symbol name actually use notice function still template meaning mangleof different value instantiation almost magical hacky magical final code compiles link actually creating valid std function double double code left exercise reader like like loading related
56,Lobsters,d,D programming,D language version 2.085.0 is released with precise GC option,https://dlang.org/changelog/2.085.0.html,language version released precise gc option,add support objectivec class add support objectivec instance variable add support objectivec super call deprecate objectivec interface contextaware assertion error message avoid calling struct constructor constcasts dmd support expressive diagnostic error message compare longer performed struct equality test memberwise comparison done instead per spec equality expression osx longer supported command line switch introduced test suite popular package transition character type c type equivalence behavior name mangling behavior,add support objectivec class prior release interface used represent objectivec class proper support objectivec class added class used instead represent objectivec class preferred use class represent objectivec class release also add support implementing objectivec subclass method match behavior objectivec additional change made static final method virtual although final method virtual possible override final method subclass static method overridable subclass example extern objectivec class nsobject static nsobject alloc selector alloc nsobject init selector init void release selector release extern objectivec class foo nsobject override static foo alloc selector alloc override foo init selector init int bar int selector bar return void main auto foo fooallocinit scope exit foorelease assert foobar add support objectivec instance variable possible declare instance variable objectivec class instance variable objectivec nonfragile mean base class change add remove instance variable without subclass needing recompile relink thanks feature necessary declare instance variable creating binding objectivec class example extern objectivec class nsobject extern objectivec class foo nsobject int bar static foo alloc selector alloc foo init selector init void release selector release void getbar selector getbar return bar void main auto foo fooallocinit scope exit foorelease foobar assert foogetbar add support objectivec super call possible implement objectivec method make super call method base class example extern objectivec class nsobject void release selector release extern objectivec class foo nsobject int foo selector foo return extern objectivec class bar foo static bar alloc selector alloc bar init selector init override int foo selector foo return superfoo void main auto bar barallocinit scope exit barrelease assert barfoo deprecate objectivec interface prior release necessary represent objectivec class interface support objectivec class implemented class keyword used instead reason deprecation allow extern objectivec interface repurposed representing objectivec protocol future deprecated extern objectivec interface nsobject replace extern objectivec class nsobject contextaware assertion error message release dmd support generating contextaware assertion error message error message provided user example currently following file void main int b assert b would yield error compiled run dmd run maind coreexceptionasserterror maind assertion failure dassertp dmain however new experimental compiler switch checkactioncontext yield dmd checkactioncontext run maind coreexceptionasserterror maind dassertmsg dmain new switch already support variety assertion message string dlang assert dlang dlang struct int assert int b assert b also error message generated fallback displaying text assert expression example complicated assert expression void main int b assert b compiling running checkactioncontext result dmd checkactioncontext run maind coreexceptionasserterror maind assert b failed dassertmsg dmain switch contextaware assertion error message still experimental feedback welcome avoid calling struct constructor constcasts previous version dmd undocumented interaction constcast regular cast ie cast cast const cast immutable cast would expressed cast const typeof expr expr hence expr type struct cast could potentially call constructor struct expr per spec dangerous part however occurred structs used first field alias implicit conversion via alias would potentially satisfy implicit struct constructor leaving field set init leading apparent data corruption mere cast word cast simplicitcast longer occur since cast cast const cast immutable longer generate implicit constructor call implicit constructor call occur one explicitly us cast dmd support expressive diagnostic error message verrorscontext new cli option verrorscontext dmd show offending line directly error message consider faulty program testd void foo run verrorscontext dmd verrorscontext testd testd error undefined identifier memcmp compare longer performed struct equality test memberwise comparison done instead per spec compiler would sometimes generate code struct equality test using memcmp across whole struct object assumed alignment hole filled always case floating point nan value compare equal even bit pattern match spec requires comparison done memberwise manner brings implementation line equality expression break existing code relied former erroneous behavior correct code use one following define opequals operator overload achieve desired behavior use instead bit compare struct object new behavior enabled previewfieldwise compiler switch eventually become default behavior osx longer supported release dmd compiler longer officially support building application osx legacy purpose older release used motivation latest macos release mojave last version osx support running application development team want focus effort buildtest infrastructure active important platform preview revert command line switch introduced command line switch adding subtracting feature language normally added adhoc basis time grown moreover parallel transition introduced following dmd example subset transitional feature dmd support moment dmd transition also name alias still clear user whether transition experimental feature upcoming breaking change b warning help upcoming change c revert change user nt want deal breaking change release dmd gained preview command line switch used test upcoming feature potentially breaking change example release list upcoming feature implement sealed reference implement scoped pointer implement nogc throwables previewmarkdown enables markdown replacement ddoc previewfixaliasthis enables potentially breaking fix alias dmd first check scope searching upper scope previewintpromote enables integral promotion unary operator previewdtorfields enables potentially breaking fix enables destruct field partially constructed object adding new feature disruptive existing code base initially putting behind preview switch user ample opportunity adapt pace therefore end user new preview interface allows glimpse future always feedback bug report preview feature welcome encouraged potential problem breakage caught early whenever preview feature get enabled default must pas continuous integration pas test suite popular package without known major realworld issue bugzilla however behavior dmd could still deviate slightly previous version sometimes revert switch might introduced development team allows easy optout new feature user case run issue dmd offer reverts reverts change revertimport revert single phase name lookup transitioning new feature fixing important bug often trivial additional transition exists transition option informational intended help gauge problem upcoming change assist debugging change example dmd currently support transition transitionfield list nonmutable field occupy object instance transitioncheckimports emit deprecation message anomaly transitioncomplex emit deprecation message usage complex imaginary type transitiontls list variable going thread local storage transitionvmarkdown list instance markdown replacement ddoc transition command line switch might turned actual deprecation importance change considered high enough compared impact realworld code intended information developer would affected certain transition information updated continuously release three command line switch support help page either h help option listing currently available option dmd previewhelp dmd reverthelp dmd transitionhelp important old command line switch continue work wo nt deprecated however removed documentation new code encouraged use preview revert applicable transition character type come advent changed character type mangling default behavior conform one release transition period new switch externstd added control version compatibility set switch set trait gettargetinfo cppstd value cplusplus corresponding version c standard defines particular note new difference wchar wchart window manifest compile error interfacing wchar wchart code calling window api cast resolve issue going forward recommend using wchar instead wchar wchart interfacing window api function wchar microsoft window bit character type c type equivalence behavior posix dmc window vc window wchar unsigned short wchart wchart dchar wchart unsigned unsigned wchart wchart wchart wchart wchar wchart wchart posix dmc window vc window wchar wchart dchar unsigned wchart wchart wchar wchart wchar wchar wchart name mangling behavior posix dmc window vc window wchar w dchar w wchart w w posix dmc window vc window wchar d dchar di u wchart w w
57,Lobsters,d,D programming,Project Highlight: Spasm,https://dlang.org/blog/2019/02/28/project-highlight-spasm/,project highlight spasm,asmdom c percy rust vladimir panteleev dscriptentools sebastien alaiwan older dscripten project asmjs via emscripten react javascript extension jsx famous todomvc application live demo still active llvmbased compiler ldc finally using binaryen release ldc support webassembly baked eliminates dependency druntime entry competition discovered webidl underrun port library developing dub repository port druntime dlang newsfeed dlangng official twitter feed dprogramming,sebastiaan koppe working react project app target market included threeyearold mobile phone encountered performance issue investigating discovered attributable solely mobile platform became clear saw flame graph many function call managed fix performance issue little smarter update redraws sight flame graph never quite left made wonder thing done efficiently time went sebastiaan gained insight ui like state machine interacting ui move one state next total set state rule governing ui static fact require static time user click button want respond way want input validation run time user submits form everything static defined upfront javascript ui framework work hard runtime figure exactly want rendered would efficient figure send code browser led idea analyzing ui definition create optimal ui renderer unable act time nativelanguage dom framework targeting webasm like asmdom c percy rust came attention around time announcement vladimir panteleev dscriptentools introduced sebastien alaiwan older dscripten project former alternative build toolchain latter example compiling asmjs via emscripten saw opportunity revisit old idea using static introspection gave tool create render code compile time bypassing need virtual dom biggest challenge map existing ui declaration pattern plain code way static introspection used extract information necessary generating rendering code one thing really wanted avoid need embed react javascript extension jsx code would require creation compiletime parser instead decided leverage compiler ui declaration ended design every html node represented struct node attribute property member struct combined annotation give enough information generate optimal render code implemented famous todomvc application end result quite satisfying actual source code par shorter javascript implementation compiled code gzip rendering various stage todo app took le announced work forum september live demo still active write unfortunately satisfied amount effort involved get end result required using llvmbased compiler ldc compile llvm ir using emscripten produce asmjs finally using binaryen compile webassembly top needed patched version llvm generate asmjs required patched ldc compiling dependency take long time anything expect end user willfully subject want compiler easy install work happened release ldc august actually rudimentary support webassembly baked sebastiaan started rewriting todo app javascript glue code use ldc new webassembly target lost emsripten bundled musl libc switched code use betterc mode eliminates dependency druntime turn c standard library easytoinstallanduse package wanted able get todomvc binary gzip announced news forum led new path someone asked webgl got motivated think creating binding apis browser night search found underrun entry competition decided port use figure write binding webgl webaudio created binding hand later discovered webidl underrun port complete started work using webidl generate binding formed quickly course month hardest part mapping every feature webidl time figuring move data object callback javascript kind hard choice came support undefined optional type union type type answer yes supported happy result binding web apis included spasm follow javascript api much possible postcompile step used generate javascript glue code run fairly quickly generates javascript glue code actually need collecting imported function generated webassembly binary crossreferencing function webidl definition generating javascript code result spasm library developing singlepage webassembly application latest version always available dub repository wait start working hot module replacement spasm many javascript framework provide outofthe box really valuable developing serverside rendering also something want get written spasm need much reduce page load time necessary want unittest html output seo moment effort directed toward creating set basic material component hard time getting something together work plain one point considered abandoning effort working instead declarative ui language compiles ultimately persisted announcing project soon material project still plenty challenge biggest thing postponing memory management right allocator spasm simple bumpthepointer allocator memory webassembly instance browser hardcoded full full could grow memory course really need way reuse memory without help compiler like rust either mean manual memory management gc one way solve problem would port druntime webassembly something say considered time already least part need far gc always issue webassembly memory linear start combine imprecise gc suddenly everything look like pointer consequence free memory recently someone wrote precise gc implementation definitely back table also excited recently ran webassembly generated cloudflare worker environment different browser many way exciting lot possibility emerge part generate webassembly binary pretty lean mean pretty excited work sebastiaan wait see go keep eye dlang newsfeed dlangng twitter official twitter feed dprogramming learn future spasm announcement
58,Lobsters,d,D programming,<wbr>PhilippeSigaud/D-templates-tut<wbr>orial</wbr></wbr>,https://github.com/PhilippeSigaud/D-templates-tutorial/blob/master/D-templates-tutorial.md,wbr philippesigauddtemplatestut wbr orial wbr wbr,introduction phobos programming language documentation boost document first part function struct class second part template constraint mixin template operator overloading third part string mixins compiletime function evaluation trait fourth part ubiquitous expression resource convention semiliterate programming unfinished get document hosted github http githubcomphilippesigauddtemplatestutorial thanks basic template template function struct class template declaration tuples ctfe alias symbol name syntax semantics struct template class template template specialization default value template constraint tuples enum instantiating template syntax template template argument selecting among declaration template specialization template constraint effect instantiation void template building block eponymous trick inner alias exposing template parameter struct template class template syntax optional code stdrange nested recursion static assert phobos stdrange stdrange power curried template template template template specialization stdalgorithm stdrange specialization static template constraint default value template specialization ifti specialization default value stdalgorithmsort todo stdtraitsreturntype function template syntax eponymous trick auto return auto ref ifti mantra mantra example flattening array range stdalgorithm stdrange stdalgorithmmap stdalgorithmreduce struct template factory function anonymous function template mantra inner structs todo closure poor man object stdtypeconstuple section constraint named field tuples function overloading unfinished storage class instantiating property automatically deduced clause modifying function unfinished accepting tuple mapping n range parallel todo stdalgorithmmap stdfunctionaladjoin doublestage template todo stdalgorithmfilter todo struct template syntax tree tree stdalgorithm stdrange factory function ifti templated constructor stdalgorithm stdrange giving access inner parameter inner alias templated member function mixin template string mixins stdalgorithmmap stdalgorithmmap stdtraitsreturntype stdalgorithmreduce stdalgorithmreduce todo templated constructor ifti inner structs anonymous function mantra templated member function operator overloading template parameter unfinished mixin template example concat flatten range flattening array range stdrange rank range constraint struct template static inner member alias factory function ifti class template section need syntax interface template template method template method template unfinished clause inner class structs anonymous class trait parametrized base class mixin template wrapper template adding functionality inheritance mixin template string mixins curiously recurring template pattern wikipedia mixin template example automatic dynamic dispatch http wikidlangorgdispatchinganobjectbasedonitsdynamictype stdtraits template interface template union template enumeration template advanced consideration basic advanced constraint template specialization syntax expression function template struct template class template template constraint usage flatten stdrange section constraint limit specialization constraint specialization specialization static predicate template section example type sorcery testing member testing operation struct flatten constraint usage template specialization expression string mixins ctfe around template completing flatten range struct flatten struct flatten template tuple parameter definition basic property declaration stdtypetupletypetuple stdtypeconstuple polymorphic tree stdtypeconstuple stdtraitsparametertypetuple stdtypetupletypetuple stdtypeconstuple stdtypeconstuple type tuples example variadic function eponymous template oneelement tuples accepting type alias todo example inheritance list unfinished class template todo stdtypetuple stdtypetuple type sorcery type specialization todo eponymous trick todo operator overloading wwwdlangorgoperatoroverloadinghtml syntax unary operation binary operation assignment index assignment slice assignment cast operation example arithmetic operator todo string mixins special case unfinished special case cast unfinished mixin template syntax todo mixing code operator overloading limitation todo http dlangorgtemplatemixinhtml mixinidentifier mixin example subscriber stack stdfunctionaltodelegate stdstdio opdispatch syntax wwwdlangorgoperatoroverloadinghtml dispatch online string mixins getters setter mixin template wrapping subtyping expanding type wrapper template unfinished mixin template adding functionality inheritance struct flatten todo alias transparent type library typedef wrapper template wrapper template tdpl library typedef todo type information userdefined literal http stdconvoctal unfinished staticallychecked writeln encoding information type annotating type encoding information type stdrangeassumesorted stdrangesortedrange annotatingtypes todo template template template declaration static filter filtering tuples template way doublestage function template string interpolation memoizing function todo memoizing function namedfields tuples ifti stdtypeconstuple stdtypetupleallsatisfy stdtraitsissomestring interleaving type closure poor man object todo unfinished default value instantiating template todo around template compiletime tool string mixins compiletime function evaluation ctfe string mixins syntax mixin template mixing code template operator overloading static limitation ctfe todo escaping string function template syntax compiletime function evaluation evaluation compiletime unfinished template ctfe unfinished template ctfe string mixins oh getters setter simple string interpolation todo example extending stdfunctionalbinaryfun unfinished stdfunctionalunaryfun stdfunctionalbinaryfun todo todo sorting network let lambda simple string interpolation stdalgorithmsort stdalgorithmsort appendix yesno question eponymous trick aggregate instantiating template basic instantiating template introspection point inspecting module stdtraitsparametertypetuple todo todo getting member even overloaded one todo mapping type tuples parent todo testing interface implementation class hierarchy local scope name mixin template string mixins wrapping together unfinished example contributor welcome type sorcery mapping filtering folding type template tuple parameter nontypes mapping type tuples stdtypetuple stdtypetuple stdtraitsunqual example testing function filtering type tuples stdtraitsisintegral template declaration example building factory function constraint inner alias unfinished folding type tuples stdalgorithmreduce sorting type ivory tower wankery stdvariantalgebraic tuple property stdtypeconstuple nontypes scanning type interleaving type crossing type todo static scan folding type tuples juxtaposing function interleaving type annotating type unfinished tuples sequence unfinished mapping tuples filtering tuples unfinished filtering type tuples fun function functiontemplates struct template determining function number argument unfinished memoizing function stdtraitsreturntype stdtraitsparametertypetuple currying function unfinished todo juxtaposing function unfinished relational algebra blog article todo interleaving type fun class structs class hierarchy unfinished generic maker function emitting event field orange extending enum static switching label example staticswitch todo generic structure unfinished gobble todo polymorphic association list unfinished polymorphic tree template constraint expression template staticallychecked writeln stdstdiowritef stdstdiowritefln wikipedia article stdstdio stdtraits template template impltrick extending class todo pattern matching function unfinished function template generating switch tuples sorting network appendix expression general syntax static constraint testing alias inner alias giving access inner parameter b supertype b stdtypeconstuple todo ifti stdtypeconstuple stdtypeconstuple type specialization class template resource reading unfinished template reference dlangorg templatehtml templatesrevisitedhtml tuplehtml variadicfunctiontemplateshtml conceptshtml templatemixinhtml mixinhtml versionhtml expressionhtml declarationhtml operatoroverloadinghtml programming language programming http ddiliorgdersdenindexhtml http ddiliorgdersdentemplateshtml wiki http wikidlangorgintroductiontodtemplates stdfunctionalunaryfun metaprogramming http wwwsemitwistcomarticlesefficientandflexiblesinglepage read http githubcomabscissaefficientandflexible unfinished unfinished unfinished,template tutorial philippe sigaud january introduction template central feature giving powerful compiletime code generation ability make code cleaner flexible even efficient used everywhere phobos standard library therefore user know based c template template bit daunting first programming language website documentation good start though description template spread among many different file language reference material nt much teach use template show syntax semantics document aim kind tutorial template show beginning coder achieved using c remember never using template containersoft stuff considered boostlevel boost metaprogramming kind code could never understand never mind produce well sane syntax template nifty feature static alias tuples cured impression hope document help boost boost c library collection make heavy use template document first part deal basic declare instantiate template standard building block use almost template along function struct class template throughout text example present application concept second part advanced topic template user probably use daily basis like template constraint mixin template operator overloading third part present metaprogramming tool string mixins compiletime function evaluation trait seen templatey point view interact template build conjunction template fourth part present developed example done template based real need time could fulfilled template finally appendix ubiquitous expression another giving resource reading advice complete document convention make document easily readable use standard coding book convention highlighting part text mainly doc keywords marked like int static trait colored depending used generate document symbol name used code sample cited text written like myfunc flatten internal link like external link like syntaxhighlighted code sample shown like doc comment module intro import stdstdio void main int time comment foreach time writeln hello word numbered line used necessary sometimes make little explanatory detour discussing small piece info small section interest reader nonetheless marked semiliterate programming code sample presented document compile reasonably recent compiler utils directory small script called codesamplesd extract code sample mardkdown file sample module name declaration extracted file called named created compiled possibly stub main none exists previous code sample creates file called introd compilation result put file called resulttxt sample depend sample import yeah modularity need specific markup weave code together sample name ending error compile expected show error mistake gotchas anonymous sample extracted use show small snippet intended stand show dish pseudocode see entire document gigantic package describing hundred small module finally section doc finished yet section consider unfinished contain unfinished hey added thanks section long adding new part document new appendix new section intro finished probably forgot unfinished tag hesitate tell get document document markdown file hosted github nt hesitate fork even better make pull request reading paper address http githubcomphilippesigauddtemplatestutorial thanks soon publicly released document community member gave help suggestion correction code sample cool see network emerge people participating common project following people helped craig dillabaugh andrej mitrovic justin whear zachary lund jacob carlborg timon gehr simen kjaeras andrei alexandrescu bjorn lietzspendig thanks guy basic template reading booksize document template interested template let say wonderful tree struct module struct tree int value tree child sizet size sizet foreach child child childsize return bool isleaf property return childrenlength used like module import void main auto tree tree tree tree tree tree tree assert treeisleaf assert treesize well good nice basic int holding nary tree time need float holding one problem coded easily bit copypasting first change tree inttree create floattree node module struct inttree int value inttree child sizet size sizet foreach child child childsize return bool isleaf property return childrenlength struct floattree float value floattree child sizet size sizet foreach child child childsize return bool isleaf property return childrenlength lot code duplication change type value child become float floattree instead int inttree waste need another tree example holding function tree callback say must better way let observe previous code need way produce code generating different tree type injecting type value userdefined input bit like function pushing parameter getting result let imagine code placeholder let call type represent type value struct tree type value tree child sizet size sizet foreach child child childsize return bool isleaf property return childrenlength type symbol introduced without warning struct scope try compile code compiler rightfully complain ask type come function parameter introduced parameter list push following scope function body want tell compiler type placeholder provided latter let continue imaginary syntax module generictree struct tree type type value tree child sizet size sizet foreach child child childsize return bool isleaf property return childrenlength see introduced type oneelement parameter list right tree ideally struct definition abstracted type value look like right sort recipe used generate tree need look previous definition standard struct template compile use heart content see next chapter essence template writing code seeing way abstract certain item type symbol number possibility numerous defining generic recipe perusal template next chapter see define function struct class template nifty syntax demonstrated special case construct simplified version full template declaration syntax see next section like introduce template really definition fundamental whole document said template way define blueprint generate code class definition function could abstract unit code let u say wonderful piece code full function definition structs method new symbol piece code offer entry point parameterization type symbol could abstracted away put template parameter list could parameterized type seen struct tree could parameterized tree type also maybe f tree mapontree tree input tree delegate tree f void printtree tree input defining different treearray possible tree alias treearray tree basic unit hold code well code block course scope ideally would like way group previous declaration one unit parameter list scope type struct tree using type tree mapontree tree input tree delegate tree f also void printtree tree input alias treearray tree get since need call produce code bit like call function code block need name need tell compiler blueprint keyword got template template mydefs type struct tree tree mapontree tree input tree delegate tree f void printtree tree input alias treearray tree template core named parameterized code block ready instantiated template declaration syntax template declaration template templatename list parameter syntactically correct declaration argument accessible inside template scope templatename usual identifier list parameter commaseparated list zero template parameter type identifier identifier alone considered type name common style use identifier beginning capital letter range rest userdefined type many template use c tradition onecapitalletter name type starting u v feel constrained use make template easy understand alias alias identifier declare alias identifier capture type symbol variable name class name even template name also accept many compiletime literal string array function literal mostly need widelyaccepting template use alias parameter note accept builtin type argument however since int valid identifier keyword literal value typename identifier declared like typename identifier literal value integral value int ulong enum based string char floatingpoint value boolean value expression evaluated compiletime ok example int depth string name template parameter tuples identifier syntax identifier yes three dot tuple must last parameter template template parameter tuples capture one identifier entire list template parameter type name literal tuples store template argument throw argument passed get empty zerolength tuple really deal type well symbol tuples bit mongrel type wonderfully powerful easy use see section tuples type alias common floating point value fairly rare use argument compiletime calculation superseded compiletime function evaluation aka ctfe see different us parameter document note pointer array object instantiated class structs function part list said alias parameter allow capture use array class function struct name access capacity alias symbol name big difference builtin type like int double userdefined type userdefined type say class called myclass type name type class myclass accepted type template argument name symbol myclass accepted alias template parameter hand int keyword symbol name type pas alias template parameter template body contain standard declaration variable function class interface template alias declaration exception think declaring module done toplevel scope syntax semantics code inside template declaration syntactically correct code code look like code semantics checked instantiation mean code happily writing template upon template compiler wo nt bat eye exercise template instantiating inside template body parameter accessible placeholder future argument also template name refers current instantiation code generated mostly used struct template class template template declaration example module declaration template arrayof type alias arraytype alias elementtype template transformer type transform import stdconv return class modificator f f template nameof alias enum string name astringof enum manifest constant determined compiletime see template complicatedone string alias bool b int code using b template minimalist zeroparameter template declaration template oneormore firsttype rest rest tuple template zeroormore type type tuple template multiple one arg version template multiple u two args template multiple u v three full syntax template declaration slightly complex introduce next section see example type restriction section template specialization default value section default value instantiation constraint template constraint tuples section tuples limitation interesting keep mind template declared almost scope except inside regular function enum previous code see line defines string called name member nameof enum placed right mean name compiletime constant see kind storage class line immutable const one mean value totally defined fixed runtime see numerous example enum document instantiating template syntax instantiate template use following syntax templatename list argument note exclamation point commaseparated argument list differentiate template argument list standard funtion argument list present function template use templatename template argument list runtime agument list small trick get shorter instantiation syntax argument list contains one argument length one token drop parenthesis like templatename argument valid template instantiation template int template int template string arg template string arg map foo range foo symbol capture alias range runtime argument map foo range ditto multiple int double multiple int double template template argument argument result another template instantiation template return type upon instantiation perfectly ok use inside another template argument list document regularly see matrioshka call like firsttemp secondtempl argument otherarguments selecting among declaration compiler look declaration one template declared called name select one correct number argument correct type instantiate one template instantiated complain stop though look template specialization template constraint effect instantiation instantiate template global effect new named scope code block created template declaration scope name new scope template name argument list templatename args inside block parameter replaced corresponding argument storage class get applied variable initialized possible instantiation previous template might look like module instantiation import declaration void main arrayof int arraytype myarray alias type double type int alias transfo transformer double int struct mystruct mystruct identifier captured alias auto name nameof mystruct name alias complicatedexample complicatedone int type hello string literal arrayof name true boolean literal calculated integral alias minimalist argument firsttype int rest double string abc alias oneormore oneormore int double string abc type tuple int alias zeroormore int type int double string alias zeroormore int double string type empty tuple alias zeroormore selects onearg version alias multiple int three args version alias multiple int double string error version alias multiple outside scope put template instantiation code internal declaration accessible fully qualifying module import declaration arraytype accessible int array completly standard dynamic array ints arrayof int arraytype array arrayof int elementtype element element int void main transform function accessible instantiated like function double string auto transformer double string transform assert typeof string string obviously using template like full name pain nifty alias declaration friend module import declaration alias dtos transformer double string void main auto dtostransform auto new dtosmodificator dtosmodificator class storing double string must keep mind instantiating template mean generating code using different argument different place code instantiate many differently named scope major difference generic language like java c generic code created type erasure used link together hand instantiating template argument create one piece code module differentinstantiations import declaration alias stod transformer string double alias dtos transformer double string alias stoi transformer string int use three different function three different class void note void valid type possible template argument type parameter take care many template make sense void used type following section appendix see way restrict argument certain type template building block template may seem interesting even simple declaration instantiation syntax wait introduced nifty trick simplify greatly expand template us section introduce future best friend foundation template built eponymous trick template declares symbol name greek eponymous enclosing template symbol assumed referred template instantiated one pretty good clean code module pair template pair template pair declares pair member pair return auto array pair int need pair int pair module template nameof alias name enum string nameof namestringof struct example int void main example example auto nameof example auto nameof example assert example assert example used limitation eponymous trick worked defined one one symbol even symbol private would break eponymous substitution changed recently fall module record template record u v import stdtypecons tuple tuple real work done use many symbol need alias tuple u pair alias pair v assocarray alias assocarray record note case eponymous member alias whereas function manifest constant enum previous example already said member name use record module usingrecord import record record int string double recordslist although case eponymous member hide member pair assocarray accessed seems logical since use eponymous trick provide simplified interface user inner alias common use template type magic deducing type assembling new way etc type firstclass entity type type easily manipulated symbol aliasing template expose type done aliasing new name module allarrays template allarraysof alias element alias pointerto alias dynamicarray alias staticarray alias associativearray exposing template parameter though part template name parameter directly accessible externally keep mind template name scope name instantiated t u exist anymore need externally expose template member done allarraysofelement find example section struct template section class template static syntax static construct staticifconstruct let decide two code path compile time specific template use part code incredibly useful template adapt argument way using compiletimecalculated predicate based template argument generate different code customize template need staticifconstruct statement declaration call construct syntax static compiletimeexpression code created compiletimeexpression evaluated true else optional code created false something really important bit compiler magic code path selected resulting code instantiated template body without curly brace otherwise would create local scope hiding happening inside would drastically limit power static curly brace group statement together one statement get rid brace entirely something see frequently code example suppose need template return true passed type dynamic array false otherwise kind predicate template developed bit section predicate module isdynamicarray template isdynamicarray static u u enum isdynamicarray true else enum isdynamicarray false see curly brace static eponymous trick isdynamicarray symbol defined template type automatically deduced compiler result clean syntax expression part way get compiletime introspection go hand hand static crash course end document see appendixisexpression optional code common use static enable disable code single static without else clause generate code condition true find many example idiom stdrange higherlevel range range wrapping range activate functionality wrapped range support like inside myrange templated struct wrapping r r innerrange code exists instantiation myrange optional code static haslength r innerrange length method auto length myrange one also return innerrangelength static isinfinite r innerrange infinite range enum bool empty false myrange also infinite nested static ifs static nested put another static else template selecting alias module selector import stdtraits isintegral isfloatingpoint template selector alias intfoo alias floatfoo alias defaultfoo static isintegral alias intfoo selector else static isfloatingpoint alias floatfoo selector else default case alias defaultfoo selector need sort static switch construct see section examplesstaticswitch recursion static rank let use static something bit complicated dispatching code path recursion know receive ndimensional array simple array array array array array array want use fastest superoptimized numerical function array another one array yet another one higherlevel array abstracting away need template introspection type return element anything array array array mathematician call rank array use definition perfectly recursive module template rank static u u array u type u enum sizet rank rank u let recurse else enum sizet rank base case ending recursion line interesting magic u deduced compiler accessible inside static branch use peel one level type recurse downward using u new type instantiating rank either u array case recursion continue hit base case stop since template defines member named like result directly accessible instantiation rank value type sizet let use module import static assert rank int static assert rank int static assert rank int static assert rank int work type obviously struct static assert rank static assert rank static assert rank static assert putting static assert force assert execution compiletime using expression test clause give assertion type one common use static assert stop compilation example ever get bad code path using static assert false somestring static assert somestring string emitted compiler error message rank range interesting sequence concept called range phobos standard library come predefined testing template stdrange extend rank deal range see something range range type tested range isinputrange element type obtained applying elementtype range type template found stdrange also since array included range concept entirely ditch array part use range slightly modified version rank module import stdrange template rank static isinputrange range enum sizet rank rank elementtype yes recurse else enum sizet rank base case stop unittest auto c cycle assert rank typeof c range range base element type rank way get number array type level nesting range range complementary query would get base element type array array equivalent range module baseelementtype import stdrange import template baseelementtype static rank range static assert tstringof range else static rank simple range alias elementtype baseelementtype else least range range alias baseelementtype elementtype baseelementtype line example static assert stopping compilation ever get bad code path line example matrioshka call template using another template call parameter generating array becoming generative inverting process given type rank r sizet want obtain r level rank mean producing result type module ndim template ndimarray sizet r static r alias ndimarray else alias ndimarray ndimarray recursion done line instantiate ndimarray type create array putting end expose alias also nice example using integral value r template parameter module usingndim import ndim alias ndimarray double static assert double static assert ndimarray double double repeated composition last example use alias template parameter conjunction static recursion define template creates exponentiation function aka repeated composition mean module usingpower import repeatedcomposition standard function string foo string return function template see soon arr makearray arr arr array return array array void main power foo n function assert power foo identity function assert power foo foo aa assert power foo foo foo aaaa assert power foo foo foo foo aaaaaaaa even better function template assert power makearray assert power makearray assert power makearray assert power makearray first template return becomes rather function easy eponymous trick define inside template function name secondly clearly recursive definition two base case exponent zero shall produce identity function exponent one shall return input function said power writes module repeatedcomposition template power alias fun uint exponent static exponent degenerate case id function auto power args args args return args else static exponent endofrecursion case fun alias fun power else auto power args args args return power fun fun args power wondering power syntax line defining eponymous template hide parent template name inside power args power refers power args power alias fun uint exponent want new power generated call global power template global scope operator three branch static power expose power member activating eponymous template trick allowing easy use client note template work unary one argument function also nargs function degenerateidentity delegate structs class define ie opcall operator function template anyargidentity degenerateidentity except degenerate n case since identity function defined accepts one arg version one argument possible would need return tuple anyargidentity cheated little bit resulting function accepts number argument type though standard function parameter check stop anything untowards happen cleaner longer template function complicated implementation would propagate initial function parameter typetuple beginning see power template curried template mean making spicy separating template argument call different place code power could mean alias power square somewhere using square square leisure exponent parameter fun alias separated fact power already partially curried fun exponent separated args see section template template given template temp writing curry template automatically generates code curried version temp also possible outside scope document template specialization write template parameter list constraint type become instantiation template specialization small subsyntax restricting template instantiation subset possible type directing compiler instantiating particular version template instead another read appendixisexpression expression already know write nt please really syntax specialization direct inheritance c template way written existed beginning long static template constraint added specialization added template parameter list u v part template definition type othertype restricts type implicitly convertible othertype module template elementtype u u instantiated array alias u elementtype template elementtype u n u sizet n static array alias u elementtype class array alias int elementtype template elementtype array alias arrayelementtype elementtype idea may seem strange know want restrict type anothertype make template parameter template specialization main use write different implementation template name obviously asked instantiate one compiler automatically decide one use taking adapted provided argument adapted obeys complicated rule find programming language website act natural way time neat thing define general template specialization specialized one chosen possible module template innertype u u specialization pointer alias u innertype template innertype u u specialization dyn array template innertype standard default case void main int p int alias innertype typeof p pointer pointer spec selected alias innertype typeof default standard template selected idiom frequently used c builtin static construct template constraint oldish template used lot since way around year recent code seems constraintoriented look heavily templated phobos module example stdalgorithm stdrange specialization static template constraint yes indeed let defer discussion seen three subsystem default value like function parameter template parameter default value syntax param defaultvalue default anything make sense respect parameter kind type literal value symbol another template parameter module def template default int bool flag false static flag alias default else alias void default alias default double instantiate default double false alias default double true instantiate default double true doh alias default instantiate default int false contrast function parameter thanks template specialization ifti template parameter automatically deduced compiler default template parameter required final parameter list module deduced import stdtypecons tuple template deduced u v u alias tuple u v deduced alias deduced int double u deduced int force v double alias deduced int u deduced int v int specialization default value yes put specialization first default value like u int u commonly used though function wellchosen default greatly simplify standard call see example stdalgorithmsort parameterized predicate swapping strategy adapted people need sorting way client us template short clean customization need still possible todo maybe something template dummy parameter like used stdtraitsreturntype thing like dummy void function template syntax come language generic maybe thought template parameterized class function nt see interest previous section acting type fear also typegeneric function added generative power template seen eponymous trick define function inside template use template name call easily module import stdconv declaration template myfunc int n auto myfunc return int n void main call auto result myfunc assert result int well full story even better first simple way declare function template put template parameter list argument list module import stdconv string concatenate b b b return string string b arg select string max arg arg arg static max return else static min return else static assert select string must either max min nice clean uh notice return type templated using arg return type select auto return since select among code path function return type vary widely depending template parameter passed use auto simplify code module morph morph return heavily depend u auto morph alias f u u arg static class return new f arg else static struct return f arg else return voidreturning function auto ref function template auto ref return type mean template returned value lvalues template get ref ed version nonref version add example behaviour ifti even better implicit function template instantiation ifti mean compiler generally able automatically determine template parameter studying function argument template argument pure compiletime parameter provide directly module ifti import struct foo void main string concatenate int b double string concatenate abc foo string b foo auto select max arg int auto select min min arg double see result simple calling code declare function template call clean syntax done structs class see next section fact syntax clean like may forget time time manipulating function struct etc manipulating template parameterized piece code mantra xxx template xxx template xxx function struct class interface union template parameterized scope scope firstclass type assigned variable returned function mean example return function template inherit class template course instantiated template perfect example function class inherit return may encounter mantra tutorial example flattening array range let use seen concrete way manipulate array sometimes need process linearly writing neither stdalgorithm stdrange provide flatten function beginning simple array want module import void main assert flatten assert flatten assert flatten assert flatten assert flatten studying example want simple array rank nonarray rank unaffected flatten return array rank higher collapse element array classically recursive apply flatten subarrays stdalgorithmmap concatenate element stdalgorithmreduce module import stdalgorithm import auto flatten arr arr array static rank arr return array else auto child map flatten array return reduce ab child concatenate child make good use auto return parameter function fact single call flatten create one instance per level different return type note flatten work perfectly range lazy eagerly concatenates element last one innermost range range lazy good flatten implementation range delivers element one one calculating next one asked thus would work infinite long range previous simple implementation implementing mean creating struct template factory function find example current flatten interesting exercise add another parameter number level want flatten first three level last two innermost example add integral template parameter get incremented decremented recurse another stopping case recursion positive level could mean outermost level negative argument would act innermost one possible use would look like flatten flatten flatten flatten anonymous function template define anonymous function delegate even closure module auto adder int return int b return ab unittest auto adder int delegate int assert previous code adder return anonymous delegate could adder templated ha remember mantra function template template returned particular problem two possible solution either need new type use module auto adder return b return ab unittest auto adder float delegate float assert import stdbigint addbigone accepts bigint return bigint auto addbigone adder bigint assert addbigone bigint bigint auto error error waiting int getting double previous example returned anonymous delegate templated happens use perfectly defined instantiation done really need return something called type use inner struct see section inner structs may come surprise anonymous function template syntax purified version anonymous function b return ab yes previous skeleton function anonymous template remember mantra return due eye bug alias grammar alias symbol alias return id error good use template alias parameter stand function function template module calltwice template calltwice alias fun auto calltwice return fun fun unittest alias calltwice return addtwo assert addtwo since delegate capture local symbol module usingcalltwice import calltwice unittest enum b manifest constant initialized alias calltwice return ab addtwob assert addtwob todo paragraph new b ab syntax closure poor man object closure wrap runtime environment keep near hot little heart course create template obtain equivalent object let create function return tuple stdtypeconstuple named argument module makecounter import stdtraits import stdtypecons auto makecounter counter tinit isnumeric bool sense true auto changesense sense sense auto inc increment counter sense increment increment auto dec decrement counter sense decrement decrement auto counter return counter return tuple typeof changesense changesense typeof inc inc typeof dec dec typeof counter counter changesense inc dec counter part argument list sanitycheck template constraint described section constraint returned tuple bit heavy taste using named tuple field give u nice objectlike call syntax extendingphobostuple otherwise simple return tuple changesense inc dec counter could used inner closure would accessed index name extendingphobostuple see example section named field tuples way extend phobos tuple use module usingmakecounter import makecounter void main auto c makecounter int auto makecounter int cinc assert ccounter cinc assert ccounter cchangesense increment fact decrement cinc assert ccounter function overloading unfinished ok need write something storage class seen section instantiating storage class get applied type instantiation also work function template argument module storage void init ref tinit unittest int init assert need arise mean customize storage class according template argument builtin syntax resort good friend static eponymous trick anyone better example module init template init static immutable const void init nothing else static class void init ref new else void init ref tinit property automatically deduced function following property function tagged pure property mean sideeffects value get back thing matter also tagged safe trusted system safe mean function corrupt memory trusted function call safe one offer guaranty concerning memory system function may whatever want last property nothrow mean function throw exception compiler get complete access function template code analyze automatically deduce property feature still quite new writing seems work function template get smattering property instantiated property course vary template parameter clause clause function given full access template parameter parameterized code mean use static enable disable code depending template argument module inoutclauses import stdcomplex stdmath stdtraits auto squareroot n n n isnumeric n iscomplex n need complex static isnumeric n assert n body return sqrt n modifying function section show use wrapper template add new functionality predefined function powerful example shown autoref funwithfunctions use template seen yet sure look though unfinished want put small functionwrapping template making function accept tuples making function named parameter sort making function default value args making function accept args original making function accept argument different type useful mapping tuples like section tuples sequence accepting tuple module acceptingtuple template tuplify alias fun auto tuplify tuple tup return fun tupexpand another interesting much complicated example juxtapose see section juxtapose mapping n range parallel todo explanation showing interest mapping n range parallel module nmap import stdalgorithm import stdtypetuple allsatisfy import acceptingtuple easy auto nmap alias fun r r range allsatisfy isinputrange r return map tuplify fun zip range complicated stdalgorithmmap accepts one function template argument case function mapped parallel range internally using stdfunctionaladjoin extend nmap accept n function parallel first difficulty auto nmap fun r r range allsatisfy isinputrange r uh see problem need variable list function variable list range template parameter tuples must last parameter template one doublestage template come rescue template nmap fun funlength auto nmap r r range allsatisfy isinputrange r two part well separated give u final code module import stdalgorithm import stdfunctional adjoin import stdrange import stdtypetuple allsatisfy import acceptingtuple tuplify template nmap fun funlength auto nmap r r range allsatisfy isinputrange r alias adjoin staticmap tuplify fun fun return map fun zip range todo give example max work n range version stdalgorithmfilter module nfilter import stdalgorithm import stdrange import stdtypetuple allsatisfy import acceptingtuple tuplify auto nfilter alias fun r r range allsatisfy isinputrange r return filter tuplify fun zip range todo example lot example struct template syntax might guessed declaring struct template done putting list template parameter struct name like module import stdarray struct tree value tree child bool isleaf property return childrenempty tree function adding child removing tree tree remember inside template declaration template name refers current instantiation inside tree name tree refers tree give u runofthemill generic tree created like template module usingtree import void main auto tree int auto tree int tree int child previous template parametrize structs using much simple type module bool lessthan b return b struct heap type alias predicate lessthan float reshuffle predicate governs internal comparison reshuffle deal internal reorganizing heap type value struct template heavily used stdalgorithm stdrange lazy evaluation look factory function one limitation struct constructor activate ifti like template function previous subsection instantiate tree explicitly indicate auto tree int yes auto tree error automatic deduction int templated constructor possible may template parameter differing global struct template honestly pain even struct template many template argument solution course use template function create correct struct return example factory function tree module import auto tree value tree child null return tree value child void main auto tree yes auto tree yes static assert typeof tree int auto tree yes typeof tree tree int look stdalgorithm stdrange show numerous example idiom giving access inner parameter said section inner alias template argument accessible externally template instantiated tree example might want get easy access template expose parameter aliasing let complete tree definition module import stdarray struct tree alias type value tree child bool isleaf property return childrenempty void main tree string tree string abc alias typeof static assert string templated member function struct template template like declare template inside even function template mean templated member function crippled okay since nt introduce powerful feature mixin template string mixins code duplication sorry condition named code sample compile mapping tree let u use templated member function give tree mapping ability range use stdalgorithmmap apply function turn element thus delivering transformed range process done tree thereby keeping overall shape modifying element could easily make free function member function section let think little bit coding map function template accepts function name template alias parameter like stdalgorithmmap let call alias fun value member transformed fun easy want return new tree type parameter result type fun fun transforms b tree mapped tree b however since fun function template may predefined return type could obtained stdtraitsreturntype apply value obtained tinit take type b typeof fun tinit child map fun collect result new child array type tree b mapped tree leaf ie child process stop since recursive template help compiler bit return type go lazymapping lazymapping difference phobos map version nt lazy module import stdarray auto tree value tree child null return tree value child struct tree alias type value tree child bool isleaf property return childrenempty tree typeof fun tinit map alias fun alias typeof fun tinit mappedtype mappedtype mappedvalue fun value tree mappedtype mappedchildren foreach child child mappedchildren childmap fun return tree mappedvalue mappedchildren let use module import stdconv import int addone int return void main auto tree auto tree auto tree tree tree int static assert int adding one value auto addone assert converting value string auto t string convert every value string t assert tstype string assert tsvalue folding tree may feel map really member function take argument let make another transformation tree folding collapsing value new one range equivalent stdalgorithmreduce collapse entire linear range one value numerical value another range tree folding example generate value preorder postorder calculate height tree number leaf range folding extremely versatile function fact used convert tree array another tree taking inspiration reduce need seed value two folding function first one ifleaf called childless node fold return ifleaf value seed second one ifbranch called node child case first apply fold child return ifbranch value foldedchildren simple case use function hence default case ifbranch code leftfold leftfold technically stdalgorithmreduce left fold shown right fold difference essential module import stdarray tree tree value tree child null return tree value child struct tree alias type value tree child bool isleaf property return childrenempty typeof ifleaf tinit sinit fold alias ifleaf alias ifbranch ifleaf seed isleaf return ifleaf value seed else typeof treeinitfold ifleaf ifbranch seed foldedchildren foreach child child foldedchildren childfold ifleaf ifbranch seed return ifbranch value foldedchildren let play bit first want sum value tree leaf return node value plus seed branch given value array containing sum value child need sum value array add node value return case seed value module summingtree import stdalgorithm import typeof tinit sinit sumleaf value seed return value seed sumbranch value summedchildren return value reduce ab summedchildren import stdstdio void main auto tree auto tree auto tree tree int sum sumleaf sumbranch assert sum family bit interesting getting value inorder iteration given tree node return array containing local value value node recursively module inordertree import stdalgorithm import inorderl value seed return value seed inorderb value inorderchildren return value reduce ab inorderchildren void main auto tree auto tree auto tree tree int seed empty array auto inorder inorderl inorderb seed assert inorder last use build tree todo write templated constructor struct constructor member function templated need template parameter struct definition module templatedconstructors struct u u u void main auto string string u int see ifti work constructor u automatically deduced though indicate case however example drastically limited value type u struct u exist outside constructor bit useful would collect alias function example use initialize struct used initialization discarded afterwards ifti activated alias interesting use seen make conversion struct construction module holder import stdconv struct holder type type value anothertype anothertype value value type value void main holder int h holder int assert hvalue way holder int constructed value conversion possible always hold int inner structs create return inner structs use local template parameter definition could factory function heap like module auto heap alias predicate type type value struct heap type value type value code initializing value using predicate heapy code return heap value alias predicate implicit case heap struct encapsulated inside heap us predicate alias inside engine templated struct use tree example recursive type becomes tricky way strangely enough though declare pure template inside function declare struct template remember adder function section anonymous function nt need templated one type argument time add number le type function convert argument string concatenating module anonymouserror auto concatenate legal code return b b b return string string b previous example legal code remember mantra course solution return struct templated member function case opcall operator module innerconcatenate import stdconv auto concatenate struct concatenator auto opcall b b b trusted return string string b concatenator c ca activate opcall return c void main auto c concatenate auto cc c abc assert cc see section operator overloading templated inner structs inside struct template perfectly legal module templatedinner struct outer struct inner auto inner return inner auto outer return outer void main auto outer outer int auto oinner abc outerouter int innerinner string template parameter unfinished kind example would great inside struct class template another kind template parameter template parameter declared identifier identifier get type reference useful mainly two us mixin template know enclosing type beforehand please see section example determine type reference qualified const immutable shared inout unqualified example concat flatten range use learned struct template create lazy range flattens range range linear range remember flatten function section flattening array range worked quite well eager lazy given infinite range cycle example would choke make lazy flattener look range defined stdrange see structs basic way get laziness struct hold iteration state expose basic range primitive least input range simplest kind range type must following member property member function manifest constant front return range first element popfront discard first element advance range one step empty return true range element false otherwise simple basis powerful algorithm designed act range defines refined range concept adding constraint forward range add save member used store range internal state allows algorithm start saved position bidirectional range also back popback primitive accessing end range begin creating simple input range take range range iterates inner element let begin basic module import stdrange import struct flatten range range range auto flatten range range range static rank range static assert flatten need range else static rank range return range else return flatten range range struct template associated factory function nt make sense instantiate flatten old type range checked range using rank template saw rank range nt seen template constraint yet described section constraint would good fit range range represented like want flatten return element order note range rank higher elemxy range given time flatten working subrange iterating element discarding empty iteration stop last subrange consumed range empty module import stdrange import struct flatten range alias elementtype range subrange alias elementtype subrange element range range subrange subrange range range range range rangeempty subrange rangefront element front return subrangefront bool empty return rangeempty void popfront subrangeempty subrangepopfront subrangeempty rangeempty rangepopfront rangeempty subrange rangefront cheat little bit standard bracing style eats vertical space like tomorrow begin line defining new type used method strictly necessary make code easier understand expose type outer world needed constructor necessary initialize struct front return subrange element work range range rank want something flattens range rank linear range easily done add recursion factory function module import public import auto flatten range range range static rank range static assert flatten need range else static rank range return range else static rank range return flatten range range else rank higher return flatten flatten range range testing module import stdalgorithm import stdrange import stdstring import import void main auto auto flatten assert rank typeof yup linear range assert equal auto flatten assert equal need insist auto text sing goddess anger achilles son peleus brought countless ill upon achaean many brave soul send hurrying hades many hero yield prey dog vulture counsel jove fulfilled day son atreus king men great achilles first fell one another auto line textsplitlines array string string word foreach line line word array splitter line assert rank typeof word range range string range range array char auto flat flatten word assert equal take flat sing ogoddess theangerofachillessonofpeleus thatbr work used struct template static inner member alias factory function ifti class template section need oop programmer used create interesting hierarchy anyone reading example class template could used throughout section game syntax surprise put template parameter list class optional inheritance indication module class base interface interface class myclass type alias fun bool b false base fun parameterized inheritance various template parameter defined base class list use module class base interface interface alias fun bool b class myclass type alias fun bool b false base type fun b interface template yes see section template open interesting vista class inherits determined template argument since base may many different class even interface depending type fact look module enum whatbase object interface baseclass template base whatbase whatbase whatbaseobject static whatbaseobject alias object base myclass inherits directly object else static whatbaseinterface alias theinterface base else alias thebase base class myclass type base type myclass inherit object root class hierarchy interface another class obviously dispatching template could much refined second template parameter base class could parameterized syntax however change number interface compiletime emptyinterface complicated say argument myclass inherit j k argument inherit l need previous interface participate action template needed interface predefined templated need wrapping template pain however type tuples used greatly simplify emptyinterface except maybe interface template empty certain parameter thus effect disappearing list method template object method nothing delegate reference local context seen structs method template unfinished need write something overriding method template also need find interesting method example man class invariant clause family clause function section inandoutclauses class template invariant clause access template parameter make disappear totally get empty static statement module classinvariant class myclass u v invariant static u invariant code else empty invariant inner class principle structs define inner class using template parameter even give method template use template argument really nothing different inner structs anonymous class return anonymous class directly function method templated well class template would nt make sense return anonymous class templated method really need module anonymousclass store function default return value auto acceptor alias fun defaultvalue return new class auto opcall static trait compiles fun tinit return fun else return defaultvalue unittest int int return auto accept acceptor auto accept assert auto accept abc assert default value trait compiles see online section trait document parametrized base class use template parameter directly base class module parametrizedbaseclass interface iserializable sizet serialize property class serializable iserializable sizet serialize property return thistohash example serializable someclass act someclass different would normal class except idiom abstracted base class write template used class different interface like nest property auto wrapped new serializable iterable someclass course base class interface may parameterized module serializetemplate enum serializationpolicy interface iserializable serializationpolicy policy static policy void serialize else void serialize class serializable policy iserializable policy also get kind effect alias x declaration class struct also look mixin template wrapper template idiom built around need adding functionality inheritance example taken timon gehr given base class cell private field getset method possible provide additional functionality inheritance defining template cell subclass new possibility doubling value logging value etc possible select new action inheritance timon gehr timongehr gmxch via puremagiccom module inheritanceexample import stdstdio abstract class cell abstract void set value abstract const get private field class addsetter c cell c override void set value field value class addgetter c cell c override const get return field class doublecell c cell c override void set value superset value class oneupcell c cell c override void set value superset class setterlogger c cell c override void set value superset value writeln cell set value class getterlogger c cell c override const get auto value superget writeln value retrieved return value concretecell true getter true setter class concretecell addgetter addsetter cell oneupdoublesetter setter add stored value double class oneupdoublesetter oneupcell doublecell addsetter cell doubleoneupsetter setter double stored value add class doubleoneupsetter doublecell oneupcell addsetter cell void main cell string x x new concretecell string xset hello writeln xget cell int new setterlogger concretecell int yset print cell set new getterlogger doublecell concretecell int yset yget print retrieved new addgetter oneupdoublesetter int yset writeln yget print new addgetter doubleoneupsetter int yset writeln yget print knowing scala programming language bit reminiscent trait scala sortof stub class added class provide new function apart feature also use mixin template string mixins curiously recurring template pattern module crtp class base child class derived base derived hold mean base easy understand derived say inherits another class templated derived derived defined stage yes work called crtp stand curiously recurring template pattern see wikipedia could interest trick see wikipedia document used either obtain sort compiletime binding inject code derived class latter offer mixin template look crtp come c multiple inheritance fear interesting feel free prove wrong gladly change section example automatic dynamic dispatch example come andrej mitrovic also find wiki http wikidlangorgdispatchinganobjectbasedonitsdynamictype sometimes may need call function object function accepts certain derived object type case need ensure dynamic type object specific type attempting cast type passing function example class class b class c void foo b b void foo c c void main b new b c new c foo b accepted object must casted either b c foo c ditto since object b c static type could dynamic type derived class user would try cast object know whether call foo object code dispatching mechanism hand would typically look like import stdstdio class class b class c void foo b b writeln called foo b b void foo c c writeln called foo c c void main b new b c new c auto obj cast c b foo obj else auto obj cast b b foo obj auto obj cast c c foo obj else auto obj cast b b foo obj however inefficient hard type introduces copypasted code errorprone since adding new leaf class mean user inspect edit dispatch code alternative method use classinfo structure retrieved via typeid associated every instantiated object compare existing classinfo structs match safely static cast object pas function help template automate entire process information template need list leaf class construct tree class properly dispatch object full implementation provided import stdstdio import stdtypetuple import stdtraits import stdstring template classtreeimpl leaf static leaveslength alias typetuple leaf baseclassestuple leaf classtreeimpl leaf classtreeimpl else static leaveslength alias typetuple leaf baseclassestuple leaf classtreeimpl else alias typetuple classtreeimpl template classtree leaf alias derivedtofront noduplicates classtreeimpl leaf classtree template autodispatch leaf void autodispatch alias func args args args argslength args class auto objinfo typeid args foreach base classtree leaf objinfo baseclassinfo static trait compiles avoid ct error due unrolled static foreach return func cast base cast void args args return func cast base cast void args args string argument argument objinfotostring foreach arg args argument typeof arg stringof assert format function callable type trait identifier func argumentsjoin class class b class c b class b void foo c c int x writefln foo c received x void foo int x int writefln foo received x void main c new c new new alias autodispatch c callfunc callfunc foo c ok callfunc foo ok callfunc foo assert runtime autodispatch take list leaf class extract tree class using trait found stdtraits inner autodispatch function used dispatch object additional argument function implementation work singleobject argument general solution dispatch multiple object possible implement template two aggregate type templated using syntax interface union interface template syntax exactly might imagine module interfacesyntax interface interf foo bar int templated interface sometimes useful look much like class template wo nt describe remember mantra interface template interface blueprint produce interface leisure union template syntax suprise module unionsyntax union union b c b b c c union template seem like good idea honestly never seen one reader document please give example know one enumeration template strangely enumeration previous simplified syntax declare templated enumeration use eponymous template trick module enumsyntax template enum enum enum b c advanced consideration previous part saw everyone know template fact much follows necessarily complicated probably little le commonly used document matures subject may flow basic advanced way round constraint template constraint way block template instantiation condition met condition determined compiletime authorized make constraint superset template specialization usage grew rapidly introduced phobos indication template specialization contrary becoming le common syntax obtain constraint put clause template parameter list enclosed scope template templatename u v somecondition u v compiler try instantiate template first check constraint evaluates false template declaration part considered set way using constraint keep drop template leasure expression friend allowing get compiletime introspection type see appendix expression crash course may many template declaration name differing constraint fact use case constraint depending activated constraint considered compiler module constrained template constrained int template constrained string template constrained u int u float template constrained u int u float alias constrained int alias constrained string error declaration fit string alias constrained int string considered dropped syntax specialcases template seen section function template struct template class template template tricky part class template may wonder put constraint inheritance list answer module constraintsyntax thefunction argument int double return argument struct thestruct int double class theclass int double baseclass write constraint remember compiletime construct thefunction argument known compiletime type use argument constraint need value type use tinit example module ctvalue auto calltwice alias fun arg ok fun fun typeof fun fun tinit return fun fun arg constraint usage constraint come idea concept er concept although simpler define understand shown implement idea define set condition type must respect representative concept check instantiating look constraint posterchild range rangetutorial rapidly described section flatten rangetutorial range overdue tutorial stdrange defines set template check different range concept called isinputrange isforwardrange call bool becoming template predicate template talk section usage quite simple module rangewrapper import stdrange struct rangewrapper range range comply input range concept isinputrange range know range least three member function front popfront empty use happily factory function auto rangewrapper range range range isinputrange range return rangewrapper range range fact bit like compiletime interface compiletime ducktyping care range kind may struct class know important respect input range concept good news compiler complain instantiate template due constraint respected give better error message way although good might need constraint limit main problem compared template specialization module constraintserror template temp int specialized ints template temp generic case alias temp int ti error error compiler find int specialized generic version instantiated decide one mean quite correctly nothing humble code problem say add constraint generic version template temp int specialized ints template temp int generic case temp int work try instantiate int template present constraint false dropped considered template list hurrah quite wormed way generic version adding code none initially imagine one three different specialized version template temp int specialized array ints template temp isrange specialized range template temp double n int n specialized static array double template temp generic constraint ok quick constraint complement constraint see template temp generic int isrange double n int n becoming complicated maintain someone else add fourth specialization need add fourth inverted version constraint bad still compile call temp temp int error constraint mutually exclusive int also input range mean need add clause excluding array int maybe modify constraint ouch yes constraint wonderful drawback data point author us time even though specialization sometimes userfriendly want impose check type done specialization constraint specialization static mean come three different way decide template exists template specialized u u template constrained u u template staticified static u u else stop compilation static assert staticified instantiated designer thinking well got specialization cousin c two subsystem added year later power compiletime metaprogramming became apparent powerful tool needed modern subsystem constraint static static constraint much powerful specialization anything test specialization test expression constraint static wonderfully useful outside template instantiation two well implanted stay specialization first quite nice porting c code second nice effect constraint one definition could instantiated priority given specialized saw explanation previous subsection end conclusion bit zen given tool powerful tool powerful sometimes option toolbox also constrain chose wisely predicate template find typing expression complicated constraint time abstract another template bool becoming one look section see way test particular piece code ok compilable another way obtain using trait compiles code example section type sorcery show another example predicate template testing member example want test type serialized sizet serialize member function module isserializable template isserializable type static trait compiles type type sizet num typeserialize enum bool isserializable true else enum bool isserializable false testing operation seen previous section struct flatten constraint usage writing kind compiletime interface type pas test long serialize member return sizet course limited testing member function template verify type arithmetic operation module hasarithmeticoperations template hasarithmeticoperations type static trait compiles type result result addition result substraction result multiplication result division result unary result unary enum bool hasarithmeticoperations true else enum bool hasarithmeticoperations false static assert hasarithmeticoperations int static assert hasarithmeticoperations double struct static assert hasarithmeticoperations see test type code mean much powerful template specialization expression may also get certain feel pattern emerging previous two example scaffolding boilerplate could easily template operator test example possible mean crafting code compiletime wait see string mixins ctfe around template completing flatten range let come back flatten section struct flatten using conceptchecking template verify rangeness wrapper type promote flatten forward range status range forward range import stdrange struct flatten range isinputrange range code static isforwardrange range flatten save property return struct enriched two way first instantiated nonrange good code section struct flatten could bypass factory function manually create flatten int would nt secondly wrapped range forward range flatten range one also open whole new algorithm flatten quitereadable little piece code could extend pattern way allowing flatten bidirectional range would need introduce backsubrange member keep trace range back state template tuple parameter definition basic property come one favourite subject template tuple parameter seen section declaration declared putting identifier last parameter template tuple absorb type alias literal passed reason bunch type interspersed symbol people consider mongrel addition template true ease use flexibility give u opinion well worth cost little cleanliness template tuples length member defined compiletime obviously element accessed using standard indexing syntax even sliced symbol aliased tuple length module dropfront template dropfront static tlength length least element int indexing alias dropfront slicing else alias void dropfront alias dropfront int double string shortened static assert shortened double static assert shortened string declare value type tuple value called expression tuple also length indexed sliced also pas directly function type check function parameter list throw array melt initialize array module tupledemonstration template tupledemonstration alias tupledemonstration unittest tupledemonstration string int double assert tlength abc auto assert assert void foo int double foo ok double array see assert array simplest possible tuple already defined phobos stdtypetupletypetuple template typetuple alias typetuple expose alias typetuple int string double isd static assert typetuple isd isd isd isd pure template parameter tuples autoflattening nest module ttflatten import stdtypetuple alias typetuple int string double isd alias typetuple isd isd isdisd isdisd int string double int string double int string double int string double static assert isdisd typetuple int string double int string double bug feature negative side condemns u linear structure tree type tuples since branching structure give rise linear would strictly powerful positive side allow u concatenate tuples easily iterate easily need recursivebranching structure using stdtypeconstuple really kind structclass template type flattened see example section polymorphic tree fully polymorphic tree last property tuples iterated use foreach expression like would array foreach iterate type tuples expression tuples indexed version also possible ask directly ref access value see example iteration done compiletime fact one main way get looping compiletime module ttiteration import stdtypetuple unittest alias typetuple string int double abc string tlength foreach index type iteration type type different er type position static type double index typestringof assert double void bar ref foreach index value iteration value value different type position bar index use iindex value get ref access assert assert import stdmath assert stdmathisnan value type created named almost firstclass two limitation however builtin syntax declaring tuple previous example calling tstringof return string string int double write string int double mytuple directly paradoxically string int double type tuple called mytuple tuples returned function wrap struct stdtypeconstuple offer tuple tuple tupleof common question newcomer difference definition different tuples found language standard library try explain template tuple parameter internal template declared last position parameter list group together list template parameter type value alias two subtypes commonly used type tuples template tuple parameter hold type expression tuples tuples hold expression get declare variable type type tuple function parameter tuples get function parameter type tuple stdtraitsparametertypetuple exactly type tuple seen value type declared passed function parameter tupleof property property aggregate type class structs return expression tuple containing member value member name tuple tuple string get using trait member sometype contains sometype member name string including method constructor alias stdtypetupletypetuple stdtypetupletypetuple predefined template phobos simplest possible template holding tuple common way deal type tuples name bit misnomer standard template parameter tuple hold type also value stdtypeconstuple stdtypeconstuple stdtypeconstuple predefined structfunction template phobos give simple syntax manipulate tuples return function type tuples get tuple type using typeof tuple like type two limit case oneelement tuples difference tuple one element lone type initialize standard value tuple extract first element idea tuple length sliced action make sense standard type zeroelement tuples possible empty tuple holding zero type confused uninitialized nelements tuple tuple holding void type fact zeroelement tuple one value initialization value reason sometimes called unit type twovalues twovalues bool type two value true false empty tuple type one value void type value voidcontaining tuples empty tuples type tuple may hold void type like type take slot tuple tuple holding void empty tuple module emptytuple import stdtypetuple alias typetuple void void alias typetuple empty static assert void empty static assert typetuple int void string typetuple int string example variadic function tuples useful make function template variadic accept different number parameter without restriction passein type need time another function template process argument standard example transforming parameter string module variadic string tostrings string sep args args args import stdconv string result foreach index argument args result string argument index argslength result sep last one return result unittest assert tostrings abc abc want restrict number parameter type use template constraint int howmany args args args argslength argslength return argslength argslength imagine bunch range since different type put array since structs cast base type would class hold tuple need call basic range method calling popfront etc possible way module popallfronts import stdrange stdalgorithm import areallranges void popallfronts range ref range range areallranges range foreach index range range range index popfront get ref access unittest auto auto hello world auto map popallfronts assert assert ello world assert equal work number range cool checked compiletime pas int discretly hoping one see job areallranges verify code classical example recursion type tuples module areallranges import stdrange template areallranges range static rangeslength base case stop enum areallranges true else static isinputrange range found notrange stop enum areallranges false else continue recursion enum areallranges areallranges range people used language like lispscheme haskell right home others little explanation might order get typetuple either empty empty element hold range return true empty least one element accessed indexing let test either range nt range iteration stop element range return false range proved anything need continue recursion interesting defining areallranges manifest constant activate eponymous template trick get initialized value obtained calling template shortened tuple slicing drop first type already tested continue next one end either exhausted tuple length case find nonrange oneelement tuples accepting type alias sometimes make sense template accept either type parameter alias example template return string representing argument case since type parameter accept symbol argument way round alias doomed repeat module template nameof enum string nameof tstringof template nameof alias enum string nameof astringof unittest assert nameof double double int assert nameof since tuples accept type alias use simplify code bit module template nameof tlength restricted one argument enum string nameof stringof todo better explanation order convinced example inheritance list unfinished section rewritten compiler accepting thought using class template might want adjust inheritance list compiletime type tuples nice way first define template alias type tuple class inherit template module interfacelist import stdtypetuple interface interface j interface k interface l class basea class baseb template inheritance base base class static base basea alias typetuple base j k inheritance else static base baseb alias typetuple base l inheritance else alias base inheritance inherits base class myclass inheritance basea class myotherclass inheritance baseb templated inheritance base class could easily template global enum example case selection abstracted away choicemaking code one place change easily todo need rewrite junction two part section let begin something simple given type type tuple eliminate occurrence type type tuple module eliminate import stdtypetuple template eliminate type targettuple static targettuplelength tuple exhausted alias targettuple eliminate job done else static targettuple type alias eliminate type targettuple eliminate else alias typetuple targettuple eliminate type targettuple eliminate unittest alias typetuple int double int string target alias eliminate int target noints static assert noints typetuple double string difficulty line first type type keep continue recursion eliminate type eliminate type juxtapose type like wrap template phobos defines typetuple stdtypetuple use know get rid occurrence type type tuple write template eliminate duplicate algorithm simple take first type eliminate occurrence type remaining type tuple call duplicate elimination anew resulting type tuple time collecting first type module noduplicates import stdtypetuple import eliminate template noduplicates type static typeslength alias type noduplicates type nothing else alias typetuple type noduplicates eliminate type type noduplicates static assert noduplicates int double int string double typetuple int double string way code also called noduplicates already phobos found stdtypetuple found coding good exercise type tuple manipulation find example kind template type sorcery last piece puzzle get given class inheritance list expression give u way type specialization module superlist import stdtypetuple template superlist class class class static class parent super alias typetuple parent superlist parent superlist object object parent super give empty typetuple template superlist alias typetuple superlist unittest class class b class c class c static assert superlist object typetuple static assert superlist typetuple object static assert superlist b typetuple object static assert superlist typetuple c object todo rewrite end good go given base class get inheritance list superlist drop base class keep interface stitch interface provided inheritance call noduplicates make thing clearer define many alias template keep use eponymous trick defer aliasing another template todo needed anymore dmd eponymous trick work even internal member defined module checkedinheritance import superlist import interfacelist template checkedinheritance base alias checkedimpl base result checkedinheritance template checkedimpl base rewrite work class noerror checkedinheritance myclass operator overloading allows user redefine operator enhance readability code guess operator overloading based member template described href wwwdlangorgoperatoroverloadinghtml doc syntax following section give operator overload template member must define custom type u value type u want define operator v value type v u interact v u different type altogether op one concerned operator introduced section unary operation concerned operator operation member template define opu opunary string op opu opindexunary string sizet op opu opindexunary string sizet sizet op opu opindexunary string sizet op opu j opsliceunary string sizet sizet j op opu opsliceunary string op binary operation concerned operator operation member template define u op v opbinary string v v v op v op u opbinaryright string v v v op assignment concerned operator operation member template define u op v opopassign string v v v op index assignment concerned operator operation member template define u op v opindexopassign string v v v sizet op slice assignment concerned operator operation member template define u j op v opsliceopassign string v v v sizet sizet j op u op v opsliceopassign string v v v op cast operation operation member template define cast u opcast many operator overloaded demand template example arithmetic operator todo tell somewhere possible foo opbinary string op idea behind strange way overload operator allow redefine many operator one method example take struct wrapping number struct number isnumeric num give four basic arithmetic operator another number another define opbinary activate operation number left case right define opbinaryright since overloadings tend use string mixins use even though introduced section string mixins basic idea string mixins paste code given compiletime string put module number import stdtraits struct number isnumeric num auto opbinary string op u u u op op op op isnumeric u u u number v v mixin alias typeof op b result static isnumeric u return number result op b else return number result op bnum op template parameter usable compiletime constant folding case concatenation string generate code way code written number respect global promotion rule number int plus number double return number double special case unfinished special case cast unfinished mixin template template seen instantiated scope declaration mixin template different behaviour code hold placed upon instantiation right call site thus used completely different way template syntax distinguish standard template mixin template latter slightly different syntax declared called declaration mixin template newfunctionality u instantiation class myclass u v mixin newfunctionality u v see put mixin declaration mixin instantiation call template nicety constraint default value still perusal symbol lookup done local scope resulting code included call made therefore injecting new functionality far know special syntax function class struct template mixin template wrap standard template declaration idea notion eponymous trick mixin template question give access template content since template cracked open content put code todo test mixin foo return way mix standard template used case possible anymore mixin template nonmixin one strictly separated cousin mixing code good cousin template seen far give nice way place parameterized implementation inside class struct template way reduce boilerplate code piece code appears different place code example structs inheritance avoid code duplication look way put mixin template also put small functionality mixin template giving client code access chose want build type note code place inside mixin template nt make sense refer notyetdefined symbol syntactically correct code example remember operator overloading code saw section operator overloading mixin containing concatenating functionality module mixinconcatenate import stdtypecons mixin template concatenate tuple typeof u opbinary string op u u u op return tuple u see us even though struct class sight used like give concatenation tuples ability struct module usingmixinconcatenate import stdtypecons import mixinconcatenate struct mixin concatenate unittest auto result assert result tuple idea take back home concatenation code written offered functionality client scope type want could easily arithmetic operation cast operation new method like log register new member whatever else build set mixins use freely remember limited class structs also use function module scope template limitation mixin template inject code local scope add invariant clause class clause function injected invariant clause todo explanation mixin templatename name allow mixing one template see http dlangorgtemplatemixinhtml mixinidentifier mixin example subscriber stack example come bjorn lietzspendig kind enough allow use thanks bjorn define two mixin template publishermixin stackmixin first one implementing subscriptionunsubscription engine second providing standard stack operation push pop like notice two important thing allowing local import publishermixin import machinery necessary function stdfunctionaltodelegate stdstdio local import really allow template mixins provide nicely wrapped functionality coherent whole alias typeof called also nice feature remember mixin look around get local type provide generic readytobeused code module publisher public mixin template publishermixin import stdfunctional todelegate import stdstdio alias void delegate object sender string event callback alias void function object sender string event callbackfun bool callback callback int callback may even smaller register subscriber void register callback callback ensure subscriber yet registered callback callback writeln subscriber already registered else callback callback true register subscriber via function ptr void register callbackfun callbackfun register todelegate callbackfun remove subscriber void unregister callback callback callback callback callbacksremove callback else writeln trying remove unknown callback remove subscriber via function ptr void unregister callbackfun callbackfun unregister todelegate callbackfun notify subscriber void notify object string evt foreach callback cb bool origin callback cb evt mixin template stackmixin get parent type alias typeof static stack protected property bool empty return stacklength property sizet count return stacklength void push element stack element pop el peek stacklength return el peek stacklength throw new exception peek empty statck el stack return el mixins defined inject structure defined use class show mixins inherited let get friend module friend import stdstdio import publisher class friendstack private string name private int age mixins mixin stackmixin mixin publishermixin void pushfriend string name int age create new instance stack auto person new friendstack personname name personage age push person notify subscriber notify person push pop void popfriend auto person pop notify person pop subscriber method void inhouseinfo object sender string msg auto p cast friendstack sender writefln subscriber house name age message n pname page msg class extfriendstack friendstack vip private bool isdeveloper push void pushfriend string name int age bool create new instance stack auto xperson new extfriendstack xpersonname name xpersonage age xpersonisdeveloper push xperson notify subscriber notify xperson push friendstack subscriber function used friendstack extfriendstack void twitter object sender string msg auto p cast friendstack sender writefln subscriber twitter name age message n pname page msg void reddit object sender string msg auto p cast friendstack sender writefln subscriber reddit name age message n pname page msg void mail object sender string msg auto p cast friendstack sender writefln subscriber email name age message n pname page msg extended friendstack subscriber function contains additional isdeveloper information void blog object sender string msg cast extfriendstack sender auto p cast extfriendstack sender writefln subscriber blog name age developer message n pname page pisdeveloper msg else writeln blog vip message rooted email mail sender msg downcast also possible auto p cast friendstack sender writefln subscriber blog name age message n pname page msg use stack heart content get friend module usingfriends import friend void main auto p new friendstack auto new extfriendstack register subscriber pregister twitter twitter blog blog push pop ppushfriend alex ppushfriend tommy han false walt true ppopfriend punregister twitter twitter pregister blog ppushfriend alexej run previous code see developerstack inherits mixins personstack stack publisher thanks alias typeof defined stackmixin extfriendstack contain additional information opdispatch syntax opdispatch sort operator overloading place href wwwdlangorgoperatoroverloadinghtml dispatch online documentation deal member call method value member definition operator opdispatch string name opdispatch string name arg arg arg opdispatch string name args args args usual template constraint used constraint name constraint argument type opdispatch method member call done without finding defined member call dispatched opdispatch invoked name string module dispatcher import stdtypetuple struct dispatcher int foo int return string opdispatch string name return dispatch activated name typetuple stringof void main dispatcher auto dfoo compiler find foo call foo auto dregister abc register member opdispatch activated assert dispatch activated register string auto dempty empty member argument assert dispatch activated empty opdispatch name called argument decide calling free function calling method using compiletime string generate new code see section string mixins since string mixins really go hand hand opdispatch use even though nt introduced right executive summary paste code given compiletime string called getters setter example suppose bunch member private want client code access good ol setxxxgetxxx method want write method lucky opdispatch help module getset class getset private int private int j private double private string thestring auto opdispatch string name arg version getter namelength name get enum string member name getxxx xxx test xxx exists ie typeof thisxxx true static trait compiles mixin typeof member mixin return member else static assert getset error member called member auto opdispatch string name arg arg arg setter namelength name set enum string member name setxxx xxx test member assigned thismember arginit static trait compiles mixin member arginit mixin member arg mixin return member else static assert getset error member called member unittest auto g new getset gsseti auto gsgeti assert gssetthestring abc assert gsgetthestring abc abc nifty eh could bit better dealing capitalization first letter getthestring good enough even better could put code mixin template give getset capacity struct class see section mixin template wrapping subtyping expanding type wrapper template unfinished idea put functionality inside possibly dispatching code seen inject code mixin template use template class inheritance modify class code adding functionality inheritance also seen define wrapper struct around range expose new iteration scheme element struct flatten idiom way modify preexisting code want put logging functionality around predefined struct method call logged class inherit class defined subclass new modified method hand speak struct luck template come rescue bit opdispatch magic todo finish put type wrapped logger struct get typetupleof call typeof opdispatch test wrappedfoo legal alias transparent type play little bit alias let u define small wrapper type module transp struct transparent value alias value factory function transparent transparent return transparent defines transparent small struct holding lone value type transparent asked something method correct type say almost every action imagine alias activates us value lieu transparent give u transparent wrapper module usingtransparent import transp void main auto transparent assert equality testing assignment int act ivalue assert intaccepting function int foo int ii return assert foo function call int trueint transmits value assert trueint assert assert trueint successive call collapse one transparent transparent transparent see transparent behaves gracefully almost circumstance int could fit tranparent int act real int course type still ok assert typeof transparent int another wrapper added module import transp struct thin value alias value thin thin return thin unittest auto transparent auto thin work assert yep value transmitted correctly assert typeof thin transparent int use invisible wrapper first perfect subtype goal alias x add functionality type new method etc look bit like class inheritance nt except transparent wrap around ie become subtype type aimed interested multiple way subtype type see section library typedef showing library typedef note subtly different idea shown section wrapper template section wrapper template use opdispatch let wrapper intercept call dispatching way add logging type instance something alias hand alias dispatching automatically done compiler need write intercepting code example another wrapper give description held type module descriptor import stdstdio struct descriptor value alias value string description property import stdconv return descriptor holding tstringof value string value n sizeof string tsizeof byte void main auto descriptor double writeln ddescription descriptor holding double value sizeof byte one day get multiple alias since described tdpl tdpl open possibility type subtype many type time literally acting chameleon depending circumstance able group disparate type functionality one place wait increasing interest multiplealiasthis multiplealiasthis written january let see get multiple alias however far concerned main interest subtyping much possibility add parallel functionality encoding information type see next section library typedef seen previous section alias give perfect subtype able mimic parent type circumstance another derived type needed used typedef keyword defines new type opposed alias redefinition define new symbolname type dropped language however need define new type relation preexisting type still template help defining librarylevel solution described mainly new type defined relation another already existing target type four different relationship shown following figure subtype standard subclass alias relationship subtype act lieu parent type circumstance whatever parent subtype also moreover subtype forcibly cast parent type think class supertype converse supertype assigned value type target subtype since subtype act supertype supertype function acting created original target type used also parallel parallel type neither subtype supertype original target mimic target created target value le behaviour nowdeceased typedef keyword independent independent type bear relationship whatsoever original target type cite interest defining type still target type mind limited clean little piece code group notion one template module librarytypedef enum relationship independent super sub parallel struct typedef target relationship relation relationshipsub target init targetinit string f file int l line target payload init static relation relationshipindependent target value payload value static relation relationshipsub typedef int foo foo f fopcast cast f target opcast target return payload static relation relationshipsub relation relationshipparallel alias payload static relation relationshipsuper typeof opassign target value payload value return else static relation relationshipsub disable void opassign target value todo give example type information userdefined literal http walter bright make convincing case using template userdefined literal example stdconvoctal wrapper allowed see possible ditch octal literal compiler construct push libraryspace way use auto octal even auto octal standin replacement octal literal complicated type char add clearer reader code may miss beginning dealing octal best implementation library code easy reach easy debug le intimidating diving compiler code easy duplicate encoding way could done auto hexa deadbeef auto binary even auto number base behind scene octal read string int argument convert int long depending argument size nice piece work could pave way similar wellintegrated language extension unfinished also dsl string see staticallychecked writeln encoding information type annotating type encoding information type extension previous section idea found example stdrangeassumesorted stdrangesortedrange phobos construct encode information type case fact range sorted associated predicate way subsequent operation acting range use better algorithm know sorted kind encoding used many different scheme matrix library could example assumehermitian assumetriangular wrap preexisting matrix xmlhtml library could imagine validated struct used indicate er validated content external input pas trough validate function delivers validated object subsequent operation work validated data raw data unit library kgms unittesting mainly bunch double complex value wrapped multichecked type allows operation depending type meter kilo gram nono meter kilo gram ok moreover easy provide additional information struct minmax min max value alias value case minmax mean wrapped value min max enforcing code would factory function example thing get interesting using multiple wrapper inside one another imagine three wrapper numerical range ordering operation minmaxed ascertains well least transmits message wrapped value extremum periodic encodes idea range period accessible period member derivative say successive element difference slope number absolute import stdrange cycle auto range cycle auto withmetadata minmaxed periodic derivative range assert withmetadataperiod propagated way previous sample withmetadata element time limited variation limited value periodic trouble want shift metadata around comparing type metadata ordered different way obviously u human range suprema periodic also periodic suprema far concerned minmaxed periodic periodic minmaxed type notion see section annotatingtypes annotating type todo unit example example part may bit big template template sometimes know user code send template first list indefinite length parameter followed second list seeing may want write code like following template mytemp b ala two template parameter tuples make sense see template declaration deadend first could try write template ab filter ab find one need done staticfilter presented static filter associated function function argument would tuplefilter shown filtering tuples case two series argument completely mixed separated two list strictly powerful hand mean must able separate type alone may possible template way happily initial problem easily solved way template mytemp template mytemp b remember template template member nest template within template constraint intermediate code use name eponymous trick activated sometimes using different name stage make code readable example want compare two template tuples see contain argument module compare template compare first template second static firstlength secondlength enum false else static firstlength end comparison enum true else static first second enum false else enum compare first second usage unittest alias compare int double string int double char c static assert c false case using inside compare let code quite easy use notice eponymous trick done inner template want result going back mytemp using slightly complicated yes alias mytemp int double string char void mytemp int double string char void mytemp int double string char void grammar authorize multiple template call like one line must use alias intermediate stage drastic limitation created template multistep construction probably wanted multistep invocation doublestage function template function template give powerful thing place code compiletime parameter given delivers another craftedjustforyourneeds template instantiate later see example string interpolation interpolate functionintemplate policy particularly good idiom section memoizing function present template transforms standard function memoized one could done twosteps template memoizer store first million tuple args discard half maximum reached free memory stage function memoize known user decided particular instantiation best memoizing strategy code memoizer could applied many different function alias memoize storingmaximum discardingfraction memoizer auto int double auto double string profit memoization even though different signature different argument return different type alias memoizer alias memoizer todo ok maybe provide updated version memoize memoizing function namedfields tuples let another example use ifti phobos function stdtypeconstuple let create tuple fly nice example ifti action module usingtuple import stdtypecons void main tuple int double string auto tuple abc tuple char char char auto tuple b c phobos tuple powerful named parameter tuple int counter string name mycounter mycountercounter mycountername one counter around writing phobos nt provide tuple factory function allowing named argument nice automated manner like module usingnamedtuple import namedtuple void main auto mycounter tuple counter name daddy counter mycountercounter even alias tuple counter name makecounter auto makecounter count ints auto makecounter hello strange one using string world previous example tuple int string whereas tuple string string mean makecounter factory function tuples two field named counter name see type determined later want let code first obvious need twostage template import stdtypetuple allsatisfy template tuple name nameslength allsatisfy isastringliteral name auto tuple args constraint check user give least one name also passed name indeed string literal template parameter use stdtypetupleallsatisfy verify condition use directly stdtraitsissomestring template act type whereas need something checking string literal module isastringliteral import stdtraits issomestring template isastringliteral alias name enum isastringliteral issomestring typeof name place need create correct tuple argument name provided right type allow mix named anonymous field first two field named fourth third anonymous alias tuple int counter string name double anonymous double total mytuple function consider given n name first n argument named remaining anonymous give u another constraint user provide le n argument refuse input stop compilation right import stdtypetuple allsatisfy template tuple name nameslength allsatisfy isastringliteral name auto tuple args tlength nameslength need alternate name argument type happily document describes interleave template interleaving type module namedtuple import stdtypecons import stdtypetuple import interleave import isastringliteral template tuple name nameslength allsatisfy isastringliteral name auto tuple args tlength nameslength return tuple interleave name args presto namedtuple factory function nt nice closure example closure poor man object could use simplify returned value todo curried template file line unfinished section need heavy testing config broken wrote part take everything big grain salt todo list test rewrite everything section default value seen template parameter default value also two special reserved symbol defined file line used standard nonmixin template behaviour remind mixins instantiated get replaced string containing file name line file instantiation call site yes sort twoway dialogue module ad defines template module bd asks instantiation instantiation done module ad line filename taken bd mostly declared like module filelinetagging struct unique string file sizet line enum sizet l line enum string f file auto unique string file file sizet line line return unique file line unique name suggests way obtain unique instantiation except call template twice line file pretty much guarantee instantiation one remember template argument become part template scope name instantiation done instantiating template module usingunique import filelinetagging void main auto u unique unique int thefiled auto v unique unique int thefiled static assert typeof v typeof u even though u v declared way different type apart oneofakind type also useful debugging use string error message auto flatten range file file line line range range static rank range static assert file file line line flatten called type rangestringof else static rank range return range else return flatten range range little gift module debugger usage debug templatetobetested template debug alias totest string file file sizet line line template args static totest args alias totest args else static assert error string totest called withs argument argsstringof way need modify beautiful template todo test around template compiletime tool compiletime metaprogramming template part describe common tool string mixins compiletime function evaluation ctfe trait seen relation template good news interoperable string mixins wonderful inject code template compiletimeevaluable function act template parameter templated best best templated compiletime function return string turn mixedin template come see fun string mixins string mixins put code called compilation injected code bona fide code like code manipulated string hence name syntax syntax slightly different mixin template mixin code string must take care forget parenthesis string mixins purely compiletime tool string must also determined compiletime mixing code template course injecting predefined code bit boring mixin int forget two semicolon one mixedin code one mixin call assert interest compared directly writing standard code fun begin powerful constant folding ability string concatenated compiletime string mixins meet template template produce string compiletime get string parameter already saw section operator overloading section opdispatch since could nt help bit foreshadowing imagine example wanting template generates structs want able name structs wish say would like usage look like module import mixin mystruct first creates new type called first struct mixin mystruct second another one called second void main first code injected right module mine first second assert typeof first come generating code module template mystruct string name enum string mystruct struct name code example name first return struct first code case string assembled inside template instantiation exposed eponymous trick mixed want note string generated utils module containing mystruct first second defined exactly mixin call use mixin different module define many different structs named way might exactly want get struct type different module code must organized bit differently structs must generated template module module template mystruct string name alias mystructimpl name result mystruct template mystructimpl string name enum string code struct name code mixin code mixin alias name result module import mystruct first mystruct second usage different see case first generated inside mystructimpl exposed alias particular alias statement generated string mixin fact entire code could put mixin module template mystruct string name alias mystructimpl name result mystruct template mystructimpl string name mixin struct name code n alias name result example using ternary operator compiletime selection code similar done static static module enum getset yes struct getset getset getsetno enum priv private value n get property return value n void set value value value enum pub value mixin getset getsetyes priv pub code import void main getsetyes int g gsset assert gsget generates struct getsetyes int private int value int get property return value void set int value value value limitation code crafting still bit awkward nt introduced ctfe yet see ctfe limited simple concatenation looping example possible template far easier ctfe even already wonderfully powerful craft code hole type name whatever completed template instantiation mixed elsewhere create kind code put mixin expression almost want todo test limit inside static expression example escaping string one usual problem manipulating code string deal string code must escape either use create string quote bit like done section function template syntax generate error message select put string q backquotes compiletime function evaluation evaluation compiletime compiletime function evaluation ctfe extension constantfolding done compilation code calculate compiletime extend whole function evaluation call evaluable compiletime function cte function hot topic right reference compiler advanced leap bound limit done cte function pushed farther away new release foreach else statement array manipulation struct manipulation function manipulation even pointer arithmetic began document dmd limitation mostly class exception enforce changed dmd allowing manipulation class compiletime dmd killed huge amount ctferelated bug fact danger lie way round easy forget cte function must also standard runtime function remember action make sense compiletime compiletime initialized constant indexing tuples example ctfe unfinished write something new functionality enables testing inside function whether compiletime runtime template ctfe unfinished juicy example added mean feed compiletime constant classical function code evaluated compiletime far template concerned mean function return value used template parameter enum initializers template function well give rise function evaluated compiletime template ctfe string mixins oh firework mix string mixins code generated function giving access almost entire language craft code mixed template produce want close loop function returning codeasstring template using another template parameter parameter concretly gettingsetting code section getters setter reloaded module import stdconv enum getset yes string priv string type string index return private type value index n type get index property return value index n void set index type value value index value string pub string type string index return type value index string generates getset getset getsetno string result foreach index type static getset getsetyes result priv typestringof string index else result pub typestringof string index return result struct getset getset getsetno mixin generates getset void main getsetyes int string int g generates struct getsetyes int string int private int int property return void int value value private string string property return void string value value private int int property return void int value value abc assert abc code much powerful one saw previously number type flexible entire set getterssetters generated asked done simply plugging string returning function together bit looping way compiletime foreach simple string interpolation play concatenating operator becoming drag write string interpolation function evaluable compiletime course help u task want use import stringinterpolation alias interpolate struct value child maketree enum string inttree maketree inttree int enum string doubletree maketree doubletree double static assert inttree struct inttree int value inttree child static assert doubletree struct doubletree double value doubletree child see string interpolated passed template parameter placeholder use character normally found code n th parameter n starting concession practicality lone considered equivalent args put string passed standard nontemplate parameter type module stringinterpolation import stdconv template interpolate string code string interpolate args args args string stringified foreach index arg args stringified string arg string result int int zero int codelength code int j int index ij codelength int code ij zero int code ij zero index index int code ij zero j result stringified index j else result code return result todo syntax could extended somewhat inserting multiple string inserting range string argument end example extending stdfunctionalbinaryfun unfinished one dear heart mapping n range parallel one first thing wanted range example create range structs constructor taking one parameter phobos two really interesting template stdfunctionalunaryfun stdfunctionalbinaryfun todo explain aim extend nargs function todo augh introduction dmd nice closure syntax le alleviate need construction bool isaz char c return c c z bool isaz char c return c c z bool isnotletter char c return isaz c isaz c int letternum char c return int c int int arity string slength return int arity string padded foreach c padded isaz padded isnotletter padded isnotletter padded arity letternum padded arity letternum padded arity return arity string templatetypes int arit arit return arit return string result foreach arit result abcdefghijklmnopqrstuvwxyz return result string params int arit arit return arit return string result foreach arit result abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz return result string naryfunbody string code int arit return interpolate auto ref naryfun return templatetypes arit params arit code template naryfun string code int arit arity code mixin naryfunbody code arit sorting network sorting network nice example compiletime code generation buy sorting vast subject obtaining nearoptimal sort many circumstance quite difficult case know input length build predefined list comparison element swap correct order represent sorting network pair index input range given index j compare input input j example given array randomaccess range length n following table present possible optimal case sorting network n sorting network table first sorting network code generate list index found knuth art computer programming net code given translated common lisp taken doug hoyte let lambda opinionated book common lisp macro module sortingnetwork int int n int n n n return given length n return array index pair corresponding sorting network length n look bit like c code nt int sortingnetwork int n int network auto n auto p p auto q auto r auto p int r p network id qp q r p p return network sortingnetwork return array index pair easy generate code basic building block done interpolate see simple string interpolation module buildsortingcode import stringinterpolation import sortingnetwork string buildsortingcode sizet l enum network sortingnetwork l string result foreach elem network result interpolate input input binaryfun pred auto temp input input temp n elem elem return result want template pregenerates templated sorting network function stdalgorithmsort predicate pred determines way individual range element compared module networksort import stdrange import stdfunctional import stdexception import buildsortingcode import stringinterpolation template networksort sizet l mixin interpolate void networksort alias pred b r ref r input israndomaccessrange r enforce inputlength calling networksort range le element elementtype r l buildsortingcode l strange mixininatemplate construction cut template two allow user code like somewhere code alias networksort somewhere else myarr b myarr designed work randomaccess range without knowing advance nature range predicate used sort call range length greater sort first element le element enforcement fail little sorting routine buy u appears quite efficient smallsize array compared stdalgorithmsort see performance degrade point following table compare one million sorting n element randomlyshuffled array done networksort stdalgorithmsort give ratio speedup brought precomputing sorting code n sorting network m standard sort m ratio table comparing networksort stdalgorithmsort least benchmark networksort outperforms phobos speedup range element cutoff course phobos sort much versatile since work range length known runtime know input length advance networksort nice use cutoff fwiw computer cutoff seems element case idea take home away good idea runtime data look like probably pregenerate optimal code compile time triaging runtime trait general trait syntax found online trait basically another compiletime introspection tool complementary expression see appendix time trait return true false simple typeintrospection question type symbol abstract class final function wont question sometimes one could ask using template constraint sometimes interesting introspection type also symbol expression yesno question trait seeing document template already seen many introspection tool quick list yesno question ask tested affirmation affirmation affirmation document reader feel free prove wrong nt difficult question doable tool isarithmetic yes isassociativearray yes isfloating yes isintegral yes isscalar yes isstaticarray yes isunsigned yes isabstractclass isfinalclass isvirtualfunction isabstractfunction isfinalfunction isstaticfunction isref isout islazy hasmember yes issame compiles yes way table comparison trait introspection tool quite useful code shy away since heavily templaterelated interesting opinion using trait get new information type really different introspection tool deal detail right identifier identifier give symbol name string quite interesting since symbol call active example foo function foostringof try first call foo stringof fail also stringof though eminently useful sometimes return strangely formatted string identifier much wellbehaved let get back one first template doc nameof initially coded like template nameof alias enum string name astringof enum manifest constant determined compiletime fails function int foo int int j return ij auto name nameof foo error foo must called argument much better use trait also eponymous trick module nameof template nameof alias enum string nameof trait identifier unittest int foo int int j return ij enum name nameof foo name available compiletime assert name foo note work many kind symbol template name class name even module import stdtypecons import nameof enum nameof nameof nameof alias enum nameof stdtypecons typecons getmember nutshell trait getmember name member give direct access namemember real member get value set anew etc construct member ok name wonder aggregate called directly name whereas member need string aggregate valid symbol exists member name existence outside aggregate even worse may refer another unrelated construct aggregate use aggregate catchall term construct member structs class obvious aggregate interface interesting keep mind template member remember section instantiating template template named parameterized scope trait call shown section used template interesting keep mind even interesting eye module also aggregate even though firstclass citizen dland see example following section allmembers one cool given aggregate name trait allmembers aggregate return tuple string literal name member class parent class member also included builtin property like sizeof included list note say tuple bit powerful array iterated compiletime name repeated overload see next section way get overload module class myclass int int j j void foo int foo int j return ij void main put array humanreadable printing enum mymembers trait allmembers myclass see foo middle standard class member foo appears despite overloaded assert mymembers ctor dtor foo tostring tohash opcmp opequals monitor factory code nice way get member field like method like foo case wonder ctor dtor internal name constructor destructors perfectly usable code structs list far le cluttered since get constructor destructor name opassign assignment operator since trait return string plugged directly getmember see bit farther way get nice list member type let ramp thing bit class struct template let try module allmemberstemplate class myclass field static assert trait allmembers myclass myclass oh happened remember basic struct class function template syntactic sugar real syntax template myclass class myclass field myclass name external template whose one member myclass class well instantiate template function might expect module import allmemberstemplate static assert trait allmembers myclass int field tostring tohash opcmp opequals monitor factory remember one first us saw template instantiating template named parameterized scope give rise interesting introspection module templateintrospection template temp b b foo b b return b int alias atype alias b aatype static assert trait allmembers temp foo atype aatype static assert trait allmembers temp double string foo atype aatype see also get alias name way true structs template also another fun fact module amenable trait call though true packaged module import packmod import pack mod symbol import mod import nothing module allmembersmodule import stdalgorithm import stdcompiler huuuge list name enum algos trait allmembers stdalgorithm bit shorter enum compiler trait allmembers stdcompiler void main assert compiler object name vendor vendor versionmajor versionminor dmajor dminor previous code see among member object implicit objectd module module imported runtime std global package show whenever import std module would easy imagine template recursively explores member find module try recurse get complete importtree template ala std block since package member findingimports findingimports someone find way determine template b import stdalgorithm delighted see done introspection pretty sure autointrospection module calling allmembers name used work fall nt work anymore hmmm like aggregate get aliased name also unit test defined module unittestsnames staticconstructors unittestsnames curious named unittestxxx xxx number type le void delegate staticconstructors nt try static constructor module nt hesitate play tell happens point inspecting module well first fun see could duplicate module create struct equivalent member list forwarding module member real deal using string mixins generate type user us mixin module could create conflict alreadyexisting name searched way mixin template inspect module currently instantiated wanted write template given class name would give entire hierarchy local module scope would see enough hierarchy template shown document testing stdtraitsparametertypetuple saw give parameter typetuple one function even overloaded inspecting module also way get full list function particular name getting parameter typetuple todo inject hierarchy todo code powerful version parametertypetuple derivedmembers really except get class parent member class member getoverloads given aggregate name instance agregrate member name string trait getoverloads name member give tuple local overload namemember local mean class get parent class overload difference using getoverloads type instance former case get tuple overload cool using ctor also get direct access type constructor overload quite handy case getting member even overloaded one like urge mix allmembers return member name without overload getoverloads return overload one member quite great let first bit machinery want member described name type let create struct holder templated course todo getting qualified name would better module member struct member string n enum name n external access alias type given member name need template delivers associated member also want way impose name come handy later module makemember public import member import nameof template makemember alias member mixin alias member nameof member typeof member makemember template makenamedmember string name template makenamedmember alias member mixin alias member name typeof member makenamedmember given aggregate name member name string since exist want list member structs holding information module import stdtypetuple import makemember template overload alias string member alias staticmap makemember trait getoverloads member overload staticmap explained section mapping type tuples already work module myclass class myclass int field alias j symbol alias alias int int type alias struct inner inner type template temp alias temp template constructor int j j constructor void foo int j foo overload int foo int j int k return ij foo overload alias foo bar symbol alias unittest int module import stdstdio import import myclass void main alias overload myclass foo print foo type void int j foo type int int j int k foreach elem writeln elemname type elemtypestringof indeed got two member instance one overload member hold name foo overload type except catch field overload alias also problematic correctly dealt need pay attention overload module import stdtypetuple import makemember get overload given member member type tuple template overload alias string member amember method static trait compiles trait getoverloads member trait getoverloads member length alias staticmap makenamedmember member trait getoverloads member overload else field alias amember field symbol alias static typeof trait getmember member mixin alias member member typeof trait getmember member overload amember type alias else static mixin member member trait getmember member mixin alias member member trait getmember member overload amember template else mixin alias member member void overload entire template may bit daunting give mostly correct way deal many kind member aggregate may field method type alias symbol alias template name writing deal correctly inner type think give outerinner type whereas produce inner qualifiednames also unittest block appear given void type default case template think void type qualifiednames maybe using qualifiedname template shown section parent last step get member given aggregate quite easy module allmembers import import stdtypetuple template getoverloads alias template getoverloads string member alias overload member getoverloads template allmembers alias alias staticmap getoverloads trait allmembers allmembers strange getoverloads twostage construction way map easily line quite long explain work nicely module import stdtypetuple import stdstdio import myclass import allmembers void main alias allmembers myclass writeln ostringof foreach writeln oname type otypestringof print type int j type int int type int ctor type myclass ctor type myclass int j foo type void int j foo type int int j int k cool every member overload accounted two contructors destructor also course type int todo example store member hashtable polymorphic association list mixin put inside type enable runtime reflection asend somemethod args asetinstancevariable testing interface implementation previous section gave u way get aggregate member list easy step get interface member list see given symbol member contains entire interface member list module implement import stdtypetuple import allmembers statically check symbol implement interface member found member template implement alias interface alias implementsimpl allmembers implement template implementsimpl alias item static itemslength enum implementsimpl true else static staticindexof item allmembers enum implementsimpl false else enum implementsimpl implementsimpl item interface int foo int void foo string tostring class bad void foo int struct good int field int foo int return void foo field string tostring return good struct unittest assert implement good assert implement bad getvirtualfunctions family getoverloads give list virtual overload class method given class name finding overload field even overriden one let exercise reader parent trait parent symbol return symbol parent parent class hierarchy sense allparents deal qualified name strip one level reach toplevel scope return module name dangerous module parent see allparents came see way get parent class see section class hierarchy module cclass import nameof class c int int foo int j int k k cclasscfook assert nameof trait parent k foo return ik module parent import nameof import cclass c precisely cclassc static assert nameof trait parent c cclass void main auto c new c c parentmainc assert nameof trait parent c main assert nameof trait parent ci c cfoo even qualifiedidentifier trait construct template get module qualifiedname import nameof template qualifiedname alias parent static trait compiles trait parent yes get name recurse enum qualifiedname qualifiedname trait parent nameof module name stop else enum qualifiedname nameof module usingqualifiedname import qualifiedname import cclass void main auto c new c assert qualifiedname c usingqualifiednamemainc assert qualifiedname cfoo cclasscfoo case assert qualifiedname cfoo cclasscfoo note cfoo qualified usingqualifiednamemaincfoo local scope name sometimes dealing mixin template string mixins inject code unknown scope get way round useful get local scope name intuitively previous example could help create local variable get qualified name parent determine scope mixin expose scope name let call one scopename associated inquisitive template getscopename module scopename public import qualifiedname mixin template getscopename enum scopename qualifiedname trait parent scopename idea declare local enum called scopename take qualified name parent expression yes work use getscopename mix need local scope name bug something changed since last tested code dmd august work anymore add todo list module usingscopename import stdstdio import scopename class c mixin getscopename int int foo int j int k mixin getscopename writeln scopename return ik void main auto c new c writeln cscopename testc cfoo testcfoo mixin getscopename writeln scopename testmain wrapping together unfinished dig cute example code base using string mixins ctfe template together example part present various example showing done template type manipulation code generation language extension example code snippet useful one time another hope useful contributor welcome even part welcome short synthetic example done template hesitate chime push code doc type sorcery one fundamental use template type sorcery type creation type manipulation etc statically type language creation defined type sometimes cumbersome write manipulate template help mapping filtering folding type saw section template tuple parameter template tuple parameter hold type tuples even original role since iterated indexed sliced ideal candidate standard iteration algorithm range map another template type tuples filter type want extract fold reduce another type nontypes acting expression tuples even though section called type sorcery template work expression tuples feel limited mapping type tuples mapping type tuple simply applying another unary template type type tuple phobos already defines staticmap stdtypetuple nice exercise code want template take another template name alias parameter say wrapper typetuple tn return wrapper wrapper wrapper wrapper tn module staticmap import stdtypetuple template staticmap alias static tlength end sequence alias typetuple staticmap stop else alias typetuple staticmap staticmap use autoflattening type tuples aggregate result unique tuple notice indexing slicing make notsocomplicated piece code already defined stdtypetuple use phobos template even simple template one great us getting rid qualifier type list mapping stdtraitsunqual type generating huge quantity type using typetuplereturning mapper see given bunch function type getting return type parameter typetuples example testing function seconde use previous section list useful unittest part code suppose templated function supposed work builtin type need generate possible combination type use staticmap generate module qualified import stdtypetuple given type generates qualified version find interesting eleven version template qualified alias typetuple const immutable shared const immutable shared const immutable shared qualified builtin type interested alias typetuple bool ubyte byte ushort short uint int ulong long float double real char wchar dchar valuetypes bang type generated alias staticmap qualified valuetypes qualifiedtypes really pervert note duplicate alias staticmap qualified qualifiedtypes doublyqualifiedtypes function supposed work generated qualified type test module tester import qualified void myfun template test alias fun void foreach type static trait compiles fun typeinit pragma msg bad testing combination funstringof typestringof unittest test myfun qualifiedtypes filtering type tuples search extract type tuple using predicate chose type generally tuple element want keep predicate particular case mean template given type argument return either true false test done tuple element complicated want particularly using expression see give u following code module staticfilter import stdtypetuple template staticfilter alias pred static tlength end sequence alias typetuple staticfilter else static pred alias typetuple staticfilter pred staticfilter else alias typetuple staticfilter pred staticfilter using staticfilter quite simple let get integral type tuple way stdtraitsisintegral module import stdtypetuple import stdtraits import staticfilter alias typetuple int double float string byte bool float void type alias staticfilter isintegral type onlyintegrals static assert onlyintegrals typetuple int byte separating type nontypes first let create template true pure type false nontypes module istype template istype enum istype true template istype alias static enum istype true else enum istype false hey wait ok two specialised template one template type parameter another alias static userdefined type myclass type symbol saw section template declaration particular use want considered type contrary symbol function name module name variable hence test change thing bit get builtin type detector may also interesting builtin type used alias parameter let test module isbuiltintype template issymbol alias enum issymbol true template isbuiltintype static trait compiles issymbol enum isbuiltintype false else enum isbuiltintype true template isbuiltintype alias enum isbuiltintype false go module import stdtypetuple import staticfilter import istype import isbuiltintype class myclass int foo int return alias staticfilter istype int abc foo myclass type alias staticfilter isbuiltintype int abc foo myclass builtins static assert type typetuple int myclass static assert builtins typetuple int admittedly pretty runofthemill stuff though useful time time quite rare someone given pure type tuple like much common use like staticfilter creating complex type example building graph first example imagine graph node edge struct templated node vertice edge type templated create graph factory function would nice able mix node edge natural way given graph node edge function obvious thing want autorize call like automatically creates graph four node labelled b c holding double node linking b c auto g graph node node b edge b node c node edge edge c allows user building graph create node edge node natural way opposed say batchbuilding node adding edge library writer mean graph factory function following signature auto graph nodesoredges nodesoredges args sanity check test nodesoredges sanity check performed template constraint constraint building code inside graph quite complicated staticfilter help separating argument node edge without extending example much say disposal following predicate template template isnode n true iff n node labeltype valuetype template isedge e true iff e edge labeltype template isnodeoredge static isnode isedge enum isnodeoredge true else enum isnodeoredge false let suppose also bona fide node edge labeltype valuetype member exposing inner type shown inner alias getting node edge easy alias staticfilter isnode nodesoredges node alias staticfilter isedge nodesoredges edge thing get interesting obtaining edge node type first building block graph must check minimum following element argument must node edge least one node list yes node labeltype valuetype least common type label type another one value stored node edge labeltypes common type note zero edge edge label correct type refer provided node note check done type thus done compiletime thereby ensuring pretty solid static check graph built done way verifying compilation edge indeed refer existing node let use seen create graphcheck template seeing another staticfilter example import stdtraits commontype template graphcheck nodesoredges enum graphcheck graphcheckimpl nodesoredges result template graphcheckimpl nodesoredges alias staticfilter isnode nodesoredges node alias staticfilter isedge nodesoredges edge argument must node edge static assert nodeslength edgeslength nodesoredgeslength args node edge must least one node static assert nodeslength must provide least one node common type node label value first step extracting label value template getlabel isnode isedge alias tlabeltype getlabel template getvalue isnode alias tvaluetype getvalue alias staticmap getlabel node nodeslabels alias staticmap getvalue node nodesvalues static assert commontype nodeslabels void common type node label type static assert commontype nodesvalues void node value type edge alias staticmap getlabel edge edgeslabels static assert commontype edgeslabels void edge label type edge node compatibility static assert commontype nodeslabels commontype edgeslabels node edge label type enum result true one huge template staticfilter sits square middle greatly simplifies code note use static assert slightly different graph signature simply auto graph nodesoredges nodesoredges args graphcheck nodesoredges unfinished second example one code generating struct string literal type parameter folding type tuples mapping filtering folding aka reducing third standard operation sequence motheroperation idea stdalgorithmreduce given seed binary function bin calculate bin bin bin apply bin seed first type tuple take resulting type new seed reapply bin second type tuple entire tuple used motheroperation fact mother operation sequence since map filter defined using reduce use function used collapse type tuple one type one type simple type example biggest type tuple definition big complex structure built iteratively step step along tuple binary tree holding type example reverse tuple even type sorted according predicate see two example getting maximum type sorting type tuple first staticreduce module staticreduce template staticreduce alias bin type type seed static typeslength static assert staticreduce tuple typesstringof enough element min element else static typeslength end recursion alias bin type type staticreduce else recurse alias staticreduce bin bin type type type staticreduce get biggest type simple apply max binary template type list module maxtemplate template max static alias max else alias max module usingmax import stdtypetuple import maxtemplate import staticreduce alias typetuple int bool double float delegate float string type alias staticreduce max type maxtype static assert maxtype float delegate float vary definition max according taste used builtin sizeof property compare two unknown type compare name used stringof sorting type ivory tower wankery mean would sorting type useful useful read sorting tuple useful mainly reason want sort sequence easily find type log n easily get afterwards first p type last p type compare two type tuples equivalence easily getting rid duplicate transforming tuple set type focus third use comparing two type tuples see example stdvariantalgebraic template struct algebraic typen hold value one typen course certain sense previous type also algebraic typen reordering type case currently module varianterror import stdvariant void main algebraic int double string algone algone algebraic double int string algtwo algone fail using sorted type internally even using factory function create algebraic value always returned sorted algebraic would allow seamless use algebraic value one way sort type using staticreduce standard situation following list already sorted type initial tuple first n type current state value constructed staticreduce take list put first remaining unsorted type reiterates next unsorted type basic step add new type sorted list small problem arises state one type store sorted type naked type tuple since autoflatten see tuple property use stdtypeconstuple wrap inner type tuple accessible type alias afraid uglify code bit finally predicate use sizeof adequate many different type size would bad consequence initial order would influence sorted order use stringified version type obtained builtin stringof property module sorttypes import stdtypecons import staticreduce template max static alias max else alias max template addtosorted sorted type length already sorted static sortedtypeslength alias tuple type addtosorted smaller first one put type first place else static max sortedtypes type sortedtypes alias tuple type sortedtypes addtosorted bigger last one put type end else static max sortedtypes type type alias tuple sortedtypes type addtosorted else compare middle type recurse left right else static max sortedtypes type type alias tuple sortedtypes addtosorted tuple sortedtypes type type addtosorted else alias tuple addtosorted tuple sortedtypes type type sortedtypes addtosorted template sort type alias staticreduce addtosorted tuple type sort said end sort applying addtosorted target tuple initial seed state staticreduce empty typetuple tuple work bet module sortingtypes import stdtypetuple import sorttypes alias typetuple int bool string function int float alias typetuple int float string function int bool static assert sort sort like sorting type alphabetically name resort definition max even better make version sort accepts another binary template argument us template way determine ordering nontypes said beginning section template presented work time template parameter pure number string alias change addtosorted second parameter accept nontypes another way would first map stringifier tuple element sort resulting string scanning type interleaving type crossing type todo determine subsection really useful short telling example static scan scan sort reduce fold operation see folding type tuples giving intermediary result used juxtapose template juxtaposing function module staticscan import stdtypetuple give typetuple resulting successive application f reduce list template staticscan alias f static tlength alias typetuple staticscan case never happen normal use static tlength alias typetuple staticscan else alias typetuple staticscan f f staticscan interleaving type module interleave import stdtypetuple given tn um return interleaving first part second part one input shorter longer part put end interleaving template interleave first template second static firstlength alias second else static secondlength alias first else alias typetuple first second interleave first second annotating type unfinished idea wrap value template adding meta data ideally like get thing like following code work auto arr array ints auto sorted arr know sorted auto positive sorted element positive generally auto arr array ints auto annotate sorted b b arr auto annotate positive assert positive assert typetuple property sorted b b property positive wrapped value still auto array filter getting rid property auto positive assert typetuple property sorted b b auto annotate negative auto annotate sorted b b assert sorted sorted predicate first rough unfinished draft module annotation import stdtypetuple struct meta string name alias data enum name name alias data data template ismeta static trait hasmember name trait hasmember data enum ismeta true else enum ismeta false template getname alias enum string getname aname template isannotated static trait compiles tannotations enum bool isannotated true else enum bool isannotated false string getnames metadata property alias staticmap getname metadata name string result foreach name name result name nameslength result result return alias typetuple result name struct annotated metadata allsatisfy ismeta metadata value alias value mixin getnames metadata metadata metadata auto property string property static staticindexof name return metadata staticindexof name else static assert false unknown property bool hasannotation string name property foreach n name name n return true return false auto annotated value return annotated value template annotated metadata metadatalength auto annotated value alias typetuple metadata metatypes static isannotated return annotated tannotatedtype tannotations metadata valuevalue else annotated metadata avalue value return tuples sequence unfinished idea treat tuples value tuple abc sequence map polymorphic aka templated function filter etc imagine example bunch range different type want group range process ca nt range must homogeneous type function presented lift restriction mapping tuples module maptuple import stdtypecons import stdtypetuple import stdfunctional helper template get template function return type template rt alias fun template rt alias typeof fun tinit rt map tuple using polymorphic function produce another tuple tuple staticmap rt fun maptuple alias fun tuple tup staticmap rt fun re foreach type re unaryfun fun tupfield return tuple re filtering tuples unfinished idea filter tuple predicate acting type quite useful get bunch parameter function want see filtering type tuples see example graph function module filtertuple import stdtypecons import stdtypetuple template filtertupletypes alias pred alias tup static tupfieldlength static pred tupfield alias typetuple tuptypes filtertupletypes pred tuple tupexpand filtertupletypes else alias filtertupletypes pred tuple tupexpand filtertupletypes else alias typetuple filtertupletypes template filtertupleindices alias pred alias tup sizet ind static tupfieldlength static pred tupfield alias typetuple ind filtertupleindices pred tuple tupexpand filtertupleindices else alias filtertupleindices pred tuple tupexpand filtertupleindices else alias typetuple filtertupleindices filter tuple value tuple filtertupletypes pred tup filtertuple alias pred alias tup filtertupletypes pred tup result alias filtertupleindices pred tup index foreach ind index result tupfield ind return tuple result abc def abc def fun function section present template acting function templated wrapper around function expand part functiontemplates us struct template part struct template wrapper struct main focus attention determining function number argument unfinished old code see anything changed past two year module functionarity import stdtraits template arity alias fun isfunction fun enum sizet arity parametertypetuple fun length memoizing function function long calculation might efficient store computed result external structure query structure result instead calling function called memoizing memorizing section show use template memoizing fun previouslyseen result stored associative array indexed tuples argument get function return type parameter type tuple use phobos stdtraitsreturntype stdtraitsparametertypetuple template accept function name type module import stdtraits import stdtypecons struct memoize alias fun alias returntype fun rt alias parametertypetuple fun ptt rt tuple ptt memo store result indexed argument rt opcall ptt args tuple args memo already seen args return memo tuple args yes use stored result else compute result store rt result fun args memo tuple args result return result memoize fun memoize alias fun memoize fun memo return memo usage simple module import int verylongcalc int double string cheating return void main auto vlcmemo memoize verylongcalc calculate verylongcalc abc take minute int vlcmemo abc int vlcmemo def minute int vlcmemo abc m get code trivial could optimized many way mostly real memoizing template also modify behavior storing policy example nolimit limited size store case limitedsize store define limit eviction policy firstinfirstout memo least recenly used memo least used timetolive discard flush store discard fraction stop memoizing last x result could stored queue time result pushed associative array push argument tuples queue reach maximum store limit discard oldest one example half stored value possible small implementation make nice example enablingdisabling code static enum based policy note use dynamic array primitive queue real queue could probably efficient nt one standard library writing module import stdtraits import stdtypecons enum storing always tomorrow maximum sustainable growth enum discarding oldest discard oldest result fraction discard fraction burn burn struct memoize alias fun storing storing discarding discarding alias returntype fun rt alias parametertypetuple fun ptt static storing storingmaximum tuple ptt argsqueue sizet maxnumstored static discarding discardingfraction float fraction rt tuple ptt memo store result indexed argument rt opcall ptt args tuple args memo already seen args return memo tuple args yes use stored result else static storing storingalways rt result fun args compute result store memo tuple args result return result else storingmaximum argsqueuelength maxnumstored static discarding discardingoldest memoremove argsqueue argsqueue argsqueue else static discarding discardingfraction auto num sizet argsqueuelength fraction foreach elem argsqueue num memoremove elem argsqueue argsqueue num else static discarding discardingall memo null argsqueuelength rt result fun args compute result store memo tuple args result argsqueue tuple args return result factory function help creating memoize structs module import runtime arg always store memoize fun storingalways discardingall memoize alias fun memoize fun storingalways discardingall result return result one runtime sizet arg maximum store discarding memoize fun storingmaximum discardingall memoize alias fun sizet max memoize fun storingmaximum discardingall result resultmaxnumstored max return result two runtime args sizet double maximum store discarding fraction memoize fun storingmaximum discardingfraction memoize alias fun sizet max double fraction memoize fun storingmaximum discardingfraction result resultmaxnumstored max resultfraction fraction return result one compiletime argument discarding oldest one runtime argument max memoize fun storingmaximum discarding memoize alias fun discarding discarding discardingoldest sizet max memoize fun storingmaximum discardingoldest result resultmaxnumstored max return result note due introduction opcall operator possible use struct literal first create struct initialize field time type runtime argument enough determine want memoizingstoring behavior rarer policy discarding oldest stored result user need indicate template argument import int verylongcalc int double string cheating return void main store first million result flush memo max auto memoize verylongcalc store first million result flush half memo max auto memoize verylongcalc store first twenty result discard oldest auto memoize verylongcalc discardingoldest currying function unfinished explanation would greatly help another useful transform function curry haskellcurry transform n args function n oneparameter function inside another haskellcurry haskell curry formalized idea todo show example mapping range example module checkcompatibility template checkcompatibility template u static ulength tlength enum false else static tlength ulength also enum true else static u enum false else enum checkcompatibility u module curry import stdtraits import checkcompatibility struct curry alias fun int index alias returntype fun rt alias parametertypetuple fun ptt ptt args auto opcall v v value vlength vlength index pttlength fun directly callable provided argument static trait compiles fun args index value return fun args index value new args stored check type else static checkcompatibility ptt index index vlength v static assert curry bad argument waited ptt index index vlength stringof got vstringof enough args yet store else curry fun indexvlength c foreach args index cargs foreach v value cargs indexi v return c auto curry alias fun curry c return c juxtaposing function unfinished idea glue function together map many range parallel create another multiplevalue range afterwards function juxtaposed given int foo int int j return ij string bar return hello world double baz double return juxtapose foo bar baz function accepting two int double argument returning tuple holding int string double module juxtapose import juxtaposehelper template juxtapose fun tuple staticfilter isnotvoid returntypes fun juxtapose parametertypetuples fun params typeof return result alias sumofarities fun arity alias sumofreturns fun return foreach fun fun enum firstparam arity enum lastparam firstparam arity fun static return return resultfield return fun params firstparam lastparam return result necessary scaffolding module juxtaposehelper import stdtraits import functionarity import staticscan import maponalias template isnotvoid enum bool isnotvoid void given bunch function name give typetuple return type used juxtapose template returntypes fun alias maponalias returntype fun returntypes given bunch function name give flattened typetuple return value used juxtapose template parametertypetuples alias fun rest alias maponalias parametertypetuple fun rest parametertypetuples template sumofarity sizet zero alias fun enum sizet sumofarity zero arity fun template sumofarities f alias staticscan sumofarity f sumofarities template sumofreturn sizet zero alias fun static returntype fun void enum sizet sumofreturn zero else enum sizet sumofreturn zero template sumofreturns fun alias staticscan sumofreturn fun sumofreturns also add module maponalias import stdtypetuple map mapper template alias list template maponalias alias mapper alias current rest static restlength alias typetuple mapper current maponalias mapper rest maponalias else alias mapper current maponalias template maponalias alias mapper alias typetuple maponalias relational algebra inspiration example come blog article todo code somewhere extracting tuple project select also naturalinnerouter join cartesian product intersectionuniondifference rename oldfield newfield database dynamic array tuples module relational import stdtraits import stdtypetuple import stdtypecons import stdrange import stdconv import isastringliteral import istype import half import interleave struct entry data datalength allsatisfy isastringliteral half data allsatisfy istype half data void alias half data header alias half data void value alias data tuple interleave value header data value value foreach unused value data value string tostring property string foreach unused value header string data return template entry header allsatisfy isastringliteral header entry interleave header value entry value value value valueslength headerslength return typeof return value template isentry e enum isentry trait compiles void fun entry e fun einit auto rename string string e e e isentry e enum index staticindexof eheaders static index static assert false bad index rename header called eheadersstringof else return entry eheaders index eheaders edataexpand auto rename string string db isdatabase returntype rename elementtype result foreach elem db result rename elem return result template isdatabase static isdynamicarray isentry elementtype enum bool isdatabase true else enum bool isdatabase false template issomeheader e isentry e template issomeheader string static staticindexof eheaders enum bool issomeheader true else enum bool issomeheader false template headervalue e isentry e template headervalue string header staticindexof header eheaders alias typetuple header evalues staticindexof header eheaders headervalue template project header headerslength auto project e e e static isentry e allsatisfy issomeheader e header alias staticmap headervalue e header headersandvalues entry headersandvalues result foreach unused header mixin result header e header return result else static isdatabase e allsatisfy issomeheader elementtype e header alias staticmap headervalue elementtype e header headersandvalues entry headersandvalues result entry headersandvalues elem foreach unused e foreach j header mixin elem header j e header j result elem return result else static assert project headersstringof type estringof half le converse interleave see section interleaving type given typetuple take every type stride stride standard generalization would template taking type n stride tn let exercise reader module half import stdtypetuple template half static tlength alias typetuple half else static tlength alias typetuple half else alias typetuple half half unittest alias typetuple alias typetuple int alias typetuple int float alias typetuple int float string alias typetuple int float string double static assert half typetuple static assert half typetuple int static assert half typetuple int static assert half typetuple int string static assert half typetuple int string give u module usingrelational import stdstdio import relational alias entry name string employid int dept string employee alias entry deptname string manager string dept void main auto e entry name employid deptname john tech auto employee susan financial auto employee bob financial auto employee sri tech auto dept tech sri auto dept financial bob auto employee auto depts writeln employee writeln rename dept dn employee fun class structs class hierarchy unfinished two thing show get class parent determine entire hierarchy class local scope generic maker function like class c int j int j int int j j j alias make c makec auto thecs map makec auto map makec zip emitting event example template comprising field notify come andrej mitrovic kind enough allow put give explanation logic behind template using experimental gui library signal event module field import stdtypetuple import isastringliteral mixin template field field allsatisfy isastringliteral field alias typeof static string makefields field string re foreach field field re tstringof field n return re static string makeopbinaryfields string op field string re foreach field field re re field field op rh field n return re mixin makefields field opbinary string op rh re mixin makeopbinaryfields op field return re void opopassign string op rh mixin op rh user mix type module usingfields import field struct point mixin field int x z w struct size mixin field int width height go hand hand notify struct template module notify import stdconv struct notify alias void delegate ref oneventfunc oneventfunc onevent void init oneventfunc func onevent func string tostring return string raw auto opequals rh return rh rh void opassign rh rh raw return avoid infinite loop temp used ref auto temp rh onevent temp auto opbinary string op rh mixin return raw op rh void opopassign string op rh temp used ref mixin auto temp raw op rh temp raw return avoid infinite loop onevent temp public raw raw access nt want invoke event alias raw mix class want notify change internal state module usingnotify import stdstdio import usingfields import notify class widget pointinit ref point pt writefln changed point pt sizeinit ref size sz writefln changed size sz notify point point notify size size example user might change point position field widget via point moveby point widgetpoint moveby nt modify field yet trigger onevent moveby turn emits signal containing widget reference requested position domoveemit moveby get processed chain arbitrary number listener listener take moveby reference come handy eg widget part layout layout simply add chain listener edits ref argument want even return false completely deny change field allows great flexibility example say user subclass widget let call child override onmove widget limit position min point topleft max point bottomright widget parent widget call parent layout set layout might allow child widget parent set following position min point max point additionally layout might take child size account widget never overflow min max point layout widget point size mean layout limit widget minimum maximum point min point max point widget point bottomright point point maximum bottomright point layout set layout wo nt allow widget position point either even though widget onmove method allows user try call childpoint point first child onmove first listener domove signal modify ref argument set point user coded way layout modify point since take widget size account nt overflow could number listener could add listener position chain event maybe want intercept modify argument reach parent layout want set temporary limit widget position finally always one last listener one internal function actually modifies raw field call internal painting blitting function make widget appear new position also listener return false break processing event deny modifying field notice assignment never happen external code use raw field actually modify internal payload avoids calling onevent field jacob carlborg orange serialization library module fieldsof evaluates array string containing name field given type template fieldsof const fieldsof fieldsofimpl implementation fieldsof return array string containing name field given type template fieldsofimpl sizet static ttupleoflength enum fieldsofimpl else static ttupleoflength enum fieldsofimpl ttupleof stringof tstringoflength else enum fieldsofimpl ttupleof stringof tstringoflength fieldsofimpl extending enum code come simen kjaeras generates enum definition string taking member old enum adding passed string parameter mixing module enumdefasstring string enumdefasstring enum string result foreach e trait allmembers result e e return result piece code iterates member passed enum generating string containing member value enum enum bar b c generated string look like want check feel free call enumdefasstring runtime print result bara b barb c barc see valid body enum mean use mixin generate exact enum wait module extendenum import enumdefasstring template extendenum string enum typeof mixin enum mixin enum extendenum enumdefasstring code concatenates string generated previous function one passed function parameter bar previously defined instantiation extendenum bar body function look like string expansion mixin enum extendenum bara b barb c barc concatenating string see valid enum definition enum extendenum bara b barb c barc mixin paste compiled regular code static switching label example staticswitch todo compiletime switch let create one example tuples type filtering constraint recursion etc module staticswitch template staticswitch list list value commanding switching type symbol static listlength slot left error static assert staticswitch match list stringof else static listlength one slot left default case enum staticswitch list else static list list comparison type list comparison value list typeof list list list list enum staticswitch list else enum staticswitch staticswitch list list generic structure unfinished section present generic structure growing complexity gobble let begin gobbler small exercise tuple manipulation operator overloading gobbler struct wrapping tuple defining one operator rightconcatenation operator module gobbler struct gobbler alias type store gobbler u opbinary string op u u u op return gobbler u store u gobbler gobble return gobbler gobble creates empty gobbler activate aspiration module usinggobbler import stdtypetuple import gobbler void main auto list gobble abc another string assert listtypes typetuple int string double string assert liststore todo indexing gobbler polymorphic association list association list sort flat associative array hold keyvalue pair linear list polymorphic aka templated one tuple holding bunch keyvalue key flexibility type key value different tradeoff done runtime compiletime nature key value unfinished section present one solution usage bit like lua table structs class put anonymous function namespaces also maybe add metadata type module alist import stdtypetuple import stdstdio import half struct alist static tlength tlength alias half key else static tlength tlength alias half key else alias typetuple key static tlength alias half value else alias typetuple value template alias key found default value present static staticindexof key tlength enum default value else static staticindexof key tlength static assert alist key equal astringof else static key staticindexof key enum value staticindexof key void main alias alist abc def foo default al writeln key alkeysstringof writeln value alvaluesstringof writeln alat writeln alat writeln foo alat foo writeln default alat polymorphic tree polymorphic tree tuple hoding tuples element standard tree container value different type obviously mean tree holding value different type also different type since entire content type part tree signature bit baffling see one helper function transform tree extract value quite interesting use get little feel use lessused example tree imagine wanting manipulate markup text could create document structure invoke function transform ddoc text latex document markdown one even html auto doc document title range tutorial author john doe tableofcontents levelone section section title range definition range nice abstraction definition input range basic kind range must define following method list definition front definition popfront definition empty section title range example code auto map assert mlength link http dlangorg website section title beyond range auto latex docto latex auto html docto html auto ddoc docto ddoc auto simple docto text previous imaginary tempting code doc tuple made document factory function holding small specifically marked piece text title section link factory function producing userdefined struct following simple convention type html member transforms content html code entire document dumped html file different type need class inheriting common base must shoehorned defined hierarchy template constraint verification think range example polymorphic tree expression template expression template kind polymorphic tree restricted known operation time unarybinaryternary operator operand allows one store example arithmetic operation like x binary variable x binary constant variable advantage manipulate resulting tree simplify expression avoid temporary evaluation previous expression could simplified hold equivalent x getting rid multiplication one generally encode programming language expression tree ast x writeln x else x foo x comparison symbol x value condition branch block functioncall writeln symbol x optional else branch block unary symbol x functioncall foo symbol x symbol way lie madness power macro manipulate resulting abstract syntax tree way wish rewrite code represents convert back string write file given compiler define compiletime parser feed reasonable part grammar define new authorized construct associated ast way new construct behindthescene assembled existing part language aka macro write code new extension precious feed macro program create resulting ast modifying like wish reassemble bona fide code feed standard compiler voila toy extension know could bug walter till add syntax want language staticallychecked writeln example verifying domainspecific language dsl compiletime goal take format string stdstdiowritef stdstdiowritefln check argument type passing writef ln example writing writefln sample result f num name f know mean argument must integral type f asks floatingpoint type mean previous sample know must exactly args le first one must integral type second one type exactly type converted string third one must floating point type four condition checked compiletime wo nt code entire posix specification printf following table show checked formatter asks equivalent constraint integral type isintegral u x x unsigned integral type isunsigned f f e floating point type isfloatingpoint e g g c char type issomechar type isanytype formatter check table standard formatters recognized cwritef interested detail wikipedia article make nice reference note formatters implemented stdstdio example p formatter void pointer seems work previous typechecking template stdtraits isintegral isfloatingpoint isunsigned issomechar already implented phobos one left isanytype quite complacent template module isanytype template isanytype enum isanytype true way fail would give nontype continuing previous chapter exampledriven development want obtain cwritefln stand checkedwritefln module usingcheckedwrite import checkedwrite void main cwritefln sample result f foo ok nok bad number args waited args got cwritefln sample result f foo nok arg type double verify check isfloatingpoint cwritefln sample result f foo given formatting string first thing extract formatters construct constraint list use string mixin need build string representing desired final code module getformatters import stdconv import stdtraits string getformatters issomestring dstring d dstring bool afterpercent false bool error string result alias typetuple foreach elem d error break afterpercent switch elem case afterpercent false break case case result isintegral integer afterpercent false break case u case x case x case result isunsigned unsigned integral afterpercent false break case f case f case e case e case g case g result isfloatingpoint floating point afterpercent false break case c result issomechar char afterpercent false break case result isanytype stringconvertible type afterpercent false break flag width case case case case case case case break default error true error break else elem afterpercent true get rid last comma resultlength result result finishing alias code result argschecks afterpercent finished string still afterpercent mode error result static assert bad format string return result quite long sample logic behind straightforward iterates character look x pattern included basic treatment flag said earlier example deal entire posix specification goal validate formatting string extract formatters determines string malformed generated code static assert end get readytobemixedin string like formatter alias typetuple argschecks previous example alias typetuple isintegral isanytype isfloatingtype argschecks bad string static assert bad format string z tuple check done need template verifies argument turn corresponding template get better error message use int template parameter count number args checked module verifychecks import stdconv import stdtraits import stdtypetuple import isanytype import getformatters template argschecks alias issomestring typeof mixin getformatters template verifychecks int check template args static checkslength argslength static assert ctwrite bad number args waited string checkslength args got string argslength else static checkslength end process enum true else static alias check c return c args recurse enum verifychecks check args else static assert cwrite bad arg arg string type args stringof verify check trait identifier check verify template another example doubledecker template seen section template template get nice calling syntax verify isintegral isfloatingpoint int double subtle part line else static alias check c return c args recurse want apply first checking constraint check first argument type args ala grammar allow following construct else static check args recurse standard way would alias check check else static check args would put check symbol template local scope one time would broken eponymous trick possible define verifyimpl template see section impltrick using local delegate work well alias check c return c args part defines delegate call returning either true false inserted inside static anyway checking code done rest easy module checkedwrite import stdstdio import stdtraits import verifychecks void cwritef alias args args args issomestring typeof verifychecks argschecks args writef args void cwritefln alias args args args issomestring typeof verifychecks argschecks args writefln args usage shown extending class todo ufcs implemented thing happened regularly wish community something called universal function call syntax ufcs automatic transformation afoo b foo b member called foo free function called foo local scope already work array hence string type way get builtin type except hacking compiler userdefined type call template rescue opdispatch used forward external free function call thismethod b becomes method b module forwarder mixin template forwarder auto opdispatch string name args args args mixin return name args void return clause legal return return void name b void returning function ok main limitation trick nt work across module boundary bad pattern matching function unfinished idea group bunch template together use pattern matching ability maybe put function template generating switch tuples case etc generally idea craft specific runtime code given compiletime information see also sorting network appendix expression general syntax expression give compiletime introspection type sideeffect expression described website expression quirky syntax basic use simple quite useful conjunction static see section static template constraint see section constraint common syntax type optional identifier type optional identifier othertype optional template parameter list type optional identifier othertype optional template parameter list inside parenthesis valid see return true compiletime else return false type let begin first syntax type valid type scope expression return true bonus inside static optional identifier becomes alias type example module canbeinstantiated template canbeinstantiatedwith alias templatename type templatename type valid type static templatename type resulttype use resulttype templatename type alias resulttype canbeinstantiatedwith else alias void canbeinstantiatedwith note previous code done template mind quite robust pas templatename something template name function name example see templatename type valid type return false canbeinstantiatedwith correctly set void program crash testing alias sometimes know template argument received type alias example dealing tuples element case use symbol test really alias type return true interesting use form testing whether code valid consider block seen delegate compiler type void delegate using conjunction typeof let test validity block statement code valid typeof code note end delegate activate real type return true let put use imagine function template fun argument know fun called particular bunch argument common case code abstract template let call validcall make function template also easily use argument module validcall import stdconv bool validcall alias fun args args args return typeof code test fun args end code test usage add b return ab string conc b b b return string string b void main assert validcall add generates add int assert validcall add abc template instantiation possible assert validcall conc abc conc int string ok assert validcall conc version conc struct assert validcall callable note tested code simply fun args condition fun type could function delegate even struct class opcall defined basically two way fun args invalid code either fun callable function callable args valid argument way fun may use trick provides cleaner way test valid compilation trait compiles code trait another numerous swiss army knife construct find compiles documentation section trait dedicated type anothertype type anothertype two basic form return true type implicitly converted derived anothertype type exactly anothertype respectively find interesting complex form list template parameter afterwards case template parameter act bit type variable equation let explain type identifier somecomplextypedependingonuandv u v previous code really mean excuse mr compiler type perchance complex type depending u v u v yes please give example template arrayelement array u u static u u alias u arrayelement u used let expose else alias void arrayelement template isassociativearray aa static aa aa value key value key code use value key deduced compiler else aa associative array value key defined strangely use type identifier syntax must identifier good new complex type inspected templated type parameter list template parameter type integral value example suppose everybody encountering template create templated ndimensional vector type struct vector type int dim expose type dim alias example seen section inner alias giving access inner parameter use extract vector myvec myvec vector ints dimension static typeof myvec mv vector int dim dim vector static typeof myvec mv vector b sorry nt exist use b beware also fire b legal type make sense defined definition equal b necessary use b b supertype b hey mytype supertype good know mytype subtype supertype ask mytype supertype subtype easy use subtype mytype main limitation template tuple parameter accepted bad see imagine use stdtypeconstuple lot one point need template test something tuple type though luck bit letdown template istuple static tup tuple innertypes innertypes todo yes changed dmd section need updating sometimes channel inner perl lo one way use ifti good friend typeof expression also use trait depending mood since appendix specifically module istuple import stdtypecons template istuple enum bool istuple typeof void tupletester innertypes tuple innertypes tup tinit possibletuple tupletester possibletuple line defines function template tupletester accepts tuple argument even though nothing create something type line using init property inherent type try call tupletester indeed tuple entire block statement valid resulting delegate call indeed type return true two thing note first istuple work templated type called tuple stdtypeconstuple want restrict change tupletester definition secondly get access inner type way stdtypeconstuple really problem accessed sometupletypes alias still way template parameter list element use b b syntax static u v u someclass w v int n w int n ok indeed instantiated u v verifying u derived someclass w w type v static array int length n determined possibly used afterwards branch static u v w n defined type specialization last thing know type identifier something version something also type specialization one following keywords function delegate return struct enum union class interface super const immutable shared condition satisfied type one except super return see identifier becomes alias property type described following table specialization satisfied identifier becomes function type function function parameter type tuple delegate type delegate delegate function type return type function return type return type delegate return type struct type struct struct type enum type enum enum base type union type union union type class type class class type interface type interface interface type super type class type tuple base class interface const type const type immutable type immutable type shared type shared type table effect type specialization let put use want factory template create new struct new class given name template parameter module maker import stdalgorithm import stdconv template make class struct auto make args args args static class return new args else return args struct int class c int int ii ii override string tostring property return c string void main auto array auto structrange map make array auto classrange map make c array assert equal structrange assert classrangefronttostring c find another example kind section class template duplicator template resource reading unfinished new resource welcome relatively young language nt dozen book online site dedicated learning still resource internet pertains template associated subject template resource template reference first stop dlangorg page template quite easy read nt hesitate peruse bother author anything unclear blatantly false dlangorg website also github project following table list page dealing template subject url general page template templatehtml template v c one templatesrevisitedhtml article tuples tuplehtml template tuple parameter variadicfunctiontemplateshtml template constraint conceptshtml mixin template templatemixinhtml small article string mixins mixinhtml static versionhtml expressionhtml type aliasing declarationhtml operator overloading operatoroverloadinghtml table page dealing template programming language main book writing course programming language also known tdpl andrei alexandrescu good reference book fun read tdpl interesting approach template andrei first introduces natural extension function class structs syntax get parametrized code afterwards templatesasscopes introduced following table list chapter deal template subject chapter function template class template struct template alias general template mixin template operator overlaoding table tdpl chapter dealing template programming another quite interesting book translation turkish ali cehreli book programming find free http ddiliorgdersdenindexhtml precisely far document concerned chapter template already translated found http ddiliorgdersdentemplateshtml ali book aim gentle introduction rhythm le gung ho tdpl want read present document previously linked chapter best bet template tutorial wiki apart book wiki tutorial template found http wikidlangorgintroductiontodtemplates explains stdfunctionalunaryfun thoroughly dealing passing various subject template string mixins instantiation scope found pleasant read nice explanation difficult part phobos metaprogramming found nick sabalausky article http wwwsemitwistcomarticlesefficientandflexiblesinglepage good read full nifty idea particular nick show use compiletime information craft code runtime argument used influence compiletime value yes read right description justice read see definitely must put section somewhere doc code shown article found github project url http githubcomabscissaefficientandflexible template language unfinished c template obviously article online book small text boost also maybe java c generic subsection genericity language unfinished haskell ml concerning type general type trick haskellers live encoding information type using type forbid unwanted state subsection metaprogramming language subsection macro unfinished maybe lisp scheme clojure macro nemerle macro
59,Lobsters,d,D programming,Writing a D Wrapper for a C Library,https://dlang.org/blog/2019/02/10/writing-a-d-wrapper-for-a-c-library/,writing wrapper c library,research project ada programming language ada user journal volume number march c library redland rdf library resource description framework rdf available github package structure mixins virtual method table vtable template mixins construct template alias parameter dealing callback little thing static via comparison conclusion,porting program created research project wrote wrapper c library objectoriented manner want share experience programmer article provides tip trick writer wrapper around c library initially started research project using ada programming language see article experience writing ada binding c library ada user journal volume number march due number bug unable overcome started looking another programming language unsatisfying experiment java python settled programming language c library c library written objectoriented style c structure pointer serve object c function taking structure pointer serve method fortunately u inheritance c library particular library deal redland rdf library set library parse resource description framework rdf file rdf resource manages enables rdf query etc worry know rdf really relevant article first stage project write wrapper librdf modeled ada wrapper already written one advantage found ada template instantiation need instantiate every single template invocation separate declaration expect substantially simplify code xml boiler program us library wrote raw binding wrapper binding translate c declaration directly wrapper new api fullfledged interface example us type constructor destructors represent object also us feature available c work progress comment welcome source code library forked dave beckett original multilanguage binding library available github currently dlang branch initially tried automatic parser c header generate code found unsatisfactory wrote necessary binding package structure put entire api rdf package hierarchy also rdfauxiliary package subpackages thing used binding discus particular rdfauxiliary package mixins ada used tagged type rough equivalent class derived withfinalization type withoutfinalization type see however tagged type increase variable size execution time use structs instead class mainly efficiency reason structs support inheritance therefore virtual method table vtable provide constructor destructors making class unnecessary use case however see simulate inheritance use template mixins defined rdfauxiliaryhandledrecord module alias construct said c object pointer structure c pointer structure format alignment isoiec section paragraph allows representation pointer c structure pointer opaque struct example urihandle opaque struct declared struct urihandle using mixins shown declare public structs api way look actual source real example struct uriwithoutfinalize mixin withoutfinalize urihandle uriwithoutfinalize uri raptoruricopy struct uri mixin withfinalize urihandle uriwithoutfinalize uri raptorfreeuri difference withoutfinalize withfinalize mixins explained main challenge writing objectoriented binding c library finalization c library consideration well many c library every object represented pointer dynamically allocated c structure corresponding object struct holding pointer aka handle oftentimes c function return socalled shared handle pointer c struct free part larger c object shall freed c library larger c object go away first define example uriwithoutfinalize uri uri destructor uriwithoutfinalize shared handle finalized support inheritance structs template mixins instead partial listing see uri example use mixin template withoutfinalize alias dummy alias withoutfinalize alias withfinalize alias copier null private dummy ptr private dummy ptr thisptr ptr property dummy handle const return cast dummy ptr static withoutfinalize fromhandle const dummy ptr return withoutfinalize cast dummy ptr static iscallable copier withfinalize dup return withfinalize copier ptr mixin template withfinalize alias dummy alias withoutfinalize alias withfinalize alias destructor alias constructor null private dummy ptr disable disable use fromhandle instead private dummy ptr thisptr ptr destructor ptr private property withoutfinalize base private work return withoutfinalize ptr alias base property dummy handle const return cast dummy ptr static withfinalize fromhandle const dummy ptr return withfinalize cast dummy ptr used template alias parameter allow template parameterized type dummy argument type handle instance usually opaque struct destructor copier argument selfexplanatory usage constructor argument see real source omitted withoutfinalize withfinalize template argument specify structs define allowing reference note alias construct make withoutfinalize essentially base withfinalize allowing u use method property withoutfinalize withfinalize also note instance withoutfinalize type may become invalid ie may contain dangling access value seems easy way deal problem way c library work may know object destroyed c library may know unable appropriately explain compiler careful using library use object already destroyed dealing callback deal c callback particularly accepting void argument additional data objectoriented way need way convert c void pointer class object pas object c user data pointer structs enough efficient represent c object like librdf library object conveniently working callback class useful provide good callback machinery form virtual function first object passed callback parameter c unexpectedly moved memory garbage collector make descendant class class unmovableobject gcsetattr cast void gcblkattrnomove moreover add property context pas void pointer c function register callback abstract class userobject unmovableobject final property void context const return cast void create callback need pas object c pointer extern c function defined u callback callback receives pointer previously passed u callback code want stay objectoriented convert pointer object pointer need bijective back forth mapping pointer c void pointer trivial use cast operator practice best way explain example consider create io stream class us c library callback implement example user wrapper request write information file class receives write message handle message implementation call virtual function dowritebytes actually handle user request private immutable dispatchertype dispatch version init null finish null writebyte raptoriostreamwritebyteimpl writebytes raptoriostreamwritebytesimpl writeend raptoriostreamwriteendimpl readbytes raptoriostreamreadbytesimpl readeof raptoriostreamreadeofimpl class useriostream userobject iostream record raptorworldwithoutfinalize world iostreamhandle handle raptornewiostreamfromhandler worldhandle context dispatch record iostreamfromnonnullhandle handle void dowritebyte char byte dowritebytes byte throw new iostreamexception abstract int dowritebytes char data sizet size sizet count abstract void dowriteend abstract sizet doreadbytes char data sizet size sizet count abstract bool doreadeof example int raptoriostreamwritebytesimpl void context const void ptr sizet size sizet nmemb try return cast useriostream context dowritebytes cast char ptr size nmemb catch exception return little thing encode c string null template instance nullable string string null holder empty however often enough transform empty string null c string work differentiate empty null string see rdfauxiliarynullablestring actually useful code would write lot advice write binding c library follow source serve example static one thing done ada compiletime comparison via static construct similar advanced c conditional preprocessor directive allows conditional compilation based compiletime value use static custom version type enabledisable feature library depending available feature version base c library use following example rasqalversionfeatures constant defined rdfconfig package created gnu configure script configdin file static version rasqalversionfeatures version private extern extern c queryresultshandle rasqalnewqueryresultsfromstring rasqalworldhandle world queryresultstype type urihandle baseuri const char string sizet stringlen static create rasqalworldwithoutfinalize world queryresultstype type uritypewithoutfinalize baseuri string value return queryresultsfromnonnullhandle rasqalnewqueryresultsfromstring worldhandle type baseurihandle valueptr valuelength comparison order comparison structs easily done mixin mixin template comparehandles alias equal alias compare import stdtraits bool opequals const ref typeof const static iscallable equal return equal handle shandle else return compare handle shandle int opcmp const ref typeof const return compare handle shandle sadly mixin called withoutfinalization withfinalization structs found solution write conclusion found great language writing objectoriented wrapper around c library small annoyance like using class wrapper around structs callback generally wrap around c well victor porton open source developer math researcher christian writer earns living programmer
60,Lobsters,d,D programming,Last Year (2018) In D,https://dlang.org/blog/2019/01/24/last-year-in-d/,last year,release rundown version january support strippeddown runtime deprecation change arithmetic rule came march came improved error message introduced dmd flag experimental exception throwing proposed changed garbage collector bundled llvm linker dbugfix campaign year may release used compile time july release change contract syntax proposal dip version user defined attribute member function parameter disable druntime exception trapping digitally signing window binary release version namespaces without scope qa system dconf held symmetry autumn code rundlangio came dlangorg homepage dlangtour website open collective coded v code plugin language server successful campaign launched flipcause donation platform fourth acm sigplan history programming language conference dip hooking struct move semantics documentation generation website dpldocsinfo dlangng started announce forum digitalmarsdannounce newsgroup autowrap automatically wrap dpp run c preprocessor code string interpolation implementation state survey several area improvement official blog annual dconf dub package manager codedlangorg website mir library unit testing library unitthreaded related vibed conclusion cookbook week arsd package legendary dconf presentation addendum,one biggest year first complete year dmd stuck steady release schedule course year language got new feature cruft cleanup compiler even got new userfacing feature time communityatlarge continued evolve surrounding ecosystem release rundown first dmd release year version january set tone much year including support strippeddown runtime betterc mode deprecation change arithmetic rule next major release came march personally found exciting release couple year came improved error message notably calling specific argument function mismatched type though note still lot room improvement moreover release introduced dmd flag automatically includes imported module proven major convenience year meanwhile strippeddown runtime support general language cleanup included release march also introduced experimental nogc exception throwing proposed release also changed garbage collector lazily initialized part effort make thing cheaper payasyougo march also first time dmd window could total build program without visual studio installed bundled llvm linker keeping release schedule may july brought u new major version focused language cleanup lot deprecation dbugfix campaign year brought fix may release allowing pow operator several stdmath function used compile time july release brought change contract syntax based proposal dip allowing small expression instead requiring whole block version september finally brought something wanted long time user defined attribute enum member function parameter well ability disable druntime exception trapping via runtime commandline switch allows easier debugging uncaught exception moreover release language foundation began digitally signing window binary release helped smooth enduser experience installing running dmd continue help solve falsepositive problem seen virus scanner end year version saw extern c get big improvement user waiting namespaces without scope make c interoperability code organization lot easier work making c standard library accessible progressing throughout year overall year brought lot awaited improvement usable various runtime library situation even phobos betterc support like refcounted tuple language ten deprecation old cruft like comma expression readmodifywrite shared comma expression class allocator even know still class allocator honest thought formally deprecated year ago actually change officially happened debugging got better uncaught exception switch also allowing debug statement escape attribute restriction better error message compiler verrorscontext switch show line right message betterc debugging aid also improved c assert function possibility also note already moving assert printing code merged recently choose control whether use c facility course library continued get better range support support nogc betterc grown well fun fact dmd ported another major part converted year company invested hosted qa system dconf held munich germany first time dconf city third time germany taking place berlin symmetry investment sponsored successful symmetry autumn code funding three student work drelated project rundlangio came end grew popularity throughout becoming new standard running code online including dlangorg homepage even support whitelist thirdparty library dlangtour website gained new translation community including vietnamese portugese french turkish german ukrainian language foundation busy well received open collective earmarked support development coded v code plugin language server drive successful campaign launched flipcause dlf able hire pull request manager three month donation platform allowed fund outreach effort well student work via scholarship increase visibility submitted history paper fourth acm sigplan history programming language conference pull result merged dlangbot github project tester gained project test every pr give realworld data compiler regression impact breakage dip hooking struct move semantics also accepted open door closed design old many developer found limiting compiler could move structs whenever wanted hookable give control programmer avoid nasty case bug opened documentation generation website dpldocsinfo dub project year upstream linked encouraging library author better document library allowing user better evaluate library downloading twitter dlangng started gained follower announcement topic announce forum aka digitalmarsdannounce newsgroup tweeted also saw community announcement autowrap dpp project autowrap automatically wrap existing code used environment dpp run c preprocessor code make possible use c header unmodified macro directly two project show community desire integrate fully existing codebases project course perfect development community including area author would like see improvement pr dmd string interpolation implementation elegant approach writer opinion remains open uncertain status despite renewed effort get merged december similarly state survey identified several area improvement came pas though progress made deprecated cruft autodecoding one topfive disliked phobos feature survey one often derided forum remains place still using bugzilla got average satisfaction rating possible star survey achieved fewer regression added even attribute bloat official blog annual dconf language foundation inner working still opaque would great weak point addressed among improvement change dub package manager codedlangorg website received criticism addressed site got new front page usage statistic project ranking based github info dub program got faster stable longer going online every run check update achieving better online uptime mir library algorithm collection written betterc compatible course mean also work environment fifthmost popular package dub registry unit testing library unitthreaded take thirdplace slot first second fourth related vibed project dub originally created support conclusion really good year still much work worthwhile development facet language ecosystem gave renewed excitement going expect march release going another big step toward improving best programming language earth today adam ruppe author cookbook maintainer week module freely available arsd package used throughout community also known legendary dconf presentation addendum total contributor listed dmd changelog special thanks others community flesh ecosystem make favorite programming language adam ruppe alexandru caciulescu alexandru jercaianu alexandru ermicioi alexibu ali akhtarzada ali çehreli andrei alexandrescu andreicristian vasile andrey penechko andy smith aravinda vk arun chandrasekaran atila neve bbasile basile burg bastiaan veelo benoit rostykus brad robert brian schott carsten schlote chris coutinho daniel kozak dashster david bennett david gileadi david nadlinger denis feklushkin diederik de groot dmitry olshansky dragos carp duncan paterson eduard staniloiu elia batek erik van velzen eugen wissner feepingcreature gabyforceq giles bathgate goalitium greg v h teoh harry vennik hiroki noda héctor barreras almarcha dechcaudron iain buclaw ilya yaroshenko ionut jack stouffer jacob carlborg jan jurzitza jeanlouis leroy jinshil joakim noah johan engelen johannes loher johannes pfau john belmonte john colvin jon degenhardt jonathan davis jonathan marler jordi sayol joseph rushton wakeling kai nacke kevin de keyser kotet laeeth isharc lance bachmeier leandro lucarella lemonboy lucia mcojocaru luís marque manu evans manuel maier markus fxj oberhumer martin kinkelin martin krejcirik martin nowak mathias baumann mathias lang mathis beer metalang michael parker mihails strasuns mike franklin mike parker márcio martin nathan sashihara nemanja boric nicholas lindsay wilson nicholas wilson nick treleaven oleg nykytenko patrick schlüter paul backus per nordlöw petar kirov pjotr prins pradeep gowda quirin f schroll radosław rusiniak radu racariu rainer schuetze razvan nitu remi thebault robert burner schadek roman chistokhodov ryan david sheasby ryan frame sebastian wilzbach simen kjærås simon naarmann spoov stanislav blinov stefan koch steven schveighoffer temtaime tero hänninen thibaut charles thomas mader timon gehr timoses timothee cour tomáš chaloupka tyler knott unknown vlad vitan vladimir panteleev walter bright yannick koechlin yuxuan shui zach tollen zevenberge byebye carblue cedretaber crimaniak devel deviator dhasenan dukc gapdan glitchbunny growlercab jercaianu kinke leitimmel lookatme rracariu shoo thaven viktor wazar olframw yashikno ľudovít lučenič
61,Lobsters,d,D programming,"D-lighted, I’m Sure",https://dlang.org/blog/2019/01/18/d-lighted-im-sure/,dlighted sure,road andrei zmievski phpgtk ran across electron list gui toolkits see gtkd among perspiration refreshment programming keep mr çehreli book handy ecology forum one dlangorg gtkdorg learn subforum gtkdcodingcom dub eludes plain ole dmd conclusion coleco adam dutch angle bio,finding recent step along road winding back least dozen year searching crossplatform development languageenvironment posix window much mobile since search began mobile really thing point fit better anything else tried go limb say holy grail xplat least brought fun back coding whenever massage hunk code finally well addicted little victory road first language tackled back midoughts meet end php web developer year found php standalone desktop version stumbled across andrei zmievski phpgtk lightbulb went firework went big drawback found phpgtk php compiler could handle gtk end year patiently hoping someone would tackle wrote nearly blog post use started looking elsewhere back steeped javascript html writing simple online apps banking client vancouver bc later bancroft ontario background ran across electron year ago seemed like good fit assumed learning would easypeasylemonsqueezy lot nature web development language changed boot several language standard paradigm thrown mix say least found confusing little intimidating really wanted one language easy distribution system gui toolkit necessitate balancing style sheet front backend code well json file electron unfortunately need drag chromium along ride little metaphorical red wagon solution one looking last year stumbled onto hearing year read much realize available across many posix platform also realize embraced oop paradigm given much thought liked subtle humor next line b c oddly enough came along later b c brief smile paid attention last october finally took good look realized curly brace oop propensity run right street rolling sleeve made sure gui toolkit could use something necessitate balancing three differing paradigm found list gui toolkits wiki gratified see gtkd among last two plus month putting effort learning gtkd work together perspiration refreshment may may important know c degree completely selftaught process started stuck middle frozen nowhere three week year ago whole story point hole education happens follow nose instead syllabus intricacy elude may always although read ali çehreli chapter subject programming idea mixins want use template seem like good idea know blame lack formal c education quite comfortable class object sweating first introduced oop gang four learning php cover familiar territory regard curly brace another thing feel quite home used programming life finding familiarity bit stumbling block well different enough c php mean work hard pounding difference brain deal rote typing example code figure copy enough code instead lazing along copynpaste eventually push c php far enough background see past keep mr çehreli book handy go completely rail quite helpful speaking ecology forum far signed two doriented forum one dlangorg gtkdorg yet find unfriendly avatar everyone encountered seems willing jump help contrast forum one active year mentioning name forum related art graphic programming forum insulted questioned looking thing warning film term dutch one thing best come art background suspect quite rabble rouser art college ask alan wood installation artist knockdowndragout shouting match cafeteria emily carr college believe whole story dlangorg mostly hang learn subforum suppose natural stage probably polite bunch run across forum ever frequenting forum since hoary day bb baud lauded fastest thing since hemi mike wey seems quite patient someone answer moreorless question gtkd forum negative found forum technical signed made post went back sign second time reregister still identified ron tarrant signed first time think perhaps thing supposed unusual work also mention gtkd documentation page mindbender planning spend lot time next decided pitch help make thing accessible drawing experience writing phpgtk blog back porting bunch code example tutorial gtkd went far buy domain name gtkdcodingcom preparation launching site blog covering deal learning curve done since wrote series basic tutorial sister freezing newfoundland outport back got running dmd quite quickly installation window freebsd straightforward quick question forum everything needed single multifile project question answered gtkd forum comfortable enough start porting phpgtk code say dub eludes know electron left feeling like json file disgruntled engineer revenge plot way brain work perhaps put mind could learn since getting result want plain ole dmd done skim dub doc record back c day make file caution eventually licked ever becomes important enough figure dub guess heart finding text editor support especially gtkd syntax highlighting rather people forum c getting good enough support led abandon search roll far done moreorless complete highlighter pspad codeblocks fair support box gtkd important mostly aid remembering module name even looked tool dimly aware subforums look like tool honest read said dmd job satisfied conclusion quick summary first two month one hand really understand paradigm one relate meeting expectation two thing found yet information would go packaging app gtkd distribution build one platform distribution another even possible willing put time eventually get gtkdcodingcom ground way giving back long time since frozen week coleco adam tried explain basic thirteenyearold sister paramedic care must say excited gtkd basic general computing way back retired time pursue looking forward becoming regular member community case know dutch angle urge watch episode batman see camera tilt thing go wrong hero dutch angle bio inspired learn programming vacationing frozen newfoundland outport april started desperate attempt keep stripping short disappearing blizzard became lifelong passion along acting writing music keeping nontypical start art college learned first serious programming language assembly later job technical writer artist wrote first serious code client online mortgage calculator credit union british columbia culmination programming career finishing phpgtk app corkboard writer tool story planning bother looking come distribution system languishes backup drive since dropping high school made living taxi driver musician screenwriter technical writer artist sound reinforcement equipment salesman biology lab technician among thing also made money acting programming promoting concert retired statistic canada since divided time acting writing lame novel pursuing elusive xplat beast keeping house wife year
62,Lobsters,d,D programming,"Comparing Pythagorean triples in C++, D, and Rust",https://atilanevesoncode.wordpress.com/2018/12/31/comparing-pythagorean-triples-in-c-d-and-rust/,comparing pythagorean triple c rust,pointed rust reddit thread blog post implementation pythagorean triple using range problem reddit thread github wise lady internet said one redditor forum post reddit generator version reddit rust version hacker news like,edit pointed rust reddit thread rust version modified run faster due suble difference z updated measurement former latter also change conclusion may recently encountered andor read blog post criticising possible implementation pythagorean triple using range author benchmark different implemetations problem comparing readability compile time run time binary size main language day given also range right opposed future version language almost immediately reached keyboard time already rust version floating result reddit thread fortunately lazy next benchmark lot code talk found github fancyreadableextensible rangescoroutinesetc may let get baseline comparing simplest possible implementation using loop printf copied simplestcpp example blog post translated rust make sure make mistake manual translation compared output canonical c implementation outputtxt github repo easy run fast output wrong familiar dmd reference compiler compiles fast generates suboptimal code compared modern backends ldc llvm based compiler frontend us llvm backend using ldc also make fair comparison clang rustc due three using backend albeit possibly different version time reported millisecond reported running command time arch linux dell compile time measured excluding linker command clang c srccpp dmd c srcd ldc c srcd rustc emitobj srcrs compiler obviously unoptimised build original number iteration runtimes short practically useless comparison increased time presented result running command time taking mininum except clang unoptmised build c range wise lady internet said nobody got time see soon optimised build done clang ldc inline dmd c rustc compiler version clang dmd ldc rustc result simple readable nonextensible version problem simplecpp simpled simplers repo simple ct m rt m clang debug clang release dmd debug dmd release ldc debug ldc release debug release debug release c run time optimised compile time lot shorter rust stand extremely slow without optimisation compiling even slower c generating code take around longer run even optimisation turned expect simple implementation couple generation triple meant done one option discussed original blog solve pas lambda callable code instead hardcoding printf simplest way solve according one redditor composability issue may arise might might important depending application though one also compose function pipeline pas sure problem case wrote implementation timed lambdacpp lambdad lambdars lambda ct m rt m clang debug clang release dmd debug dmd release ldc debug ldc release debug release debug release first thing notice except rust slow anyway compile time risen factor cost generic run time seem unaffected except unoptimised rust build got slightly slower glad intuition seems right extend original example keep loop pas lambda profit sure compiletimes went context larger project probably matter much even c ok performancewise tie language runtime penalty compared nongeneric version nice next code motivated range write version forum post c code blog using available range library rust code reddit result range ct m rt m clang debug clang release dmd debug dmd release ldc debug ldc release debug release debug release hand rustc whatever throw compile time seem flat modifying code mentioned edit beginning fastest dmd compile time still fast generated code ldc better optimising runtimes pretty bad wonder change would made frontend generate code loop c ran debug version going wait long besides whatever systematic error measurement process really matter take minute compile time abysmal solace optimising code take longer time bother opinion none version readable rust least manages nearly fast previous two version c taking twice long used task fare well performance concerned possible get ldc optimised version eliminating bound checking even seem worth bother conclusion bother range version nigh unreadable code compiles run slowly finally tried generator version reddit rust version hacker news well involves using rust nightly enabling feature bothered figuring rustacean want submit something work build script please open pr repo generator ct m rt m dmd debug dmd release ldc debug ldc release compile time great worst far runtimes quite acceptable sneaky suspicion runtimes slower due startup code stdconcurrency increased n compared version simplest possible one top post rt m dmd relase simple dmd release generator expected difference vanished final conclusion passing lambda way go generator c coroutines yet rust version mentioned need feature apparently available nightly build like range c incarnation sometimes worth lambdasgenerators ftw like like loading related
63,Lobsters,d,D programming,Using D to Create the World’s Fastest File System,https://dlang.org/blog/2018/12/04/interview-liran-zvibel-of-wekaio/,using create world fastest file system,matrix world fastest file system posted impressive number node challenge wekaio write prototype quickly easily continue working codebase reach production quality joakim liran joakim liran ldc compiler llvm backend joakim blogged visiting tel aviv liran generic introspection watch andrei dconf keynote design introspection userdefined attribute builtin unit test range clever even contract programming joakim liran dub package manager build environment joakim liran available github fork nongc standard library joakim liran andrei alexandrescu giving talk google campus interviewed member community week android port ldc,matrix world fastest file system written recently posted impressive number node challenge created wekaio san jose ca based startup engineering tel aviv israel liran zvibel cofounder ceo wekaio regular speaker dconf talking use dconf wekaio expression design goal write prototype quickly easily continue working codebase reach production quality opposed prototyping different highlevel programming language liran took time busy schedule answer question wekaio use liran zvibel dconf video joakim tell u enterprise storage market wekaio use product liran compute environment mix cpu power networking storage uniform across many organization type size whether infrastructure inhouse premise public cloud cloud somebody else computer say storage component provides current state also history needed compute compute stateless many time rebooted computer fix problem network ephemeral storage must able keep state consistently coherently providing enough performance compute job otherwise running job iobound nobody like three main type centralized storage system block storage system provide abstraction local drive sits remotely several system may get access volume centralized system aws equivalent system elastic block store volume usually shared one server reason use failure resiliency reliability performance also advanced feature taking point time backup integration vm environment etc file system centralized storage also shared allows several server network access data kind system wekaio provides traditionally people turned blockbased solution needed high performance created local file system based shared volume wekaio show enable shareable file system even faster local file system block storage object storage solution enable storing object reduced semantics ability modify data stored eventually consistent etc enable cost saving generally care performance review storage system talk mainly blockbased file system solution object storage much simpler implemented using different method requirement storage system reliability performance lowlatency iop throughput feature traditionally system data path care reliability performance control path management path take care higherlevel feature making reliability work higher level many storage system data path implemented system programming language c c management path implemented higherlevel language python java go etc previous company xiv ibm acquired used private version c polymorphism generic programming integrated rpc code mixture xml c weird header file wekaio use programming language implement data path control path use single language get machinelevel access high performance needed higherlevel language feature joakim end choosing mentioned dconf initially tried combination python c liran first part work done cpython combo work efficient inprocess rpc mechanism python c would allow u refer object c python efficient way way object could run c context needing performance python needing brevity idea start implementing system python convert piece c needed interprocess communication inter intra server would done c time prototype system implemented python started working c part rpc definition first discovered realized may able get single language handle highlevel performance requirement started running pet project verify indeed working language next phase implementing rpc much elegant c version tracing system would allow u debug tracing system reviewed dconf talk biggest limitation initially availability optimizing compiler reference compiler dmd provide assembly equivalent llvm even gcc running modern processor dconf help david nadlinger able get ldc compiler llvm backend compile code generate result met need joakim andrei alexandrescu one coarchitects language blogged visiting tel aviv code compact added new feature without growing codebase much key feature use accomplish speed benefit storage system liran strongest part generic programming use generic programming two way usually contradictory actually work well one way use generic programming achieve higher performance example using static polymorphism object type get fully assembled compiler runtime run correct code many case passing compiletime argument save expensive memory load branch leading much faster execution compiletime introspection allows placing object memory differently also make code run faster based static decision use static generic foreach introspection allow u write higherlevel code much easier also write code applies many case watch andrei dconf keynote design introspection probably use language feature including userdefined attribute mark code introspection chooses handle differently later debugging purpose builtin unit test obviously range clever even contract programming joakim widely known yet bring developer board common hangups liran internal environment proprietary form dependency build environment unique u biggest grief get user trying start using even wekaio employee try run pet project first minute outofthebox experience dub package manager build environment streamlined enough often get comparison upcoming language onboarding process easier inviting new user write second project compiled obligatory hello world program newcomer usually unaware feature code full adapt extremely quickly welcome project problem joakim mention contracting ldc devs work kind fix put could talk generally flaw solve work around liran biggest problem initially year ago ldc even compile code compiler choked failed first iteration david getting compiler compile got running binary long series change make sure code generated ldc worked way dmdgenerated code got adding performance improvement code ldc wekaio codebase larger standard project current ldc use available github fork contains template instantiation change part standard frontend johan engelen run current ldc effort spent lot time linktime optimization performanceguided optimization get ldc code run faster johan work running code test advancing ldc next frontend release make sure thing still run well care deeply performance also binary representation data structure work johan release verify change biggest issue work around reliance garbage collector gc throughout runtime standard library phobos work making sure leverage exception gc create nongc standard library rely phobos able get ldc library state efficient runtime environment produce extremely fast code gc jitter grief around compilation time large project joakim talked sponsoring meetups tel aviv publicizing language kind reception generally tel aviv famous startup hotbed wekaio find situated liran tel aviv israel fertile ground startup run meetups one even andrei alexandrescu giving talk google campus office big enough fit people coming reception concept good unfortunately able get startup actually start using language startup tel aviv blessing curse lot strong talent lot experience especially around infrastructure also lot demand alongside startup many large corporation google apple microsoft amazon many engineering office offering lucrative position even though lot good supply demand even stronger filling position easy joakim resident interviewer blog also interviewed member community week responsible android port ldc
64,Lobsters,d,D programming,D vs Nim,https://github.com/timotheecour/D_vs_nim,v nim,ufcs http nimlanggithubionimmanualhtml templateslimitationsofthemethodcallsyntax tuple ctfe http oop syntax http dlangorgspecmodulehtml packagemodule http http http http http dlangorgdstylehtml nim enhancement proposal type http semantics http http raii source type annotation debugging maturity interop http standard library http http http http http ecosystem http githubcomnimlangnimpulls http githubcomdlangdmdpulls http githubcomnimlangnimpulse http githubcomdlangdmdpulse http githubcomnimlangnimissues http dlangorgbugstatshtml http githubcomnimlangnimissues package http codedlangorg http nimbledirectorypackagesxml http githubcomnimlangpackages http codedlangorg tooling http http http githubcomdlangcommunitydrepl http githubcomcallumenatordabble nrpl implementation doc http nimlangorgdocslistshtml metaprogramming rfc variadic generic http jester backend http githubcomarnetheducknlvm,ufcs ufcs supported everywhere everywhere eg mixin expr typeof expr local symbol called ufcs mc nim cast templatesmacros untyped see http nimlanggithubionimmanualhtml templateslimitationsofthemethodcallsyntax tuple tuple unpacking yes proc gettup auto foo let gettup ctfe engine ast interpreter every expression encountered allocate one ast node within tight loop interpreter easily generate node eat gigabyte ram exhaust memory quite quickly future work http us register vm also basis nimscript faster ffi ctfe embed directly cc code yes emit readwriteexec ctfe read string import yes allows filesystem access via staticread staticexec ctfe limitation heap allocated compiletime variable turned immutable staticconst runtime oop design java like allows multimethod dynamic dispatch defined outside avoiding kitchen sink class syntax allows local import yes import order irrelevant yes package module allows backward compatible breaking module package yes http dlangorgspecmodulehtml packagemodule yes see http mutually recursive import yes compiletime error use forward declaration andor mixin foosymbol tell compiler symbol visible one point checkme see also http http http workaround lack cyclic dependency nim usually worked around type module familiarity clike c pythonlike interpolated string yes named parameter argument yes style subjective opinion http dlangorgdstylehtml style guide phobos take much vertical whitespace eg brace line nim enhancement proposal type mutually recursive type yes type declared within single type section else would require arbitrary symbol lookahead slows compilation nested type yes see http semantics rvalue reference attribute inference template function distinction traced untraced pointer yes forward declaration allowed yes see http user defined operator partial opcall opslice opassign etc yes user defined attribute yes raii yes modulo caveat http see raii prevention null dereferencing manual null check required null pointer class object exist way check remember use myobj null lessening impact many builtin type integer fixedsize array map struct object never throw null dereference error either null treating null value empty value source manual null check required nil reference pointer exist standard way check remember use myobj nil myobjisnil lessening impact many builtin type never nil including seqs ptr ref type cstrings nil nim also experimental notnil feature enables nil type annotation eg ref someobject nil ensure variable never hold nil feature made experimental debugging maturity stability breaking change release pre new release often make lot break change community larger interop c calpypso ldc fork allows direct c integration c cc code generation giving u much better interop offer case point converting cstring nt require allocation copy see also http compile j yes direct use nim emits c code break emit pragma c code nt written outside nim file standard library range range implement empty front popfront yieldbased iterators maybe simpler write le efficient flexible eg ca nt infinite range bidirectional range variable length array allows alloca see http variable length array slice form pointer length builtin pending http http string built array yes immutable char different type le generic api lazy functional programming eg map filter yes eg stdalgorithm pending http http ecosystem contributing pr languish forever pr get merged way faster nim see http githubcomnimlangnimpulls v http githubcomdlangdmdpulls phobos etc sure quantify objectively see also http githubcomnimlangnimpulse v http githubcomdlangdmdpulse quote nim magnitude order easier contribute compiler code easier reason least pr accepted lot willingly bet openness core devs make nim evolution faster hope gon na stay way matter repo split dmd druntime phobos single repo compiler stdlib making synchronization easier github history highly intertwined us merges almost linear guessing rebases issue tracker bugzilla issuesdlangorg github issue http githubcomnimlangnimissues openedclosed bug http dlangorgbugstatshtml http githubcomnimlangnimissues package package dub http codedlangorg nimble http nimbledirectorypackagesxml http githubcomnimlangpackages number package http codedlangorg nimble list tooling format code dfmt inplace nimpretty yet ready http code reduction bug dustmite pending http repl http githubcomdlangcommunitydrepl http githubcomcallumenatordabble unofficially use nim secret support lot thing promising nrpl implementation gc single shared memory heap controlled gc thread safe fully conservative stoptheworld precise threadlocal heap bit deterministic lot faster even timeframe need consistent example much better gc implementation soft realtime application paused max pause tuned default gc thread safe gc implementation switched compiletime deferred reference counting cycle detection default mark sweep boehm gc memory region untraced heapallocated manually managed object available nim distinguishes bw ref ptr traced reference point object garbage collected heap untraced reference point manually allocated object object somewhere else memory compile speed faster via dmd checkme compiler bootstrapped frontend yet backend yes bootstrapping source regenerated nim allowing compiler source use latest feature error message us poisoninggagging avoid spurious error yes binary size produced produce smaller binary shared library support linux ok osx ldc dmd window ok checkme anything linked c doc builtin doc ddoc noisy nonstandard restructuredtext eg removesnfroml efficiency eg http nimlangorgdocslistshtml metaprogramming variadic generic yes void fun rfc variadic generic varargs untyped allowed macro though eg ca nt used template function partial type template type deduction yes see http supported generic parameter type alias constant type alias constant template constraint void fun isfoo concept simpler use type isfoo concept proc fun isfoo macro hygienic macro system instead string mixin string mixin available parsestmt macro modify directly abstract syntax tree given parser compiler pas possible implement new dsl based macro system example webserver dsl jester backend available backends custom dmd gcc gdc llvm ldc c c j wip llvm http githubcomarnetheducknlvm
65,Lobsters,d,D programming,D compilation is too slow and I am forking the compiler,https://blog.thecybershadow.net/2018/11/18/d-compilation-is-too-slow-and-i-am-forking-the-compiler/,compilation slow forking compiler,usual tool second part graph theory digger excluding library kosaraju clever algorithm strongly connected component dag topological sorting insertion sort part hacking compiler relatively simple change switch bit broken part forking time cow memory posix implementation note quitting part putting together pretty simple worth dmdforker branch dmd github fork caveat anticipated question q q q new mozilla q linux subsystem thanks reading reddit hacker news forum comment section,working current project constant creep increasing compilation time becoming noticeable even throwing usual tool problem total time still second seven second compile time profiling showed blame lay liberal use metaprogramming stdregex willing give usual approach reducing build time split program package compile one package time static library object file use header file di avoid parsing implementation often necessary link everything together however much work fit neatly existing toolchain wanted try something else c compiler handle similar problem precompiled header result parsing header file serialized saved disk implementationdefined format implementation analogous feature moment still left wondering precompiled header format highly implementationspecific compiler free break compatibility even across minor version goal preserve information avoid repeated work across multiple invocation compiler main difficulty implementing serializing compiler internal state disk deserializing back memory care saving disk checkpoint compiler parsing file onebyone rewind necessary way efficiently snapshot process internal state rewind resume back oh wait called fork granted typical use case still promising idea build let get work part graph theory order correctly partially rebuild program need know part need rebuilt case come knowing file need recompiled certain file change luckily dmd u covered output dependency information plethora format great let use slurping result deps get u directed graph like digger module dependency click enlarge clearly ahem let try digger module dependency excluding library may noticed graph cycle allow cyclic dependency module long one module cycle static constructor problem u meaningfully snapshot compiler middle cycle need treat allornothing indivisible entity fortunately graph theory come rescue use kosaraju clever algorithm separate graph strongly connected component simplifies graph dag cycle job done yet need flatten dag list meaningfully combine checkpoint one parent another use topological sorting get arrow pointing right great list component wherein component group file compile together create snapshot component file modification time work nicely secondary sorting parameter assume recently modified file likely modified soon placing front older file save u rebuilding older file ranked equally dependencywise implementation note got lazy used insertion sort topologicalchronological sorting though sure efficient algorithm exists additional curiosity stdalgorithmsort work apparently expects weak order predicate strict partial order full credit feep irc figuring part hacking compiler graph theory world help u endeavor get compiler actually compile file onebyone currently dmd compiles source code roughly following order read source file module given command line memory parse loaded module load imported module parse perform first semantic pas module perform second semantic pas module perform third semantic pas module perform inlining yes dmd inlines frontend manipulating language ast backend module generate code write object file module link clearly unsuitable u want able perform many step possible one file time fortunately coax compiler relatively simple change instead processing file read group time go motion compile repeat wish could say got compilation step work serially unfortunately managed serialize code generation attempt ended linking error involving template instantiation area compiler everyone agrees become unordinarily messy theory compiler attempting place template instantiation object file whose module already compiled theory allinst switch supposed alleviate emitting template instantiation every module instantiates template rather however currently appears bit broken still third semantic pas work serially test far take significant part compilation time still win u part forking time getting meat subject actually making use fork snapshotting recall flattened dependency graph part corresponding snapshot look like one rectangle one snapshot compilation order righttoleft note compilation order reverse topological order get back bit snapshot except first hold result compiling one module plus module fork cow memory allows snapshot share memory page previous module thus consuming extra ram though real result vary bit due fragmentation going split design three part separate fork driver program handle module dependency decides time recompile file need recompiled order forkserver compiler process communicates fork driver owner snapshot fork process process fork server change rewinding exactly one fork server ie process reading command driver time snapshot fork process implementationwise goal keep communication channel open driver program sends command like compile file rewind ensure main instance crash even face segmentation fault ice compiler code reasonably manage resource clean old snapshot necessary command driver program send would compile next group file reply successfailure create snapshot rewind previouslycreated snapshot finish compilation file compiled far ie emit machine code link optimization upon closer examination combine first two command one create snapshot automatically compiling new file group since need fork order snapshot compiling file group anyway use fork backup case compilation error crash case fork promoted current forkserver instead becoming snapshot also need channel snapshot communicate forkserver simple posix pipe brings lifetime compiler process fork following hmm looked le messy head might find implementation tried comment well easier follow instead note quitting one thing may notice chart explicit quit command quit signal implicit side pipe closed straightforward case forkserver reading driver get interesting case snapshot snapshot implicitly keep open file descriptor snapshot necessary rewinding snapshot cause promoted current forkserver said snapshot able rewind one ancestor fork server exit immediate parent snapshot remains zero process end control channel cause said snapshot exit however exit also close file read end immediate parent control channel well creates dominolike chain reaction snapshot cause exit turn whatever snapshot currently promoted forkserver rewinding snapshot case driver closed control connection fun part putting together one final piece missing program drive forkserver tell compile driver need collect dependency program compiled flatten sorted list component start fork server control forkserver recompile part program change dependency note dependency discovery need happen separate step compilation compilation order two reverse discovering dependency must visit compiled file toptobottom ie program entry point lowest dependency order snapshot work part dependent file may read dependees saved snapshot together main loop driver pretty simple put context forkserver flowchart hopefully clarify everything worth let find compilation take bit longer video using debug dmd build time saving spectacular still significant would even significant pesky template try check dmdforker branch dmd github fork caveat tested work pair read literally two nontrivial program aside problem serializing code generation mentioned inlining ctfe another troublesome combination unlike sane compiler dmd inlining implemented frontend ie semantic ast normally inlining happens ctfe executed longer true processing module turn problem inliner worry making sure ast remains wellformed done transformation care good enough backend understand sufficiently turn machine code workarounds use inline use le ctfe annotate troublesome function pragma inline false change topology module dependency handled dependency new module work sense cause compiled time importing module new backward dependency module incidentally already compiled cause problem change causing forward dependency graph however break compilation may see module foo file food specified twice command line restart server rebuild graph case driver dmdforker also know change module outside initial dependency graph think program date anticipated question q affect integrity compilation process question multifaceted false cache hit ie compiler recompiling code using stale code instead impossible long driver dependency graph uptodate compiler even know file name file compiled yet even guess traversing dependency graph bottomup change edge within dependency graph cause wasted work error see caveat never wrong result get error change dependency graph would caused dependency incorrectly included snapshot addition new node file dependency graph cause current driver implementation see change rebuilds following addition manifest driver claiming program uptodate might said run weird error way plus inlining issue mentioned compiler code base really designed compile file one time though new switch impose many similar constraint ymmv q bit much trouble save second compile yes idea sitting decided go implementing given opportunity technique might useful truly larger project though might applicable compiler process compilation q done precompiled header around long idea using fork snapshot new seen used goal speeding compilation exist debugger capable snapshotting reverse execution like mozilla rr however fork require special permission dependency portable faster q next well assuming interest continue hack weekend project compiler patch could potentially upstreamed dmd thus making forkserver builtin option protocol simple even use interactively build tool could use well dub great candidate already know dependency graph dub package could treat package component sure would nice fix code generation work perfile would also allow greatly speeding optimization take lot time release build possible detect change dependency graph automatically rebuild necessary thus avoiding need manually restart fork driver happens direct analogue fork window would seem make window port however window support linux subsystem also mysterious rtlcloneuserprocess function seems much fork would perhaps impossible thanks reading acknowledgement discus article reddit hacker news forum comment section
66,Lobsters,d,D programming,Implementing Rust’s std::sync::Mutex in D,https://atilanevesoncode.wordpress.com/2018/11/06/implementing-rusts-stdsyncmutex-in-d/,implementing rust std sync mutex,http githubcomatilanevesfearless one project std sync mutex atomic operation concurrency part rust book std sync arc nogc stdconcurrency http githubcomatilanevesfearless like,tl dr http githubcomatilanevesfearless first time encountered mutex c puzzled made sense locking one protect data way indicate data protected certain mutex naming convention seemed like recipe disaster course hardly written code rust fact one project learn basic language time spent enough marvel std sync mutex last made sense access variable go mutex api convention needed course rust tradition said access safe unsurprisingly made slightly jealous shared keyword protects programmer inadvertently accessing shared state unsafe manner mostly atomic operation typically take pointer shared larger object ie userdefined structs usually dealt locking mutex casting away shared using object threadlocal work tedious errorprone certainly safe since imitation highest form flattery decided shamelessly copy much possible idea behind rust mutex rust make api safe via borrow checker however sortofstillexperimental similar try achieve set use new functionality try devise safe way avoid current practice byom bring mutex started reading concurrency part rust book helpful even explains implementation detail fact borrow return smart pointer instead wrapped type copied started thinking way use scope emulate rust borrow checker idea semantics enable safe usage fail compile unsafe code pragmatism key initially confused std sync mutex nearly always used std sync arc took writing bug realise shared data never allocated stack obvious retrospect somehow failed realise since rust markandsweep gc real option use reference counting heapallocated shared data realisation led another choice reference counting simply using gcallocated memory api reflects rc version even nogc api force initialisation userdefined type happen passing parameter constructor type passing extant object safe reference may exist program data race could occur rust guarantee compiletime mutable reference exist hence restriction type without mutable indirection restriction lifted made possible world class static reflection capability api also enforces type shared point using library type even le point making user type shared time although actor model message passing library stdconcurrency none function safe also realised would trivial write deadlock sending shared data mutex held another thread fix issue library wrote safe version concurrency primitive send function check see mutex locked actually passing compound mutex type named exclusive library another thread execution hard understand ended reading proposal several time help current implementation match document end however result seems work http githubcomatilanevesfearless possible due bug fearless programmer break safety extent knowledge brings safe concurrent code love concurrency expert could try poke hole library fix like like loading related
67,Lobsters,d,D programming,The D Language Front-End Finally Merged Into GCC 9,https://www.phoronix.com/scan.php?page=news_item&px=GCC-9-Merges-D-Language,language frontend finally merged gcc,long sought approved adding frontend renewed push gcc gcc feature development ending november gdc wikipedia dlangorg,gnu compiler collection gcc new language frontend language support finally merged language support gcc long sought past two year going several revision back june gcc steering committee approved adding frontend taken year get code adequate shape merging last month renewed push gcc sunday evening frontend related code finally merged mainline gcc great timing gcc feature development ending november gcc frontend delayed would pushed gcc code merged gdc including libphobos library runtime library test suite adding support touch three thousand file test suite case line code yes better part million new line frontend long available gdc gnu compiler history dating back around unfamiliar curious syntax find various code snippet wikipedia dlangorg gcc initial stable compiler release gdc support due release around end
68,Lobsters,d,D programming,Interfacing D with C: Arrays Part 1,https://dlang.org/blog/2018/10/17/interfacing-d-with-c-arrays-part-1/,interfacing c array part,part ongoing series regular user forum array declaration definitc try online read declaration right left property type definitc rundlangio give go default initialization value basic type explicit array initialization used initialization used initialize instance actually make distinction array function used steven schveighoffer excellent array article try online gc enemy people try online time blog dance,post part ongoing series potential issue might appear interfacing c avoid interacting c apis almost given array going pop one way another perhaps often string subject future article c series although array implemented manner directly compatible c fundamental building block make compatibility two relatively painless long difference forgotten article first exploring difference using c api sometimes necessary translate existing code c new program benefit existing example using c api anyone porting program c us api would well keep initial port close original possible basis starting look declaration initialization syntax language translate subsequent post series cover multidimensional array anatomy array passing array receiving c array c function gc fit picture original concept covering topic much smaller scope intent brush boring detail assume reader would know enough basic c derive gave tutorial presentation group among one person experience c also become aware regular user forum never touched line c covering lot ground otherwise would hence twopart article morphed least three urge much said ground old hat get complacent skimming page comfortable experience c apt none obscure pitfall describe array declaration let start simple declaration onedimensional array int declaration allocates enough memory stack hold three int value value stored contiguously memory one right may may initialized depending declared global variable static local variable default initialized following c program demonstrates definitc include stdioh global also declared static int void main int argc char argv static int static local int nonstatic local printf one printf two printf three print one two three value happened lying around memory location equivalent declaration int try online already find first gotcha general rule thumb c code pasted source file either work c fail compile long c array declaration syntax fell former category legal alternative syntax since deprecated subsequently removed language meaning int cause compiler scold error instead cstyle syntax use dstyle int may seem arbitrary restriction really core consistency couple different level one read declaration right left declaration everything flow right left order say array three integer true cstyle declaration another type actually int consider following pointer declaration int type int c would pointer would simply int type declaration left symbol right consider int int two different syntax array declaration one split type like infinitive set stage production inconsistent potentially confusing code making cstyle syntax illegal consistency enforced code readability key component maintainability another difference element default initialized matter declared module scope local scope static matter unless compiler told otherwise variable always default initialized predefined value specified init property type array element initialized init property element type happens intinit translate definitc see open rundlangio give go translating c default initialization business subtle gotcha consider innocently contrived c snippet static variable default initialized c static float vertex somefuncthatexpectsinitedvert vertex direct translation straight produce expected result floatinit floatnan translating two language always aware c variable explicitly initialized expected initialized default initialization value basic type failure account subtlety may well lead debugging session hairpulling variety default initialization easily disabled void declaration particularly useful array going loaded value read contain element init value useful anything marker uninitialized variable float matrix void setidentity matrix side note purpose default initialization provide convenient default value make uninitialized variable stand fact may come appreciate future debugging session common mistake assume type like float char number floatnan invalid initializers oddball outlier value great marker uninitialized memory useful much else integer type bool break pattern type entire range value potential meaning single value universally shout hey uninitialized integer bool variable often left default initializer since false frequently value one would pick explicit initialization type floating point character value however generally explicitly initialized assigned soon possible explicit array initialization c allows array explicitly initialized different way int int int int int see element initialized sequentially constant value initializer list fewer value list array element remaining element initialized seen array length omitted declaration array take length initializer list designated initializers allow specific element initialized index value pair index list initialized length omitted declaration designated initializer used array length based highest index initializer element unlisted index initialized seen initializers supposed longer array gcc give warning initializes threeelement array first three initializers list ignoring rest note possible mix designated nondesignated syntax single initializer int value without designation applied sequential order normal designated initializer immediately preceding becomes value next index element initialized go index normal since first two value list next come designator corresponding value list initialized next come designator skipped initialized finally lack designator immediately follows becomes value element end initialized length element also note designated array initializers added c c compiler version either support syntax require special command line flag enable probably something encounter much wild still useful know translating open door gotchas thankfully first one compiler error cause heisenbugs road int wrong int right array initializers array literal syntax used pas anonymous array function writeln curious declaration wrong produce following compiler error error struct valid initializer int syntax used struct initialization confused struct literal also used initialize struct instance next surprise come translation int int actually produce compiler error error mismatched array length give first take look translation int int c code difference fixedlength threeelement array allocated stack one case general rule thumb pasting c code source module break unlike c actually make distinction array type int int former like c fixedlength array commonly referred static array latter unlike c dynamiclength array commonly referred dynamic array slice length grow shrink needed initializers static array must length array simply allow initializers shorter declared array length dynamic array take length initializers initialized three element appended moreover initializer required dynamic array c int foo illegal length omitted declaration initializer present gcc say error array size missing illegalc int illegalc int legald legald legald empty array memory allocated element element added via append operator memory dynamic array allocated point declaration explicit initializer provided initializer present memory allocated first element appended default dynamic array memory allocated gc heap though compiler may determine safe allocate stack optimization space element needed initialized order reduce need future allocation reserve function used allocate large block one go without initializing element appended element go preallocated slot none remain next append trigger new allocation steven schveighoffer excellent array article go detail also describes array feature touch next part often translating declaration like difference fixedlength stackallocated c array dynamiclength gcallocated array going matter one iota one case matter array declared inside function marked nogc nogc void main int try online compiler letting get away error array literal nogc function main may cause gc allocation error triggered array static since allocated stack literal element shoved right new c programmer coming first time tend reach nogc almost go nature something bump eventually come realization gc enemy people wrap big paragraph designated array initializers c pull double duty also support designated array initializers different syntax int int int try online work static dynamic array following rule producing initialization value c main takeaway section distinction static dynamic array c static array allocated stack dynamic array allocated gc heap uninitialized static array default initialized init property array element dynamic array explicitly initialized take length initializer dynamic array explicitly initialized nogc scope uninitialized dynamic array empty time blog dance lot word preceding section originally intended write array declaration initialization still quite bit say array next post look multidimensional array anatomy array mean people say c array decay pointer last two topic set stage part three dig art passing c array across language divide
71,Lobsters,d,D programming,Using D Features to Reimplement Inheritance and Polymorphism,https://theartofmachinery.com/2018/08/13/inheritance_and_polymorphism_2.html,using feature reimplement inheritance polymorphism,inheritance polymorphism work compiled language used trick real code template mixins template mixins statement also used code place compiletime brainfuck compiler like c equivalent previous post,month ago showed inheritance polymorphism work compiled language reimplementing basic structs function pointer wrote code could translated directly plain old c post show take advantage feature make diy inheritance bit ergonomic use although used trick real code honestly writing think neat help explain highlevel feature implemented using language alias original version code run command inherited commmand base class including command instance first member run command still considered completely different type meant explicit typecasting needed every time run instance polymorphically used command type system actually allows declaring struct subtype another struct even primitive type using feature called simple example work struct base int x struct derived add instance base member like base base time declare member used subtyping alias base void foo base b void main derived derived inherits member base dx derived instance used base instance expected foo code work way code previous blog post alias tell type system allows u work type system le typecasting example showed derived instance passed value base instance passing ref also work unfortunately version implicitly convert derived base maybe implemented future example alias used implement slightly realistic inheritance import io stdstdio struct animal struct vtable void function animal instance greet immutable vtable vtable void greet vtablegreet struct penguin private static immutable animalvtable vtable greet greetimpl auto base animal vtable alias base public string name string name pure thisname name static void greetimpl animal instance still need one typecast type system ca nt guarantee okay auto penguin cast penguin instance iowritef penguin swimn penguinname void main auto p penguin paul p inherits member animal pgreet passed function work animal instance dothings p void dothings ref animal agreet unlike code previous blog post version us vtable like polymorphic inheritance normal compiled language explained previous post every penguin instance use list function pointer virtual function instead repeating function pointer every instance one list function pointer shared across penguin instance ie list static member vtable realworld compiled oop language work template mixins implemented another animal subtype add exactly vtable base member boilerplate penguin struct snake bit exactly private static immutable animalvtable vtable greet greetimpl auto base animal vtable alias base public static void greetimpl animal instance iowriteln unfriendly snake go away another feature dumping kind boilerplate code thing template mixins mixin template deriveanimal private static immutable animalvtable vtable greet greetimpl auto base animal vtable alias base struct snake mixin deriveanimal static void greetimpl animal instance iowriteln unfriendly snake go away actually template mixins take parameter possible create generic derive mixin inherits struct defines vtable struct template mixins inject kind declaration including template function derive mixin even handle complex thing like typecast animal subtype way mixin statement also used code place like hygienic version c preprocessor used also compiletime brainfuck compiler opdispatch highly redundant wrapper code inside definition animal void greet vtablegreet added another virtual method add another wrapper void eat food food vtableeat food opdispatch provides way automatically add member struct opdispatch defined struct time compiler fails find member try opdispatch template function word fallback member lookup fallback fully generic return vtablemember args effectively fill virtual function dispatcher u auto opdispatch string membername args auto ref args args mixin return vtable membername args downside opdispatch fails reason compiler give member lookup get generic property foo type confusing foo actually valid virtual member called argument wrong type something opdispatch need good error handling eg static assert static foreach alternative use newer feature static foreach powerful tool create declaration inside struct place using loop directly read list member vtable definition using compiletime reflection import stdtraits fieldnametuple static foreach member fieldnametuple vtable mixin auto member args auto ref args args return vtable member args advantage case explicitly creating struct member compiler distinguish member exist member exists used properly like c equivalent said basically tourdeforce way improve code previous post however original motivation blog post people asking trick used implement polymorphic inheritance bare metal code finish saying stuff work betterc code none requires extra runtime support code post implement kind thing previous post expressed compact le errorprone way
72,Lobsters,d,D programming,Compiling D -> WebAssembly with LDC,https://wiki.dlang.org/Generating_WebAssembly_with_LDC,compiling webassembly ldc,official prebuilt release package,starting ldc support compiling linking directly webassembly page show get started building webassembly let generate wasm file code wasmd extern c disable mangling double add double double b return b seems required entry point void start build wasmwasm betterc wasmd case ldc error eg unsupported linkinternally try official prebuilt release package test html page let test little html page loading invoking webassembly via javascript generate html file directory wasm file following content html head script const request new xmlhttprequest requestopen get wasmwasm requestresponsetype arraybuffer requestonload consolelog response received const byte requestresponse const importobject webassemblyinstantiate byte importobject result consolelog instantiated const export resultinstance finally call add function implemented const r exportsadd consolelog r r requestsend consolelog request sent script head body test page body html note fetch nt work file local filesystem file xmlhttprequest firefox chrome though iirc open html page javascript console show request sent response received instantiated r calling external function minimal example call one direction javascript webassembly call external function wasmd extern c disable mangling void callback double double b double c double add double double b const c b callback b c return c void start add lallowundefined linker flag ldc command line otherwise lld refuse link due undefined callback implement callback function javascript specify importobjectenv const callback b c consolelog callback b c const importobject env callback log show request sent response received instantiated callback r example
73,Lobsters,d,D programming,Compiler Explorer (think CodePen for C(++)/D/Go/Rust/Swift/Haskell disassembly),https://gcc.godbolt.org/,compiler explorer think codepen c dgorustswifthaskell disassembly,,
74,Lobsters,d,D programming,How an Engineering Company Chose to Migrate to D,https://dlang.org/blog/2018/06/20/how-an-engineering-company-chose-to-migrate-to-d/,engineering company chose migrate,early acquaintance noweb using bison flex brought page present version decorated homepage programming professionally sarc dutch engineering company iso standard system computer aided design ship hull using qt company outlives programming language last archived gnu pascal changing odds codedlangorg found pegged enjoyed writing excellent documentation language tour try online language specification peg phenomenon called leftrecursion support kind leftrecursion longest match alternation case insensitive literal method browsing syntax tree logging parsing process dconf berlin watch extra bit presented lunch time language competition founder sarc option translation gnu c offer nested function move away c due unsafe feature free pascal ada score although exists selecting winner expressive challenge solution ada solution make difference writing compatibility library postprocessed dfmt string userdefined attribute uda binary compatible file io detecting bit involved way forward transpiler,bastiaan veelo lead developer specialised program computer aided geometric design ship hull called fairway company sarc netherlands imagine littleknown programming language enjoy programming free time know ready prime time dream using work everyday story made dream like come true early acquaintance back google yet common verb web search parsing c reason writing report assignment derailed writing syntax highlighter noweb using bison flex found firsthand c easy parse web search brought page present version overview programming language following statement hooked ever since lexical analyzer parser totally independent semantic analyzer mean easy write simple tool manipulate source perfectly without build full compiler also mean source code transmitted tokenized form specialized application genius thought someone know representative pragmatic professionalism still radiates community combine unpretentious flair make pleasant around funny quote decorated homepage many year great need another programming segfault nevertheless many opportunity use language largely remained sitting fence observing development programming professionally mostly academic programming experience started programming professionally sarc dutch engineering company serving maritime industry since early developing software ship design onboard loading calculation today amount roughly half million line code think success partly attributed choice programming language extended pascal iso standard one many proprietary extension pascal extended pascal great improvement iso pascal compiler prospero software england fast well documented language small enough syntax appropriately verbose make engineering professional quickly productive programming personally though spent time programming c modernizing system computer aided design ship hull using qt company outlives programming language although selecting iso standard favor proprietary pascal dialect seemed wise time apparent company outlived language prospero development software ltd officially dissolved year ago still former director tony hetherington continued giving support many year close year old longer reached website gone last archived gnu pascal also support iso project stopped moving long ago lost synchrony gcc although immediate crisis clear something need happen sometime company want continue activity coming decade changing odds couple year ago secretly started playing fantasy replacing extended pascal even though syntax somewhat different pascal share least four important similarity support nested function boundary checking module compilation speed addition many trait make language attractive engineer good focus performance numerics garbage collection dynamic array easy parallelization understandable template contract programming memory safety unit test even wysiwyg string formatted numeral language feature encourage experimentation resonates well engineer wondered could highlight significance employer show attractive language switch thought could make compelling case could write parser would take extended pascal source transpile source least would fun trying went codedlangorg see alternative flex bison found pegged instantly fun began pegged combine functionality flex bison one incredibly easy use package creator philippe sigaud obviously enjoyed writing excellent documentation nowadays pegged part language tour try online without install thing beauty grammar extended pascal language specification map almost linearly peg pegged generates parser make heavy use generic programming capability compiletime function evaluation generate parser compile time want however smooth sailing along testing suddenly found tested well learned hard way phenomenon called leftrecursion peg parser typically break extended pascal grammar leftrecursive several way consequently spent many evening weekend researching parsing theory eventually managed extend pegged support kind leftrecursion one thing came another added longest match alternation case insensitive literal tohtml method dynamically browsing syntax tree tracer logging parsing process obviously fun importantly demonstrating programming language accessible enough naval architect understand people code expand nontrivial way icing cake came asked present experience dconf berlin watch extra bit presented lunch time livestream audience time able automatically translate following trivial example program hello output begin writeln hello world end import stdstdio program name hello void main string args writeln hello world language competition come far founder sarc agreed time investigate merit various alternative programming language would thorough objective comparison based trial translation comprehensive set language feature due amount manual labor requires drastically prune space programming language initial review round note present declare programming language best industry looking language allows efficient transition extended pascal without interrupting business enables u take advantage modern insight tool initial review round looked general language characteristic highlight fell sieve performance important u consider interpreted language c use one component software written ground feel option translation favorable long compile time serious hindrance productivity many way one shoot one self foot require expert naval architect also become expert c nowadays whenever publicly evaluated younger language go rust often brought alternative need go indepth comparison language rust go lack one feature rely heavily nested function access variable enclosing scope solution eliminating nested function like bringing global scope passing extra variable breaking file smaller module find unattractive would complicate automated translation like preserve structure style current code gnu c offer nested function nonstandard extension predicted many move away c due unsafe feature initial pruning three language remained shortlist free pascal ada basis detailed comparison wrote fifteen small program used specific feature extended pascal important current code base translated program language shortlist kept simple score board well feature represented language feature supported implemented lack feature worked around came evaluation test free pascal ada array beginning arbitrary index set schema type type custom initial value class cast protection use dangling pointer thread safe memory de allocation calling window api forwarding window callback nested function speed calculation calling procedure written assembly calling procedure dll binary compatibility string binary compatible file io score free pascal candidate negative score ada position middle achieves almost perfect score effortlessly though talk technical challenge later free pascal like fully open source written extending language filling gap theoretically possible although deficiency could certainly resolved way others would quite complicated andor unlikely accepted upstream also estimated productivity language free pascal scored high closest used despite dissimilar syntax scored high expressiveness flexibility ada scored lowest rigidity extra work programmer put importantly cast conversion ada verbose pascal disliked u somewhat obscure essence piece code try express frequently code became verbose cryptic unanimously disliked third estimated future prospect advantage language could bring table although free pascal active community expected see great potential growth ada renowned support writing reliable code although monopoly field come cost requires real effort dynamic open community support scriptlike productivity high performance includes various feature writing reliable software approaching ada much lower cost offer unique advanced feature wonder accomplished finally estimated effort translation although free pascal similar extended pascal missing feature pose real problem would require high degree manual translation rewriting although exists work partially case fully support extended pascal ada frequently requires additional code casting correct type pulling package instantiating generic type adding pragma splitting putlines etc writing extending reliable transpiler ada would difficult selecting winner gave away winner title landed conclusion follows ada first language dropped really felt extra work programmer put brake productivity creativity although barely played role evaluation illustrative difference ada equivalent expressive challenge solution concise expressive ada solution hardly expressive consists line want write read also secondary importance difficult ignore difference community surrounding language ada case adacore support problem demanding annual fivefigure subscription fee although akin current language free pascal mainly dropped due porting challenge estimation potential lower future outlook le optimistic choose free pascal would basically invest lot effort arrive technological solution felt would lower quality currently saw dream come true clap table company founder decided commit effort bringing twentyfive year worth extended pascal code make difference short experience feature present language powerful enough feature implemented library translating sample program hand really helped focus replicating functionality leaving translation process later concern led writing compatibility library type function vital conversion equivalent known parser done implement code generation follows another example currently translates automatically executes identically iterates fixed length array running inclusive fill value print memory footprint writes binary file program arraybase input output type array integer var n integer f bindable file begin n n n writeln size byte sizeof openwrite f arraydat begin write f close f end end transpiled say dascal postprocessed dfmt fix formatting import epcompat import stdstdio program name arraybase alias staticarray int int n bindable f void main string args n n n n n writeln size byte asizeof openwrite f arraydat epcompatwrite f close f course mean idiomatic fact recognizable readable nice especially colleague go unusual transition way notice code comment preserved one verynicetohave feature binary file compatibility fact may killer feature without might victorious case whenever persistent data structure extended software make sure still read convert structure prior format way client pull old design archive run current software still work without user even aware conversion occurs possibly multiple step give ability attractive easy get main difficulty difference string represented prospero implementation extended pascal memory file presented challenge preserve binary compatibility file io data structure contain string member string prospero extended pascal string implemented schema type parameterized type used following way type string var string procedure foo string defines alias string type discriminated capacity character discriminated string variable like passed function procedure take undiscriminated string argument like foo thereby work string capacity memory laid sequence char followed ushort encodes length string say encodes shorter string padded capacity ushort actually contains length padding way pointer string passed c function content string occupy full capacity padding length double terminating c string first thought mimic data representation template would require procedure like foo turned template well would escalate horribly template bloat problem multiple string argument argument ordering would complicate translation besides schema type also discriminated run time translate template could sort inheritance scheme solution really instance class live heap string embedded struct would pointer instead char array ushort binary layout actually relevant file stroke insight realized must userdefined attribute uda exist annotate string correct capacity file io use native string everywhere genuinely must best possible translation solves function argument issue annotation done instance struct like struct epstring ushort capacity pascal snippet translates like epstring struct string alias epstring string void foo string notice alias translated slightly convoluted struct instead normal alias would looked like epstring alias string code although compiles way retrieve uda case plain alias introduce symbol hasuda typeof epstring would equivalent hasuda string epstring evaluates false using struct symbol typeof give hasuda epstring evaluates true example one side effect learn accept taking slice string produce result extended pascal string index start extended pascal strategy eliminate slice source replace call standard substr function implement index correction finding string slice accomplished switch transpiler make insert static test slice taken string abort compilation array transpiled custom array type handle slice index compatibly extended pascal binary compatible file io write structs file handle embedded epstring annotated string specially use compiletime introspection overload tofile act structs shown left handling aliased string clarity well shortstring legacy string type yet different binary format void tofile file f struct import stdtraits static hasindirections flockingbinarywriterput else todo union foreach field fieldnametuple member tofile method call static hasmember typeof trait getmember field tofile trait compiles trait getmember field tofile f trait getmember field tofile f member struct recurse else static typeof trait getmember field struct tofile trait getmember field f treat string specially else static typeof trait getmember field string look uda member string static hasuda trait getmember field epstring enum capacity getudas trait getmember field epstring capacity static assert capacity writeasepstring trait getmember field capacity f else static assert false need epstring n front fullyqualifiedname field write data member else static isfunction trait getmember field flockingbinarywriterput trait getmember field time writing still work union used translation variant record including considering use one seven existing library solution currently detecting union bit involved also complication determination size union largest variant contains string version variant may largest string slice probably work around adding dummy variant fixed size array byte force size union compatible extended pascal reason scored mere file format compatibility amazing allows though may able automatically award perfect score retroactively hand probably easiest add dummy variant pascal source place matter done way forward obviously long term planning taken year grow possibly take year probably longer migrate unless others turn boat u please contribute row ship dland still regular duty attend colleague continue develop extended pascal usual transpiler able translate almost make switch overnight long run trust u decade come
75,Lobsters,d,D programming,BetterC: Converting make.c to D,https://dlang.org/blog/2018/06/11/dasbetterc-converting-make-c-to-d/,betterc converting makec,walter bright digital mar empire wargame century third series betterc mode dmd compiler front end datalight c compiler make manual source code spoiler alert completed conversion step step c version replacing relevant declaration line declaration replaced version condition predefined version linkage attribute debug printf preprocessor directive conditional compilation statement manifest constant manifest constant template function macro replaced function obsolete platform removed storage class attribute declaration keyword multiple pointer declaration use instead c array declaration array declaration declaration syntax applied entire block declaration attribute forward reference declaration wildcard expansion function parameter declared array syntax expands nothing argument function global searchreplace c arrow operator conditional compilation directive lack function prototype keyword line ending comment unused code line block nesting block comment replace condition decay array pointer use cstyle string implicitly cast replace used transfer function replaced array property replace mutable one stack allocated array string literal replaces c property old version window manc make manual page code summary future action forum,walter bright bdfl programming language founder digital mar decade experience implementing compiler interpreter multiple language including zortech c first native c compiler also created empire wargame century post third series betterc mode betterc aka dasbetterc way upgrade existing c project incremental manner article show stepbystep process converting nontrivial c project deal common issue crop dmd compiler front end already converted large project hard see involved needed find smaller modest project easily understood entirety yet contrived example old make program wrote datalight c compiler early came mind real implementation classic make program constant use since early written prestandard c ported system system remarkably compact line code including comment still regular use today make manual source code executable size makeexe byte last modification date aug evil plan minimize diffs c version program behave differently far easier figure source difference attempt made fix improve c code translation also service attempt made refactor code see duplicate behavior c program exactly much possible bug whatever necessary needed service completed time fix refactor clean etc spoiler alert completed conversion resulting executable byte quite comparable original analyzed increment size likely due instantiation newobj template macro c version change dmc runtime library since step step difference c version line third look like lot hope convince nearly trivial include file replaced corresponding import replacing include stdioh import corestdcstdio unfortunately include file specific digital mar c version exist need fix let stop project simply included relevant declaration line see documentation import declaration replaced version window see documentation version condition predefined version extern c mark remainder declaration file compatible c see documentation linkage attribute global searchreplace change us macro debug printf general ifdef debug preprocessor directive replaced debug conditional compilation see documentation debug statement delete old c macro definition ifdef debug define printf define b printf b define b c printf b c else define define b define b c endif replace usage debug statement returning x lxn datetime debug printf returning x lxn datetime true false null macro searchreplaced true false null esc macro replaced manifest constant see documentation manifest constant define esc enum esc newobj macro replaced template function define newobj type type memcalloc sizeof type type newobj type return cast type memcalloc typesizeof filenamecmp macro replaced function support obsolete platform removed global variable placed default threadlocal storage tl since make singlethreaded program inserted global storage gshared storage class see documentation gshared attribute int cmdlinelen gshared int cmdlinelen separate struct tag name space typedefs necessary alias used instead see documentation alias declaration also struct omitted variable declaration typedef struct filenode char name genext char dblcln char expanding timet time filelist dep struct rule frule struct filenode next filenode struct filenode char name char genext char dblcln char expanding timet time filelist dep rule frule filenode next alias filenode filenode macro keyword use macro instead grouping together multiple pointer declaration allowed use instead char name text part type applies symbol declaration char name text c array declaration transformed array declaration see documentation declaration syntax char name genext char name char genext static meaning module scope static globals c equivalent private modulescope variable really matter module never imported anywhere still need gshared applied entire block declaration see documentation static attribute static ignoreerrors false static execute true static gag false static touchem false static debug false static listlines false static usebuiltin true static print false gshared bool ignoreerrors false bool execute true bool gag false bool touchem false bool xdebug false bool listlines false bool usebuiltin true bool print false forward reference declaration function necessary function defined module called point module definition wildcard expansion much meaning make program function parameter declared array syntax pointer reality declared pointer int cdecl main int argc char argv int main int argc char argv meminit expands nothing previously removed macro c code play fast loose argument function demand function prototype respected void cmderr const char format const char arg cmderr ca nt expand response filen cmderr ca nt expand response filen null global searchreplace c arrow operator dot operator member access uniform replace conditional compilation directive version termcode endif version termcode lack function prototype show age code requires proper prototype doswitch p char p void doswitch char p debug keyword rename xdebug n line ending c multiline string literal necessary comment unused code using nesting block comment see documentation line block nesting block comment static replace many us see documentation static condition decay array pointer automatic use ptr utime name timep utime name timepptr use const cstyle string derived string literal allow taking mutable pointer string literal see documentation const immutable linelist readmakefile char makefile linelist rl linelist readmakefile const char makefile linelist rl void implicitly cast char make explicit buf memrealloc buf bufmax buf cast char memrealloc buf bufmax replace unsigned uint inout used transfer constness function argument return value parameter const return value parameter const neither return value see documentation inout function char skipspace p inout char skipspace inout char p arraysize replaced length property array see documentation array property usecommand inarray p builtin arraysize builtin usecommand inarray p builtinptr builtinlength string literal immutable necessary replace mutable one stack allocated array see documentation string literal static char envname cmdline char envname cmdline sizeof replaces c sizeof see documentation sizeof property q char memcalloc sizeof envname len q cast char memcalloc envnamesizeof len care old version window replace ancient c usage char void wrap change see bad set timer doubt took hour including debugging couple error made process leaf file manc used open browser make manual page man switch given fortunately already ported copy code building make easy even need makefile maked dmand release betterc summary stuck evil plan translating nontrivial old school c program thereby able quickly get working correctly equivalent executable generated issue encountered typical easily dealt replacement include import lack version include file global searchreplace thing like replacement preprocessor macro manifest constant simple template function version declaration debug declaration handling identifier keywords replacement c style declaration pointer array unnecessary forward reference stringent typing enforcement array handling replacing c basic type type none following necessary reorganizing code changing data control structure changing flow program changing program work changing memory management future dasbetterc lot modern programming feature available improve code action let u know forum dasbetterc project coming along
76,Lobsters,d,D programming,Driving Continuous Improvement in D,https://dlang.org/blog/2018/06/02/driving-continuous-improvement-in-d/,driving continuous improvement,blog previous article dscanner dscanner continuous improvement ratcheting quality,jack stouffer member phobos team contributor dlangorg check writing blog previous article went technique use standard library aka phobos develop wide variety testing mechanism also briefly mentioned style checker dscanner article detail use dscanner prevent style documentation best practice regression code none covered standard unit test keeping level quality software project neverending battle bad practice shortsighted design decision make way code time whether poor oversight rushing thing simple code rot three thing phobos test fight entropy first pull request required one thing one thing count one thing subjective example pr fix bug specific piece code also edit documentation function allows phobos reviewer merge documentation change quickly issue bug fix preventing merged vice versa time keep reviewer focused one set change second pr need small ideally le line code changed possible need broken multiple commits smaller change really help reviewer keep best practice mind also fully understanding internalizing new code third continuously improve existing code dscanner among thing official linting tool dscanner example check dscanner provide let take look code contains hardtospot bug following code creates type mimic int allows null state struct nullableint private int value bool isnull int get assert isnull ca nt get null return value void nullify isnull true bool opequals rh equality overloading function isnull rhsisnull return true isnull rhsisnull return false return value rhsvalue bug code code structs default version standard operator overloading function defined user one function provides hash represent value use builtin associative array default version us type field make hash problem nullableint decided instance type null equal illustration bug void main auto nullableint false auto b nullableint false auto c nullableint true auto nullableint true assert b assert b c assert c import coreinternalhash hashof internal hashing function assert chashof dhashof dscanner emit message every time find type defines custom opequals define custom tohash well alerting u bug continuous improvement ratcheting quality dscanner tie continuous improvement philosophy improvement process design made periodic timely manner rather onetime breakthrough large breakthrough change tend pushed back infinitely phrase letting perfect enemy good easily fit continuous delivery rapid release philosophy vastly reduce bug software given enough time using warning dscanner ratchet phobos quality time never used socket wrench ratchet mechanism allows user freely move wrench back forth allows bolt spin wrench move clockwise similarly move quality phobos forward letting ever slip backwards dscanner work follows run dscanner every check one turned file populate black list check dscanner configuration file containing file issued warning repeat current code pass check turned blacklist enabled listofblacklists new pr trigger warning issue detected dscanner file included blacklist thereby keeping status quo quality next ratchet quality making pr fix one issue one file removing blacklist entry configuration way file checked future every new pr time quality issue removed phobos crop example release phobos gone public symbol without example currently using ratchet technique dscanner remove unused variable add const immutable variable modified construction make sure every public symbol documented make sure every symbol phobos documentation code example documentation force every assert error message print case fails make sure exception error caught trycatch block among thing process also added benefit dogfooding dscanner help u find bug know feature would helpful add user perspective project using linting tool part test suite matter time code rot creep
77,Lobsters,d,D programming,Livestream of DConf 2018 in Munich,https://www.youtube.com/watch?v=km5rEBDo2M0,livestream dconf munich,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature,press copyright contact u creator advertise developer term privacy policy safety youtube work test new feature
78,Lobsters,d,D programming,Calling C++ constructors in D,https://forum.dlang.org/thread/kbcdppawjtcdkdtdzwwp@forum.dlang.org,calling c constructor,manu permalink reply,posted atila nevesin reply manupermalinkreplyatila neveson monday april utc manu wrote april atila neve via digitalmarsdannounce digitalmarsdannounce puremagiccom wrote saturday april utc manu wrote april atila neve via digitalmarsdannounce digitalmarsdannounce puremagiccom wrote paste preprocessed code generate c mangled symbol name call wrapper attempted normal mostly constructor pragma mangle move work correctly involved two wrapper one taking value one taking nonconst ref explain move issue interesting sure thought generating wrapper everything tdd fashion tried slapping pragma mangle copy constructor thing worked odd dmd nt try correctly mangle constructor destructors since perfectly callable move constructor signature use exactly hack well move would done value nt quite work since ref const auto auto cause constructed value version instead copy constructor clearly want ref const ref cast const rvalues go byvalue version lvalues copy constructor byvalue constructor pragma mangle whatever c move constructor tinit avoid problem rvalues go c move constructor since definition module probably inlined well thing left enable explicit moving lvalues thing already injecting code user file anyway maybe use enable move ca nt put code different module maybe might later namespace put struct called dpp struct dpp static struct move ptr static auto move ref value ref lvalues apply return move value emit another constructor code user move wrapper wrapperptr call c move constructor bob uncle
79,Lobsters,d,D programming,#include C headers in D code,https://atilanevesoncode.wordpress.com/2018/04/09/include-c-headers-in-d-code/,include c header code,wait happened mean include c killer feature worse better next code happen http githubcomatilanevesdpp like,lead file stdlibdpp include stdioh include stdlibh void main printf hello worldn ptr enum numints auto ints cast int malloc intsizeof numints scope exit free ints foreach int numints ints printf ints ptr ints printf n ptr keen eye notice except two include directive file plain code let build run stdlibdpp stdlib hello world ints ints ints ints wait happened saw file directly include two header c standard library call two function compiled run worked mean argued include c killer feature interfacing existing c c library c remaining use case include relevant header go binding nonsense work fan envied attempt eliminate last reasonable people may disagree use case one would reach c weapon choice reason c became popular upgrading c decision essentially risk wanted work feature compiler wrapper default us dmd compile code configurable option dmd compile code include directive lexer even like give go dpp file upon encountering include directive expands inplace similarly would happen c c compiler differently clang gcc however header file inserted since syntax declaration different language us libclang parse header translates declaration fly trickier sound since c c allow thing valid one piece usability puzzle missing story preprocessor c header file declaration also macro necessary use library intended one try emulate ctfe function sometimes work want sometimes want guarantee way use c preprocessor blasphemy know since worse better redefines macro included header file available use program run c preprocessor result expanding include directive final result regular file compiled dmd next bug fixing c support happy work include vector void main auto v stdvector int vpushback code happen almost forgot http githubcomatilanevesdpp like like loading related
80,Lobsters,d,D programming,Diamond: MVC and template framework,https://github.com/DiamondMVC/Diamond,diamond mvc template framework,diamond programming language http diamondmvcorg keyfeatures goal dependency example view controller model example view controller view controller api model faq http diamondmvcorgfaq syntax guideline http diamondmvcorgdocsviews syntax installing web http diamondmvcorgdownload installing standalone contributing http diamondmvcorgcontribute version branch support,diamond diamond powerful fullstack webframework written programming language diamond used write powerful website webapis standalone template parser website http diamondmvcorg keyfeatures goal provide powerful consistent api api diamond rich feature still powerful performance style consistent high performance without complexity performance diamond high without making api complex use compiletime template parsing template parsed compiletime thus produce little runtime overhead easytouse featurerich template syntax syntax template featurerich easytouse syntax easy create advanced template without complex looking code secure le errorprone api api diamond provide security battle errorprone code enabling code written bugfree enterprise development diamond stable enough enough feature used enterprise commercial work always free opensource diamond always remain free opensource matter framework size popularity little dependency possible le dependency diamond better library dependency database driver etc okay crossplatform always able support platform vibeddmd support natural development feeling using diamond feel natural without annoyance focus developing application rather setting diamond dependency package version description vibed used backend diamond web application vibed optional dependency dmdphobos standard library thus required dependency mysqlnative native wrapper mysql dependency mysql orm ddbc xxx database wrapper lot database system diamond using postgresql sqlite mssql example view layout doctype html head title website title title head body view body html view layout layout route home model home controller homecontroller placeholder title home p hello modelname p controller module controllershomecontroller import diamondcontrollers final class homecontroller tview controller tview tview view super view home httpdefault status defaultaction viewmodel new home world return statussuccess homesetname name httpaction httppost status setname auto name thisgetbyindex string viewmodel new home name return statussuccess model module modelshome final class home private string name public final string name name name property string name return name example view layout doctype html head title website title title head body view body html view layout layout route home model home controller homecontroller placeholder title home p hello modelname p controller view module controllershomecontroller import diamondcontrollers final class homecontroller tview webcontroller tview tview view super view home httpdefault status defaultaction viewmodel new home world return statussuccess homesetname name httpaction httppost status setname string name viewmodel new home name return statussuccess controller api module controllersusercontroller import diamondcontrollers final class usercontroller apicontroller httpclient client super client userupdate httpaction httppost status update usermodel user stuff return statussuccess model module modelshome final class home private string name public final string name name name property string name return name module modelsuser final class user public string name int age faq see http diamondmvcorgfaq syntax guideline see http diamondmvcorgdocsviews syntax installing web see http diamondmvcorgdownload installing standalone supported since contributing see http diamondmvcorgcontribute version branch support diamond support latest minor version including prerelease version version supported working branch deleted anything longer supported earlier version adviced use unless necessary generally backward compatible currently supported version longer supported available release note yet supported master branch
81,Lobsters,d,D programming,std.variant Is Everything Cool About D,https://dlang.org/blog/2018/03/29/std-variant-is-everything-cool-about-d/,stdvariant everything cool,matt kline std visit everything wrong modern c year biggest proponent exploring stdvariant stdvariant variant algebraic algebraic data type sum type alias note universal function call syntax recap problem std visit note cppreferencecom note solution documentation delegate function note check consideration constexpr dlang website mailing list pull request welcome,jared hanson involved community since active contributor since recently joined phobos team devised scheme make look like contributing adding least tag every new pr hold bachelor computer science degree university new brunswick work level support engineer one largest cybersecurity company world recently read great article matt kline std visit everything wrong modern c c skill grown rusty disuse long since left greener pasture curious thing changed absence despite relative unfamiliarity c heard addition librarybased sum type std curiosity mildly piqued news although like many new addition c past decade something year given seemingly sensational title mr kline article wanted see bad std visit get feel well equivalent measure intuition author exaggerating sake interesting article heard oftrepeated criticism c complex inconsistent even biggest proponent think true ergonomics template vastly improved c nevertheless underlying concept dubious std visit could much harder use stdvariantvisit record intuition completely utterly wrong exploring stdvariant continue let quickly introduce stdvariant module module centre around variant type actually sum type like c std variant typesafe container contain value type also know type value currently contains ever implemented typesafe union realize part important akin c std opposed std variant unfortunate c chose use name variant implementation sum type instead c est la vie type used follows import stdvariant variant assert atype typeid int assert float f aget float convert float assert f f assert f rock assert atype typeid string variant b new object variant c b assert c b c b point object b error possible match found variant int luckily stdvariant provide sum type well enter algebraic name algebraic refers algebraic data type one kind sum type another example tuple product type actuality algebraic separate type variant former alias latter take compiletime specified list type value algebraic may take limited whose type list example algebraic int string contain value type int string try assign string value algebraic float bool get error compile time result effectively get inlibrary sum type free pretty darn cool used like alias null typeof null convenience alias option algebraic null option sizet indexof int haystack int needle foreach sizet int n haystack n needle return option sizet return option sizet null int option sizet index aindexof call indexof like method using ufcs assert indexpeek null assert index contain value type null assert index sizet option sizet aindexof assert null peek function take variant runtime argument type compiletime argument return pointer point variant contained value iff variant contains value type otherwise pointer null note made use universal function call syntax call free function indexof member function int addition like c standard library special visit function operates algebraic allows user supply visitor type value algebraic may hold executed iff hold data type runtime moment recap stdvariantvariant equivalent std typesafe container contain value type stdvariantalgebraic equivalent std variant sum type similar find swift haskell rust etc thin wrapper variant restricts type value may contain via compiletime specified list stdvariant provides visit function akin std visit dispatch based type contained value way let talk wrong std visit c make stdvariantvisit much pleasant use leveraging powerful toolbox compiletime introspection code generation feature problem std visit main problem c implementation aside clunkier template syntax metaprogramming arcane convoluted static introspection tool included box get absolute basic std typetraits couple thirdparty solution appropriately horrifying verbose make implementing std visit much difficult also push complexity consumer library make using much difficult well eye bled code mr kline article generates visitor struct provided lambda function template class f struct overload template class class frest struct overload frest overload frest overload frest rest overload frest rest using operator using overload frest operator template class struct overload overload using operator template class f auto makevisitor f f return overload f f point simplified following template class t struct overloaded t using t operator template class t overloaded t overloaded t template class f auto makevisitor f f return overload f f however code still quite ugly though suspect could get used elipses syntax eventually despite massive improvement preceding example hard get right writing hard understand reading write importantly read code like know lot complicated template expansion code generation going hidden behind scene boy oh boy screw something better believe compiler going spit supremely perplexing error back note fun exercise try leaving overload one type contained variant marvel truly cryptic error message compiler print example cppreferencecom showcasing minimal amount work necessary use std visit template class t struct overloaded t using t operator template class t overloaded t overloaded t using vart std variant int long double std string std vector vart vec hello auto v vec std visit overloaded auto arg std cout arg double arg std cout std fixed arg const std string arg std cout std quoted arg v note show article want see example rewritten extra work forced u c make use std visit user stuck rock hard place either write truly stigmatainducing code generate struct necessary overload bite bullet write new struct every time want use std visit neither appealing oneway ticket boilerplate hell fact jump ridiculous hoop write uglylooking boilerplate something simple ridiculous mr kline astutely put rigmarole needed std visit entirely insane better solution typical programmer would implement makevisitor using powerful compiletime type introspection tool code generation ability import stdtraits parameter struct variantvisitor fun fun f fun f thisfs f static foreach fun fun generate different overload opcall f auto opcall parameter fun params return f params auto makevisitor fun fun f return variantvisitor fun f done pain strain bleeding eye line c version granted opinion also much simpler c version write andor read code understand demonstrably smaller number concept however programmer would write code stdvariantvisit take callable struct documentation applies delegate function given algebraic depending held type ensuring type handled visiting function visiting handler passed template parameter list emphasis mine visit accepts delegate function figure one pas contained value based function signature give user fewer option like call antiboilerplate language thing prefers direct method thus visit take compiletime specified list function template argument stdvariantvisit may give user fewer option unlike std visit require painstakingly create new struct overload opcall case waste time writing something like makevisitor also highlight difference two language may sometimes give user fewer option worry though system programming language never completely without option service making life easier get faster safer code combine speed native compilation productivity scripting language hence motto fast code fast stdvariantvisit messing around defining structs callable method unpacking tuples wrangling argument straightforward understandable code algebraic string int bool v rock vvisit string writeln string int n writeln int n bool b writeln bool b puff efficiency completely obviated machinery c requires std visit greatly simplified user life comparison c equivalent template class t struct overloaded t using t operator template class t overloaded t overloaded t std variant std string int bool v c rock std visit overloaded const std string std cout n int n std cout n n bool b std cout b n v note unlike c version error message get accidentally leave function handle one type comprehendable mere mortal check bonus example look similar builtin pattern matching syntax find many upandcoming language take inspiration functional forebear implemented completely user code powerful consideration final point indulge moment like argue strawman c programmer creation article mr kline also mention new constexpr feature added course decade like forestall argument strawman friend cheating use new constexpr simplify code cut makevisitor entirely like example yes could use constexpr token static mr kline explicitly reject using article problem approach make allaround inferior c one method error prone inflexible case need add new type variantalgebraic old code still compile wrong two way uglier complicated passing function visit directly least three version would still blow c water readability consider vvisit arg alias unqual typeof arg remove const shared etc static string writeln string arg else static int writeln int arg else static bool writeln bool arg v c visit auto arg using std decayt decltype arg constexpr std issamev string printf string sn argcstr else constexpr std issamev int printf integer dn arg else constexpr std issamev bool printf bool dn arg v version code would want read understand modify version contest article whet appetite want find visit official dlang website join u mailing list irc freenodenet communitydriven project also always looking people eager jump get hand dirty pull request welcome
83,Lobsters,d,D programming,Advent of D,http://jordi.inversethought.com/blog/advent-of-d/,advent,advent code programming language gem writing every day day mercurial repository content day parsing argument type conversion template constraint day functional programming uniform function call syntax day let try complex arithmetic day reusing familiar tool find duplicate day practice familiar tool day range day structs compiletime regexes day compiletime fun mixin day switch statement day learning range day offline hex coding day want set day offline coding day reusing older code module day generator lambda function delegate day permutation primitive tool day avoiding work clever observation day concurrency finally understand write correctly day string parsing enums final switch day physic problem vector operation day indexable hashable comparable struct day enums final switch complex number day another opcode parsing problem day routine graphsearch problem day formatted read finish advent day parsing argument type conversion template constraint problem statement solution concept c day functional programming uniform function call syntax problem statement solution uniform function call syntax day let try complex arithmetic problem statement solution day reusing familiar tool find duplicate problem statement solution day practice familiar tool problem statement solution day range problem statement solution good taste range depth day structs compiletime regexes problem statement solution good overview topic day compiletime fun mixin problem statement solution introduced september discussion day switch statement problem statement solution good discussion day learning range problem statement solution quick trip standard library day offline hex coding problem statement solution battle wesnoth day want set problem statement solution day offline coding problem statement solution day reusing older code module problem statement solution initial bwlabeln implementation unionfind day familiar c preprocessor macro idiom linux osx conditionally compile particular operating system day generator lambda function delegate problem statement solution example documentation pseudorandom linear congruence generator language spec day permutation primitive tool problem statement solution worth read bug orbit day avoiding work clever observation problem statement solution josephus problem day concurrency finally understand write correctly problem statement solution actor concurrency model message passing day string parsing enums final switch problem statement solution day physic problem vector operation problem statement solution builtin support writing vector instruction avx standard library support day indexable hashable comparable struct problem statement solution dihedral group posix syntax positional argument day enums final switch complex number problem statement solution day another opcode parsing problem problem statement solution day day others already done remarkable job explaining day routine graphsearch problem problem statement solution depthfirst search day formatted read finish advent problem statement solution compiletime version readf concluding remark,wrote advent code programming language first time used earnest every day something substantial fun learned thing along way easy metaprogramming concurrency could write correctly functional programming feel like one arm tied behind back would main programming language c python combination best two power c ease use python put another way c always wanted used sale pitch name lot evident c heritage c successor worthy consideration question people always ask whenever bring faced following set standard rebuttal rust still around bring anything new interesting answer briefly easier learn rust yes still around lively lot interesting idea garbage collector guess gc never noticed never gotten way let speak would like address rebuttal different way seems people would rather learn another new thing right rust lot attention code right seems like rust may solution always wanted safe systemslevel coding take effort work new programming language think people mostly saying care different programming language immediately dismiss spend time learning rust instead posit immediately dismiss nothing else try listen idea many distilled alexandrescu programming language recommend book good reading material computer science even never plan write language reference already dated number way still recommend idea discus also browse gem section tour meantime let show learned using writing every day day took slightly longer day write advent code solution partly stumped little partly around actual christmas wanted spend time family instead writing code writing code would say nearly every day advent code forced look new aspect see solution mercurial repository going go much detail abstract theory concerning solution problem perhaps another time instead focus specific technique learned found useful content day parsing argument type conversion template constraint day functional programming uniform function call syntax day let try complex arithmetic day reusing familiar tool find duplicate day practice familiar tool day range day structs compiletime regexes day compiletime fun mixin day switch statement day learning range day offline hex coding day want set day offline coding day reusing older code module day generator lambda function delegate day permutation primitive tool day avoiding work clever observation day concurrency finally understand write correctly day string parsing enums final switch day physic problem vector operation day indexable hashable comparable struct day enums final switch complex number day another opcode parsing problem day routine graphsearch problem day formatted read finish advent day parsing argument type conversion template constraint problem statement solution day planning bit careful everything around code going carefully parse cli argument produce docstrings error message anything went wrong carefully validate template argument constraint comparable concept c could done day went tried golf solution abandoned boilerplate instead lazily relied getting stack trace runtime compiler error messed see solution kept boilerplate bad though template constraint achieved adding isnumeric numtype check compile time template given template argument correct type isnumeric come import stdtraits also found getopt sufficiently mature standard library handling commandline parsing quite rich python argparse merely sufficient show string input auto opts getopt args inputi input captcha process input optshelpwanted defaultgetoptprinter day aoc optsoptions finally frequent workhorse appeared day stdconv parsing string number single function surprisingly versatile much taking single template argument converting casting one type another know parse string number vice versa also convert numerical type keeping much precision possible reading list associative array literal string standard string representation good basic example power flexibility generic programming day functional programming uniform function call syntax problem statement solution whatever reason probably kind trying golf solution ended writing lot functionalish code lot map reduce filter forth started early day mostly unopinionated style programming one use offer tool objectorientation functional programming plain procedural programming presenting obstacle mixing style lambda easily written inline concise syntax eg x x x basic standard functional tool like map reduce filter available approach functional programming quite pragmatic rarely used careful solution function labelled pure mean side effect however still let local impure thing reassigning variable loop restriction impurity must stack call impure function another feature came completely fall love call uniform function call syntax ufcs caveat basically mean sugar function one argument round bracket optional foobar sugar bar foo basic syntactic convenience make easy pleasant chain function call together lending making inviting write functional code also happy unification oop fp syntactically give object new member function create freestanding function whose first argument object day let try complex arithmetic problem statement solution geometry often well described complex number spiral problem seemed easy describe associative array complex coordinate integer value decided give stdcomplex try easy use big surprise day reusing familiar tool find duplicate problem statement solution new technique nice see easy build simple word counter builtins slightly disappointed data structure builtin like python collectionscounter hardly insurmountable problem day practice familiar tool problem statement solution much new like relative ease possible read integer list using map stdconvto day range problem statement solution usually fundamental paradigm structure programming language everything else depends haskell function monad c pointer array c class template python dicts iterators javascript callback object rust borrowing immutability range one fundamental concept roughly speaking range anything iterated like array lazy generator thanks powerful metaprogramming range defined satisfy kind compiletime duck typing method check emptiness get first element get next element inputrange duck typing kind reminiscent type class haskell general principle container algorithm container built upon range concept range intended simpler reformulation iterators c standard libary using range along foreach loop kind like sugar invoking method range however day actually wanted use method invoke stdrange method enumerate simply iterates range simultaneously producing counter used write brief code obtain maximum array index occurs another rangerelated feature appears first time slicing certain randomaccess range allow integer indexing also allow slicing typical method remove element array use slicing example remove first five element last two element array dollar sign sugar arrlength removal simply done moving start end pointer memory byte touched tour good taste range programming go depth day structs compiletime regexes problem statement solution solution problem complicated forced break actual tree data structure trying particularly parsimonious memory usage execution speed decided create tree node struct global associative array indexing node structs value semantics class reference semantics roughly mean structs stack get copied around passed function class always handled reference instead dynamically allocated destroyed another difference structs class class inheritance hence polymorphic dispatch structs however give structs method implicit parameter although little sugar freestanding function enough oop let talk really exciting stuff compiletime regular expression problem input parsing let look wrote void parseline string line static noderegex regex r p name w p weight p child w auto row matchfirst line noderegex init node struct static keyword instructs variable computed compiletime compiler basically interpreter execute arbitrary code long input available compile time case par compiles regex binary next line call matchfirst line done runtime whatever reason string available compile time say defined big inline string line source file could also regex parsing compile time wanted really nice one favourite feature add static precompute binary anything often even need extra syntax compiler realises information compile time something might known compiletime function execution hereafter ctfe tour good overview topic day compiletime fun mixin problem statement solution day another problem interesting part parsing used compiletime regex interesting part problem following bit code parsing string corresponding comparison operation originally wrote auto comparison function int int b b function int int b b function int int b b function int int b b function int int b b function int int b b okay terrible pretty like basically line repeated six time furthermore also like within line repeat operator string part function body enter mixin keyword basically string mixins allow evaluate string compile time kind like c preprocessor much safer example string mixins evaluate complete expression shenanigan like define private public allowed first attempt shorten looked like bool function int int string comparison static foreach cmp comparison cmp mixin function int int b cmp b since decided use compiletime static loop populate array needed separate declaration variable forced spell ungainly type associative array take string return function signature mixin take concatenated string evaluates function however work two reason first one static foreach introduced september compiler packaged debian yet wrote code second problem subtle initialisation associative array currently statically done internal data structure rely runtime computation according understanding discussion might fix day next best thing final answer bool function int int string comparison auto getcomparisons args foreach cmp args comparison cmp mixin function int int b cmp b return comparison shared static comparison getcomparisons alright size hardly shorter repetitive original still think better dull repetition bug often introduced using variableargument templated function mixin value available compile time us next best thing compiletime initialisation module initialiser shared static call function perform init day switch statement problem statement solution day simpler parsing problem simple instead using regex decided use switch statement anything terribly fancy switch statement work almost exactly language distinct feature switch statement work numeric string bool type deprecated implicit fallthrough fallthrough instead must explicitly done goto case deprecation complete oh also specify range case statement eg case case z stuff lowercase ascii break small convenience make pleasant programming good discussion switch statement day learning range problem statement solution superficially might think expression like arr valid would also allow thing like arr traverse array reverse order syntax different step size least kind array indexing common numericbased array octave julia r python numpy day hash requires reversing array thought could turn language syntax allow quick trip standard library found necessary function thought could written instead became minor discovery range day getting algorithm right using specialised utility since real hash typically allow several size templated hash function total size round hashing chunk size template constraint chunk size must divide total size auto gethash int int int string input size chunksize nothing new like template constraint easy write day offline hex coding problem statement solution day paper took figure proper hex coordinate system distance function coordinate system seen hex coordinate playing battle wesnoth took figure actual code pretty simple used technique seen think first time used cumulativefold function nothing see immutable global associative array populated module init time like pure static direction ne n nw sw se day want set problem statement solution new technique problem decided use set structure keep track graph node visited problem builtin set structure yet setdifference function bit clunky work ordered array sufficient purpose probably much worse hashing traditional set structure would one observation keyword used test membership like python also unrelated use defining input output argument function unlike python associative array make sense complexity testing membership data structure vary widely depending structure chosen algorithm clear universal choice like associative array desired however possible define operator class like bool opbinaryright elt check elt would assume could use write set class day offline coding problem statement solution one another solution paper thus managed write short program new technique usual functionalish style seem developing day reusing older code module problem statement solution problem interesting solved labelling connected component problem c gnu octave wrote initial bwlabeln implementation using unionfind tempted think quick way talking others lobster channel irc realised simpler recursive solution would work without overflowing stack problem small enough stackbased algorithm clever interesting part reusing earlier solution hashing algorithm day first blush quite simple every file also creates module namespaced desired directory reminiscent python import statement module namespacing snag file void main string args function one linker like duplicate definition symbol purpose offer conditional compilation c c usually achieved via familiar c preprocessor macro idiom idiom codified language proper via version kewyord like version standalone void main string args main thing instructs compiler compile inside version block option called standalone passed gdc fversionstandalone appd regrettably slightly different flag dversionstandalone appd builtin argument version linux osx conditionally compile particular operating system keyword offer quite bit flexibility conditional compilation big improvement c preprocessor idiom day generator lambda function delegate problem statement solution problem opportunity test new function generate take function iterates repeatedly range haskell call one iterate think better name also lazy generator need something like take say much generator want use example haskell code translated auto x auto pow generate x x take example documentation let also take moment talk different anonymous function following declare function square input function int return delegate int return difference question closure delegate version carry hidden pointer enclosing scope dynamically close outer scope variable afford pay runtime penalty function version reference enclosing scope extra pointer generator typically want use delegate since want generator remember scoped variable across successive call like auto generator ulong val ulong mult return generate delegate val val mult return val function return generator range entry result new entry pseudorandom linear congruence generator delegatefunction part type omitted inferred context eg passing function another function argument furthermore lambda shorthand using along return foo boilerplate shortened like form valid enough context infer delegate function well type detail language spec day permutation primitive tool problem statement solution permutation problem made reach stdalgorithm function bringtofront cyclicly permuting array place like bringtofront progs rot progs rot surprisingly versatile function used perform trick cyclic permutation documentation worth read also ran bug create character array immutable input string due unicoderelated reason handling character especially cast ubyte instead char besides second part realise permutation big orbit also ended using string array canfind stdalgorithm would preferred string set hashing instead linear searching make huge difference size problem really want set standard library maybe see make happen day avoiding work clever observation problem statement solution puzzle variation josephus problem needed help lobster irc figure solve new technique dumb array concatenation tilde operator inserting element array circ circ po circ po second part solved via simple observation need track one position one immediately following zero day concurrency finally understand write correctly problem statement solution day exciting one discussing problem others seems many people much difficulty solving problem programming language people seemed emulate concurrency help programming language choice contrast absolutely shined based actor concurrency model message passing precisely fit problem statement concurrency primitive case actor concurrency model sufficient sufficient basic idea concurrency thread execution localises state default thread share data order communicate thread pas message thread indicate time ready send receive message message type thread say type expecting receive thread receives type prepared handle throw exception detail happens thread receives many message respond let go basic idea thread get spawned thread send receive message let spend little bit time looking relevant function type used defined stdconcurrency spawn start thread execution first argument reference function thread execute along argument function may take return tid type thread id used address send message thread refer parent thread via special variable ownertid unless explicitly declared shared argument threaded function must immutable compiler guarantee race condition manipulating variable course shared variable programmer signalling taking synchronisation data may require using lowlevel mutexes send send message particular thread first argument thread id argument anything receiving thread handle argument receives receiveonly indicate thread ready receive single type return value type type must course specified compiletime argument receive indicates several possible type argument function collection function whose parameter type dynamically typematched received type need function wanted mention exists receivetimeout problem statement designed deadlock although probably elegant solution timing deadlock solution wrote function listens message set amount time message received designated time handler function executed receivetimeout return true timeout happens return false instead armed tool solution breeze write first spawn two thread save thread id auto spawn runprogram opcodes auto spawn runprogram opcodes two thread defined runprogram immediately stop waiting thread id know talk void runprogram immutable string opcodes ulong pid auto otherprog receiveonly tid parent thread connects two worker thread send send go two thread run opcodes problem statement eventually deadlock decided handle timeout like case rcv receivetimeout long val regs reg val goto done timeout handle next opcode goto default thread timed signal parent thread done done send ownertid thistid sent parent turn receives two tuples thread id computed value thread based decides output figuring thread wait child let u know done auto receiveonly tid long auto receiveonly tid long writeln else writeln voilà concurrency easypeasy day string parsing enums final switch problem statement solution new technique final switch final switch enum type make compiler enforce writing case match possible value wanted make sure matched left right direction final switch dir case dird j break case diru j break case dirl break case dirr break rest problem merely string parsing day physic problem vector operation problem statement solution yet done serious numerical work see necessary ingredient one obvious amongst builtin support writing vector instruction given struct model particle motion struct particle double po double vel double acc following function return another particle vector divided norm ie normalised auto unit particle p auto po ppos vel pvel acc pacc po posnorm vel velnorm acc accnorm particle u po vel acc return u vec scalar notation divide vector given scalar also add multiply vector elementwise similar syntax double ppos pvel pvel pacc give vector difference position velocity respectively velocity acceleration use criterion three mostly collinear determine particle escaped system thus longer interact particle mostly syntactic sugar however although compiler sometimes turn instruction like native vector instruction like avx real vectorisation done via standard library support day indexable hashable comparable struct problem statement solution happy recognise via string mixins could solve problem considering dihedral group square immutable dihedralfun function ref const pattern p auto n pdim auto output new int n n foreach n foreach j n output j pgrid return output immutable dihedralfourgroup mixin format dihedralfun j mixin format dihedralfun j mixin format dihedralfun mixin format dihedralfun mixin format dihedralfun j mixin format dihedralfun mixin format dihedralfun j mixin format dihedralfun new technique really happy turn almost like lisp macro without devolving lawless chaos python javascript eval c preprocessor macro aside format function accepts formatted string posix syntax positional argument anything builtin nice perl string interpolation python format string real meat problem implement grid structure could hashed compared indexed done number utility function indexing slicing basic idea userdefined type foo sugar fooopindex fooopslice bar baz two function need implement indexing slicing similarly equality comparison hashing implement opequals tohash respectively relied dihedral function comparison problem implementing function struct recall like class value semantics inheritance rest problem string parsing bit logic implement fractallike growth rule day enums final switch complex number problem statement solution another rectangular grid problem decided represent via complex number posssible infection state given problem turned enum checked final switch grid associative array complex grid position infection state nothing new familiar tool writing code becoming habitual day another opcode parsing problem problem statement solution problem technically difficult point view usual switch string parsing technique day work well fact started code day modified slightly fit problem challenge statically analyse opcode program determine implementing inefficient primality testing algorithm go analysis program others already done remarkable job explaining analysis complete meat problem becomes write faster primality testing algorithm dumb dumb trial division auto iscomposite long p return iota sqrt cast double p filter x p x use test appropriate location day routine graphsearch problem problem statement solution problem required sort graph structure implemented associative array node id edge incident node problem reduces sort graph traversal depthfirst search keeping track edge weight new technique either practice growing bag trick day formatted read finish advent problem statement solution final problem involved parsing slightly verbose dsl decided use formatted string reading like auto branchfmt write value move one slot continue state auto parsebranch file f int writeval string movedir char newstate freadf branchfmt writeval movedir newstate return branch writeval true false movedir left newstate admittedly bit brittle even type check formatted string expected type done runtime newer version compiletime version readf typechecking format string error cause exception runtime new technique actually wrote loop parse program file auto parseinstructions file f instruction char instruction feof char state freadf state n state freadln current value auto fparsebranch freadln current value auto fparsebranch freadln blank line instruction state instruction return instruction small comfort checking eof loop condition actually work always subtly wrong c never remember left problem absolutely routine associative array ufcs foreach loop standard library utility summing iterating forth favourite thing concluding remark best part code also fast comparing solution someone else advent code c could routinely match execution speed problem bothered compare whenever wrote similar algorithm eager see faced real numbercrunching come appreciate well seeing weak point think already raved enough much like functional style standard library typechecking compiletime calculation also ran bug deprecated feature also observed language questionable design choice notice garbage collector lot fun merry belated christmas
84,Lobsters,d,D programming,First Impressions! (D),http://forum.dlang.org/thread/dvngtqpqoxbjnrklvfvf@forum.dlang.org,first impression,includes include,rikki cattermoleon guy opinion wrote hi using personal project two week thought share initial impression case useful like feedback thing assume others plus opinion best internet see hopefully sarcasm obvious otherwise appear pompous would probably better retrospective project completed life know happen could lose interest something finish guy would nt know opinion ca nt allow start saying like overall experience come c c background little bit c mixed part though work c sql web technology day day basis three year stint working cc mostly c never really enjoyed much c overly verbose overly complicated overly littered poor legacy decision error prone c hand part delight problem nt find best come generative programming c generative programming generic part always struck specialized container type anything remotely outside purpose take fair bit cleverness sick clever aspect impression good bad porting straight c seems pretty straight forward even net framework like file unicode fairly direct counterpart code far pushing towards flat code lack better way phrase far helped tremendously come readability c kind opposite namespace class method coupled lock using etc tend lot nesting generally true logic even begin couple trycatch idisposableusing locking ifelse get quite chaotic easily right away saw c code actually appear readable translated think flatness sure opinion hold delve static little far us nt really dampened opinion visual might poor expectation read tooling poor internet nothing ever wrong internet however combination visual dmd actually exceeded expectation quite happy relatively easy set worked would expect work let debug add breakpoints basic syntax highlighting would expect could feature project corporate backed really could asked far compiling fast hear stay fast big motivator one commercial c project worked beast could take hour compile needed compile something fundamental c fairly fast grown accustomed go bathroom get drink etc returning find linking step used nt take le ten second probably le prep error deal want remain error dmd little strange nt want crap much part fine however occasionally throw error still ca nt really work error gave may saw question learn forum knowing use static embedded class error following error defined nonstatic member function say error far cryptic stuff c throw however nt delved deeply template yet nt hold yet term quality put somewhere c c quality c ideal standard library far really good nullable worked thought guessed method based seen point got right appears consistent intuitive also like fact peek code understand reading unlike c still nt know stuff really implemented stl almost seems like written completely different language stuff enables instance figured package seeing phobos however collection queue stack hashtable read big focus built stuff behave like thing c project porting utilizes queue specifically c dictionary quite bit looking forward hand roll use something nt fundamentally definitely biggest negative come across want queue something behave queue definitely expected language old todo list allocator need come experimental form rc tackle mean time http githubcomeconomicmodelingcontainers pretty good package public import really think useful forward importsusing statement kind package everything required use thing namespacepackage together nt include dozen thing c c includes unsatisfactory way least opinion module like module better include nt like better c namespaces specifically nt like gravity kind pull associate module file appears nt package thing whenever try thing outside one idiom end soup error sure use far little dissatisfying sometimes want physically file system different include source file c namespaces really standard beat meet module fairly well understood concept ml family use keep mind namespaces binding c code nt heard anybody abusing purpose using name space tend ugly hack ambiguity running course never use c sure somebody give war story unit test finally built unit test enough said lack collection biggest negative biggest positive would like enable build time possible though keep saying nt unit test built nt care code quality attribute another post learn forum attribute unfortunate first excited seems like surface would help write better code get little tedious tiresome remember decorate code seems like default would preferred compiler helped reminded asked way enforce globally guess guess also way turn afterwards bit unfortunate least see solution nt need bother code default primitive seem seem encourage error nt think best design decision even encourages error caught quickly possible think better decision would error occur asked seemed disassociation spec implementation spec say declaration error explicitly set implementation initializes something likely error like nan float would thought would based prior experience language nt mean language right either immutable sure fully understand surface seemed like const transitive tried method return immutable value used unit test got weird error object able return immutable forget exact error apology refactored use const worked expected nt get immutable nt work returning value type nt see passing assert objecterrorcount would triggered error set class keep track snapshot specific count seems like perfect fit immutable nt want snapshot change like ever kept getting error trying use like const type string seems immutable char work exactly way expecting nt ran problem sure problem confused knowing string work nt unicode support good although think string type probably default especially considering utf module state utf character support restricted character seems like natural fit plus vast majority use case pretty guaranteed char codepoint biggest issue world maybe overly critical us lot memory instead would argue instead need wstring use wstring aware microsoft alone thinking awesome everybody else standardized unicode template seem powerful fiddled thus far nt think quite comprehended usefulness yet probably take time figure wield effectively one thing accidentally stumbled upon liked could simulate inheritance structs using mixin keyword cool even sure really meant enable use alias instead wish fully implemented though multiple welcome
85,Lobsters,d,D programming,D is for Data Science,http://tech.adroll.com/blog/data/2014/11/17/d-is-for-data-science.html,data science,data science programming language brief introduction inverse square root inline assembly ripping data thirteen second log file day let u know,data science written andrew pascoe november programming language quickly become language choice data science team task requires efficiency keystone language critical infrastructure lot offer brief introduction one clearest advantage using compared typical data science workflow compiles machine code without interpreter virtual machine layer rip data significantly faster tool like java hadoop framework r python would allow compiler fast enough many case run scripting language try comparing python generating million uniform random variate sorting finding decile random import uniform variate uniform range variatessort range print variate time python decilespy somedeciles real user sys similarly import stdrandom import stdstdio void main string args double variate new double foreach ulong double variate variate uniform variatessort foreach int writeln variate time rdmd decilesd somedeciles real user sys took longer ran includes compilation time change anything run time rdmd decilesd somedeciles real user sys better rdmd bother recompile code change saving add quite significantly code becomes computationally complex need perform many computation substantial amount data course real revelation want hyperefficient code know best drop compiled language key thing separate efficient language like oftsuggested c c free program style feel comfortable given time code show write quick without incurring additional headache simpler python also clean want start writing objectoriented code import stdrandom import stdrange import stdstdio class rectangle double width double height double width double height thiswidth width thisheight height double area return width height void main string args rectangle r new rectangle r rsmap x new rectangle uniform uniform array rssort x xwidth ywidth foreach int writefln r width r height r area rdmd rectangledecilesd ready highperformance need example want calculate fast inverse square root use pointer voodoo lightly modified linked wikipedia article import stdconv import stdstdio void main string args computes x auto x float args int float const float threehalves x x cast int cast float threehalves writeln rdmd invsqrtd rdmd invsqrtd rdmd invsqrtd rdmd invsqrtd even let write inline assembly really want squeeze performance fun game help realworld scenario ripping data course work adroll infrastructure running fine certain point data problem exceeded scope code designed optimize believe problem banal pulling field delimited file gist particular log file contains ad data delimited ascii record separator say want pull timestamps country whence data come probably imagine solution quite readable perhaps snappy like import stdstdio import stdstring static immutable uint timestampindex static immutable uint countryindex static immutable char delimiter cast char void main string args auto file file args r foreach char line filebyline char field split line delimiter writefln st field timestampindex field countryindex fileclose time rdmd parserd logtxt countryinfo real user sys thirteen second eternity one log file mere sample producing generate log file day ok could potentially distribute problem spinning cluster take time one motto improve performance keep scalability one best thing minimize amount memory allocating allocate new char every time read line even beyond read line put char read split record separator splitting creates array field line allocates memory every one efficiency standpoint clean straightforward code actually quite mess address first concern memory allocation buffer already allocated read trick next line immediately follow previous line buffer end may fit buffer worse may get partial bit field care solution two buffer swap field care may straddle buffer also construct doublelength buffer simple reconstruction reach end current buffer make buffer load data buffer promoting current buffer caveat need make sure none line length longer buffer combined second concern inefficiency splitting instead breaking apart line totality memory sequentially read keep track progress buffer index array current line number delimiters seen hit right number delimiters need find next delimiter know field content hit end line reading newline reset line progress finally collected field need rip buffer find next newline enough chitchat look code import stdstdio immutable static ulong readbuffersize immutable static char delimiter cast char immutable static char newline cast char immutable static uint timestampindex immutable static uint countryindex immutable static char unknownfield unknown class fastreader file file char buffera char bufferb char doublebuffer char currentbuffer char lastbuffer ulong numbuf ulong index uint numdel bool lineend string filename file file filename r buffera new char readbuffersize bufferb new char readbuffersize doublebuffer new char readbuffersize currentbuffer buffera lastbuffer bufferb numbuf index numdel lineend false void resetprogress numdel lineend false void swapandload lastbuffer currentbuffer numbuf numbuf currentbuffer buffera else currentbuffer bufferb currentbuffer filerawread currentbuffer index void getfield uint fieldid ref char field lineend field unknownfielddup return ulong start index numdel fieldid start currentbufferlength swapandload start currentbuffer start newline lineend true break currentbuffer start delimiter numdel start start currentbufferlength swapandload start lineend field unknownfielddup index start return ulong end start bool swapped false currentbuffer end delimiter end end currentbufferlength swapandload swapped true end currentbuffer end newline lineend true numdel nt count delimiter break numdel swapped field currentbuffer start end else ulong sizeend lastbufferlength start doublebuffer sizeend lastbuffer start doublebuffer sizeend sizeend end currentbuffer end field doublebuffer sizeend end index end void advancetonext ulong start index start currentbufferlength swapandload start currentbuffer start newline start start currentbufferlength swapandload start index start resetprogress bool eof return fileeof index currentbufferlength void close fileclose void processfile string file char timestamp char country fastreader frd new fastreader file frdeof frdgetfield timestampindex timestamp frdgetfield countryindex country frdadvancetonext writefln st timestamp country frdclose void main string args processfile args really beef simple program accomplish task break bit buffera bufferb two backing buffer pointed either currentbuffer lastbuffer depending state track numbuf keep track progress currentbuffer use index keep track progress line use numdel represent number delimiters seen thus far finally want know hit end line lineend instantiation fastreader straightforward start buffera resetprogress get called hit start new line update state reflect swapandload toggling method note numbuf operation determine currentbuffer equivalent numbuf also quick catch filerawread method though take char populates file hit end file char previous content past eof example import stdstdio void main string args auto file file testtxt r char buffer dup writeln buffer length bufferlength writeln buffer content buffer filerawread buffer writeln buffer length bufferlength writeln buffer content buffer echo n test testtxt rdmd testd buffer length buffer content buffer length buffer content purpose undesirable behavior want know actually hit end file end last line turn filerawread also return char slice passed array new content changing line buffer filerawread buffer fix issue rdmd testd buffer length buffer content buffer length buffer content test use construction swapandload finally resetting progress currentbuffer getfield trickiest method still intelligible already hit end line field find write unknown starting currentbuffer start counting delimiters hit end currentbuffer time swapandload hit correct number delimiters need find next one essentially code need know swap buffer process hit newline count end field constructing field simple swap slice currentbuffer start end index otherwise piece together lastbuffer currentbuffer advancetonext method also work similar way searching delimiters instead look newline character move next line resetprogres couple catch point first eof method possible hit eof line read check ensuring truly done index currentbuffer length finally processfile call make sure move next line getting field require critically search field numerical order need run line sequence never look back ok code gained weight fortunately gained weight term muscle mass instead bloat check time rdmd parserfastd logtxt countryinfofast real user sys hey better improvement run way data amount time make sure nothing fishy going diff countryinfo countryinfofast awesome hey would really cool could exploit fact running multicore machine read multiple file would import stdparallelism import stdstdio import stdstring main void main string args auto file split args foreach string file parallel file processfile file well pretty easy type performance get cp logtxt log itxt done time rdmd parserparalleld logtxt morecountryinfo real user sys time rdmd parserparalleld logtxt morecountryinfo real user sys time rdmd parserparalleld logtxt morecountryinfo real user sys time rdmd parserparalleld logtxt morecountryinfo real user sys wow five time faster original solution running four time data performance boost done rdmd perform many optimization could code state want make sense compile dmd rather running scripting idiom fair also compile original solution nonparallelized one dmd release inline parserd time parser logtxt countryinfo real user sys dmd release inline parserfastd time parserfast logtxt countryinfofast real user sys dmd release inline parserparalleld time parserparallel logtxt morecountryinfo real user sys time parserparallel logtxt morecountryinfo real user sys time parserparallel logtxt morecountryinfo real user sys time parserparallel logtxt morecountryinfo real user sys compiling everything fast solution nearly performance boost one parallelized solution run four time data nearly boost adroll data science become big fan easy see rapidly prototype new infrastructure analysis task efficiency becomes core concern ability refactor code base squeeze much performance possible interested tackling big data problem eye lean mean code let u know
86,Lobsters,d,D programming,D language IDE based on DlangUI,https://github.com/buggins/dlangide,language ide based dlangui,dlang ide http githubcombugginsdlangide http githubcombugginsdlangidewiki http githubcombugginsdlangui http githubcomrainersmago try dlangide http dlangorgdownloadhtml osx build note linux build note window build note build tool dcd integration importing existing project debugger support building dlangide keyboard shortcut setting development environment setup http githubcombugginsdlanguiblobmastercodingstylemd workspace include path setting,dlang ide cross platform language ide written using dlangui library screenshot default theme screenshot dark theme screenshot console mode running window console currently supported feature us dub dubjson dubsdl project format show tree project source file open edit source file project file system multitab editor build run project dub build log highlight navigation place error warning clicking log line contributed extrawurst dub dependency update dub package configuration selection contributed ncrashed dependency project shown workspace tree new project wizard toolchain setting dmd ldc gdc project specific setting basic debugger support using gdb work progress source editor feature language source code json dml syntax highlight indent unindent text tab shifttab ctrl ctrl toggle line block comment ctrl ctrlshift source code autocompletion ctrlspace ctrlshiftg using dcd source code go definition ctrlg using dcd source doc comment display mouse hover using dcd source code smart indent select word mouse double click github page http githubcombugginsdlangide wiki http githubcombugginsdlangidewiki dlangui project github page http githubcombugginsdlangui mago debugger github page http githubcomrainersmago try dlangide use dub utility dmd compiler download build run recent version dlangide git repository prerequisite install dmd http dlangorgdownloadhtml recent dmd package dub utility included fetch build run dlangide dub fetch dlangide dub run buildrelease dlangide osx build note osx need install used default backend eg use homebrew package manager install brew install troubleshooting screen dpi detection eg everything small retina display choose dpi manually menu edit preference interface override screen dpi issue fixed soon linux build note linux need install used default backend yet installed install order run dlangide debianubuntu use sudo aptget install rpm based distribution sudo yum install window build note prebuilt binary found release section well build recent build dmd window issue crash optilink linker dmd workaround add dub commandline build version using microsoft linker coff object library file format dub run buildrelease dlangide build version using microsoft linker dub run buildrelease dlangide note unlike default dependency linker visual studio c compiler toolchain build tool dlangide us dub build tool dubjson dubsdl project file format select dmd ldc gdc compiler toolchain dcd integration symbol lookup autocompletion using dcd completion daemon hansalbert maritz freakazo implementated dcd integration using dcd clientserver keywan ghadami improved use dcd library dcd embedded dlangide separate executables needed importing existing project dlangide support dub project format import existing dub project use menu item file open project workspace select dubjson dubsdl project import debugger support building dlangide build run dub git clone http githubcombugginsdlangidegit cd dlangide dub run see build error try upgrade dependency dub cleancaches dub upgrade forceremove dub build force need dmd newer build hint try open sample project tetri workspacestetris dlangide develop visuald together dlangui put project level dlangui repository dependency keyboard shortcut setting keyboard shortcut setting support added linux macos setting placed file dlangideshortcutsjson window directory like c usersuserappdataroamingdlangideshortcutsjson file exists created dlangide start filling default value simplify configuration edit content redefine key binding file format simple intuitive example editoractionscopy ctrlc editoractionspaste ctrlv editoractionscut ctrlx editoractionsundo ctrlz editoractionsredo ctrly ctrlshiftz editoractionsindent tab ctrl editoractionsunindent shifttab ctrl editoractionstogglelinecomment ctrl editoractionstoggleblockcomment ctrlshift development environment setup howto hack dlangide window install m visual studio eg community visuald plugin install git dub dmd linux osx install monodevelop monod plugin linux osx additionally install development package create folder place source eg srcd clone dlangui dlangide repository source folder git clone recursive http githubcombugginsdlanguigit git clone recursive http githubcombugginsdlangidegit window open solution file visuald dlanguidlanguimsvcsln linux open solution file monod dlangidedlangidemonodlinuxsln osx open solution file monod dlangidedlangidemonodosxsln choose dlangide startup project coding style http githubcombugginsdlanguiblobmastercodingstylemd workspace include path setting set dmd includes path correct work dcd workspace setting file newworkspacedlangidews example name newworkspace description null project newproject newprojectdubjson includepath usrincludedlangdmd
87,Lobsters,d,D programming,The Making of ‘D Web Development’,https://dlang.org/blog/2017/09/13/the-making-of-d-web-development/,making web development,web development ldc packt publishing cookbook web development vibed framework ldc release digest authentication,longtime contributor community kai nacke author web development maintainer ldc llvm compiler post tell story book came together beginning asked packt publishing wanted review cookbook adam ruppe course wanted review stressful lot fun end year came surprising question would willing switch side write book hesitated sure writing book dream possible top regular job proposed topic web development interesting web technology knew course vibed framework large unit test ldc release interest awakened created chapter overview based solely experience developer online documentation vibed result came well offered contract came immediate challenge set small project plan plan write book without experience area stuck following rule chapter planned little time frame include least one weekend larger chapter perhaps even two reserved time easter holiday first version book would therefore ready beginning july started writing midfebruary even first chapter showed plan much optimistic writing went quickly soon something could write experimenting testing took lot time one thing much experience vibed sample program wanted develop saturday write sunday however still searching error monday without written single line hand still rough edge vibed time want write would changed implemented later version library developed patch vibed eg digest authentication way also new ldc release create fortunately ldc team expanded took care release thanks much folk result course missed many milestone may first chapter came back review process content also written text back book middecember last chapter finished almost review note chapter incorporated little christmas break remaining note quickly incorporated prefinal version chapter created january february news came book published done almost exactly one year started first chapter work worth case special experience would yes right playing idea updating book expanding chapter let see
88,Lobsters,d,D programming,Interfacing to C++ - D Programming Language,https://dlang.org/spec/cpp_interface.html,interfacing c programming language,interfacing c c interface namespace linkageattribute module import semantics section lifetime management empty base optimization,interfacing c document specifies interface c directly also possible indirectly interface c code either c interface com interface compatible c mean le adding fully functional c compiler front end anecdotal evidence suggests writing minimum manyear project essentially making compiler capability unimplementable language looking hook c face problem solution support com interface work window laboriously construct c wrapper around c code use automated tool swig construct c wrapper reimplement c code language give take pragmatic approach assumes couple modest accommodation solve significant chunk problem matching c name mangling convention matching c function calling convention matching c virtual function table layout single inheritance c global function including namespaces declared called defined called c given c function c source file include iostream using namespace std int foo int int j int k cout endl cout j j endl cout k k endl return corresponding code foo declared c linkage function calling convention extern c int foo int int j int k called within code extern c int foo int int j int k void main foo compiling two file first c compiler second compiler linking together running yield g c foocpp dmd bard fooo llstdc bar j k several thing going understands c function name mangled correct c function callreturn sequence module part c function c linkage global namespace must globally unique within program cdecl far stdcall declspec nonstandard c extension volatile type modifier string terminated see data type compatibility information however string literal terminated make function accessible c give c linkage import stdstdio extern c int foo int int j int k writefln writefln j j writefln k k return extern c void bar void main bar c end look like int foo int int j int k void bar foo compiling linking running produce output dmd c food g barcpp fooo pthread bar bar j k c symbol reside namespaces accessed namespace added extern c linkageattribute extern c n int foo int int j int k void main nfoo c open namespace file multiple file done follows module n extern c n int foo return int bar return multiple file organizing package consisting several module n ad bd packaged file nsad module extern c n int foo return file nsbd module b extern c n int bar return file nspackaged module n public import b import package containing extern c declaration follows import n static assert foo bar note extern c n linkage attribute affect abi name mangling calling convention declaration importing follows usual module import semantics alternatively nonstring form used introduce scope note enclosing module already provides scope symbol declared namespace form allow closing reopening namespace module module extern c int foo return module b extern c int bar return import b static assert foo bar work extern c int foo return extern c int bar return additionally alias used avoid collision symbol module extern c n int foo return module b extern c n int bar return module n import b alias foo ansfoo alias bar bnsbar import n static assert foo bar c class declared using extern c attribute class struct interface declaration extern c interface restriction interface mean multiple inheritance supported extent one base class member field extern c structs support virtual function used map c value type unlike class interface linkage extern c class interface rooted object used typeid structs class different semantics whereas c structs class basically use struct class depends c implementation used c keyword mapping class onto c struct use extern c struct avoid linking problem c compiler notably msvc distinguish c class struct mangling conversely use extern c class map struct onto c class extern c class extern c struct combined c namespaces extern c struct extern c foo class bar following example show binding pure virtual function implementation derived class nonvirtual member function member field include iostream using namespace std class base public virtual void int int b int c class derived public base public int field derived int field field field void int int b int c cout endl cout b b endl cout c c endl int mul int factor int derived mul int factor return field factor derived createinstance int return new derived void deleteinstance derived delete use code like extern c abstract class base void int int b int c class derived base int field disable override void int int b int c final int mul int factor derived createinstance int void deleteinstance ref derived void main import stdstdio auto createinstance writeln writeln base deleteinstance assert null auto createinstance writeln deleteinstance assert null compiling linking running produce output g basecpp dmd maind baseo llstdc main b c note example constructor bindable instead disabled side alternative would reimplement constructor see section lifetime management information given code like extern c int calle e extern c interface e int bar int int j int k class f e extern c int bar int int j int k import stdstdio writefln writefln writefln j j writefln k k return void main f f new f calle f c code access look like class e public virtual int bar int int j int k int calle e e return e bar dmd c based g klasscpp baseo pthread klass klass j k c allows struct inherit base struct done using alias struct base member struct derived base base alias base member c struct zero field struct still size byte c struct zero field used base struct size zero called empty base optimization two method emulating behavior first forward reference function returning faked reference base struct base member struct derivedstruct static basetupleoflength base base else ref inout base base inout return cast inout base alias base member second make use template mixins mixin template basemembers void memberfunction struct base mixin basemembers struct derived mixin basemembers member note template mixin evaluated context instantiation declaration problem template mixin use local import member function forward actual function c function type template bound using extern c attribute function type template declaration note instantiation used code must provided linking c object code shared library containing instantiation example include iostream template class struct foo private field public foo field get void set template class foo get return field template class void foo set field foo int makeintfoo int return foo int foo char makecharfoo char c return foo char c template class void increment foo foo fooset fooget template class void printthreenext foo foo sizet std cout fooget std endl increment foo following two function ensure required instantiation printthreenext provided code module void printthreenexti foo int foo printthreenext foo void printthreenextc foo char foo printthreenext foo extern c struct foo private field public disable get void set foo int makeintfoo int foo char makecharfoo char c void increment ref foo foo void printthreenext foo foo extern void main auto makeintfoo assert iget iset increment assert iget auto c makecharfoo increment c assert cget b cset printthreenext c compiling linking running produce output g c templatecpp dmd maind templateo llstdc main b c c follow different rule function overloading source code even calling extern c function still follow overloading rule c code explicitly manages memory call operator new operator delete new operator allocates memory using garbage collector explicit delete necessary new operator compatible c operator new operator delete attempting allocate memory new deallocate c operator delete result miserable failure explicitly manage memory using variety library tool stdexperimentalallocator additionally corestdcstdlibmalloc corestdcstdlibfree used directly connecting c function expect malloc buffer pointer memory allocated garbage collector heap passed c function critical ensure referenced memory collected garbage collector c function done accomplished making copy data using stdexperimentalallocator corestdcstdlibmalloc passing copy instead leaving pointer stack parameter automatic variable garbage collector scan stack leaving pointer static data segment garbage collector scan static data segment registering pointer garbage collector using corememorygcaddroot corememorygcaddrange function interior pointer allocated memory block sufficient let gc know object use ie necessary maintain pointer beginning allocated memory garbage collector scan stack thread registered runtime scan data segment shared library nt registered runtime c type equivalence typec type void void byte signed char ubyte unsigned char char char char unsigned corestdcstddefwchart wchart short short ushort unsigned short int int uint unsigned long long long ulong unsigned long long corestdcconfigcpplong long corestdcconfigcppulong unsigned long float float double double real long double extern c struct struct class extern c class struct class extern c interface struct class member field union union enum enum type type ref type parameter list type type dim type dim type dim type dim type equivalent type type equivalent type function parameter type parameter type delegate parameter equivalent equivalent hold c compiler used companion host platform structs union analogous c c code often adjusts alignment packing struct member command line switch various implementation specific pragmas support explicit alignment attribute correspond c compiler rule check alignment c code using explicitly set struct declaration support bitfields standard library see stdbitmanipbitfields c constructor copy constructor move constructor destructors called directly code constructor postblit operator destructors directly exported c code interoperation type special operator possible either disabling operator client language using host language faithfully reimplementing operator client language latter approach care need taken ensure observable semantics remain implementation difficult edge case impossible due difference operator work two language example object movable move constructor directly call c special member function vice versa include constructor destructors conversion operator operator overloading allocator runtime type identification us completely different technique c two incompatible exception interoperability work progress present c exception caught thrown exception caught thrown c additionally object c stack frame guaranteed destroyed unwinding stack due exception vice versa plan support except throwing exception directly c code throwable indirectly calling function c linkage const immutable comparison const keywordyesyes immutable keywordyesno const notationconst int p postfix ptr const ptr const int const int const p transitive constconst int p p const ptr ptr int int const p p ok cast away constconst int p int q cast int p yes ptr const int const int p int q constcast int p ok castmutateconst int p int q cast int p q yes ptr const int const int p int q constcast int p q ok overloadingvoid foo int x void foo const int x void foo int x void foo const int x error constmutable aliasingvoid foo const int x int bar x bar x int foo yes void foo const int x int bar x bar bar x bar int foo immutablemutable aliasingvoid foo immutable int x int bar x bar x int foo cast immutable immutables type string literal immutable char const char string literal nonconst allowed allowed deprecated
89,Lobsters,d,D programming,Metaprogramming is less fun in D,https://epi.github.io/2017/03/18/less_fun.html,metaprogramming le fun,talk metaprogramming meeting c hana case study event system skip part compiletime lookup special string literal operator implementation hana map template parameter pack expansion magic time practical language practical programmer need get job done quickly reliably leave behind maintainable easy understand code interface compiletime lookup phobos argument list overloading trigger builtin associative array oneonone download version designed fast compilation c hana map equivalent prerequisite storage value operator readonly indexing indexing simple assignment indexing compound assignment performance archive summing post type object new ctfe engine hurt build time,despite speaker calm voice slide showing almost nothing code c normally expect keynote louis dionne talk metaprogramming meeting c truly exciting one year since last time metaprogramming c talk brought back old memory feeling put together incredibly clever piece template black magic finally worked oh soo cunning best hacker sure know feeling happy learn picture changed significantly since time cluttering code many nested level angle bracket adorned double colon longer thing hana basically write code look like usual runtime function operator call hood function generic operate information carried type argument runtime state involved operation generated machine code optimized impressive case study event system let take look example discussed talk starting watched already skip part copy entire example close hand reference discussion consider event system identifies event name register number callback handler called event triggered later trigger event expecting callback registered given event execute int main eventsystem event foo bar baz eventson foo std cout foo triggered n eventson foo std cout foo n eventson bar std cout bar triggered n eventson baz std cout baz triggered n eventstrigger foo eventstrigger baz eventstrigger unknown woops runtime error start javastyle runtime implementation use hash map find vector function call given event name initially empty vector inserted map known event struct eventsystem using callback std function void std unorderedmap std string std vector callback map explicit eventsystem std initializerlist std string event auto const event event mapinsert event register callback find right vector map push callback end template typename f void std string const event f callback auto callback mapfind event assert callback mapend trying add callback unknown event callback secondpushback callback finally triggering event cause calling callback vector specified event void trigger std string const event auto callback mapfind event assert callback mapend trying trigger unknown event auto callback callback second callback well good frequently already known design time possible event triggered pay search map time trigger event worse mistype name event may unlucky enough know late compiletime lookup hana save u annoyance allowing u lookup compile time cosmetic change code first update call site compiletime string literal place runtime one int main auto event makeeventsystem foo bar baz eventson foo std cout foo triggered n eventson foo std cout foo n eventson bar std cout bar triggered n eventson baz std cout baz triggered n eventson unknown compiler error eventstrigger foo overhead eventstrigger baz eventstrigger unknown compiler error note suffix event name requires special string literal operator probably make c standard already implemented clang gcc using operator build stateless object string stored object type eg foo becomes instance hana string f implementation hana map let replace runtime map hana map declaring vector callback event bit template parameter pack expansion magic template typename event struct eventsystem using callback std function void hana map hana pair event std vector callback map default construct eventsystem default construct map consequently vector callback contains initialized empty vector template typename event eventsystem event makeeventsystem event event return finally replace runtime lookup compiletime equivalent template typename event typename f void event e f callback auto isknownevent hana contains map e staticassert isknownevent trying add callback unknown event map e pushback callback template typename event void trigger event e const auto isknownevent hana contains map e staticassert isknownevent trying trigger unknown event auto callback map e callback happens vector accessed determined compile time instantiation function template access vector expect additional runtime cost compared hand written function event eg template typename f void triggerfoo f callback auto callback callbacksfoo callback application trigger event frequently changing dynamic static dispatch may result noticeable speedup chart show time call trigger event exactly one callback registered compiletime lookup based hana map time faster runtime lookup unorderedmap slower calling std function time case event triggered decided run time eg std string e readfromstdin eventstrigger e event system easily extended handle case like first version runtime lookup use unordered map want store callback vector twice value map pointer vector already stored inside static map std unorderedmap std string std vector callback const dynamic eventsystem hana foreach hana key map auto event dynamicinsert eventcstr map event able trigger runtimedetermined event matter overloading trigger method exactly one pure runtime implementation void trigger std string const event auto callback dynamicfind event assert callback dynamicend trying trigger unknown event auto callback callback second callback better point talk hear louis saying need support compiletime runtime lookup single overload pretty powerful know language allows obvious could better took minute sketch equivalent implementation understand advertise effect year hard work done want people look something else know could heard c done right entirely true also baggage bad decision quirk time collected adhoc standard library addition completely different style documentation sometimes outdated miss one thing looking community support receives industry incomparably smaller received c leaving aside year using various task must agree really life promise practical language practical programmer need get job done quickly reliably leave behind maintainable easy understand code let see overload trick least match chana duo expressiveness use case interface let start expect call site void main eventsystem foo bar baz event eventson foo writeln foo triggered eventson foo writeln foo eventson bar writeln bar triggered eventson baz writeln baz triggered eventson unknown compile error eventstrigger foo eventstrigger baz eventstrigger bar overload dynamic dispatch eventstrigger unknown compile error look pretty similar c important difference special syntax compiletime string regular string passed template parameter reason idea stateless object string encoded type add value technically possible implement see eventsystem struct template instantiated passing event name argument default static initializers sufficient member need factory function function template trigger also accept compiletime string since string single token parenthesis around template argument list skipped around empty runtime argument list minor syntactic quirk turned trigger foo le cluttered trigger foo distiction runtime compiletime argument preserved regular language rule need remember particular case suffix implies compiletime entity note trigger foo baz via static dispatch also expect overload available accepts runtime evaluated event name trigger bar compiletime lookup implementation struct eventsystem event alias callback void delegate callback eventslength callback like std array std vector callback sizeof event c equivalent hana map phobos since value map type declare fixedlength array use staticindexof map event name index array argument list struct template receives event may include various compiletime entity including type template name constant value different primitive composite type particular string fine implementation trigger also look pretty similar c version except first look index requested vector callback get vector array via index void string event callback c enum index staticindexof event event static assert index trying add callback unknown event event callback index c void trigger string event enum index staticindexof event event static assert index trying trigger unknown event event foreach callback callback index callback note enum place c version used auto type also inferred automatically using enum force index computed compile time used static assert lookup compiletime linear search staticindexof done per instantiation ie per key runtime cost associated also indexing array via statically known index add runtime overhead overloading trigger overload trigger accepting dynamic key nothing unusual template nontemplate overload side side let focus implementation runtime lookup one way would use builtin associative array populated construction map object try small number key linear search comparing requested key known key much worse void trigger string event foreach e event event e foreach c callback c return assert false trying trigger unknown event event going outer foreach iterates event compiletime tuple string really compiler paste body static foreach element tuple substituting element e index index result three ifs one another event foo foreach callback callback callback return event bar foreach callback callback callback return event baz foreach callback callback callback return oneonone download version stare code compile version compiled dmd gdc ldc machine consistently compiles noticeably faster c one minimum consecutive attempt compiled c g clang gdc gccgdc clang draw serious conclusion time take compile tiny toy program general designed fast compilation mention volume library code brought much smaller mistyped name event frontend common major compiler try balance volume usefulness error message job well thing see esd error static assert trying trigger unknown event unknown esd instantiated trigger unknown c shell scroll hundred line heavily punctuated message see important one coming staticassert although clang highlighting bad gcc used tool transforming c error message something digestible human still around last thing check lose performance graph see comparison v c version static dynamic dispatch version seems slightly faster case limited microbenchmark dynamic lookup might perform better use different algorithm favor small set speedup static lookup likely come std function bit work call delegate check assembly c noticed larger application anything meaningful callback let assume version perform equally well conclusion achieved similar result c without resorting complex library implementation look straightforward us basic feature language standard library feeling superclever learn anything new exactly expect maintainable easy understand code really better absolute scale factor important likely favor solution rely external library compiles faster produce le scary error message something go wrong hana map equivalent wanted data structure behaves like hana map always value type using intermediate integer index feel little bit unprofessional possible prerequisite turn obstacle compiletime entity type value used runtime argument overloaded indexing operator overcome technique hana us applied consider struct template parameterized single value type know name let entity struct entity arg arglength static arg alias type arg else static typeof arg alias type enum value arg instantiate concrete struct type create object writing eg entity foo entity double object state type select different instantiation template function unlike regular function call constructing struct object requires parenthesis make bit verbose hana c suffix number way make concise parameterized enum one enum c arg entity arg static assert c inttype int static assert c foo type string static assert c foo value foo static assert c similar syntax userdefined literal reportedly used first stdconvoctal storage value let get map want something store value different type like stdtypeconstuple key type compiletime value instantiated like struct bar map foo int string foo map value type int bar string type bar map value type string 한 string map string 한 map value type string need separate interleaving key value type declare storage value struct map spec alias key even spec alias value odd spec value value even odd standard thing quickly implement template stride sizet first sizet stride static alength first alias stride aliasseq first stride stride stride first else alias stride aliasseq alias odd stride alias even stride value builtin tuple consisting element type type list value indexed using constant integer eg mapvalues also iterated using static foreach construct saw mean got iteration key value free try initialize via struct literal syntax auto map map foo int bar string 한 string baz lorem ipsum dolor iterate key foreach k mapkeys writeln kstringof iterate type value foreach v mapvalues writeln vstringof iterate value foreach value mapvalues writeln value operator hana offer free function template contains check whether given key map operator usually used overloaded implementing opbinaryright since depends compiletime information type argument declared static static bool opbinaryright string op key entity key key op enum index staticindexof key key return index let see work static assert c foo map static assert c bar map static assert c 한 map static assert c map look value using compiletime key use staticindexof add meaningful message key found private template indexof alias key enum indexof staticindexof key key static assert indexof trying access nonexistent key key used implement indexing operator single one unlike c operator return lvalue reference manipulated using eg assignment operator operator readonly indexing indexing simple assignment indexing compound assignment overloaded separately auto opindex key entity key key const return value indexof key auto opindexassign key auto ref value entity key key return value indexof key value auto opindexopassign string op key auto ref value entity key key return mixin value indexof key op value case key inferred type argument evaluation indexof key indexing value done compile time let test compiletime lookup runtime assignment map c foo opindexassign map c bar baz map c 한 lorem opindexopassign map c 한 ipsum map c 한 dolor compiletime lookup runtime comparison assert map c foo opindex assert map c bar baz assert map c 한 lorem ipsum dolor performance map allows lookup iteration compile time runtimelike syntax like hana map nothing bunch everyday trivial oneliners may want try modifying eventsystem use map implemented impatient find one possible implementation archive notice measurable difference compilation time version previous one runtime performance also similar shown graph question whether would right design choice operator syntactic sugar could easily replaced normal template function like get contains making awkward c arg unnecessary iteration list compiletime entity element value tuples builtin language feature need either summing first attempt emulating hana see example post type object interesting example quicksort type hana trick making metafunctions look like regular runtime code applicable thanks builtin metaprogramming feature substantially improve code readability programmer productivity new ctfe engine complete merged probably hurt build time without giving much return talk concludes example possible feature proposed named argument foreach type list serialization json reflection probably surprised possible year cleaner syntax le intellectual effort required stripping metaprogramming fun could c
90,Lobsters,d,D programming,"Interfacing D with C and FORTRAN. Use D as ""betterC"" with no runtime, and GC.",http://www.active-analytics.com/blog/interface-d-with-c-fortran/,interfacing c fortran use betterc runtime gc,interfacing c fortran mir community phobos gcc calling c function code ensures carry number potentially unsafe action alias parameter philippe sigaud mir phobos tool calling static c library calling function c calling fortran code fortran iso c binding link calling fortran code mixins summary,interfacing c fortran author dr chibisi chimaokereke ilya yaroshenko created march gmt published march gmt article written collaboration ilya yaroshenko contributor creator mir collection numerical package code article located thanks community suggestion informed article c fortran programming language many popular library heavily relied upon generic metaprogramming feature well multiparadigm nature clear syntax make great choice various application many programming language allow varying degree compatibility c fortran library however c library full compatibility fortran subroutine called article describes interface code c fortran includes outlining ease function c standard library accessed calling function c static library calling function c calling fortran subroutine article also cover use string mixins generate code avoid repetitive writing wrapper function declaration code article us betterc style mode programming increasingly popular circle focusing replacement c system programming betterc flag compiler us lightweight subset sideeffect facilitating integration code c seamless calling c code main effect betterc flag remove linktime dependency druntime phobos standard library however time writing article flag partially implemented remove module information example presented run linux ubuntu system use gcc c fortran compiler version llvmbased compiler calling c function mathh header describes standard library c code show code importing fabs pow function library extern c brace contain function imported c qualifier nogc nothrow used imported c function garbage collected throw exception general c language easily allows unsafe action one corrupting data imported function modified safe ensures carry number potentially unsafe action printf function marked safe instead scope statement used pointer lifetime escape function addition scoped pointer passed another function internally scoped global variable another internal pointer returned nogc nothrow declare c function extern c double pow double x double safe double fabs double x pure safe int printf scope const char format pragma inline false void printarray double arr foreach elem arr printf f elem printf n pragma inline true void apply alias fun double arr foreach ref elem arr elem fun elem gshared double x extern c int main apply fabs x printarray x apply pow x printarray x return give output betterc oz release linkoncetemplates run following helpful descriptor code full description flag compiler given help flag current flag reduce code size bloat create lightweight executables new apply function example using metaprogramming technique pas function using template alias parameter detail template metaprogramming found philippe sigaud tutorial addition mir phobos library offer map function iterate array purity function enforced using pure qualifier indicate function sideeffects case fabs function printarray function used multiple time explicitly marked pragma inline false gshared qualifier indicates global shared data default behaviour cc place x data section object file garbage collection execptions used extern c declares common c main instead dmain allows final executable reduced size time kb kb nm tool allows object file symbol inspected output show economy created symbol omits creation code increase file size perhaps efficiency executable betterc nogc oz release linkoncetemplates c nm main constarray u fabs u pow u printf u putchar symbol object file described printarray mangling main main c mangling x length pointer constarray x data fabs pow printf extern c symbol putchar extern c symbol optimized version printf n calling static c library main difference calling static c library calling installed c library compilation process example simple multiplication function written c double mult double x double return x code call similar previous example extern c nogc nothrow double mult double x double safe pure int printf scope const char format extern c int main printf fn mult return many way compile two script one way compile c code object file use compiler compile c object file together script generate executable however c script compiled separate object file object file compiled together gcc compiler gcc c oz c release betterc nogc gcc nm mult nm main u mult u printf code given calling function c calling c le seamless affair feature supported c however betterc used create compatitable object file code creates multiplication function different type using string mixins string mixins metaprogramming technique allows user generate code string compile time extern c nothrow nogc safe pure template generate string template genwrap string type enum string genwrap type type mult type x type n ntreturn x n mixin genwrap double mixin genwrap float mixin genwrap double expand code double dmult double x double return x instead using quote user prefer using q notation represent string case syntactic code held curly brace revisiting use mixins final example generate fortran code c code reference call function created include stdioh extern double dmult double x double extern float fmult float x float int main double xd yd float xf yf printf output fn dmult xd yd printf output fn fmult xf yf return compile gcc c release betterc linkoncetemplates c gcc output output nm u dmult u fmult main u printf nm dmult fmult code located calling fortran code fortran subroutine called directly similar way calling static c library working fortran good idea explore fortran iso c binding documentation fortran subroutine equivalent multiplication function subroutine mult x implicit none real intent x real intent inout x end subroutine mult main difference calling c code fortran code input fortran subroutine must referenced name function mangled fortran object file include underscore afterwards cstyle notation used double mult double x double however provides ref notation allows referenced input without requring pointer extern c nothrow nogc double mult ref double x ref double safe pure int printf scope const char format int main double x printf fn mult x return compilation similar calling c gfortran c output fortran object file showing underscore mangled append name gfortran c nm mult code located link useful resource fortran useful compilation hint calling fortran code mixins consider situation fortran subroutine signature different name need called used generate necessary declarative wrapper code avoid repetitive code example consider porting following trigonometric subroutine fortran subroutine sin x implicit none real intent inout x x dsin x end subroutine sin subroutine co x implicit none real intent inout x x dcos x end subroutine co subroutine tan x implicit none real intent inout x x dtan x end subroutine tan subroutine atan x implicit none real intent inout x x datan x end subroutine atan use template generate string compiletime string compiletime interpreted code using string mixins template first template used generate declaration extern c template declare string fun enum string declare double fun ref double x pure declare sin generate string double sin ref double x pure declares ported fortran sin function next wrapper function allow user use sin x rather sin x template wrap string fun enum string wrap double fun double x n n return fun x n template function recursively concatenates output many function generate one string function given template genfuns string fun alias wrapper static funslength enum string genfuns wrapper fun genfuns fun wrapper else enum string genfuns complete script given template declare string fun enum string declare double fun ref double x pure template wrap string fun enum string wrap double fun double x n n return fun x n template genfuns string fun alias wrapper static funslength enum string genfuns wrapper fun genfuns fun wrapper else enum string genfuns name function ported immutable string trigfuns sin co tan atan extern c nothrow nogc int printf scope const char format mixin genfuns trigfuns declare mixin genfuns trigfuns wrap extern c int main double pii immutable double pi atan pii assert sin assert co assert tan printf yay n return make code release betterc linkoncetemplates oftrig gfortran c phony clean clean rm running make return output yay passing correct assertion code code section given summary article show interface c fortran simply efficiently case calling c function minimal effort required function need declared extern c case calling code c effort need made remove feature incompatible c using betterc appropriate flag calling fortran subroutine almost straightforward calling c however fortran mangle exported name postfix underscore argument code side must referenced either using ref cstyle pointer mixins used generate repetitive section code make easier port function general call structure
91,Lobsters,d,D programming,D reference compiler is now Open Source,http://forum.dlang.org/thread/oc8acc$1ei9$1@digitalmars.com,reference compiler open source,,dmd backend converted boost licensere dmd backend converted boost licensere dmd backend converted boost license
