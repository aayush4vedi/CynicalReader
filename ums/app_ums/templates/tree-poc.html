<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>{{ title }}</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width">
    <!-- <link rel="stylesheet" type="text/css" href="tree-boxes.css"> -->

    <script src="https://code.jquery.com/jquery-latest.min.js" type="text/javascript"></script>
    <script src="https://d3js.org/d3.v3.min.js" type="text/javascript"></script>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/select2/3.5.2/select2.min.css"></link>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/select2/3.5.2/select2.min.js"></script>
    <!-- <script src="tree-boxes.js" type="text/javascript"></script> -->
  </head>
  <body>
    <style>
         .node {
             cursor: pointer;
             align-items: center
         }
         .node circle {
             fill: #fff;
             stroke: "rgb(19, 185, 202)";
             stroke-width: 1.5px;
         }
         .node text {
             font: 10px sans-serif;
         }
         .link {
             fill: none;
             stroke: rgb(190, 188, 186);
             stroke-width: 1.5px;
         }
         .bttn{
            cursor: pointer;
            border: none;
            border-radius: 5px;
            padding: 5px;
         }
         .checkboxx{
            width: 1.3em;
            height: 1.3em;
            background-color: white;
            border-radius: 50%;
            vertical-align: middle;
            border: 1px solid rgb(53, 53, 53);
            -webkit-appearance: none;
            outline: none;
            cursor: pointer;
         }
         .checkboxx:checked {
            background-color: rgb(231, 97, 186);
        }
        .checkboxx:disabled {
            background-color: rgb(110, 108, 108);
            cursor: not-allowed;
        }
 
         .found {
             fill: #ff4136;
             stroke: #ff4136;
         }
 
         .search {
             position: fixed;
             font: 10px sans-serif;
             width: 300px;
             margin: 0 auto;
         }
 
         ul.select2-results {
             max-height: 100px;
         }
 
         .select2-container,
         .select2-drop,
         .select2-search,
         .select2-search input {
             font: 10px sans-serif;
         }
        
        .tooltip{
            background-color:rgb(59, 59, 59);
            color: white;
            text-align:center;
            border-width:2px;
            border-radius:5px;
            padding: 2px;
            z-index: 10;
            font-size: 12px;
            padding: 5px;
            opacity: 50%;
        }

        .uncheck_my_node_btn{
            background-color: rgb(218, 37, 37);
            color: white;
            border: none;
            border-radius: 30%;
            margin-left: 20px;
            cursor: pointer;
        }
         /* #block_container {
             display: inline;
         } */
         body {
             overflow: hidden;
             position: absolute;
             width: 100%;
             height: 100%;
             align-items: center
         }
     </style>  

    {{body}}
    <button onclick="resetPrefrences()" class ="bttn" style="background-color: rgb(247, 210, 6);">Reset Preferences</button>
    <button type="submit" onclick="submitSelections()" class ="bttn" style="background-color: rgb(2, 187, 187);">Submit</button>
    <div id="block_container">
        <div id="searchName"></div>
    </div>
    <br>
    <input type="hidden" name="csrf_token" id="csrf_token" value="{{ csrf_token() }}" />
    <div>
        <div class="container">
            <div id="body" style="display: flex;justify-content: center;"></div>
        </div>
        <h1>Selected Topics</h1>
        <div id="user-select">
        </div>
    </div>
    <!-- <hr>
    <h2>Bottom</h2> -->

    <div class="container">
        <script>

            data = JSON.parse('{{ data | tojson | safe }}')
            // console.log("data::: ",data);
            unselectable_nodes = JSON.parse('{{ unselectable_nodes | tojson | safe }}')
            console.log("unselectable_nodes: ",unselectable_nodes);
            existing_user_selections = JSON.parse('{{ existing_user_selections | tojson | safe }}')
            // console.log("existing_user_selections: ", existing_user_selections);
            
            var userSelectedTopics = existing_user_selections;  //type = string
            // var userSelectedTopics = [];
            var allSelectedTopics = []; // includes auto selected child nodes too(type: node)
            var MAX_ALLOWED_NODES = parseInt('{{ MAX_ALLOWED_NODES }}')
            
            treeBoxes(data);
            //this checks & updates color for all nodes in userSelectedTopics; if exists-> marks them checked
            function updateNodesIn_userSelectedTopics(){
                userSelectedTopics.forEach(function(element){
                    if( document.getElementById('check_'+element)){
                        document.getElementById('check_'+element).checked = true;
                    }
                    //fill the color instantly
                    if( document.getElementById("rect_" + element)){
                        document.getElementById("rect_" + element).style.fill = "rgb(253, 214, 4)";
                    }
                })
            }
            //update userSelectedTopics in UI
            function loadInUI_userSelectedTopics(){
                let listContainer = document.createElement('div'),
                    listElement = document.createElement('ul')
                
                document.getElementById("user-select").innerHTML = '';  //remove all prev children
                document.getElementById("user-select").appendChild(listContainer);
                listContainer.appendChild(listElement);

                userSelectedTopics.forEach(function(element){
                    let listItem = document.createElement('li');
                    listItem.id = 'li_' + element;

                    let button = document.createElement('button');

                    button.innerHTML = '&#215;';
                    button.classList.add('uncheck_my_node_btn');
                    button.onclick = function(){
                        userSelectedTopics = userSelectedTopics.filter(function(item) {
                            return item !== element;
                        });
                        console.log("@button click:userSelectedTopics: ",userSelectedTopics);
                        //update in tree
                        if( document.getElementById('check_'+element)){
                            document.getElementById('check_'+element).checked = false;
                        }
                        //fill the color instantly
                        if( document.getElementById("rect_" + element)){
                            document.getElementById("rect_" + element).style.fill = "rgb(255,255,255)";
                        }
                        //remove the item from page
                        if(document.getElementById('li_'+element)){
                            item = document.getElementById('li_'+element);
                            item.parentNode.removeChild(item);
                        }
                    }
                    listItem.innerHTML = element;
                    listItem.appendChild(button);
                    listElement.appendChild(listItem);
                })
            }

            function treeBoxes(jsonData)
            {
                var margin = {
                    top: 20,
                    right: 120,
                    bottom: 20,
                    left: 120
                },
                width = 960 - margin.right - margin.left,
                height = 800 - margin.top - margin.bottom;

                
                var root = jsonData

                //------------------------------------------ SEARCHBAR:START
                select2Data = [];
                select2DataCollectName(root);
                select2DataObject = [];
                select2Data.sort(function(a, b) {
                            if (a > b) return 1; // sort
                            if (a < b) return -1;
                            return 0;
                        })
                        .filter(function(item, i, ar) {
                            return ar.indexOf(item) === i;
                        }) // remove duplicate items
                        .filter(function(item, i, ar) {
                            select2DataObject.push({
                                "id": i,
                                "text": item
                            });
                        });
                $("#searchName").select2({
                        data: select2DataObject,
                        containerCssClass: "search"
                });

                $("#searchName").on("select2-selecting", function(e) {
                    clearAllSearched(root);
                    expandAll(root);
                    update(root);

                    searchField = "d.name";
                    searchText = e.object.text;
                    searchTree(root);
                    root.children.forEach(collapseAllNotFound);
                    update(root);
                })
                function collapseAllNotFound(d) {
                    if (d.children) {
                        if (d.class !== "found") {
                            d._children = d.children;
                            d._children.forEach(collapseAllNotFound);
                            d.children = null;
                    } else 
                            d.children.forEach(collapseAllNotFound);
                    }
                }

                function expandAll(d) {
                    if (d._children) {
                        d.children = d._children;
                        d.children.forEach(expandAll);
                        d._children = null;
                    } else if (d.children)
                        d.children.forEach(expandAll);
                }
                function clearAllSearched(d) {
                    d.class = "";
                    if (d.children)
                        d.children.forEach(clearAllSearched);
                    else if (d._children)
                        d._children.forEach(clearAllSearched);
                }
                
                function select2DataCollectName(d) {
                    if (d.children)
                        d.children.forEach(select2DataCollectName);
                    else if (d._children)
                        d._children.forEach(select2DataCollectName);
                    select2Data.push(d.name);
                }

                function searchTree(d) {
                    if (d.children)
                        d.children.forEach(searchTree);
                    else if (d._children)
                        d._children.forEach(searchTree);
                    var searchFieldValue = eval(searchField);
                    if (searchFieldValue && searchFieldValue.match(searchText)) {
                            // Walk parent chain
                            var ancestors = [];
                            var parent = d;
                            while (typeof(parent) !== "undefined") {
                                ancestors.push(parent);
                                parent.class = "found";
                                parent = parent.parent;
                            }
                    }
                }
                //------------------------------------------ SEARCHBAR:END

                var i = 0,
                    duration = 750,
                    // width = 1680 - margin.right - margin.left,
                    // height = 700 - margin.top - margin.bottom,
                    rectW = 80,             //TODO: make it according to item size
                    rectH = 30;
                var tree = d3.layout.tree()
                                    .size([height, width])
                                    .sort(function(a,b){
                                        return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
                                    });
                var diagonal = d3.svg.diagonal()
                    .projection(function (d) {
                    return [d.x + rectW / 2, d.y + rectH / 2];
                });

                var svg = d3.select("#body")
                                .append("svg")
                                .attr("width",1680)
                                .attr("height",700)
                                .attr("align-items", "center")
                                // .call(zm = d3.behavior.zoom().scaleExtent([1,3]).on("zoom", redraw))
                                .append("g")
                                // .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                                .attr("transform", "translate(" + 200 + "," + 20 + ")");    //NOTE: this is to center align(hori) tree at depth of 20px

                //necessary so that zoom knows where to zoom and unzoom from
                // zm.translate([200, 20]);    //1680/2 = 840 ; 1680 being size of screen

                root.x0 = 0;
                root.y0 = height / 2;

                // Tooltip functions : START ===============================
                var Tooltip = d3.select("#body")
                .append("div")
                    .style("opacity", 0)
                    .style("position", "absolute")
                    // .style("left", d3.select(this).attr("x") + "px")     
                    // .style("top", d3.select(this).attr("y") + "px")
                    .attr("class", "tooltip")
                    

                    // Three function that change the tooltip when user hover / move / leave a cell
                var mouseover = function(d) {
                    Tooltip
                    .style("opacity", 1)
                    d3.select(this)
                        .attr("stroke-width", 10)
                        // .style("stroke", "black")
                    //     .style("fill","rgb(14, 135, 148)")
                }
                var mousemove = function(d) {
                    Tooltip
                    .html("The name of<br>this node is: " + d.name)
                        // .style("left", (d3.mouse(this)[0]+70) + "px")
                        // .style("left", (d3.mouse(this)[0]+900)+ "px")
                        // .style("top", (d3.mouse(this)[1]-20) + "px")
                        .style("left", (d3.event.pageX ) + "px")
                        .style("top", (d3.event.pageY) + "px");
                    // d3.select(this)
                    //     .attr("stroke-width", 10)
                }
                var mouseleave = function(d) {
                    Tooltip
                        .style("opacity", 0)
                    d3.select(this)
                        .attr("stroke-width", 5)
                    //     .style("stroke", "none")
                    //     .style("opacity", 0.8)
                }
                // Tooltip functions : END ===============================

                function collapse(d) {
                    if (d.children) {
                        d._children = d.children;
                        d._children.forEach(collapse);
                        d.children = null;
                    }
                }

                root.children.forEach(collapse);
                update(root);

                d3.select("#body").style("height", "700px");

                function update_allSelectedTopics(d,task){
                    if(task == 'add'){
                        if(!allSelectedTopics.includes(d)){ 
                            allSelectedTopics.push(d);
                            if( document.getElementById('check_'+d.name)){
                                document.getElementById('check_'+d.name).checked = true;
                            }
                        }
                    }else{
                        allSelectedTopics = allSelectedTopics.filter(function(item) {
                                                                return item.name !== d.name;
                                                            });
                        if( document.getElementById('check_'+d.name)){
                            document.getElementById('check_'+d.name).checked = false;
                        }
                    }
                    if(d.children){
                        d.children.forEach(function(child) {
                            update_allSelectedTopics(child,task);
                        })
                    }
                }

                //=====================START:  Auxilary functions to create, update & destroy child nodes
                function createNodes(node,source){
                    //check nodes in userSelectedTopics                           
                    updateNodesIn_userSelectedTopics();
                    //update userSelectedTopics nodes in UI 
                    loadInUI_userSelectedTopics();
                    // Enter any new nodes at the parent's previous position.
                    var nodeEnter = node.enter().append("g")
                                        .attr("class", "node")
                                        .attr("id", "node")
                                        .attr("transform", function (d) {
                                            // console.log("@nodeEnter:: node = ",d);
                                            return "translate(" + source.x0 + "," + source.y0 + ")";
                                        })
                                        .on("click", click);
                    nodeEnter.append("rect")
                        .attr("width", rectW)
                        // .attr("width", function(d){
                        //     console.log(" node: ", d.name, "len = ",(d.name).length*10 );
                        //     return (d.name).length*10;
                        // })
                        .attr("height", rectH)
                        .attr("id",function(d){
                            return "rect_" + d.name;
                        })
                        .attr("stroke", "black")
                        .attr("stroke-width", 3)
                        // .style("fill", function(d) { return myColor(d.value)} )      //TODO: give diff colors
                        .attr("opacity",1)
                        .attr("rx",10)
                        .attr("ry",10)
                        .style("fill", function (d) {
                            //color yellow if it's a user selected node
                                if(userSelectedTopics.includes(d.name)){
                                    return "rgb(253, 214, 4)";
                                }
                                return d._children ? "rgb(19, 185, 202)" : "#fff";
                            })
                    // Add checkboxes in nodes----------------
                    nodeEnter.append('foreignObject')
                        .attr('width', '50')
                        .attr('height', '50')
                        .attr("align-items", "center")
                        .append('xhtml:input')
                        .attr('type', 'checkbox')
                        .attr('class', 'checkboxx')
                        .attr('id', function (d) {
                            return 'check_'+d.name;
                        })
                        .attr('value',function (d) {
                            return d.name;
                        })
                        .property("disabled",function(d){
                            return unselectable_nodes.includes(d.name);
                        })
                        .on('change', function (d) {
                            //if it exists in userSelectedTopics => means user wants to remove it
                            if(userSelectedTopics.includes(d.name)){
                                userSelectedTopics = userSelectedTopics.filter(function(item) {
                                    return item !== d.name;
                                });
                                //remove all its children too
                                update_allSelectedTopics(d,'remove');
                            }else{   //if it doesnt exists in  userSelectedTopics => means user wants to add it
                                if(userSelectedTopics.length < MAX_ALLOWED_NODES){
                                    userSelectedTopics.push(d.name);
                                    update_allSelectedTopics(d,'add');
                                }else{
                                    //if user has exceeded plan limits
                                    document.getElementById('check_'+d.name).checked = false;
                                    alert("Max allowed topics under your plan :"+MAX_ALLOWED_NODES+"\nUpgrate to premium for more choices!");
                                }
                            }
                            // console.log(" @userSelectedTopics: ",userSelectedTopics );
                            // console.log(" @allSelectedTopics: ",allSelectedTopics );
                            //check nodes in userSelectedTopics                           
                            updateNodesIn_userSelectedTopics();
                            //update userSelectedTopics nodes in UI 
                            loadInUI_userSelectedTopics()
                            return 1;       //just for the sake of returning something
                        })
                    nodeEnter.append("text")
                        .attr("x", rectW / 2)
                        .attr("y", rectH / 2)
                        .attr("dy", ".35em")
                        .attr("text-anchor", "middle")
                        .text(function (d) {
                            return d.name;
                        });
                    nodeEnter
                        .on("mouseover", mouseover)
                        .on("mousemove", mousemove)
                        .on("mouseleave", mouseleave)

                    //check nodes in userSelectedTopics                           
                    updateNodesIn_userSelectedTopics();
                    //update userSelectedTopics nodes in UI 
                    loadInUI_userSelectedTopics();
                }

                function updateNodes(node,source){
                    // Transition nodes to their new position.
                    var nodeUpdate = node.transition()
                        .duration(duration)
                        .attr("transform", function (d) {
                            // console.log("@nodeUpdate:: node = ",d);
                            return "translate(" + d.x + "," + d.y + ")";
                        });
                    nodeUpdate.select("rect")
                        .attr("width", rectW)
                        // .attr("width", function(d){
                        //     console.log(" node: ", d.name, "len = ",(d.name).length*10 );
                        //     return (d.name).length*10;
                        // })
                        .attr("height", rectH)
                        .attr("stroke", "black")
                        .attr("stroke-width", 2)
                        .style("fill", function (d) {
                            //color yellow if it's a user selected node
                            if(userSelectedTopics.includes(d.name)){
                                return "rgb(253, 214, 4)";
                            }else if (d.class === "found") {
                                return "#ff4136"; //red
                            }
                            return d._children ? "rgb(19, 185, 202)" : "#fff";
                        })
                    nodeUpdate.select("text")
                        .style("fill-opacity", 1);
                    
                    //check nodes in userSelectedTopics                           
                    updateNodesIn_userSelectedTopics();
                    //update userSelectedTopics nodes in UI 
                    loadInUI_userSelectedTopics();
                }

                function destroyNodes(node,source){
                    // Transition exiting nodes to the parent's new position.
                    var nodeExit = node.exit().transition()
                        .duration(duration)
                        .attr("transform", function (d) {
                            return "translate(" + source.x + "," + source.y + ")";
                        })
                        .remove();
                    nodeExit.select("rect")
                        .attr("width", rectW)
                        .attr("height", rectH)
                        //.attr("width", bbox.getBBox().width)""
                        //.attr("height", bbox.getBBox().height)
                        .attr("stroke", "black")
                        .attr("stroke-width", 1)
                        .style("fill", function (d) {
                            //color yellow if it's a user selected node
                            if(userSelectedTopics.includes(d.name)){
                                return "rgb(253, 214, 4)";
                            }
                            return d._children ? "rgb(19, 185, 202)" : "#fff";
                        });
                    nodeExit.select("text");
                }

                //=====================END:  Auxilary functions

                function update(source) {
                    // Compute the new tree layout.
                    var nodes = tree.nodes(root).reverse(),
                        links = tree.links(nodes);
                    // console.log("----[source: ",source,"] ----- nodes ", nodes);
                    
                    // Normalize for fixed-depth.
                    // nodes.forEach(function (d) {
                    //     d.y = d.depth * 120;
                    // });
                    // Normalize for fixed-depth UPDATE: if more children; brek into 2 columns
                    nodes.forEach(function (d) {
                        d.y = d.depth * 120;
                        if (d.parent != null) {
                            d.x =  d.parent.x - (d.parent.children.length-1)*80/2
                            + (d.parent.children.indexOf(d))*80;
                        }
                        // if the node has too many children, go in and fix their positions to two columns.
                        if (d.children != null && d.children.length > 10) {
                            d.children.forEach(function (d, i) {
                                d.y = (d.depth * 120 + i % 2 * 50);
                                d.x =  d.parent.x - (d.parent.children.length-1)*80/4
                                + (d.parent.children.indexOf(d))*80/2 - i % 2 * 40;
                            });
                        }
                    });

                    // Update the nodes…
                    var node = svg.selectAll("g.node")
                                    .data(nodes, function (d) {
                                        return d.id || (d.id = ++i);
                                    })
                                    
                    createNodes(node,source);
                    updateNodes(node,source);
                    destroyNodes(node,source);

                    allSelectedTopics.forEach(function(item){
                        if( document.getElementById('check_'+item)){
                            document.getElementById('check_'+item).checked = true;
                        }
                        if(item.children){
                            item.children.forEach(function(child) {
                                if(document.getElementById('check_'+child.name)){
                                    document.getElementById('check_'+child.name).checked = true;
                                    allSelectedTopics.push(child);
                                }
                            })
                        }
                    })
                    // Update the links…
                    var link = svg.selectAll("path.link")
                        .data(links, function (d) {
                        return d.target.id;
                    });

                    // Enter any new links at the parent's previous position.
                    link.enter().insert("path", "g")
                        .attr("class", "link")
                        .attr("x", rectW / 2)
                        .attr("y", rectH / 2)
                        .attr("d", function (d) {
                        var o = {
                            x: source.x0,
                            y: source.y0
                        };
                        return diagonal({
                            source: o,
                            target: o
                        });
                    });

                    // Transition links to their new position.
                    link.transition()
                        .duration(duration)
                        .attr("d", diagonal)
                        .style("stroke", function(d) {
                            if (d.target.class === "found") {
                                return "#ff4136";
                            }
                        });

                    // Transition exiting nodes to the parent's new position.
                    link.exit().transition()
                        .duration(duration)
                        .attr("d", function (d) {
                        var o = {
                            x: source.x,
                            y: source.y
                        };
                        return diagonal({
                            source: o,
                            target: o
                        });
                    })
                        .remove();

                    // Stash the old positions for transition.
                    nodes.forEach(function (d) {
                        d.x0 = d.x;
                        d.y0 = d.y;
                    });
                }

                // Toggle children on click.
                function click(d) {
                    if (d.children) {
                        d._children = d.children;
                        d.children = null;
                    } else {
                        d.children = d._children;
                        d._children = null;
                    }
                    // If the node has a parent, then collapse its child nodes
                    // except for this clicked node.
                    if (d.parent && d.children) { //add here, 
                        d.parent.children.forEach(function(element) {
                            if (d !== element) {
                            collapse(element);
                        }});
                    }
                    clearAllSearched(root);
                    update(d);
                }


                //Redraw for zoom
                function redraw() {
                    //console.log("here", d3.event.translate, d3.event.scale);
                    svg.attr("transform",
                        "translate(" + d3.event.translate + ")"
                        + " scale(" + d3.event.scale + ")");
                }
            }

            function resetPrefrences(){
                userSelectedTopics = []     //TODO: make it equal to the one passed from backend
                allSelectedTopics = []
                document.querySelectorAll('input[type=checkbox]').forEach(cb => cb.checked = false);
            }

            function submitSelections(){
                let csrf_token = document.getElementById('csrf_token').value;
                return fetch('/treesubmit', {
                    headers: {
                        'X-CSRFToken': csrf_token,
                        'Content-Type': 'application/json'
                    },
                    method: 'POST',
                    body: JSON.stringify({
                        "selectedTopics": userSelectedTopics
                })
                }).then(function () { // At this point, Flask has printed our JSON
                    // console.log("response.text(): ",response.text());
                    // return response.text();
                    console.log("FORM SUBMITTED SUCCESSFULLY");
                })
            }

        </script>

    </div>
</body>
</html>



